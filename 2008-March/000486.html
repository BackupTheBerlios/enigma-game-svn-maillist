<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1054 - in trunk/doc: . reference
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1054%20-%20in%20trunk/doc%3A%20.%20reference&In-Reply-To=%3C200803012232.m21MWENG023788%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000487.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1054 - in trunk/doc: . reference</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1054%20-%20in%20trunk/doc%3A%20.%20reference&In-Reply-To=%3C200803012232.m21MWENG023788%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1054 - in trunk/doc: . reference">ral at mail.berlios.de
       </A><BR>
    <I>Sat Mar  1 23:32:14 CET 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000487.html">[Enigma-game-svn] r1055 - trunk/doc/reference
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#486">[ date ]</a>
              <a href="thread.html#486">[ thread ]</a>
              <a href="subject.html#486">[ subject ]</a>
              <a href="author.html#486">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2008-03-01 23:32:12 +0100 (Sat, 01 Mar 2008)
New Revision: 1054

Modified:
   trunk/doc/
   trunk/doc/reference/enigma-ref.texi
   trunk/doc/reference/enigma-t2h.init
Log:
Trunk 1.1: Refman
- Chapter Enigma Paradigm: many sections
- formatting: coloring of code statements



Property changes on: trunk/doc
___________________________________________________________________
Name: svn:ignore
   - Makefile
Makefile.in
eniginecode

   + Makefile
Makefile.in
enginecode


Modified: trunk/doc/reference/enigma-ref.texi
===================================================================
--- trunk/doc/reference/enigma-ref.texi	2008-02-29 22:55:23 UTC (rev 1053)
+++ trunk/doc/reference/enigma-ref.texi	2008-03-01 22:32:12 UTC (rev 1054)
@@ -2641,9 +2641,614 @@
 naming scheme, and every new library should follow it from the beginning.
 
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ===================  Paradigm  =======================
 @node Enigma Paradigm
 @chapter Enigma Paradigm
 
+Now that you have learned about the formal declarative XML part of a level you
+should be eager to understand the basic principles of the participants of an
+Enigma level world. In this chapter we explain all the fundamental concepts and
+the terms used in the following chapters that describe the level author's view
+of a level.
+
+Please note that we describe the features of the new API of Enigma 1.10. The
+API of the earlier releases does not provide all the features and differs in
+several aspects.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* The World's Structure:: 
+* Object Description::
+* Methods of Interaction::
+* The Lifecycle of a Level::
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> The World's Structure
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> The World's Structure
+
+We speak of a level as the opus as a whole that describes the initial composition
+of a gaming world and its dynamic behaviour during the game play. Let us look
+at the participating objects in details.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* World's Shape and Coordinates::    Grid Positions and Tiles
+* Object Layers::                    Floors, Items, Stones, Actors and Others
+* Global World Attributes::          Friction, Brittleness, Modes and Co.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- World's Shape and Coordinates -------------------- 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> World's Shape and Coordinates
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> World's Shape and Coordinates
+
+Having played a few levels you will have noticed that every screen shows
+quadratic tiles, 20 ones in the horizontal and 13 ones in the vertical direction.
+Even if it is difficult for a player to map together all rooms and screens of a 
+large level, every level world has the shape of a rectangle in whole. 
+Nevertheless some parts may never be visible to the player due to walls of 
+stones or oceans of water.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> onescreener
+On the creation of a world the level author has to give its size in measure of
+tiles. The given width and height of the world are fixed and cannot be changed
+lateron. A common size is 20x13 for a @dfn{Onescreener}. But there are no limits.
+You can even build levels smaller than a screen. Note that for larger levels
+you have to take into account that one tile row or column is usually shared
+between two screens on scrolling. Thus a level of 2x2 screens has a size of
+39x25 tiles, a 3x4 screen level has 58x49 tiles,...
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> position
+Looking at the edges of all the tiles we get a grid that spans our world. We
+define the upper left corner of our world as the @dfn{position} @{0,@ 0@}. The first
+coordinate is the horizontal offset to the right, the second coordinate the
+vertical offset to the bottom. For a Onescreener level the tile in the lower
+right corner is located at position @{19,@ 12@}, whereas the corner itself is at
+the position @{20,@ 13@} (Note that this point is actually not part of the level
+anymore).
+
+A position of an actor like the black marble needs to be given by two floating
+numbers as coordinates like @{1.5,@ 2.5@} for an actor positioned in the center
+of the tile that is one row right and two columns down of the upper left corner
+tile.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> grid position
+But most objects like stones can only be placed on the fixed integral grid
+positions. Even if you try to put a stone on @{1.5,@ 2.5@} it will be put on
+on the grid position @{1,@ 2@}. Thus we speak of a @dfn{grid position} if just the
+integral part is taken into account. You may note that a tile is positioned
+according to its upper left corner. Actually the upper and the left edge are
+part of a tile, whereas the right and lower edge belong to the neighbour tiles.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> tile
+Finally let us look more precisly on the tile itself. On one grid position you
+may place a floor, an item, a stone and even several actors. The combination
+of all objects on one grid position is called a @dfn{tile}. It is a common 
+technique to declare these object combinations once in so called tile 
+definitions. As many grid positions share the same combination of objects these
+tiles can be reused very efficiently.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Object Layers
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Object Layers
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> layer
+On every grid position you may set a floor, an item and a stone. But just one
+of each. If you set a second stone the first one will be replaced. Floor, item
+and stone have a unique physical arrangement with the floor always being below
+an item and a stone always being on top of the others. Thus we speak of three
+object @dfn{layers} - the floor layer, the item layer and the stone layer.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> default floor
+The floor layer has a unique prerequisite. Every grid position needs to be
+covered by a floor. You can define a default tile which contains a
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at dfn</A>{default floor} that gets automatically set on every grid where you set
+no other floor. Even if you @dfn{kill} a floor, that means removing a floor
+without setting a replacement floor, a default floor will be set for you.
+
+The floors provide two elementary features to the game: friction and adhesion.
+The friction slows down actors and the adhesion enables you to accelerate
+actors with your mouse. A floor may additionally cause a directed flat force
+that gives the user the feeling of a slope. And last but not least a floor
+may burn. A whole set of attributes let you control the details of the fire
+behaviour.
+
+The item layer is shared between items that an actor can pickup and items that
+are static. The first category are items like keys, banana, etc. Static items
+are bombs, landmines, triggers, hollows and items that will only be set by the
+system itself like laserbeams, fire animations, ash, etc. As only one item can
+be positioned of every grid position a marble can not drop an item on such a
+static item. This is the technical reason that you can not intercept a laser
+beam by dropping an item. But as an level author you are free to add any item
+you like to the initial grid tile.
+
+The stone layer is straight forward. The level author can choose a stone out
+of the repository per grid. Of course most grid positions should be kept free
+for the actors to move around. Even if most levels have a stone wall at the 
+border of the world that visually limits the area this is not mandatory. Without
+a stone wall the marbles will be bounced at the physically boundary of the world.
+
+The actors live in another layer that is not grid based. The actors can be 
+placed at any position. Actors that pass a stone will be displayed below the
+stone.
+
+As a certain exception rubberbands that connect an actor with another one or 
+with a stone will simply be added to the world and will be displayed above any
+stone.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Global World Attributes
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Global World Attributes
+
+Friction, Brittleness, Modes and Co., Scrollmodes
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Object Description -------------------- 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Object Description
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Object Description
+
+Knowing where to place objects it is time to know how to select an object type,
+how to specify the details of the object and how to reference it later on.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* Object Kind::
+* Object Reference::
+* Object Naming::
+* Object Attributes::
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Object Kind
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Object Kind
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> abstact kind
+Up to now we have spoken about object kinds of floor @code{&quot;fl&quot;}, item 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;it&quot;}, stone @code{&quot;st&quot;} and actor @code{&quot;ac&quot;}. All these kinds are called
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at dfn</A>{abstract}. You can check if a given object is of such a kind, but you can
+not instantiate an abstract kind.
+
+To create an object you need to give a specific kind name like 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;st_switch&quot;}. You will find all object kinds described in the chapters
+starting with @ref{Floor Objects}. All these kind names with at least one 
+underscore can be instantiated.
+
+Most kinds provide subkinds like @code{&quot;st_switch_black&quot;} and 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;st_switch_white&quot;}. In case of the switches you get a color independent
+switch if you do not append a suffix. In other cases like @code{&quot;st_chess&quot;}
+the super kind will result in a default @code{&quot;st_chess_black&quot;} as no colorless
+chess stone exists.
+
+If you request an object for its kind it will always return the most specific
+kind. This means that a fresh generated @code{&quot;st_chess&quot;} returns the kind
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;st_chess_black&quot;}, whereas an @code{&quot;st_switch&quot;} reports its name
+unchanged.
+
+Objects can change their kind by level code statements or by user actions. You 
+may set a color on a switch or a marble may cause a color change on a chess 
+stone by hitting it with a revealed wand. The object will report the new kind on 
+subsequent requests.
+
+A few special object kinds do exist only for setting a new object. The are
+usually named with a suffix &quot;_new&quot;. These objects will never report their
+initial kind name but change to a standard kind immediately.
+
+If you are not interested in the specific subkind you can check an object for
+conformity to any super kind. E.g. any switch stone of whatever color will 
+return true if checked for @code{&quot;st_switch&quot;}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Object Reference
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Object Reference
+
+Having set objects to the various layers a level author sometimes has the need
+of referencing them lateron. On callbacks the engine provides references to
+sender objects. But the author can request any grid object anytime by its 
+position.
+
+With an object reference, that is of a special Lua type @code{object}, you can
+request the objects on its current state and attributes, modifiy the
+object, send messages or perform any supported methods of the object.
+
+Objects can be grouped for efficient handling of common operations on
+all affected objects. E.g. if you can send a message to a group of objects
+all objects will receive the message in turn. The sequence of several objects
+in a group is constant and guaranteed to be observed in processing common
+operations.
+
+As objects can ceize to exist you have to be aware that the references are
+volatile, too. You can check every object reference for existance. But in many
+cases the validity of the reference is unimportant as Enigma 1.10 is very 
+tolerant on invalid object references access. The operations will simply be
+ignored and requests will return default values.
+
+As a general thumb rule you should request and keep object references just
+for the time of a local call. As long as your level code is processed in
+sequence without the running world simulation giving the player a chance to
+kill objects by marble actions, objects should ceize to exist just due to your
+own direct statements.
+
+To gain access to an object later on a subsequent call you can address it via 
+two methods. First you can address it via its position. But as many objects are
+movable the position is not constant. Therefore you can address an object by
+name. @xref{Object Naming}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Object Naming
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Object Naming
+
+For addressing objects on a longterm valid basis every object can individually 
+be tagged by a name. Assigning a name to an object is as simple as setting
+the attribute @code{&quot;name&quot;} with a unique string on this object. Of course you
+can request an objects name by reading the attribute @code{&quot;name&quot;}.
+
+The name is a string that should be made up of characters @code{a..z}, 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{A..Z}, numbers @code{0..9} and the underscore @code{_}. Other special
+charcters are only allowed as far as they are explained in the following text.
+
+It is up to you to ensure unique names. Reusage of an already assigned name
+will unname the prior object and assign the name to the new object. To simplify
+the naming of larger groups of similar objects you can add the hash sign 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{#} as the last character to a name, e.g. &quot;mydoor#&quot;. This causes Enigma
+to add a unique number to the given string. The number will start with 1, the
+first unused number will be taken. Thus the first door will be named &quot;mydoor#1&quot;
+the second one &quot;mydoor#2&quot; and so on. If you delete the object named &quot;mydoor#2&quot;
+lateron and if you name another object &quot;mydoor#&quot; it will be assigned the unused
+name &quot;mydoor#2&quot;.
+
+All named objects are registered by the @dfn{named object} repository. The API
+provides a variable @code{no} that allows you to retrieve any named object, e.g.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{no[&quot;mydoor#1&quot;]}. You get an @ref{Object Reference} or @code{nil} if no
+object is registered by the given name.
+
+As you can auto name groups of objects you are allowed to use the wildcard
+characters @code{'?'} and @code{'*'}. The question mark replaces a single 
+arbitrary character, the asterix any number of arbitrary characters. E.g.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{no[&quot;mydoor#*&quot;]} retrieves all auto named &quot;mydoor&quot; objects in a single
+object group.
+
+Many object attributes like &quot;target&quot;, &quot;destination&quot; need object references
+to other objects. Besides a volatile @ref{Object Reference} you and always
+give a name string as a longterm valid object reference. If the attribute
+allows several objects to be given you can either give a group of object
+references, a table of object names or a object name with wildcards. Thus
+the string @code{&quot;mydoor#*&quot;} is a valid target.
+
+Another unique feature of object names is their late on access evaluation. This
+allows you to reference an object prior to its existence. E.g. if you want to
+set two vortices each declaring the other one as its destination, object names
+are the favorite solution:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo[@{3,4@}]  = @{&quot;it_vortex&quot;, name=&quot;vortex1&quot;, destination=&quot;vortex2&quot;@}
+wo[@{15,9@}] = @{&quot;it_vortex&quot;, name=&quot;vortex2&quot;, destination=&quot;vortex1&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+In general you will need to use object name references within any tile 
+declarations as none of the referenced objects will yet exist at the point of
+tile declarations.
+
+Objects do change over time. Doors do open, a chess may be recolored, a blocker
+stone may shrink to a blocker item. This means that the kind of the objects
+will change. But in many cases this means that the volatile object reference
+will brake, too. For the sake of the level authors the identity of the object
+will be transfered even if the reference gets invalid. And like the user
+attributes the name is part of the object identity. Thus if you name an 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{st_blocker} and it it shrinks to an @ref{it_blocker} you will retrieve this
+item if you ask the name object repository for the named object.
+
+To avoid unexpected problems with invalid object references a few critical
+objects are internally autonamed if the level author does not provide a name.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Object Attributes
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Object Attributes
+
+One of the key concepts for the versatility of Enigma is possibility to fine
+tune objects by means of attributes. The level author is not limited to a fixed
+set of preconfigured objects as given by the object kind.
+
+An attribute is a name, a string, with an assigned value. E.g. 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{obj[&quot;inverse&quot;]=true} sets a single object attribute to a boolean value
+and @code{@{&quot;it_magnet&quot;, range=6.5@}} describes a magnet item with an initial set
+floating point attribute.
+
+The scope of values is manifold. Most Lua types and a bunch of Enigma specific
+types can be assigned:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at itemize</A> @bullet
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> bool
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> int
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> double
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> string
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> nil
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> position
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> object
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> group
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> tokens
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> itemize
+
+If we speak of a bool value we do it in the sense of Lua 5, that means with the
+possible values @code{true} and @code{false}. 
+
+Many enumerated values like directions and colors are covered by the integer
+numbers.
+
+Of special interest is the value @code{nil}. Just a few attributes make direct
+use of the value @code{nil}, e.g. &quot;color&quot; on some objects. If you set an 
+attribute to value @code{nil} you do actually reset its value to the default
+value. E.g. if you set the attribute &quot;orientation&quot; of @ref{st_boulder} to 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{nil} it will be set to its default, which is actually @code{NORTH}, an
+enumerated direction value. A subsequent read of the attribute will return this
+value. Just those attributes that allow a nil value will ever return @code{nil}
+on a read access. Aa a direct consequence these attributes always default to 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{nil}.
+
+The most complex attribute value type are the tokens. Their purpose is the
+specification of one or many objects. As Enigma provides several means to do
+that this value type combines and mix all possibilities. A tokens value may 
+be a string, representing an object name, an object reference, a group or a
+table with any of these basic types in any sequence and number. E.g. the 
+following right sides are all valid tokens for the attribute &quot;target&quot;:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+obj1[&quot;target&quot;] = &quot;mydoor&quot;
+obj2[&quot;target&quot;] = myobject
+obj3[&quot;target&quot;] = grp(ojb1, obj2, obj3)
+obj4[&quot;target&quot;] = @{&quot;mydoor&quot;, myobject@}
+obj5[&quot;target&quot;] = @{grp(ojb1, obj2, obj3), &quot;mydoor&quot;, myobject, &quot;anotherdoor&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+This versatility is useful to set tokens attributes independent of the given
+object reference types.
+
+The chapter @ref{Common Attributes and Messages} and its followers describe
+the existing object attributes in detail.
+
+Besides these predefined attributes the level author can store own information
+on objects for later retrieval. Any name starting with an underscore '_' is
+can be used for level specific purposes. This prefix has been chosen as the
+resulting names are still valid Lua names. Common usage patterns are switches
+or triggers with callback functions. These functions provide the sender, the
+switch or trigger, as an argument. If you attach the same function to number of
+senders you can store the necessary context information within the sender.
+
+The internal engine uses object attributes as well. Such unaccessable attributes
+are named with a leasing dollar sign '$'. They may appear in the documentation
+for C++ developers information. Level authors should ignore these attributes.
+
+In some cases you may observe a different behaviour on setting an attribute
+within the object definition and setting the same attribute while the object
+is already on the grid. E.g. a door @code{@{&quot;st_door_h&quot;, state = OPEN@}} is 
+opened from the very beginning. Whereas @code{mydoor[&quot;state&quot;] = OPEN} on a
+closed door will start opening the door. This takes a short time until the
+door is really open. You find more details on these as aspects in the section
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{The Lifecycle of a Level}.
+
+If you ever look into the C++ code you may wonder about the implementation of
+attributes. They are not all directly stored in a map. Some of them are hold
+in object instance variables, other do not exist at all. Objects attributes
+are an abstract concept that unifies several internal features within a
+common simple API for level description code. Within the C++ engine subtle
+reasons like performance optimization forces a much more complex handling.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Methods of Interaction -------------------- 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Methods of Interaction
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Methods of Interaction
+
+Having looked at the description of the initial object composition of a
+level world we still need to undestand how to configure the dynamic behaviour
+of a level.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* Messages::             Asking objects to do something
+* Target - Action::      Automatic reactions on an event
+* Callback Function::    Lua hooks to react on events
+* Object State::
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Messages
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Messages
+
+You can generate an initially open door by setting its attributes. But how
+can a switch stone open a door when it is hit by a marble? It simply sends
+a message @code{&quot;open&quot;} to the door. Another switch may send a message
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;on&quot;} to a laser or @code{&quot;ignite&quot;} to a @ref{it_dynamite}. On explosion
+the dynamite will in turn send automatically @code{&quot;ignite&quot;} messages to the
+neighbour grid positions.
+
+Messages are a simple universal function or from the receiver object and the
+Lua level authors point of view a &quot;method&quot;. It takes two arguments - the message
+name, a string, and an optional value. E.g.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+mydoor:message(&quot;open&quot;)
+myboulder:message(&quot;orientate&quot;, NORTH)
+
+mydoor:open()
+myboulder:orientate(NORTH)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+The last two examples are a common abbreviation of the first two ones.
+
+Messages may return a value. But most messages just return @code{nil}.
+
+You can send any message to any object. Not supported messages are silently
+ignored. This is the reason that an exploding dynamite can send @code{&quot;ignite&quot;}
+messages to its neighbours without knowing if the objects can be ignited at all.
+Furtheron the dynamite has not to bother with the recipients of the messages.
+Due to messages the sender and the receiver objects are totally decoupled
+concerning the code base. Thus the level author just needs one method that
+allows sending arbitrary messages to arbitrary objects.
+
+You should not send a message during initialization of the level. You configure
+the switch to send an @code{&quot;open&quot;} message to the door by @ref{Target - Action}.
+Within a Lua @ref{Callback Function} you may send messages during runtime to
+any object.
+
+All messages are listed and described in @ref{Common Messages} and the 
+subsequent chapters.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Target - Action
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Target - Action
+
+The &quot;target action paradigm&quot; is a classical object oriented method that allows
+you to easily plug together objects. One object is triggered by a function
+call or by an event like an actor hitting a stone, crossing over or applying an
+item. You simply plug this object to another target object and tell it to send
+an action message. Everytime the first object is triggered it will send the 
+message to its target.
+
+You configure such a target action by setting the attributes @code{&quot;target&quot;}
+and @code{&quot;action&quot;} on the first object. E.g. a for a switch stone that should
+open a door named @code{&quot;mydoor&quot;} you can write:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+@{st_switch, target=&quot;mydoor&quot;, action=&quot;open&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+Objects like the switch can be triggered &quot;on&quot; and &quot;off&quot;. Each time they will
+perform the action. If you would like the door to open and close in turn to
+the switch you another action than @code{&quot;open&quot;}. The universal message for
+changing targets in their alternate states is @code{&quot;toggle&quot;}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+@{st_switch, target=&quot;mydoor&quot;, action=&quot;toggle&quot;@}
+@{st_switch, target=&quot;mydoor&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+Now the door will toggle in sync with the switch between its open and closed
+state. The message @ref{&quot;toggle&quot;} can be used quite independent of the target 
+object. In fact it is the default action message. As a default you may omit
+the action in this case as it is demonstrated by the second example.
+
+But keep in mind that toggling just changes the state of the target. If you
+start with a switch in off state and an open door, the door will close when
+the switch in turned on. They will not sync. If you configure two switches
+both targeting the same door, you will have no clear relationship between the
+switch states and the door.
+
+As you remember messages can take a value. Action messages are no exception.
+Every objects sends its actions with a value, usually a bool value. A switch
+sends a value @code{true} if it just switched on, and a value @code{false} if
+it just switched off. The appropriate message for the door would be the 
+universal message @code{&quot;signal&quot;}:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+@{st_switch, target=&quot;mydoor&quot;, action=&quot;signal&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+Now the door will open when the switch is turned on and close if the switch is
+turned off.
+
+If you look at @ref{signal} you will notice that this messages takes an integer
+value of @code{0} or @code{1}. Indeed the action value does not match. But in
+this as in many other cases the messages and values are designed in a way that
+they are autoconverted to the appropriated type. This compatibility is the basis
+for a seamless plugging of objects.
+
+In many cases authors face the task of triggering two or more objects by a
+single object. @code{&quot;target&quot;} and @code{&quot;action&quot;} are both able to take 
+multiple values.  @code{&quot;target&quot;} is of type tokens, as described in 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{Object Attributes}, whereas @code{&quot;action&quot;} can be a string or a table
+of strings.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+@{st_switch, target=@{grp(ojb1, obj2, obj3), &quot;mydoor&quot;, myobject, &quot;anotherdoor&quot;@},
+            action=@{&quot;toggle&quot;,              &quot;open&quot;,   &quot;turn&quot;,   &quot;close&quot;@}@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+All objects described by a token receive the related message in the action
+table. If not enough messages are listed the default action @code{&quot;toggle&quot;}
+will be sent.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Callback Function
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Callback Function
+
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Object State
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Object State
+
+state dependent target action
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- The Lifecycle of a Level -------------------- 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> The Lifecycle of a Level
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> The Lifecycle of a Level
+
+
+Snapshot
+Levelloading, Initialization, Runtime Callbacks, 
+Ending Conditions - the mystery of Oxyds and Meditation
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* Library Preloading:: 
+* Snapshot Principle:: 
+* Level Initialization:: 
+* Runtime Ticks and Callbacks:: 
+* Ending Conditions:: 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Library Preloading
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Library Preloading
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Snapshot Principle
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Snapshot Principle
+
+Most levels contain objects that take influence on each other. A switch might
+toggle a door by @ref{Target - Action}, marbles may press a trigger, or a laser
+might activate a laserswitch or transform a hammer into a sword. Of course it is
+essential to know how to set up such objects to get the desired start 
+configuration without the objects changing unexpected on level initialization.
+
+The snapshot principle is a simple thumb rule that you can rely on in describing
+the level as snapshot of object at a given point of time. Every object has just
+to be configured as it should be at the given time. All interactions that would
+take place in a running game do not take place while setting objects during
+initialization.
+
+E.g. if a switch toggles a door and the switch should be initially on and the
+door should be initially open you describe the object with exactly these
+attributes:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+@{&quot;st_switch&quot;, target=&quot;mydoor&quot;, state=ON@}
+@{&quot;st_door_v&quot;, name=&quot;mydoor&quot;, state=OPEN@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+A laser that is initially on that illuminates a laserswitch needs an initially
+active laserswitch. But of course no attribute exists that would allow you to
+set a laserwitch active. The snapshot principle includes the rule that all
+internal states are updated without external actions. This means that the
+laserswitch will show up active without causing an action on its target.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+@{&quot;st_laser&quot;, state=ON@}
+@{&quot;st_laserswitch&quot;, target=&quot;mydoor&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+What about objects that transform on laser light. The snapshot principle keeps
+the object from transforming during initialization. A hammer that is set in
+an initially existing laser beam will not transform to a sword. It remains as
+a hammer that will transform on any subsequent new laser light during the game.
+
+Of course it cannot be allowed to describe impossible initial level states.
+Objects like dynamite do explode immediatly on a laser beam hit. Thus a 
+dynamite item in an initial laser beam is a fault that causes an exception.
+The snapshot principle forces you in this case to set an explosion item instead
+of the dynamite.
+
+Some objects do process internal state transformations that cannot be configured
+by attributes. But some of these states may be of interest on describing a
+snapshot of a level. Where possible special object subkinds exists with a suffix
+of @code{_new}. These objects can be used in the initial level description to
+set objects in special initial states. E.g. @ref{it_blocker} provides such a
+special subkind. Note that these objects will never report their initial
+subkind on a kind request as they come into existance as a standard object.
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Level Initialization
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Level Initialization
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Runtime Ticks and Callbacks
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Runtime Ticks and Callbacks
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Ending Conditions
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Ending Conditions
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ===================  Lua API  =======================
 @node Lua API
 @chapter Lua API
 
@@ -2743,7 +3348,7 @@
 @subsection it_blocker
 @obindex it_blocker
 
-A door like object that grows to @ref{st_blocker} when a @ref{st_boulder}
+A door like object that grows to @ref{st_blocker} when an @ref{st_boulder}
 passes. When the boulder did shrink and pass the blocker again it stays in its
 item like open state until it is passed again by a boulder which causes it to 
 grow again to a blocker stone.
@@ -2796,7 +3401,7 @@
 @item @b{open} @ @ @xref{open}
 As the item is open this message takes only effect if it is currently covered
 by a stone and marked as unlocked. That means it should grow as soon as the
-stone moves away what happens when a @ref{st_boulder} passes an idle blocker
+stone moves away what happens when an @ref{st_boulder} passes an idle blocker
 item. In this case an open messages locks the blocker again to avoid a growing
 when the stone moves away.
 @end table
@@ -2846,6 +3451,7 @@
 * st_blocker::         Shrinkable Blocker
 * st_boulder::         Moving Arrow Boulder
 * st_fourswitch::      Four Direction Switch
+* st_switch::          A classical on/off Switch
 @end menu
 
 
@@ -2854,7 +3460,7 @@
 @subsection st_blocker
 @obindex st_blocker
 
-A door like object that shrinks to @ref{it_blocker} when hit by a
+A door like object that shrinks to @ref{it_blocker} when hit by an
 @ref{st_boulder}. When the boulder did pass the blocker stays in its item like
 open state until it is passed again by a boulder which causes it to grow again
 to a blocker stone.
@@ -3044,7 +3650,59 @@
 @end table
 
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Switch Stone -------------------- 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> st_switch
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> st_switch
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at obindex</A> st_switch
 
+A classical on/off switch that toggles its state on actors hitting the stone.
+Of course other objects can send messages on actions to make this switch turning.
+
+Three variants of the switch do exist. A neutral, gray colored one that reacts
+on any actor hits, and a black and a white colored switch. These last switches
+will react only if hit by marbles of matching color.
+
+If a switch turns on or off there will be a short delay until it reaches the
+new state and performs it actions. If you need a switch without delay you
+need to set the @code{instant} attribute.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Attributes:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{state}, @ @ @i{values}: @code{ON}, @code{OFF}; @ @ @i{default}: @code{OFF} @ @ @xref{state}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{color} @ @ @i{values}: @code{nil}, @code{BLACK}, @code{WHITE}; @ @ @i{default}: @code{nil}
+The color of the switch that needs to match the hitting actor to cause a toggle.
+The default @code{nil} color is a grey switch that matches all actors, marbles
+of any color as well as all other actors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{instant} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
+A default switch requires a short time equivalent to the animation until the
+new state is reached and the actions are performed. An instant switch jumps
+directly into the new state.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{inverse} @ @ @xref{inverse}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Messages:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{signal} @ @ @xref{signal}
+Switches on at value @code{1}, and off at values @code{0}.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{on} @ @ @xref{on}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{off} @ @ @xref{off}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Action:} @ @ @xref{target}, @ @ @xref{action}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Variants:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{st_switch}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{st_switch_black}: color = @code{BLACK}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{st_switch_white}: color = @code{WHITE}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
+
 @c ===================  Actors  =======================
 
 @node Actor Objects

Modified: trunk/doc/reference/enigma-t2h.init
===================================================================
--- trunk/doc/reference/enigma-t2h.init	2008-02-29 22:55:23 UTC (rev 1053)
+++ trunk/doc/reference/enigma-t2h.init	2008-03-01 22:32:12 UTC (rev 1054)
@@ -6,5 +6,6 @@
 $css_map{'pre.example var'} = 'color:rgb(80%,0%,80%)';
 $css_map{'h3'} = 'background-color:rgb(95%,95%,100%)';
 $css_map{'hr'} = 'height:0px;';
+$css_map{'code'} = 'color:rgb(0%,50%,0%)';
 
 1;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000487.html">[Enigma-game-svn] r1055 - trunk/doc/reference
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#486">[ date ]</a>
              <a href="thread.html#486">[ thread ]</a>
              <a href="subject.html#486">[ subject ]</a>
              <a href="author.html#486">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
