<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r912 - in trunk/src: . gui
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2007-October/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r912%20-%20in%20trunk/src%3A%20.%20gui&In-Reply-To=%3C200710292330.l9TNUo7i008438%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000343.html">
   <LINK REL="Next"  HREF="000345.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r912 - in trunk/src: . gui</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r912%20-%20in%20trunk/src%3A%20.%20gui&In-Reply-To=%3C200710292330.l9TNUo7i008438%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r912 - in trunk/src: . gui">ral at mail.berlios.de
       </A><BR>
    <I>Tue Oct 30 00:30:50 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000343.html">[Enigma-game-svn] r911 - trunk/src
</A></li>
        <LI>Next message: <A HREF="000345.html">[Enigma-game-svn] r913 - in trunk/src: . stones
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#344">[ date ]</a>
              <a href="thread.html#344">[ thread ]</a>
              <a href="subject.html#344">[ subject ]</a>
              <a href="author.html#344">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2007-10-30 00:30:45 +0100 (Tue, 30 Oct 2007)
New Revision: 912

Modified:
   trunk/src/Inventory.cc
   trunk/src/Inventory.hh
   trunk/src/ItemHolder.hh
   trunk/src/WorldProxy.cc
   trunk/src/WorldProxy.hh
   trunk/src/actors.cc
   trunk/src/actors.hh
   trunk/src/editor.cc
   trunk/src/enigma-lua.pkg
   trunk/src/enigma.cc
   trunk/src/enigma.hh
   trunk/src/floors.cc
   trunk/src/floors.hh
   trunk/src/gui/MainMenu.cc
   trunk/src/items.cc
   trunk/src/items.hh
   trunk/src/laser.cc
   trunk/src/laser.hh
   trunk/src/lua-display.cc
   trunk/src/lua-display.hh
   trunk/src/lua-ecl.cc
   trunk/src/lua-ecl.hh
   trunk/src/lua-editor.cc
   trunk/src/lua-editor.hh
   trunk/src/lua-enigma.cc
   trunk/src/lua-enigma.hh
   trunk/src/lua-global.cc
   trunk/src/lua-global.hh
   trunk/src/lua.cc
   trunk/src/lua.hh
   trunk/src/main.cc
   trunk/src/objects.cc
   trunk/src/objects.hh
   trunk/src/objects_decl.hh
   trunk/src/ox_extra.cc
   trunk/src/ox_magnum.cc
   trunk/src/ox_peroxyd.cc
   trunk/src/oxyd.cc
   trunk/src/oxyd_internal.hh
   trunk/src/player.cc
   trunk/src/player.hh
   trunk/src/server.cc
   trunk/src/st_switches.cc
   trunk/src/stones.cc
   trunk/src/stones.hh
   trunk/src/stones_complex.cc
   trunk/src/stones_internal.hh
   trunk/src/stones_simple.cc
   trunk/src/world.cc
   trunk/src/world.hh
   trunk/src/world_internal.hh
Log:
Trunk 1.1: Reengineering Namespaces
- abolished namespaces world, stones, lasers
- all names from these namespaces moved to enigma
Note:
- all objects of the world simulation now reside in the common
  namespace enigma
- subsystems as gui, lev, lua are subnamespaces
- server, client namespace still need to be reengineered


Modified: trunk/src/Inventory.cc
===================================================================
--- trunk/src/Inventory.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/Inventory.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -21,7 +21,7 @@
 #include &lt;algorithm&gt;
 
 using enigma::Inventory;
-using world::Item;
+using enigma::Item;
 
 typedef std::vector&lt;Item*&gt; ItemList;
 

Modified: trunk/src/Inventory.hh
===================================================================
--- trunk/src/Inventory.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/Inventory.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -26,8 +26,8 @@
 
 namespace enigma
 {
-    using world::Item;          // TODO: remove this after moving Item into enigma namespace
-
+//    using Item;          // TODO: remove this after moving Item into enigma namespace
+    class Item;
     class Inventory : public ItemHolder {
     public:
         Inventory();

Modified: trunk/src/ItemHolder.hh
===================================================================
--- trunk/src/ItemHolder.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/ItemHolder.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -20,8 +20,8 @@
         virtual bool is_empty() const = 0;
 
         //! Add another item
-        virtual void add_item (world::Item *it) = 0;
-        virtual world::Item *yield_first() = 0;
+        virtual void add_item (Item *it) = 0;
+        virtual Item *yield_first() = 0;
         virtual void takeItemsFrom(ItemHolder *ih) {return;}
     };
 }

Modified: trunk/src/WorldProxy.cc
===================================================================
--- trunk/src/WorldProxy.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/WorldProxy.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -21,9 +21,7 @@
 #include &quot;server.hh&quot;
 #include &quot;display.hh&quot;
 
-using namespace enigma;
-
-namespace world {
+namespace enigma {
  
     WorldProxy *WorldProxy::theSingleton = 0;
     
@@ -129,4 +127,4 @@
         }
     }
 
-} // namespace world
+} // namespace enigma

Modified: trunk/src/WorldProxy.hh
===================================================================
--- trunk/src/WorldProxy.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/WorldProxy.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -21,7 +21,7 @@
 
 #include &quot;objects_decl.hh&quot;
 
-namespace world {
+namespace enigma {
 
     class WorldProxy : public Object {
     public:
@@ -37,6 +37,6 @@
     private:
         static WorldProxy *theSingleton;
     };
-} // namespace world
+} // namespace enigma
 
 #endif

Modified: trunk/src/actors.cc
===================================================================
--- trunk/src/actors.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/actors.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -30,11 +30,13 @@
 
 using namespace std;
 using namespace enigma;
-using namespace world;
+//using namespace world;
 using ecl::V2;
 
 #include &quot;actors_internal.hh&quot;
 
+namespace enigma {
+
 const double Actor::max_radius = 24.0/64;
 
 
@@ -975,8 +977,8 @@
     case RISING_VORTEX: {
         set_model(kind);
         if (Item *it = GetItem(get_gridpos())) {
-            world::ItemID id = get_id(it);
-            if (id == world::it_vortex_open || id == world::it_vortex_closed) 
+            ItemID id = get_id(it);
+            if (id == it_vortex_open || id == it_vortex_closed) 
                 SendMessage(it, &quot;arrival&quot;); // closes some vortex
         }
         change_state(JUMP_VORTEX);
@@ -1001,7 +1003,7 @@
             ActorInfo *ai = get_actorinfo();
             ai-&gt;forceacc = V2();
         }
-        world::ReleaseActor(this);
+        ReleaseActor(this);
         break;
 
     case SHATTERING:
@@ -1009,26 +1011,26 @@
             sound_event (&quot;shattersmall&quot;);
         else
             sound_event (&quot;shatter&quot;);
-        world::GrabActor(this);
+        GrabActor(this);
         set_anim (kind+&quot;-shatter&quot;);
         break;
 
     case DROWNING:
         // @@@ FIXME: use same animation as SINKING ?
-        world::GrabActor(this);
+        GrabActor(this);
 //         sound::PlaySound(&quot;drown&quot;);
         sound_event(&quot;drown&quot;);
 //         set_anim (&quot;ring-anim&quot;);
         set_anim (&quot;ac-drowned&quot;);
         break;
     case BUBBLING:
-        world::GrabActor(this);
+        GrabActor(this);
 //         sound::PlaySound(&quot;drown&quot;);
         set_anim (&quot;ac-drowned&quot;);
         break;
     case FALLING:
     case FALLING_VORTEX:
-        world::GrabActor(this);
+        GrabActor(this);
         set_anim(kind+&quot;-fall&quot;);
         break;
     case DEAD: 
@@ -1043,17 +1045,17 @@
     case APPEARING:
     case RISING_VORTEX:
         set_anim(kind+&quot;-appear&quot;);
-        world::GrabActor(this);
+        GrabActor(this);
         break;
     case JUMP_VORTEX:
         ASSERT(oldstate == RISING_VORTEX, XLevelRuntime,
             &quot;BasicBall: change to state JUMP_VORTEX but not RISING_VORTEX&quot;);
         vortex_normal_time = 0;
         set_model(kind);
-        world::ReleaseActor(this);
+        ReleaseActor(this);
         break;
     case DISAPPEARING:
-        world::GrabActor(this);
+        GrabActor(this);
 	disable_shield();
         set_anim(kind+&quot;-disappear&quot;);
         break;
@@ -1226,10 +1228,10 @@
     0.7f                        // mass
 };
 
-
+
 /* -------------------- Functions -------------------- */
 
-void world::InitActors () 
+void InitActors () 
 {
     RegisterActor (new Bug);
     RegisterActor (new Horse);
@@ -1241,3 +1243,5 @@
     RegisterActor (new Killerball);
     RegisterActor (new CannonBall);
 }
+
+} // namespace enigma

Modified: trunk/src/actors.hh
===================================================================
--- trunk/src/actors.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/actors.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -21,8 +21,8 @@
 
 #include &quot;objects_decl.hh&quot;
 
-namespace world
-{
+namespace enigma {
+
     enum ActorID {
         ac_INVALID    = -1,
         ac_FIRST      = 0,
@@ -239,6 +239,7 @@
 /* -------------------- Global Functions -------------------- */
 
     void InitActors();
-}
+    
+} // namespace enigma
 
 #endif

Modified: trunk/src/editor.cc
===================================================================
--- trunk/src/editor.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/editor.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -55,13 +55,13 @@
 using display::ScreenArea;
 using display::DisplayEngine;
 using display::Model;
-//using world::ObjectTraits;
+//using world ObjectTraits;
 
-using world::ItemID;
+using enigma::ItemID;
 
 #include &quot;editor_impl.hh&quot;
 
-
+
 /* -------------------- Editor state -------------------- */
 
 EditorState::EditorState()

Modified: trunk/src/enigma-lua.pkg
===================================================================
--- trunk/src/enigma-lua.pkg	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/enigma-lua.pkg	2007-10-29 23:30:45 UTC (rev 912)
@@ -76,7 +76,7 @@
 
 /* -------------------- world.cc, objects.cc -------------------- */
 
-$using namespace world;
+$using namespace enigma;
 
 module world
 {

Modified: trunk/src/enigma.cc
===================================================================
--- trunk/src/enigma.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/enigma.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -32,8 +32,9 @@
 
 using namespace std;
 using namespace ecl;
-using namespace enigma;
 
+namespace enigma {
+    
 /* -------------------- Game Type -------------------- */
 
 static const char *versionName[GAMET_COUNT+1] = {
@@ -45,7 +46,7 @@
     0
 };
 
-GameType enigma::GetGameType(std::string name) {
+GameType GetGameType(std::string name) {
     GameType type = GAMET_UNKNOWN;
     for (int v = 0; v&lt;GAMET_COUNT; ++v) {
         if (0 == strcmp(name.c_str(), versionName[v])) {
@@ -56,7 +57,7 @@
     return type;
 }
 
-std::string enigma::GetGameTypeName(GameType type) {
+std::string GetGameTypeName(GameType type) {
     if (type &gt;= GAMET_FIRST &amp;&amp; type &lt;= GAMET_LAST)
         return versionName[type];
     else
@@ -65,18 +66,18 @@
 
 /* -------------------- Direction -------------------- */
 
-Direction enigma::reverse(Direction d) {
+Direction reverse(Direction d) {
     static Direction rdir[] = { NODIR, EAST, NORTH, WEST, SOUTH };
     return rdir[d+1];
 }
 
-Direction enigma::rotate_cw (Direction d)
+Direction rotate_cw (Direction d)
 {
     static Direction rdir[] = { NODIR, NORTH, WEST, SOUTH, EAST };
     return rdir[d+1];
 }
 
-Direction enigma::rotate_ccw (Direction d)
+Direction rotate_ccw (Direction d)
 {
     static Direction rdir[] = { NODIR, SOUTH, EAST, NORTH, WEST };
     return rdir[d+1];
@@ -105,15 +106,14 @@
     return d;
 }
 
-string enigma::to_suffix(Direction d) {
+string to_suffix(Direction d) {
     static const char *sfx[] = { &quot;&quot;, &quot;-w&quot;, &quot;-s&quot;, &quot;-e&quot;, &quot;-n&quot; };
     return sfx[d+1];
 }
 
 /* -------------------- DirectionBits -------------------- */
 
-DirectionBits
-enigma::rotate(DirectionBits d, bool clockwise)
+DirectionBits rotate(DirectionBits d, bool clockwise)
 {
     if (clockwise) {
         d = DirectionBits(((d&gt;&gt;1) | (d&lt;&lt;3)) &amp; ALL_DIRECTIONS);
@@ -304,7 +304,7 @@
         case OBJECT:
             return Object::getObject(round_nearest&lt;int&gt;(val.dval[0]));
         case STRING:
-            return world::GetNamedObject(val.str);            
+            return GetNamedObject(val.str);            
         default: return NULL;
     }
 }
@@ -324,7 +324,7 @@
                     if ((*it)[0] == '$') {
                         result.push_back(Object::getObject(atoi((it-&gt;c_str()) + 1)));
                     } else {
-                        result.push_back(world::GetNamedObject(*it));
+                        result.push_back(GetNamedObject(*it));
                     }
                 }
             }
@@ -423,23 +423,23 @@
 }
 
 
-int enigma::to_int(const Value &amp;v) {
+int to_int(const Value &amp;v) {
     return v;
 }
 
-bool enigma::to_bool(const Value &amp;v) {
+bool to_bool(const Value &amp;v) {
     return v.to_bool();
 }
 
-double enigma::to_double(const Value &amp;v) {
+double to_double(const Value &amp;v) {
     return v;
 }
 
-std::string enigma::to_string(const Value &amp;v) {
+std::string to_string(const Value &amp;v) {
     return v.to_string();
 }
 
-Direction enigma::to_direction (const Value &amp;v) {
+Direction to_direction (const Value &amp;v) {
     int val = Clamp(to_int(v), 0, 3);
     return static_cast&lt;Direction&gt;(val);
 }
@@ -452,7 +452,7 @@
 {}
 
 
-std::ostream&amp; enigma::operator&lt;&lt;(std::ostream&amp; os, const GridPos&amp; val)
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const GridPos&amp; val)
 {
     return os &lt;&lt; '(' &lt;&lt; val.x &lt;&lt; ',' &lt;&lt; val.y &lt;&lt; ')';
 }
@@ -462,7 +462,7 @@
    203
    748
 */
-GridPos enigma::get_neighbour (GridPos p, int i)
+GridPos get_neighbour (GridPos p, int i)
 {
     ASSERT (i &gt;= 0 &amp;&amp; i &lt;= 9, XLevelRuntime, &quot;get_neighbour: index out of bounds&quot;);
     static int xoff[9] = { 0,0,-1,1,0,-1,1,-1,1 };
@@ -472,7 +472,7 @@
 
 /* -------------------- GridLoc -------------------- */
 
-bool enigma::to_gridloc (const char *str, GridLoc &amp;l) {
+bool to_gridloc (const char *str, GridLoc &amp;l) {
     GridLoc loc;
     const char *numstr = str + 3;
 
@@ -495,23 +495,23 @@
 
 /* -------------------- Random numbers -------------------- */
 
-void  enigma::Randomize ()
+void  Randomize ()
 {
     srand (time(NULL));
 }
 
-void   enigma::Randomize (unsigned seed)
+void  Randomize (unsigned seed)
 {
     srand (seed);
 }
 
-int    enigma::IntegerRand (int min, int max)
+int   IntegerRand (int min, int max)
 {
     int r = round_down&lt;int&gt;((max-min+1) * (rand()/(RAND_MAX+1.0)));
     return r+min;
 }
 
-double enigma::DoubleRand (double min, double max)
+double DoubleRand (double min, double max)
 {
     return min + double(rand())/RAND_MAX * (max-min);
 }
@@ -520,7 +520,7 @@
 /* -------------------- Time &amp; Date -------------------- */
 
 #define MAX_DATE_LENGTH 256
-const char *enigma::date(const char *format) { // format see 'man strftime'
+const char *date(const char *format) { // format see 'man strftime'
     static char *result = 0;
     char         buffer[MAX_DATE_LENGTH];
 
@@ -623,7 +623,7 @@
     return ecl::LoadImage(name.c_str());
 }
 
-void enigma::DefineFont (const char *name, 
+void DefineFont (const char *name, 
                          const char *ttf_name, 
                          int ttf_size,
                          const char *bmf_name,
@@ -632,12 +632,12 @@
     font_cache.define_font (FontDescr (name, ttf_name, ttf_size, bmf_name, r, g, b));
 }
 
-ecl::Font *enigma::GetFont (const char *name) 
+ecl::Font *GetFont (const char *name) 
 {
     return font_cache.get(name);
 }
 
-ecl::Surface *enigma::LoadImage(const char *name) 
+ecl::Surface *LoadImage(const char *name) 
 {
     string filename;
     if (app.resourceFS-&gt;findImageFile (string(name) + &quot;.png&quot;, filename)) 
@@ -645,7 +645,7 @@
     return 0;
 }
 
-ecl::Surface *enigma::GetImage(const char *name, const char *ext) 
+ecl::Surface *GetImage(const char *name, const char *ext) 
 {
     string filename;
     if (app.resourceFS-&gt;findImageFile (string(name) + ext, filename)) 
@@ -653,12 +653,14 @@
     return 0;
 }
 
-ecl::Surface *enigma::RegisterImage (const char *name, ecl::Surface *s) 
+ecl::Surface *RegisterImage (const char *name, ecl::Surface *s) 
 {
     image_cache.store(name, s);
     return s;
 }
 
-void enigma::ClearImageCache() {
+void ClearImageCache() {
     image_cache.clear();
 }
+
+} // namespace enigma

Modified: trunk/src/enigma.hh
===================================================================
--- trunk/src/enigma.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/enigma.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -36,10 +36,9 @@
 
 #define NUMENTRIES(array) (sizeof(array)/sizeof(*array))
 
-namespace enigma
-{
-    using namespace world;
-    class world::Object;
+namespace enigma { 
+
+    class Object;
     
 /* -------------------- Various types -------------------- */
 
@@ -191,7 +190,7 @@
 
 /* -------------------- Value -------------------- */
 
-    typedef std::list&lt;world::Object *&gt; ObjectList;
+    typedef std::list&lt;Object *&gt; ObjectList;
 
     /**
      * A flexible container for various types of data. This class is one
@@ -486,6 +485,6 @@
     : pos(p), layer(l) 
     {}
 
-}
+} // namespace enigma
 
 #endif

Modified: trunk/src/floors.cc
===================================================================
--- trunk/src/floors.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/floors.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -27,9 +27,9 @@
 #include &lt;iostream&gt;
 
 using namespace std;
-using namespace enigma;
-using namespace world;
 
+namespace enigma {
+
 Floor::Floor(const char *kind, double friction_, double mfactor, FloorFlags flags,
              FloorFireType flft, const char *firetransform_, const char *heattransform_)
 : GridObject (kind),
@@ -930,7 +930,7 @@
         enigma::Inventory *inv = player::GetInventory(m_affected_actor);
         if (inv &amp;&amp; inv-&gt;size() &gt; 0) {
             if (bag == NULL) {
-                bag = world::MakeItem(it_bag);
+                bag = MakeItem(it_bag);
                 bag-&gt;setOwnerPos(get_pos());
             }
             int i = IntegerRand (0, int (inv-&gt;size()-1));
@@ -943,10 +943,10 @@
     if(Item *it = GetItem(get_pos())) {
         if (!(it-&gt;get_traits().flags &amp; itf_static)) {
             if (bag == NULL) {
-                bag = world::MakeItem(it_bag);
+                bag = MakeItem(it_bag);
                 bag-&gt;setOwnerPos(get_pos());                
             }
-            dynamic_cast&lt;ItemHolder *&gt;(bag)-&gt;add_item(world::YieldItem(get_pos())); 
+            dynamic_cast&lt;ItemHolder *&gt;(bag)-&gt;add_item(YieldItem(get_pos())); 
             didSteal = true;
         }
     }
@@ -957,15 +957,15 @@
 Value Thief::message(const string &amp;msg, const Value &amp;v) {
     if(msg == &quot;capture&quot; &amp;&amp; state == IDLE) {
         state = CAPTURED;
-        Item * it =  world::GetItem(get_pos());
+        Item * it =  GetItem(get_pos());
         
         // add items on grid pos that can be picked up to our bag
         if (it != NULL &amp;&amp; !(it-&gt;get_traits().flags &amp; itf_static) &amp;&amp; bag != NULL) {
-            dynamic_cast&lt;ItemHolder *&gt;(bag)-&gt;add_item(world::YieldItem(get_pos()));
+            dynamic_cast&lt;ItemHolder *&gt;(bag)-&gt;add_item(YieldItem(get_pos()));
         }
         // drop bag if pos is not occupied by a static item
-        if (world::GetItem(get_pos()) == NULL)
-            world::SetItem(get_pos(), bag);
+        if (GetItem(get_pos()) == NULL)
+            SetItem(get_pos(), bag);
         bag = NULL;
         set_anim(get_modelname() + string(&quot;-captured&quot;));
         return Value(1);
@@ -1006,7 +1006,7 @@
 }
 
 
-void world::InitFloors()
+void InitFloors()
 {
     // Floors (most floors are defined in init.lua)
     Register(new Abyss);
@@ -1043,3 +1043,5 @@
     Register(&quot;fl-gradient15&quot;, new Gradient(24));
     Register(&quot;fl-gradient16&quot;, new Gradient(23));
 }
+
+} // namespace enigma

Modified: trunk/src/floors.hh
===================================================================
--- trunk/src/floors.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/floors.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -19,8 +19,11 @@
 #ifndef FLOORS_HH_INCLUDED
 #define FLOORS_HH_INCLUDED
 
-namespace world
-{
+namespace enigma {
+
+    class Actor;
+    class Stone;
+    
     enum FloorFlags {
         flf_default        = 0,
         flf_indestructible = 0x01,
@@ -146,6 +149,6 @@
 
     void InitFloors();
 
-}
+} // namespace enigma
 
 #endif

Modified: trunk/src/gui/MainMenu.cc
===================================================================
--- trunk/src/gui/MainMenu.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/gui/MainMenu.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -48,7 +48,7 @@
       load the appropriate models. */
     void ChangeVideoMode()
     {
-        world::PrepareLevel();      // make sure no references to models remain
+        enigma::WorldPrepareLevel();      // make sure no references to models remain
         video::ChangeVideoMode();
         LevelPreviewCache::instance()-&gt;clear();
         enigma::ClearImageCache();

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/items.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -37,7 +37,6 @@
 
 
 using namespace std;
-using namespace world;
 
 using enigma::GridPos;
 using enigma::Value;
@@ -83,6 +82,8 @@
     ItemTraits classname::traits = { name, id, 0, radius }
 
 
+namespace enigma {
+
 /* -------------------- Item implementation -------------------- */
 
 Item::Item()
@@ -857,7 +858,7 @@
     }
 
     if (ess_cnt == ess_wcnt &amp;&amp;
-        (wcnt+ess_wcnt) == CountActorsOfKind (world::ac_meditation))
+        (wcnt+ess_wcnt) == CountActorsOfKind (ac_meditation))
     {
         server::FinishLevel();
     }
@@ -1377,10 +1378,10 @@
         init_model();
         if (m_pressedp) {
             sound_event (&quot;triggerdown&quot;);
-            world::PerformAction(this, true);
+            PerformAction(this, true);
         } else {
             sound_event (&quot;triggerup&quot;);
-            world::PerformAction(this, false);
+            PerformAction(this, false);
         }
     }
 }
@@ -1427,9 +1428,9 @@
                     return;
                }
            }
-           Stone *st = world::MakeStone (get_stone_name());
+           Stone *st = MakeStone (get_stone_name());
            TransferObjectName (this, st);
-           world::SetStone (p, st);
+           SetStone (p, st);
            kill();
         }
 
@@ -1530,7 +1531,7 @@
         if (st == 0) {
             warning(&quot;stone_change: Stone disappeared w/o sending me a proper message!&quot;);
             activated = false;
-            world::PerformAction(this, false);
+            PerformAction(this, false);
         }
     }
 }
@@ -1539,7 +1540,7 @@
     if (str == &quot;noshogun&quot;) {
         if (activated) {
             activated = false;
-            world::PerformAction(this, false);
+            PerformAction(this, false);
         }
     }
     else {
@@ -1551,7 +1552,7 @@
 
         if (size_matches != activated) {
             activated = size_matches;
-            world::PerformAction(this, activated);
+            PerformAction(this, activated);
         }
     }
     return Value();
@@ -1562,7 +1563,7 @@
 namespace
 {
     class Magnet : public OnOffItem {
-        class Magnet_FF : public world::ForceField {
+        class Magnet_FF : public ForceField {
         public:
             Magnet_FF()
             : m_active(false), strength(30), range(1000)
@@ -1603,13 +1604,13 @@
 	        ff.set_range (range);
 	        ff.set_strength (strength);
 
-            world::AddForceField(&amp;ff);
+            AddForceField(&amp;ff);
             Item::on_creation (p);
         }
         
         void on_removal (GridPos p) {
             Item::on_removal(p);
-            world::RemoveForceField(&amp;ff);
+            RemoveForceField(&amp;ff);
         }
 
         virtual void notify_onoff(bool on) {
@@ -1648,7 +1649,7 @@
 
 namespace
 {
-    class WormHole_FF : public world::ForceField {
+    class WormHole_FF : public ForceField {
     public:
         WormHole_FF() : strength(0.6 * 50), rangesquared(1000000) {}
 
@@ -1708,9 +1709,9 @@
                 double s = getAttr(&quot;strength&quot;, server::WormholeForce);
                 ff.set_strength (s);
 
-                world::AddForceField(&amp;ff);
+                AddForceField(&amp;ff);
             } else {
-                world::RemoveForceField(&amp;ff);
+                RemoveForceField(&amp;ff);
             }
         }
 
@@ -1771,7 +1772,7 @@
                 init_model();
             }
             justWarping = true;
-            world::WarpActor(actor, targetpos[0], targetpos[1], false);
+            WarpActor(actor, targetpos[0], targetpos[1], false);
             justWarping = false;
         }
     }
@@ -1791,7 +1792,7 @@
 }
 
 void WormHole::on_removal(GridPos p) {
-    world::RemoveForceField(&amp;ff);
+    RemoveForceField(&amp;ff);
     Item::on_removal(p);
     ASSERT(!justWarping, XLevelRuntime, &quot;Tried to kill a busy wormhole. Please use another way.&quot;);
 }
@@ -2008,7 +2009,7 @@
 {
     GridPos targetpos;
     // signals take precedence over targetx, targety attributes
-    if (world::GetSignalTargetPos(this, targetpos, idx)) {
+    if (GetSignalTargetPos(this, targetpos, idx)) {
         target = targetpos.center();
         return true;
     }
@@ -2040,7 +2041,7 @@
 
 void Vortex::emit_actor () {
     V2 v(m_target_vortex-&gt;get_pos().center());
-    world::WarpActor (m_actor_being_warped, v[0], v[1], false);
+    WarpActor (m_actor_being_warped, v[0], v[1], false);
     SendMessage (m_actor_being_warped, &quot;rise&quot;);
     m_actor_being_warped = 0;
 
@@ -2051,7 +2052,7 @@
 
 void Vortex::warp_to(const V2 &amp;target) {
     client::Msg_Sparkle (target);
-    world::WarpActor (m_actor_being_warped, target[0], target[1], false);
+    WarpActor (m_actor_being_warped, target[0], target[1], false);
     SendMessage (m_actor_being_warped, &quot;appear&quot;);
     m_actor_being_warped = 0;
     state = OPEN;
@@ -2082,7 +2083,7 @@
                 // is destination vortex blocked? redirect
                 m_target_index += 1;
                 client::Msg_Sparkle (v_target);
-                world::WarpActor (m_actor_being_warped,
+                WarpActor (m_actor_being_warped,
                                   v_target[0], v_target[1], false);
                 GameTimer.set_alarm(this, 0.4, false);
             }
@@ -2238,7 +2239,7 @@
             Direction dir = get_orientation();
             
             // usage within a st-window
-            Stone *stone = world::GetStone(get_pos());
+            Stone *stone = GetStone(get_pos());
             if (stone &amp;&amp; (stone-&gt;get_traits().id == st_window) &amp;&amp;
                     to_bool(SendMessage(stone, &quot;inner_pull&quot;, dir))) {
             }
@@ -2693,8 +2694,8 @@
 
 void Blocker::grow()
 {
-    Stone *st = world::MakeStone(&quot;st-blocker-growing&quot;);
-    world::SetStone(get_pos(), st);
+    Stone *st = MakeStone(&quot;st-blocker-growing&quot;);
+    SetStone(get_pos(), st);
     TransferObjectName(this, st);
     kill();
 }
@@ -2821,7 +2822,7 @@
                 sound_event (&quot;switchmarbles&quot;);
             }
             else {
-                world::RespawnActor(a);
+                RespawnActor(a);
             }
             return ITEM_DROP;
         }
@@ -3471,7 +3472,7 @@
         CLONEOBJ(Oxyd5fItem);
         DECL_TRAITS;
 
-        virtual Value on_message (const world::Message &amp;) {
+        virtual Value on_message (const Message &amp;) {
             PerformAction (this, true);
             return Value();
         }
@@ -3497,8 +3498,8 @@
             player::ReplaceActor((int)v, olda, newa);
         }
 
-        world::AddActor (newa);
-        if (!world::YieldActor (olda)) {
+        AddActor (newa);
+        if (!YieldActor (olda)) {
             enigma::Log &lt;&lt; &quot;Strange: could not remove old actor\n&quot;;
         }
         olda-&gt;hide();
@@ -3537,8 +3538,8 @@
 
             if (id == ac_blackball || id == ac_whiteball) {
                 // Kill ALL rubberbands connected with the actor:
-                world::KillRubberBands (a);
-                Actor *rotor = world::MakeActor (ac_rotor);
+                KillRubberBands (a);
+                Actor *rotor = MakeActor (ac_rotor);
                 rotor-&gt;set_attrib (&quot;mouseforce&quot;, Value (1.0));
                 rotor-&gt;set_attrib (&quot;controllers&quot;, Value (iplayer+1));
                 rotor-&gt;set_attrib (&quot;player&quot;, Value (iplayer));
@@ -3554,7 +3555,7 @@
 
                 replace_actor (a, rotor);
 
-                world::GameTimer.set_alarm (new DropCallback (rotor, a),
+                GameTimer.set_alarm (new DropCallback (rotor, a),
                                             ROTOR_LIFETIME,
                                             false);
             }
@@ -3580,7 +3581,7 @@
             double length = getAttr(&quot;length&quot;, 1.0);
             double minlength = getAttr(&quot;minlength&quot;, 0.0);
 
-            world::RubberBandData rbd;
+            RubberBandData rbd;
             rbd.strength = strength;
             rbd.length = length;
             rbd.minlength = minlength;
@@ -3604,17 +3605,17 @@
             if((!target_actor)&amp;&amp;(!target_stone)) return ITEM_DROP;
 
             if (isScissor)
-                world::KillRubberBands (a);
+                KillRubberBands (a);
 
             sound_event (&quot;rubberband&quot;);
             if (target_actor) {
                 // It's not allowed to connect a rubberband to self.
                 if (target_actor != a)
-                    world::AddRubberBand (a,target_actor,rbd);
+                    AddRubberBand (a,target_actor,rbd);
                 else
                     return ITEM_DROP; }
             else
-                world::AddRubberBand (a,target_stone,rbd);
+                AddRubberBand (a,target_stone,rbd);
 
             return ITEM_KILL;
         }
@@ -3627,7 +3628,7 @@
 
 /* -------------------- Functions -------------------- */
 
-void world::InitItems()
+void InitItems()
 {
     RegisterItem (new Bag);
     RegisterItem (new Banana);
@@ -3722,3 +3723,5 @@
     RegisterItem (new YinYang);
     RegisterItem (new Rubberband);
 }
+
+} // namespace enigma

Modified: trunk/src/items.hh
===================================================================
--- trunk/src/items.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/items.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -21,8 +21,8 @@
 
 #include &quot;objects_decl.hh&quot;
 
-namespace world
-{
+namespace enigma {
+    
     enum ItemID {
         it_INVALID = -1,
         it_FIRST = 0,
@@ -164,6 +164,7 @@
         float       radius;     //!&lt; Radius, 0.0 = default
     };
 
+    class Stone;
     class Item : public GridObject {
     public:
         Item();
@@ -256,6 +257,7 @@
 /* -------------------- Functions -------------------- */
 
     void InitItems();
-}
+    
+} // namespace enigma
 
 #endif

Modified: trunk/src/laser.cc
===================================================================
--- trunk/src/laser.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/laser.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -25,14 +25,10 @@
 #include &lt;map&gt;
 
 using namespace std;
-using namespace world;
-using namespace lasers;
 
-using stones::maybe_push_stone;
 using ecl::V2;
 
-namespace
-{
+namespace enigma {
 
 /* -------------------- LaserBeam -------------------- */
 
@@ -101,7 +97,7 @@
 \ref st-pmirror, \ref st-3mirror
 
 */
-    class LaserStone : public LaserEmitter, public stones::OnOffStone {
+    class LaserStone : public LaserEmitter, public OnOffStone {
     public:
         LaserStone (Direction dir=EAST);
         static void reemit_all();
@@ -140,9 +136,9 @@
         void on_creation (GridPos p);
         void init_model();
     };
-}
 
-
+
+
 /* -------------------- PhotoCell -------------------- */
 
 vector&lt;void*&gt; PhotoCell::instances;
@@ -337,7 +333,7 @@
         GridPos    pos = lb-&gt;get_pos();
 
         old_laser_positions[pos] = static_cast&lt;int&gt;(lb-&gt;directions);
-        world::KillItem(pos);
+        KillItem(pos);
     }
 }
 
@@ -486,7 +482,7 @@
         void on_recalc_finish() {}
 
         // Stone interface
-        void actor_hit(const world::StoneContact &amp;sc);
+        void actor_hit(const StoneContact &amp;sc);
         void on_creation (GridPos p);
         void on_removal (GridPos p);
         bool is_transparent(Direction) const { return is_transparent(); }
@@ -555,7 +551,7 @@
     return Value();
 }
 
-void MirrorStone::actor_hit(const world::StoneContact &amp;sc)
+void MirrorStone::actor_hit(const StoneContact &amp;sc)
 {
     if (is_movable())
         maybe_push_stone(sc);
@@ -588,7 +584,7 @@
         traits.movable = to_bool(val) ? MOVABLE_STANDARD : MOVABLE_PERSISTENT;
 }
     
-
+
 /* -------------------- Plane Mirror -------------------- */
 namespace
 {
@@ -666,7 +662,7 @@
     }
 }
 
-
+
 /* -------------------- TriangleMirror -------------------- */
 
 namespace
@@ -742,7 +738,7 @@
     bool light_recalc_scheduled = false;
 }
 
-void lasers::Init() {
+void InitLasers() {
     Register (new LaserStone);
     Register (&quot;st-laser-n&quot;, new LaserStone(NORTH));
     Register (&quot;st-laser-e&quot;, new LaserStone(EAST));
@@ -787,17 +783,17 @@
 }
 
 
-void lasers::MaybeRecalcLight(GridPos p) {
+void MaybeRecalcLight(GridPos p) {
     light_recalc_scheduled |=
         (LightFrom(p, NORTH) || LightFrom(p, SOUTH) ||
          LightFrom(p, WEST) || LightFrom(p, EAST));
 }
 
-void lasers::RecalcLight() {
+void RecalcLight() {
     light_recalc_scheduled = true;
 }
 
-bool lasers::LightFrom (GridPos p, Direction dir) {
+bool LightFrom (GridPos p, Direction dir) {
     p.move(dir);
     if (LaserEmitter *le = dynamic_cast&lt;LaserEmitter*&gt;(GetStone(p)))
         if (has_dir(le-&gt;emission_directions(), reverse(dir)))
@@ -807,7 +803,7 @@
     return false;
 }
 
-void lasers::RecalcLightNow() {
+void RecalcLightNow() {
     if (light_recalc_scheduled) {
         PhotoCell::notify_start();
         LaserBeam::kill_all();
@@ -817,3 +813,5 @@
         light_recalc_scheduled = false;
     }
 }
+
+} // namespace enigma

Modified: trunk/src/laser.hh
===================================================================
--- trunk/src/laser.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/laser.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -24,16 +24,15 @@
 
 #include &quot;objects.hh&quot;
 
-namespace world
-{
+namespace enigma {
     /**
      * This interface must be implemented by all items and stones that
      * are capable of emitting light.
      */
     class LaserEmitter {
     public:
-	virtual ~LaserEmitter() {}
-	virtual DirectionBits emission_directions() const = 0;
+        virtual ~LaserEmitter() {}
+        virtual DirectionBits emission_directions() const = 0;
     };
 
 /* -------------------- PhotoCell -------------------- */
@@ -101,12 +100,10 @@
         virtual void notify_laseron() = 0;
         virtual void notify_laseroff() = 0;
     };
-}
 
+
 /* -------------------- Functions -------------------- */
-namespace lasers
-{
-    void Init();
+    void InitLasers();
 
     /*! This function must be called at the end of each tick; it
       recalculates the laser beams if necessary. */
@@ -114,7 +111,7 @@
 
     /*! Force all light beams to be recalculated at the end of the
       current tick.  So far, this is only used by laser stones and in
-      world::InitWorld().  */
+      WorldInitLevel().  */
     void RecalcLight();
 
     /*! If position `p' is inside a laser beam, force all laser beams
@@ -127,5 +124,7 @@
     /*! Return true iff a stone or an item at position `p' it hit by
       light coming from direction `dir'. */
     bool LightFrom (enigma::GridPos p, enigma::Direction dir);
-}
+
+} // namespace enigma
+
 #endif

Modified: trunk/src/lua-display.cc
===================================================================
--- trunk/src/lua-display.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-display.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: display
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 #ifndef __cplusplus

Modified: trunk/src/lua-display.hh
===================================================================
--- trunk/src/lua-display.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-display.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: display
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 /* Exported function */

Modified: trunk/src/lua-ecl.cc
===================================================================
--- trunk/src/lua-ecl.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-ecl.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: px
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 #ifndef __cplusplus

Modified: trunk/src/lua-ecl.hh
===================================================================
--- trunk/src/lua-ecl.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-ecl.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: px
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 /* Exported function */

Modified: trunk/src/lua-editor.cc
===================================================================
--- trunk/src/lua-editor.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-editor.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: editor
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 #ifndef __cplusplus

Modified: trunk/src/lua-editor.hh
===================================================================
--- trunk/src/lua-editor.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-editor.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: editor
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 /* Exported function */

Modified: trunk/src/lua-enigma.cc
===================================================================
--- trunk/src/lua-enigma.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-enigma.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: enigma
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 #ifndef __cplusplus
@@ -21,7 +21,7 @@
 using ecl::Font;
 using namespace server;
 using namespace lev;
-using namespace world;
+using namespace enigma;
 #include &quot;video.hh&quot;
 using namespace video;
 using ecl::Screen;

Modified: trunk/src/lua-enigma.hh
===================================================================
--- trunk/src/lua-enigma.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-enigma.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: enigma
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 /* Exported function */

Modified: trunk/src/lua-global.cc
===================================================================
--- trunk/src/lua-global.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-global.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: global
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 #ifndef __cplusplus

Modified: trunk/src/lua-global.hh
===================================================================
--- trunk/src/lua-global.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua-global.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: global
-** Generated automatically by tolua++-1.0.92 on Fri Apr 20 13:59:44 2007.
+** Generated automatically by tolua++-1.0.92 on Mon Oct 29 00:41:21 2007.
 */
 
 /* Exported function */

Modified: trunk/src/lua.cc
===================================================================
--- trunk/src/lua.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -66,10 +66,10 @@
 using ecl::strf;
 
 using enigma::GridPos;
-using world::Object;
-using world::GridObject;
-using world::ForceField;
-using world::WorldProxy;
+using enigma::Object;
+using enigma::GridObject;
+using enigma::ForceField;
+using enigma::WorldProxy;
 
 namespace enigma { namespace lua {
      
@@ -197,7 +197,7 @@
     int id = *(static_cast&lt;int *&gt;(lua_touserdata(L,idx)));
     Object *obj = NULL;
     if (id != -1)
-       obj = world::Object::getObject(id);
+       obj = Object::getObject(id);
 
     return obj;  // NULL if object does no longer exist
 }
@@ -383,13 +383,13 @@
 /* -------------------- Interface routines -------------------- */
 
 
-int MakeObject (lua_State *L)
+int en_make_object (lua_State *L)
 {
     const char *name = lua_tostring(L, 1);
     if (!name) {
         throwLuaError(L, &quot;MakeObject: string expected as argument&quot;);
     }
-    Object *obj = world::MakeObject(name);
+    Object *obj = MakeObject(name);
     if (obj == NULL)
         throwLuaError(L, ecl::strf(&quot;MakeObject: unknown object name '%s'&quot;, name).c_str());
     pushobject(L, obj);
@@ -399,7 +399,7 @@
 static int
 en_get_object_template(lua_State *L)
 {
-    Object *obj = world::GetObjectTemplate(lua_tostring(L, 1));
+    Object *obj = GetObjectTemplate(lua_tostring(L, 1));
     pushobject(L, obj);
     return 1;
 }
@@ -474,7 +474,7 @@
              throwLuaError(L, &quot;object argument 3 must be a floor or nil&quot;);
          }
     }
-    world::SetFloor(GridPos(x,y), fl);
+    SetFloor(GridPos(x,y), fl);
     return 0;
 }
 
@@ -487,7 +487,7 @@
     if( ! it) {
         throwLuaError(L, &quot;object is no valid item&quot;);
     }
-    world::SetItem(GridPos(x,y), it);
+    SetItem(GridPos(x,y), it);
     return 0;
 }
 
@@ -499,7 +499,7 @@
     Stone *st = dynamic_cast&lt;Stone*&gt;(to_object(L, 3));
     if( ! st)
         throwLuaError(L, &quot;object is no valid stone&quot;);
-    world::SetStone(GridPos(x,y), st);
+    SetStone(GridPos(x,y), st);
     return 0;
 }
 
@@ -507,7 +507,7 @@
 {
     int x = round_down&lt;int&gt;(lua_tonumber(L, 1));
     int y = round_down&lt;int&gt;(lua_tonumber(L, 2));
-    world::KillStone(GridPos(x,y));
+    KillStone(GridPos(x,y));
     return 0;
 }
 
@@ -515,7 +515,7 @@
 {
     int x = round_down&lt;int&gt;(lua_tonumber(L, 1));
     int y = round_down&lt;int&gt;(lua_tonumber(L, 2));
-    world::KillItem(GridPos(x,y));
+    KillItem(GridPos(x,y));
     return 0;
 }
 
@@ -527,8 +527,8 @@
     Actor *ac = dynamic_cast&lt;Actor*&gt;(to_object(L, 3));
     if( ! ac)
         throwLuaError(L, &quot;object is no valid actor&quot;);
-    if (world::IsInsideLevel(GridPos(round_down&lt;int&gt;(x), round_down&lt;int&gt;(y))))
-        world::AddActor(x, y, ac);
+    if (IsInsideLevel(GridPos(round_down&lt;int&gt;(x), round_down&lt;int&gt;(y))))
+        AddActor(x, y, ac);
     else
         throwLuaError(L, &quot;position is outside of world&quot;);
     return 0;
@@ -545,7 +545,7 @@
         throwLuaError(L,&quot;Illegal message&quot;);
     else if (obj) {
         try {
-            v = world::SendMessage (obj, msg, to_value(L, 3));
+            v = SendMessage (obj, msg, to_value(L, 3));
         }
         catch (const XLevelRuntime &amp;e) {
             throwLuaError (L, e.what());
@@ -613,7 +613,7 @@
     else if (!name) 
         throwLuaError(L, &quot;NameObject: Illegal name&quot;);
     else
-        world::NameObject(obj, name);
+        NameObject(obj, name);
 
     return 0;
 }
@@ -621,7 +621,7 @@
 static int
 en_get_named_object(lua_State *L)
 {
-    Object *o = world::GetNamedObject(lua_tostring(L,1));
+    Object *o = GetNamedObject(lua_tostring(L,1));
     pushobject(L, o);
     return 1;
 }
@@ -631,7 +631,7 @@
 {
     int x = round_down&lt;int&gt;(lua_tonumber(L, 1));
     int y = round_down&lt;int&gt;(lua_tonumber(L, 2));
-    Object *o = world::GetFloor(GridPos(x, y));
+    Object *o = GetFloor(GridPos(x, y));
     pushobject(L, o);
     return 1;
 }
@@ -640,7 +640,7 @@
 {
     int x = round_down&lt;int&gt;(lua_tonumber(L, 1));
     int y = round_down&lt;int&gt;(lua_tonumber(L, 2));
-    Object *o = world::GetItem(GridPos(x, y));
+    Object *o = GetItem(GridPos(x, y));
     pushobject(L, o);
     return 1;
 }
@@ -649,7 +649,7 @@
 {
     int x = round_down&lt;int&gt;(lua_tonumber(L, 1));
     int y = round_down&lt;int&gt;(lua_tonumber(L, 2));
-    Object *o = world::GetStone(GridPos(x, y));
+    Object *o = GetStone(GridPos(x, y));
     pushobject(L, o);
     return 1;
 }
@@ -682,7 +682,7 @@
     ecl::V2 v;
     v[0] = lua_tonumber(L, 1);
     v[1] = lua_tonumber(L, 2);
-    world::SetConstantForce (v);
+    SetConstantForce (v);
     return 0;
 }
 
@@ -693,7 +693,7 @@
     Object *o2       = to_object(L, 2);
     Actor  *a2       = dynamic_cast&lt;Actor*&gt;(o2);
     Stone  *st       = dynamic_cast&lt;Stone*&gt;(o2);
-    world::RubberBandData d;
+    RubberBandData d;
     d.strength  = lua_tonumber (L, 3);
     d.length    = lua_tonumber (L, 4);
     d.minlength = lua_tonumber (L, 5);
@@ -702,9 +702,9 @@
         throwLuaError(L, &quot;AddRubberBand: First argument must be an actor\n&quot;);
     else {
         if (a2)
-            world::AddRubberBand (a1, a2, d);
+            AddRubberBand (a1, a2, d);
         else if (st)
-            world::AddRubberBand (a1, st, d);
+            AddRubberBand (a1, st, d);
         else
             throwLuaError(L, &quot;AddRubberBand: Second argument must be actor or stone\n&quot;);
     }
@@ -751,7 +751,7 @@
     char       *found   = strchr(allowed, dir[0]);
 
     if (found &amp;&amp; found[0]) 
-        world::AddScramble(GridPos(x,y), enigma::Direction(found-allowed));
+        AddScramble(GridPos(x,y), enigma::Direction(found-allowed));
     else 
         throwLuaError(L, &quot;AddScramble: Third argument must be one character of \&quot;wsen\&quot;&quot;);
 
@@ -761,7 +761,7 @@
 static int
 en_set_scramble_intensity(lua_State *L)
 {
-    world::SetScrambleIntensity(int(lua_tonumber(L, 1)));
+    SetScrambleIntensity(int(lua_tonumber(L, 1)));
     return 0;
 }
 
@@ -781,7 +781,7 @@
     if (msg == 0)
         msg = &quot;signal&quot;;
 
-    world::AddSignal (source, target, msg);
+    AddSignal (source, target, msg);
     return 0;
 }
 
@@ -1005,7 +1005,7 @@
             std::string key = lua_tostring(L, -1);
             if (key == &quot;name&quot;) {
                 if (lua_isstring(L, -2))
-                    world::NameObject(obj, lua_tostring(L, -2));
+                    NameObject(obj, lua_tostring(L, -2));
             } else {
                 obj-&gt;set_attrib(key, to_value(L, -2));
             }
@@ -1031,7 +1031,7 @@
     int x = round_down&lt;int&gt;(lua_tonumber(L, -1));
     lua_rawgeti(L, -2, 2);
     int y = round_down&lt;int&gt;(lua_tonumber(L, -1));
-    Object *o = world::GetFloor(GridPos(x, y));
+    Object *o = GetFloor(GridPos(x, y));
     pushobject(L, o);
     return 1;
 }
@@ -1046,7 +1046,7 @@
     int x = round_down&lt;int&gt;(lua_tonumber(L, -1));
     lua_rawgeti(L, -2, 2);
     int y = round_down&lt;int&gt;(lua_tonumber(L, -1));
-    Object *o = world::GetItem(GridPos(x, y));
+    Object *o = GetItem(GridPos(x, y));
     pushobject(L, o);
     return 1;
 }
@@ -1061,7 +1061,7 @@
     int x = round_down&lt;int&gt;(lua_tonumber(L, -1));
     lua_rawgeti(L, -2, 2);
     int y = round_down&lt;int&gt;(lua_tonumber(L, -1));
-    Object *o = world::GetStone(GridPos(x, y));
+    Object *o = GetStone(GridPos(x, y));
     pushobject(L, o);
     return 1;
 }
@@ -1073,15 +1073,15 @@
         switch (obj-&gt;getObjectType()) {
             case Object::FLOOR :
                 gobj = dynamic_cast&lt;GridObject*&gt;(obj);
-                world::KillFloor(gobj-&gt;get_pos());
+                KillFloor(gobj-&gt;get_pos());
                 break;
             case Object::STONE :
                 gobj = dynamic_cast&lt;GridObject*&gt;(obj);
-                world::KillStone(gobj-&gt;get_pos());
+                KillStone(gobj-&gt;get_pos());
                 break;
             case Object::ITEM  :
                 gobj = dynamic_cast&lt;GridObject*&gt;(obj);
-                world::KillItem(gobj-&gt;get_pos());
+                KillItem(gobj-&gt;get_pos());
                 break;
             case Object::ACTOR :
             default :
@@ -1156,7 +1156,7 @@
     
     if (obj) {   // ignore not existing objects
         try {
-            answer = world::SendMessage (obj, msg, val);
+            answer = SendMessage (obj, msg, val);
         }
         catch (const XLevelRuntime &amp;e) {
             throwLuaError (L, e.what());
@@ -1531,11 +1531,11 @@
     
     if (name.find_first_of(&quot;*?&quot;) != std::string::npos) {
         // search all objects that match the template
-        std::list&lt;Object *&gt; group = world::GetNamedGroup(name);
+        std::list&lt;Object *&gt; group = GetNamedGroup(name);
         return pushNewGroup(L, group);
     } else {    
         // search for a unique object
-        Object *obj = world::GetNamedObject(name);
+        Object *obj = GetNamedObject(name);
         pushobject(L, obj);
     }
     return 1;
@@ -1555,7 +1555,7 @@
         throwLuaError(L, &quot;NameObject: names with leading '$' are reserved&quot;);
         return 0;
     }
-    world::NameObject(obj, name);
+    NameObject(obj, name);
     return 0;
 }
 
@@ -1614,17 +1614,17 @@
     }
     
     if (name == &quot;fl-nil&quot;) {
-        world::KillFloor(GridPos(xi, yi));
+        KillFloor(GridPos(xi, yi));
         return 0;
     } else if (name == &quot;st-nil&quot;) {
-        world::KillStone(GridPos(xi, yi));
+        KillStone(GridPos(xi, yi));
         return 0;
     } else if (name == &quot;it-nil&quot;) {
-        world::KillItem(GridPos(xi, yi));
+        KillItem(GridPos(xi, yi));
         return 0;
     }
     
-    obj = world::MakeObject(name.c_str());
+    obj = MakeObject(name.c_str());
     if (obj == NULL) {
         throwLuaError(L, ecl::strf(&quot;World: unknown object name '%s'&quot;, name.c_str()).c_str());
         return 0;
@@ -1637,13 +1637,13 @@
                 if ((xi+yi)%2 != (int)odd)
                     break;
             }
-            world::SetFloor(GridPos(xi,yi), dynamic_cast&lt;Floor *&gt;(obj));
+            SetFloor(GridPos(xi,yi), dynamic_cast&lt;Floor *&gt;(obj));
             break;
         case Object::STONE :
-            world::SetStone(GridPos(xi,yi), dynamic_cast&lt;Stone *&gt;(obj));
+            SetStone(GridPos(xi,yi), dynamic_cast&lt;Stone *&gt;(obj));
             break;
         case Object::ITEM  :
-            world::SetItem(GridPos(xi,yi), dynamic_cast&lt;Item *&gt;(obj));
+            SetItem(GridPos(xi,yi), dynamic_cast&lt;Item *&gt;(obj));
             break;
         case Object::ACTOR :
             lua_rawgeti(L, -1, 2);
@@ -1653,8 +1653,8 @@
             if (lua_isnumber(L, -1))
                 y += lua_tonumber(L, -1);
             lua_pop(L, 2);               
-            if (world::IsInsideLevel(GridPos(round_down&lt;int&gt;(x), round_down&lt;int&gt;(y)))) 
-                world::AddActor(x, y, dynamic_cast&lt;Actor *&gt;(obj));
+            if (IsInsideLevel(GridPos(round_down&lt;int&gt;(x), round_down&lt;int&gt;(y)))) 
+                AddActor(x, y, dynamic_cast&lt;Actor *&gt;(obj));
             else
                 throwLuaError(L, &quot;World: actor addition to position outside of world&quot;);
             break;
@@ -1727,7 +1727,7 @@
     width = width/keyLength;
     Log &lt;&lt; &quot;initWorld  - w &quot; &lt;&lt; width &lt;&lt; &quot;  - h &quot; &lt;&lt; height &lt;&lt; &quot;\n&quot;;
 
-    world::Resize(width, height);
+    Resize(width, height);
     
     luaL_getmetatable(L, LUA_ID_TILES);
     lua_rawgeti(L, -1, 1);               // tiles content table
@@ -2063,7 +2063,7 @@
     {FindDataFile,          &quot;FindDataFile&quot;},
     {loadLib,               &quot;LoadLib&quot;},
     {en_get_object_template,&quot;GetObjectTemplate&quot;},
-    {lua::MakeObject,       &quot;MakeObject&quot;},
+    {en_make_object,        &quot;MakeObject&quot;},
     {en_set_actor,          &quot;SetActor&quot;},
 
     // finding objects
@@ -2299,7 +2299,7 @@
     }
 }
 
-Error CallFunc(lua_State *L, const char *funcname, const Value&amp; arg, world::Object *obj) {
+Error CallFunc(lua_State *L, const char *funcname, const Value&amp; arg, Object *obj) {
     int retval;
     lua_getglobal(L, funcname);
     push_value(L, arg);
@@ -2482,7 +2482,7 @@
     RegisterFuncs(L, levelfuncs);
     RegisterFuncs2(L, levelFuncs);
 
-    // Create a new metatable for world::Object objects
+    // Create a new metatable for world objects
     RegisterLuaType(L, LUA_ID_OBJECT, objectOperations, objectMethods, objectMethodeMap);
     RegisterLuaType(L, LUA_ID_POSITION, positionOperations, positionMethods, positionMethodeMap);
     RegisterLuaType(L, LUA_ID_NAMEOBJ, namedObjOperations, namedObjMethods, namedObjMethodeMap);

Modified: trunk/src/lua.hh
===================================================================
--- trunk/src/lua.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/lua.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -89,7 +89,7 @@
 
     /*! Call a Lua function with one argument.  This is mainly used
       for callbacks during the game. */
-    Error CallFunc(lua_State *L, const char *funcname, const enigma::Value&amp; arg, world::Object *obj);
+    Error CallFunc(lua_State *L, const char *funcname, const enigma::Value&amp; arg, Object *obj);
 
     /*! Call a Lua function with a (large) byte vector as the sole
       argument.  Currently only used for loading XML levels. */

Modified: trunk/src/main.cc
===================================================================
--- trunk/src/main.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/main.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -79,7 +79,7 @@
     class Nulbuf : public std::streambuf {};
     Nulbuf* nullbuffer = new Nulbuf;
 }
-
+
 /* -------------------- Variables -------------------- */
 
 namespace enigma
@@ -299,9 +299,9 @@
     init_i18n();
     
     // ----- Initialize object repositories
-    world::Init();
+    InitWorld();
     if (ap.dumpinfo) {
-        world::DumpObjectInfo();
+        DumpObjectInfo();
         exit(0);
     }
 
@@ -788,7 +788,7 @@
 void Application::shutdown() 
 {
     oxyd::Shutdown();
-    world::Shutdown();
+    enigma::ShutdownWorld();
     display::Shutdown();
     if (!isMakePreviews) { // avoid saves on preview generation
         lev::RatingManager::instance()-&gt;save();

Modified: trunk/src/objects.cc
===================================================================
--- trunk/src/objects.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/objects.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -35,9 +35,9 @@
 
 
 using namespace std;
-using namespace enigma;
-using namespace world;
 
+namespace enigma {
+
 // remove comment from define below to switch on verbose messaging
 // note: VERBOSE_MESSAGES is defined in multiple source files!
 // #define VERBOSE_MESSAGES
@@ -87,7 +87,7 @@
     return id;
 }
 
-Value Object::on_message (const world::Message &amp;m)
+Value Object::on_message (const Message &amp;m)
 {
     return message (m.message, m.value);
 }
@@ -253,3 +253,5 @@
 
     va_end(arg_ptr);
 }
+
+} // namespace enigma

Modified: trunk/src/objects.hh
===================================================================
--- trunk/src/objects.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/objects.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -25,13 +25,5 @@
 #include &quot;stones.hh&quot;
 #include &quot;actors.hh&quot;
 
-namespace enigma
-{
-    using world::Item;
-    using world::Stone;
-    using world::Actor;
-    using world::Floor;
-    using world::Object;
-}
 
 #endif

Modified: trunk/src/objects_decl.hh
===================================================================
--- trunk/src/objects_decl.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/objects_decl.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -24,10 +24,11 @@
 #include &quot;ecl_alist.hh&quot;
 #include &lt;map&gt;
 
-namespace world
-{
+namespace enigma { 
+
     using std::string;
-    using namespace enigma;
+    
+    struct Message;
 
 /* -------------------- Objects -------------------- */
 
@@ -143,6 +144,7 @@
     };
 
 /* -------------------- GridObject -------------------- */
+    class Actor;
 
     /** 
      * GridObject is the base class for everything that can only be
@@ -233,9 +235,10 @@
          */
         GridPos pos;
     };
-}
 
+} // namespace enigma
 
+
 #define CLONEOBJ(TYPE)                                  \
         TYPE* clone() { return new TYPE(*this); }       \
         void dispose() { delete this; }

Modified: trunk/src/ox_extra.cc
===================================================================
--- trunk/src/ox_extra.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/ox_extra.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -31,10 +31,10 @@
 // Standard enigma section :
 
 #define ITEMSPEC(i) i
-#define ITEMMAPTYPE world::ItemID
+#define ITEMMAPTYPE enigma::ItemID
 
 #include &quot;oxyd_internal.hh&quot;
-using namespace world;
+using namespace enigma;
 
 #endif // PLAIN_SPEC_ONLY
 // only tables following!

Modified: trunk/src/ox_magnum.cc
===================================================================
--- trunk/src/ox_magnum.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/ox_magnum.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -31,10 +31,10 @@
 // Standard enigma section :
 
 #define ITEMSPEC(i) i
-#define ITEMMAPTYPE world::ItemID
+#define ITEMMAPTYPE enigma::ItemID
 
 #include &quot;oxyd_internal.hh&quot;
-using namespace world;
+using namespace enigma;
 
 #endif // PLAIN_SPEC_ONLY
 // only tables following!

Modified: trunk/src/ox_peroxyd.cc
===================================================================
--- trunk/src/ox_peroxyd.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/ox_peroxyd.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -31,13 +31,13 @@
 // Standard enigma section :
 
 #define ITEMSPEC(i) i
-#define ITEMMAPTYPE world::ItemID
+#define ITEMMAPTYPE enigma::ItemID
 
 #include &quot;objects.hh&quot;
 #include &quot;server.hh&quot;
 #include &quot;oxyd_internal.hh&quot;
 
-using namespace world;
+using namespace enigma;
 using namespace oxyd;
 
 Stone *PerOxydLoader::make_stone (int type, int x, int y)

Modified: trunk/src/oxyd.cc
===================================================================
--- trunk/src/oxyd.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/oxyd.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -41,15 +41,15 @@
 
 using namespace std;
 using namespace enigma;
-using world::Stone;
-using world::MakeStone;
-using world::Item;
-using world::MakeItem;
+using enigma::Stone;
+using enigma::MakeStone;
+//using enigma::Item;
+using enigma::MakeItem;
 
 using namespace oxyd;
 using OxydLib::Level;
 
-
+
 /* -------------------- Helper functions -------------------- */
 
 namespace 
@@ -92,21 +92,21 @@
         const Grid &amp;sgrid = level.getGrid (GridType_Pieces);
         for (unsigned y=0; y&lt;sgrid.getHeight(); ++y)
             for (unsigned x=0; x&lt;sgrid.getWidth(); ++x)
-                if (Stone *st = world::GetStone(GridPos(x, y)))
+                if (Stone *st = GetStone(GridPos(x, y)))
                     if (int code = st-&gt;getAttr(&quot;code&quot;))
                         stones.insert(code);
 
         const Grid &amp;igrid = level.getGrid (GridType_Objects);
         for (unsigned y=0; y&lt;igrid.getHeight(); ++y)
             for (unsigned x=0; x&lt;igrid.getWidth(); ++x)
-                if (Item *it = world::GetItem(GridPos(x, y)))
+                if (Item *it = GetItem(GridPos(x, y)))
                     if (int code = it-&gt;getAttr(&quot;code&quot;))
                         items.insert(code);
 
         const Grid &amp;fgrid = level.getGrid (GridType_Objects);
         for (unsigned y=0; y&lt;fgrid.getHeight(); ++y)
             for (unsigned x=0; x&lt;fgrid.getWidth(); ++x)
-                if (world::Floor *fl = world::GetFloor(GridPos(x, y)))
+                if (Floor *fl = GetFloor(GridPos(x, y)))
                     if (int code = fl-&gt;getAttr(&quot;code&quot;))
                         floors.insert(code);
 
@@ -238,7 +238,7 @@
 void OxydLoader::load ()
 {
     // Prepare Enigma game engine
-    world::Resize (level.getWidth(), level.getHeight());
+    Resize (level.getWidth(), level.getHeight());
     if (config.twoplayers) 
         server::TwoPlayerGame = true;
     display::ResizeGameArea (20, 11);
@@ -287,7 +287,7 @@
 Stone *OxydLoader::make_timer (int x, int y)
 {
     const OscillatorMap &amp;oscillators = level.getOscillators(config.gamemode);
-    Stone *st = world::MakeStone (&quot;st-timer&quot;);
+    Stone *st = MakeStone (&quot;st-timer&quot;);
     st-&gt;set_attrib(&quot;interval&quot;, Value(0.2));
 
     Block block(x, y);
@@ -303,7 +303,7 @@
 
 Stone *OxydLoader::make_stone (int type, int x, int y)
 {
-    world::Stone *st = 0;
+    Stone *st = 0;
 
     if (type == 0) {
         // ignore
@@ -313,7 +313,7 @@
         char color[2] = &quot;0&quot;;
         color[0] += (type-1) / 2; 
 
-        st = world::MakeStone(&quot;st-oxyd&quot;);
+        st = MakeStone(&quot;st-oxyd&quot;);
         st-&gt;set_attrib(&quot;color&quot;, color);
         st-&gt;set_attrib(&quot;flavor&quot;, config.oxyd_flavor);
     }
@@ -328,11 +328,11 @@
         const char *name = config.stonetable[type];
         if (name == 0) {
             Log &lt;&lt; ecl::strf(&quot;Unknown stone %X\n&quot;, type);
-            st = world::MakeStone (&quot;st-dummy&quot;);
+            st = MakeStone (&quot;st-dummy&quot;);
             st-&gt;set_attrib(&quot;code&quot;, type);
         }
         else if (name[0] != '\0') { // ignore if name==&quot;&quot;
-            st = world::MakeStone (name);
+            st = MakeStone (name);
         }
     }
     return st;
@@ -370,7 +370,6 @@
 
 Item  *OxydLoader::make_item (int type)
 {
-    using namespace world;
 
     Item *it = 0;
 
@@ -385,14 +384,14 @@
     case 0x00: break;           // ignore
     case 0x02:                  // note 1
 	{
-	    it = MakeItem (world::it_document);
+	    it = MakeItem (it_document);
 	    string text = convert_encoding(level.getNoteText(0, lang));
 	    it-&gt;set_attrib (&quot;text&quot;, text.c_str());
 	}
         break;
     case 0x03:                  // note 2
 	{
-	    it = MakeItem (world::it_document);
+	    it = MakeItem (it_document);
 	    string text = convert_encoding(level.getNoteText(1, lang));
 	    it-&gt;set_attrib (&quot;text&quot;, text.c_str());
 	}
@@ -402,7 +401,7 @@
             ItemID id = config.itemtable[type];
             if (id == it_INVALID) {
                 Log &lt;&lt; ecl::strf (&quot;Unknown item %X\n&quot;,type);
-                it = MakeItem (world::it_dummy);
+                it = MakeItem (it_dummy);
                 it-&gt;set_attrib(&quot;code&quot;, type);
             }
             else
@@ -415,7 +414,6 @@
 
 void OxydLoader::load_floor () 
 {
-    using namespace world;
 
     const Grid &amp;grid = level.getGrid (GridType_Surfaces);
     for (unsigned y=0; y&lt;grid.getHeight(); ++y) {
@@ -444,12 +442,11 @@
     for (unsigned y=0; y&lt;grid.getHeight(); ++y)
         for (unsigned x=0; x&lt;grid.getWidth(); ++x)
             if (Item *it = make_item (grid.get(x,y)))
-                world::SetItem (GridPos(x, y), it);
+                SetItem (GridPos(x, y), it);
 }
 
 void OxydLoader::load_stones()
 {
-    using namespace world;
 
     const Grid &amp;grid = level.getGrid (GridType_Pieces);
     for (unsigned y=0; y&lt;grid.getHeight(); ++y) {
@@ -468,7 +465,7 @@
 
     for (int i = 0; i&lt;count; ++i) {
         const ScrambleItem&amp; si = level.getScrambleItem(i);
-        world::AddScramble (GridPos(si.getX(), si.getY()),
+        AddScramble (GridPos(si.getX(), si.getY()),
                             direction_oxyd2enigma(si.getDir()));
     }
 }
@@ -476,7 +473,7 @@
 
 void OxydLoader::load_actors () 
 {
-    using world::MakeActor;
+    using enigma::MakeActor;
 
     int     nmeditationmarbles = 0;
     size_t  nmarbles           = level.getNumMarbles();
@@ -497,23 +494,23 @@
 
         switch (marble.getMarbleType()) {
         case MarbleType_Black:
-            ac = MakeActor (world::ac_blackball);
+            ac = MakeActor (ac_blackball);
             ac-&gt;set_attrib (&quot;player&quot;, Value(0.0));
             break;
         case MarbleType_White:
-            ac = MakeActor (world::ac_whiteball);
+            ac = MakeActor (ac_whiteball);
             ac-&gt;set_attrib (&quot;player&quot;, Value(1.0));
             break;
         case MarbleType_Meditation:
             if (have_black_marble &amp;&amp; !level.getHarmlessMeditationMarbles()) {
                 // # example: Oxyd Extra #28
-                ac = MakeActor (world::ac_killerball);
+                ac = MakeActor (ac_killerball);
 //                ac-&gt;set_attrib (&quot;player&quot;, Value(0.0));
                 ac-&gt;set_attrib (&quot;mouseforce&quot;, Value (1.0));
                 ac-&gt;set_attrib (&quot;controllers&quot;, Value (3.0));
             }
             else {
-                ac = MakeActor (world::ac_meditation);
+                ac = MakeActor (ac_meditation);
                 nmeditationmarbles += 1;
 
                 if (config.twoplayers &amp;&amp; (nmeditationmarbles % 2) == 0)
@@ -530,7 +527,7 @@
             }
             break;
         case MarbleType_Jack:
-            ac = MakeActor (world::ac_top);
+            ac = MakeActor (ac_top);
             if (!minfo.is_default(MI_FORCE)) {
                 double force = minfo.get_value(MI_FORCE) / 4; // just a guess
                 ac-&gt;set_attrib(&quot;force&quot;, Value(force) );
@@ -544,7 +541,7 @@
             break;
 
         case MarbleType_Rotor: {
-            ac = MakeActor (world::ac_rotor);
+            ac = MakeActor (ac_rotor);
 
             double force = minfo.get_value (MI_FORCE, 30) * 0.3;
             double range = minfo.get_value (MI_RANGE, 100) / 32.0;
@@ -561,7 +558,7 @@
         }
 
         case MarbleType_Horse: {
-            ac = MakeActor (world::ac_horse);
+            ac = MakeActor (ac_horse);
             int levelw = level.getWidth();
             if (!minfo.is_default(MI_HORSETARGET1)) {
                 int targetpos = minfo.get_value(MI_HORSETARGET1);
@@ -590,7 +587,7 @@
             break;
         }
         case MarbleType_Bug:
-            ac = MakeActor (world::ac_bug);
+            ac = MakeActor (ac_bug);
             break;
         default:
             enigma::Log &lt;&lt; &quot;Unhandled actor type &quot; &lt;&lt; int(marble.getMarbleType()) &lt;&lt; endl;
@@ -601,7 +598,7 @@
         }
 
         if (ac) 
-            world::AddActor (x, y, ac);
+            AddActor (x, y, ac);
 
         m_actors.push_back (ac);
     }
@@ -614,18 +611,18 @@
     for (int i=0; i&lt;num_rubberbands; ++i) {
         const RubberBand &amp;rb = level.getRubberBand(game_mode, i);
 
-        world::Actor *actor = get_actor (rb.getFirstEndMarble());
-        world::RubberBandData rbd;
+        Actor *actor = get_actor (rb.getFirstEndMarble());
+        RubberBandData rbd;
         rbd.length = rb.getNaturalLength() / 32.0;
         rbd.strength = rb.getForce() / 60.0;
         if (rb.isSecondEndMarble()) {
-            world::Actor *actor2 = get_actor (rb.getSecondEndMarble());
-            world::AddRubberBand (actor, actor2, rbd);
+            Actor *actor2 = get_actor (rb.getSecondEndMarble());
+            AddRubberBand (actor, actor2, rbd);
         }
         else {
             GridPos p(rb.getSecondEndPieceX(), rb.getSecondEndPieceY());
-            if (world::GetStone(p) != NULL) // Fix for MagnumGold Level #108
-                world::AddRubberBand (actor, world::GetStone(p), rbd); 
+            if (GetStone(p) != NULL) // Fix for MagnumGold Level #108
+                AddRubberBand (actor, GetStone(p), rbd); 
         }
     }
 }
@@ -646,14 +643,14 @@
             SignalLocation recipient = level.getRecipient(sender, irec);
             GridLoc src = to_gridloc(sender);
             GridLoc dst = to_gridloc(recipient);
-            world::AddSignal (src, dst, &quot;signal&quot;);
+            AddSignal (src, dst, &quot;signal&quot;);
         }
     }
 }
 
 void OxydLoader::parse_specials ()
 {
-    using world::SendMessage;
+    using enigma::SendMessage;
 
     server::FlatForce = 5.0 * level.getFlatForce (config.gamemode);
 
@@ -689,22 +686,22 @@
 
         case 'i':           // turn item on
             if (parse_gridpos (cmd, levelw, levelh, p))
-                SendMessage(world::GetItem(p), &quot;signal&quot;, Value(1.0));
+                SendMessage(GetItem(p), &quot;signal&quot;, Value(1.0));
             break;
 
         case 'o':           // turn item off
             if (parse_gridpos (cmd, levelw, levelh, p))
-                SendMessage(world::GetItem(p), &quot;signal&quot;, Value(0.0));
+                SendMessage(GetItem(p), &quot;signal&quot;, Value(0.0));
             break;
 
         case 'I':           // turn stone on
             if (parse_gridpos (cmd, levelw, levelh, p))
-                SendMessage(world::GetStone(p), &quot;signal&quot;, Value(1.0));
+                SendMessage(GetStone(p), &quot;signal&quot;, Value(1.0));
             break;
 
         case 'O':           // turn stone off
             if (parse_gridpos (cmd, levelw, levelh, p))
-                SendMessage(world::GetStone(p), &quot;signal&quot;, Value(0.0));
+                SendMessage(GetStone(p), &quot;signal&quot;, Value(0.0));
             break;
 
         case 'Q':           // default charge
@@ -722,7 +719,7 @@
     }
 }
 
-world::Actor *OxydLoader::get_actor (int idx) 
+Actor *OxydLoader::get_actor (int idx) 
 {
     assert (0 &lt;= idx &amp;&amp; unsigned(idx) &lt;= m_actors.size());
     return m_actors[idx];
@@ -730,7 +727,7 @@
 
 
 
-
+
 /* -------------------- LevelPack_Oxyd -------------------- */
 
 LevelPack_Oxyd::LevelPack_Oxyd (OxydVersion ver, DatFile *dat, 
@@ -881,7 +878,7 @@
     PerOxydLoader (level, c).load();
 
     // Add a yinyang item if a white marble is present
-    if (world::CountActorsOfKind (world::ac_whiteball) &gt; 0)
+    if (CountActorsOfKind (ac_whiteball) &gt; 0)
         player::AddYinYang();
 }
 

Modified: trunk/src/oxyd_internal.hh
===================================================================
--- trunk/src/oxyd_internal.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/oxyd_internal.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -54,7 +54,7 @@
         bool           twoplayers;
         GameMode       gamemode;
         const char   **floortable;
-        world::ItemID *itemtable;
+        ItemID        *itemtable;
         const char   **stonetable;
 
         int id_timer;
@@ -64,7 +64,7 @@
         LoaderConfig (bool twoplayers_,
                       GameMode gamemode_,
                       const char **floortable_,
-                      world::ItemID *itemtable_,
+                      ItemID *itemtable_,
                       const char **stonetable_,
                       const char *oxyd_flavor_ = &quot;a&quot;
                       )
@@ -114,11 +114,11 @@
 
         void connect_rubberbands ();
         void connect_signals ();
-        world::Actor *get_actor (int idx);
+        Actor *get_actor (int idx);
 
 
         /* ---------- Private variables ---------- */
-        std::vector&lt;world::Actor *&gt; m_actors;
+        std::vector&lt;Actor *&gt; m_actors;
         bool harmless_medi;
     };
 
@@ -303,19 +303,19 @@
 
 /* -------------------- Global Variables -------------------- */
 
-    extern world::ItemID oxyd1_item_map[];
+    extern ItemID oxyd1_item_map[];
     extern const char *oxyd1_floor_map[];
     extern const char *oxyd1_stone_map[];
 
-    extern world::ItemID peroxyd_item_map[];
+    extern ItemID peroxyd_item_map[];
     extern const char *peroxyd_floor_map[];
     extern const char *peroxyd_stone_map[];
 
-    extern world::ItemID oxydmag_item_map[];
+    extern ItemID oxydmag_item_map[];
     extern const char *oxydmag_floor_map[];
     extern const char *oxydmag_stone_map[];
 
-    extern world::ItemID oxydextra_item_map[];
+    extern ItemID oxydextra_item_map[];
     extern const char *oxydextra_floor_map[];
     extern const char *oxydextra_stone_map[];
 

Modified: trunk/src/player.cc
===================================================================
--- trunk/src/player.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/player.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -34,8 +34,7 @@
 
 using namespace std;
 using namespace enigma;
-using namespace world;
-using world::Actor;
+using enigma::Actor;
 using enigma::Inventory;
 
 namespace
@@ -115,7 +114,7 @@
     const double RESPAWN_TIME = 1.5;
 
 //    a-&gt;find_respawnpos();
-    world::SendMessage(a, &quot;resurrect&quot;);
+    SendMessage(a, &quot;resurrect&quot;);
     remove_extralife(a);
     respawn_list.push_back(RespawnInfo(a, RESPAWN_TIME));
 }
@@ -182,7 +181,7 @@
         Inventory *inv = GetInventory(i);
         inv-&gt;assignOwner(i);
         for (int j = 0 ; j &lt; extralives[i]; j++)
-            inv-&gt;add_item (MakeItem (world::it_extralife));
+            inv-&gt;add_item (MakeItem (it_extralife));
     }
     
     unassignedActors.clear();
@@ -194,7 +193,7 @@
     for (unsigned i=0; i&lt;players.size(); ++i) {
         Inventory *inv = GetInventory (i);
         if (inv-&gt;find (&quot;it-yinyang&quot;) == -1) 
-            inv-&gt;add_item (world::MakeItem (world::it_yinyang));
+            inv-&gt;add_item (MakeItem (it_yinyang));
     }
 }
 
@@ -213,11 +212,11 @@
         Inventory *inv = GetInventory(iplayer);
         int nextralifes=0;
         for (size_t i=0; i&lt;inv-&gt;size(); ++i)
-            if (get_id (inv-&gt;get_item(i)) == world::it_extralife)
+            if (get_id (inv-&gt;get_item(i)) == it_extralife)
                 nextralifes += 1;
         inv-&gt;clear();
         for (int i=0; i&lt;nextralifes; ++i)
-            inv-&gt;add_item (world::MakeItem (world::it_extralife));
+            inv-&gt;add_item (MakeItem (it_extralife));
 
         players[iplayer].actors.clear();
     }
@@ -231,8 +230,8 @@
     for (unsigned i=0; i&lt;players.size(); ++i) {
         for (unsigned j=0; j&lt;players[i].actors.size(); ++j) {
             Actor *a = players[i].actors[j];
-            world::SendMessage(a, &quot;disappear&quot;);
-            world::KillRubberBands (a);
+            SendMessage(a, &quot;disappear&quot;);
+            KillRubberBands (a);
         }
     }
 }
@@ -318,7 +317,7 @@
     for (unsigned i=0; i&lt;players.size(); ++i) {
         vector&lt;Actor *&gt; &amp;al = players[i].actors;
         for (unsigned j=0; j&lt;al.size(); ++j) {
-            world::SendMessage(al[j], &quot;suicide&quot;);
+            SendMessage(al[j], &quot;suicide&quot;);
         }
     }
 }
@@ -344,7 +343,7 @@
     if (iplayer &gt;= players.size())
         server::RaiseError (&quot;Invalid actor number&quot;);
 
-    world::ReleaseActor(a);
+    ReleaseActor(a);
     players[iplayer].actors.push_back(a);
 
     if (players[iplayer].actors.size() == 1) {
@@ -562,7 +561,7 @@
 void player::PickupItem (Actor *a, GridPos p) 
 {
     if (Inventory *inv = MayPickup(a, GetField(p)-&gt;item)) {
-        if (Item *item = world::YieldItem(p)) {
+        if (Item *item = YieldItem(p)) {
             item-&gt;on_pickup(a);
             inv-&gt;add_item(item);
             RedrawInventory (inv);
@@ -575,15 +574,15 @@
 {
     if (Inventory *inv = MayPickup(a, GetField(p)-&gt;item)) 
     {
-        if (world::Stone *stone = world::YieldStone(p)) 
+        if (Stone *stone = YieldStone(p)) 
         {
             string kind = stone-&gt;get_kind();
             if (kind[0] == 's') 
                 kind[0] = 'i';
 
-            if (Item *item = world::MakeItem(kind.c_str())) {
+            if (Item *item = MakeItem(kind.c_str())) {
                 KillRubberBands(stone);
-                world::DisposeObject (stone);
+                DisposeObject (stone);
                 inv-&gt;add_item(item);
                 player::RedrawInventory(inv);
                 sound::EmitSoundEvent (&quot;pickup&quot;, p.center());
@@ -599,7 +598,7 @@
 
     if (inv.size() &gt; 0) {
         Item *it = inv.get_item (0);
-        world::Actor *ac = 0;
+        Actor *ac = 0;
         GridPos p;
         bool can_drop_item = false;
         if (!players[icurrent_player].actors.empty()) {
@@ -609,7 +608,7 @@
         }
 
         switch (it-&gt;activate(ac, p)) {
-        case world::ITEM_DROP:
+        case ITEM_DROP:
             // only drop if no item underneath and actor allows it
             if (it-&gt;can_drop_at(p) &amp;&amp; can_drop_item) {
                 it = inv.yield_first ();
@@ -617,11 +616,11 @@
                 it-&gt;drop(ac, p);
             }
             break;
-        case world::ITEM_KILL:
+        case ITEM_KILL:
             DisposeObject (inv.yield_first ());
             RedrawInventory (&amp;inv);
             break;
-        case world::ITEM_KEEP:
+        case ITEM_KEEP:
             break;
         }
     }
@@ -654,7 +653,7 @@
     Inventory *inv = GetInventory (CurrentPlayer());
     std::vector&lt;std::string&gt; modelnames;
     for (size_t i=0; i&lt;inv-&gt;size(); ++i) {
-        world::Item *it = inv-&gt;get_item(i);
+        Item *it = inv-&gt;get_item(i);
         modelnames.push_back(it-&gt;get_inventory_model());
     }
     STATUSBAR-&gt;set_inventory (modelnames);

Modified: trunk/src/player.hh
===================================================================
--- trunk/src/player.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/player.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -92,7 +92,7 @@
         void RotateInventory (int dir=1);
 
         void ActivateFirstItem();
-        world::ItemAction ActivateItem (Item *it);
+        ItemAction ActivateItem (Item *it);
 
         void Tick (double dtime);
         void PlayerShutdown();

Modified: trunk/src/server.cc
===================================================================
--- trunk/src/server.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/server.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -131,7 +131,7 @@
 
         game::ResetGameTimer();
 
-        world::InitWorld();
+        WorldInitLevel();
         if (!CreatingPreview) {
                 player::LevelLoaded(isRestart);
                 client::Msg_LevelLoaded(isRestart);
@@ -186,13 +186,13 @@
     }
     player::Tick (time_accu);
     for (;time_accu &gt;= timestep; time_accu -= timestep) {
-        world::Tick (timestep);
+        WorldTick (timestep);
         if (lua::CallFunc (lua::LevelState(), &quot;Tick&quot;, timestep, NULL) != 0) {
             throw XLevelRuntime (string(&quot;Calling 'Tick' failed:\n&quot;)
                                                 + lua::LastError(lua::LevelState()));
         }
     }
-    world::TickFinished ();
+    TickFinished ();
 }
 
 
@@ -251,7 +251,7 @@
 
     move_counter = 0;
 
-    world::PrepareLevel ();
+    enigma::WorldPrepareLevel();
     server::WorldInitialized = false;
 
     player::PrepareLevel();
@@ -567,7 +567,7 @@
 }
 
 void server::Msg_MouseForce (const ecl::V2 &amp;f) {
-    world::SetMouseForce (f);
+    SetMouseForce (f);
 }
 
 

Modified: trunk/src/st_switches.cc
===================================================================
--- trunk/src/st_switches.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/st_switches.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -26,10 +26,9 @@
 #include &quot;stones_internal.hh&quot;
 
 using namespace std;
-using namespace world;
-using namespace stones;
 
-
+namespace enigma {
+
 /* -------------------- Switch -------------------- */
 
 namespace
@@ -89,7 +88,7 @@
         }
 
         void actor_hit(const StoneContact &amp;sc) {
-            if (get_id (sc.actor) == world::ac_blackball)
+            if (get_id (sc.actor) == ac_blackball)
                 set_on (!is_on());
         }
 
@@ -133,7 +132,7 @@
         }
 
         void actor_hit(const StoneContact &amp;sc) {
-            if (get_id (sc.actor) == world::ac_whiteball)
+            if (get_id (sc.actor) == ac_whiteball)
                 set_on (!is_on());
         }
 
@@ -392,7 +391,7 @@
             };
 
             if (!m_inactive_so_far) {
-                world::EmitSignalByIndex(this, direction2idx[m_direction], 0);
+                EmitSignalByIndex(this, direction2idx[m_direction], 0);
             } else
                 m_inactive_so_far = false;
 
@@ -401,8 +400,8 @@
             set_on(!is_on());
             sound_event (&quot;fourswitch&quot;);
 
-            if (world::HaveSignals (this)) {
-                world::EmitSignalByIndex(this, direction2idx[m_direction], 1);
+            if (HaveSignals (this)) {
+                EmitSignalByIndex(this, direction2idx[m_direction], 1);
             } else {
                 // no signal handler defined
                 PerformAction(this, is_on());
@@ -678,7 +677,7 @@
     }
 }
 
-
+
 /* -------------------- Functions -------------------- */
 
 void InitSwitches()
@@ -697,3 +696,5 @@
     Register (new Switch_white);
     Register (new TimeSwitch);
 }
+
+} // namespace enigma

Modified: trunk/src/stones.cc
===================================================================
--- trunk/src/stones.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/stones.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -25,15 +25,14 @@
 #include &quot;Inventory.hh&quot;
 
 using namespace std;
-using namespace world;
-using namespace stones;
 
-
+namespace enigma {
+
 /* -------------------- Helper routines -------------------- */
 
 /*! Determine whether the actor hitting the stone can move stone
   and return either the direction the stone should move or NODIR. */
-Direction stones::get_push_direction (const StoneContact &amp;sc) 
+Direction get_push_direction (const StoneContact &amp;sc) 
 {
     ActorInfo *ai  = sc.actor-&gt;get_actorinfo();
     Direction  dir = contact_face(sc);
@@ -47,7 +46,7 @@
 
 /* Move a stone (by sending an impulse) Called when an actor hits a
    stone. */
-bool stones::maybe_push_stone (const StoneContact &amp;sc) 
+bool maybe_push_stone (const StoneContact &amp;sc) 
 {
     Direction dir = get_push_direction(sc);
     if (dir != enigma::NODIR) {
@@ -57,7 +56,7 @@
     return false;
 }
 
-
+
 //======================================================================
 // STONES
 //======================================================================
@@ -143,7 +142,7 @@
 void Stone::actor_hit(const StoneContact &amp;sc) 
 {
     if (is_movable())
-        stones::maybe_push_stone (sc);
+        maybe_push_stone (sc);
 }
 
 void Stone::actor_touch(const StoneContact &amp;sc) {
@@ -310,13 +309,13 @@
 }
 
 
-
 
+
 // *******************************************************************************
 //  Stones under development :
 
 
-
+
 /* -------------------- Explosion stone -------------------- */
 namespace
 {
@@ -346,7 +345,7 @@
     DEF_TRAITSM(ExplosionStone, &quot;st-explosion&quot;, st_explosion, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Charge stone -------------------- */
 
 // Attributes:
@@ -376,7 +375,7 @@
     };
 }
 
-
+
 /* -------------------- SpitterStone -------------------- */
 
 namespace
@@ -411,7 +410,7 @@
 
         state = SPITTING;
         ai-&gt;vel = ball_velocity;
-        world::AddActor (center[0], center[1], ball);
+        AddActor (center[0], center[1], ball);
         set_anim (&quot;st-spitter-spitting&quot;);
         break;
     }
@@ -439,7 +438,7 @@
     }
 }
 
-
+
 /* -------------------- YieldedGridStone -------------------- */
 
 YieldedGridStone::YieldedGridStone(Stone *st)
@@ -475,7 +474,7 @@
     model = 0;
 }
 
-
+
 /* -------------------- Oxyd compatibility stones -------------------- */
 
 namespace
@@ -526,7 +525,7 @@
     DEF_TRAITSM(Oxyd_0x18, &quot;st-oxyd-0x18&quot;, st_oxyd_0x18, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Flash stone -------------------- */
 namespace
 {
@@ -545,7 +544,7 @@
     };
 }
 
-
+
 /* -------------------- Surprise stone -------------------- */
 namespace 
 {
@@ -578,7 +577,7 @@
     DEF_TRAITS(SurpriseStone, &quot;st-surprise&quot;, st_surprise);
 }
 
-
+
 /* -------------------- Coffee stone -------------------- */
 namespace
 {
@@ -599,7 +598,7 @@
     DEF_TRAITS(CoffeeStone, &quot;st-coffee&quot;, st_coffee);
 }
 
-
+
 /* -------------------- Breaking stone -------------------- */
 namespace
 {
@@ -622,7 +621,7 @@
     DEF_TRAITSM(BreakingStone, &quot;st-breaking&quot;, st_breaking, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Bug stone -------------------- */
 namespace
 {
@@ -642,7 +641,7 @@
     DEF_TRAITSM(BugStone, &quot;st-bug&quot;, st_bug, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Plain stones -------------------- */
 
 /* These stones mimic the behaviour of the plain-looking stones in
@@ -857,7 +856,7 @@
                 MOVABLE_STANDARD);
 }
 
-
+
 /* -------------------- Black- and Whiteballs Stones -------------------- */
 
 namespace
@@ -868,7 +867,7 @@
         virtual Value on_message (const Message &amp;m)
         {
             GridPos p = get_pos();
-            Actor *a = world::CurrentCollisionActor;
+            Actor *a = CurrentCollisionActor;
             if (a &amp;&amp; get_id(a) == ac_blackball) {
                 if (p.y == m.gridpos.y) {
                     SendMessage (GetStone (move (p, EAST)),  &quot;signal&quot;, 1.0);
@@ -896,7 +895,7 @@
         virtual Value on_message (const Message &amp;m)
         {
             GridPos p = get_pos();
-            Actor *a = world::CurrentCollisionActor;
+            Actor *a = CurrentCollisionActor;
             if (a &amp;&amp; get_id(a) == ac_whiteball) {
                 if (p.y == m.gridpos.y) {
                     SendMessage (GetStone (move (p, EAST)),  &quot;signal&quot;, 1.0);
@@ -947,8 +946,7 @@
 
 extern void InitSwitches();
 
-void stones::Init()
-{
+void InitStones() {
 
     // Register(new ...);
 
@@ -981,3 +979,4 @@
     Init_complex();
     InitSwitches();
 }
+} // namespace enigma

Modified: trunk/src/stones.hh
===================================================================
--- trunk/src/stones.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/stones.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -21,9 +21,11 @@
 
 #include &quot;objects_decl.hh&quot;
 
-namespace world
-{
-    using namespace enigma;
+namespace enigma {
+    
+//    using namespace enigma;
+    struct Impulse;
+    struct StoneContact;
 
     enum StoneID {
         st_INVALID = -1,
@@ -240,11 +242,10 @@
     inline StoneID get_id(Stone *st) {
         return st-&gt;get_traits().id;
     }
-}
+    
+    void InitStones();
+    
+} // namespace enigma
 
-namespace stones
-{
-    void Init();
-}
 
 #endif

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/stones_complex.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -33,10 +33,10 @@
 #include &lt;iostream&gt;
 
 using namespace std;
-using namespace world;
-using namespace stones;
 
-
+namespace enigma { 
+
+
 /* -------------------- RotatorStone -------------------- */
 namespace
 {
@@ -134,7 +134,7 @@
     const double RotatorStone::IMPULSE_DELAY = 0.1;
 }
 
-
+
 /* -------------------- PullStone -------------------- */
 
 // When pushed this stone acts like pulled.
@@ -338,7 +338,7 @@
     sound_event(&quot;moveslow&quot;);
 }
 
-
+
 /* -------------------- Oneway stones -------------------- */
 
 // These stone can only be passed in one direction.
@@ -455,7 +455,7 @@
         return STONE_REBOUND;
 }
 
-
+
 /* -------------------- BolderStone -------------------- */
 
 /** \page st-bolder Bolder Stone
@@ -670,10 +670,10 @@
         void animcb() {
             switch (state) {
             case SHRINKING: {
-                Item *it = world::MakeItem(&quot;it-blocker-new&quot;);
-                world::SetItem(get_pos(), it);
+                Item *it = MakeItem(&quot;it-blocker-new&quot;);
+                SetItem(get_pos(), it);
                 TransferObjectName(this, it);
-                world::KillStone(get_pos());
+                KillStone(get_pos());
                 break;
             }
             case GROWING:
@@ -732,7 +732,7 @@
     DEF_TRAITSM(BlockerStone, &quot;INVALID&quot;, st_INVALID, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Volcano -------------------- */
 namespace
 {
@@ -803,7 +803,7 @@
     DEF_TRAITSM(VolcanoStone, &quot;st-volcano&quot;, st_volcano, MOVABLE_BREAKABLE);    
 }
 
-
+
 /* -------------------- BigBrick -------------------- */
 
 // BigBricks allow to build stones of any size based on st-brick.
@@ -954,9 +954,9 @@
     bool Window::tryInnerPull(Direction dir) {
         DirectionBits faces = get_connections();
         if (!has_dir(faces, dir) &amp;&amp; has_dir(faces, reverse(dir))){
-            Stone *stone = world::GetStone(move(get_pos(), dir));
+            Stone *stone = GetStone(move(get_pos(), dir));
             if (!stone || ((stone-&gt;get_traits().id == st_window) &amp;&amp;  
-                    !has_dir(dynamic_cast&lt;stones::ConnectiveStone *&gt;(stone)-&gt;get_connections(), reverse(dir)))) {
+                    !has_dir(dynamic_cast&lt;ConnectiveStone *&gt;(stone)-&gt;get_connections(), reverse(dir)))) {
                 ReplaceStone(get_pos(), new Window((faces&amp;(~to_bits(reverse(dir)))|to_bits(dir))+1));
                 return true;
             }
@@ -1036,7 +1036,7 @@
 */
 namespace
 {
-    class PuzzleStone : public ConnectiveStone, public TimeHandler, public world::PhotoCell {
+    class PuzzleStone : public ConnectiveStone, public TimeHandler, public PhotoCell {
         INSTANCELISTOBJ(PuzzleStone);
         DECL_TRAITS;
     public:
@@ -1635,7 +1635,7 @@
 }
 
 
-
+
 /* -------------------- DoorBase -------------------- */
 
 // Base class for everything that behaves like a door, i.e., it has
@@ -1729,12 +1729,12 @@
     switch (newstate) {
     case OPEN:
         set_model(basename+&quot;-open&quot;);
-        lasers::MaybeRecalcLight(get_pos());
+        MaybeRecalcLight(get_pos());
         break;
     case CLOSED:
         set_model(basename+&quot;-closed&quot;);
-        world::ShatterActorsInsideField (get_pos());
-        lasers::MaybeRecalcLight(get_pos()); // maybe superfluous
+        ShatterActorsInsideField (get_pos());
+        MaybeRecalcLight(get_pos()); // maybe superfluous
         break;
     case OPENING:
         sound_event (opening_sound().c_str());
@@ -1749,14 +1749,14 @@
             get_model()-&gt;reverse();
         else
             set_anim(basename+&quot;-closing&quot;);
-        world::ShatterActorsInsideField (get_pos());
-        lasers::MaybeRecalcLight(get_pos());
+        ShatterActorsInsideField (get_pos());
+        MaybeRecalcLight(get_pos());
         break;
     }
     set_state(newstate);
 }
 
-
+
 /* -------------------- Door -------------------- */
 
 // Attributes:
@@ -1839,7 +1839,7 @@
     }
 }
 
-
+
 /* -------------------- ShogunStone -------------------- */
 
 // Attributes:
@@ -1993,7 +1993,6 @@
 }
 
 
-
 /* -------------------- Stone impulse stones -------------------- */
 
 // Messages:
@@ -2140,10 +2139,10 @@
             switch (st) {
             case IDLE:
                 init_model();
-                lasers::MaybeRecalcLight(get_pos());
+                MaybeRecalcLight(get_pos());
                 break;
             case PULSING:
-                lasers::MaybeRecalcLight(get_pos());
+                MaybeRecalcLight(get_pos());
                 set_anim(&quot;st-stoneimpulse-hollow-anim1&quot;);
                 break;
             case CLOSING:
@@ -2243,7 +2242,7 @@
                 st_stoneimpulse_movable, MOVABLE_STANDARD);
 }
 
-
+
 /* -------------------- Oxyd stone -------------------- */
 
 /** \page st-oxyd Oxyd Stone
@@ -2530,7 +2529,7 @@
     kill_model (p);
 }
 
-
+
 /* -------------------- Turnstiles -------------------- */
 namespace
 {
@@ -2649,7 +2648,7 @@
     DEF_TRAITSM(Turnstile_W, &quot;st-turnstile-w&quot;, st_turnstile_w, MOVABLE_IRREGULAR);
 }
 
-
+
 /* -------------------- Turnstile_Arm -------------------- */
 
 void Turnstile_Arm::on_impulse(const Impulse&amp; impulse) {
@@ -2943,7 +2942,7 @@
             continue;
         }
 
-        world::WarpActor(ac, ac_target_pos.x+.5, ac_target_pos.y+.5, false);
+        WarpActor(ac, ac_target_pos.x+.5, ac_target_pos.y+.5, false);
 
         if (Stone *st = GetStone(ac_target_pos)) {
 
@@ -2984,7 +2983,7 @@
 
 }
 
-
+
 /* -------------------- Mail stone -------------------- */
 
 namespace
@@ -3021,7 +3020,7 @@
     if (enigma::Inventory *inv = player::GetInventory(sc.actor)) {
         if (Item *it = inv-&gt;get_item(0)) {
             GridPos p = find_pipe_endpoint();
-            if (world::IsInsideLevel(p) &amp;&amp; it-&gt;can_drop_at (p)) {
+            if (IsInsideLevel(p) &amp;&amp; it-&gt;can_drop_at (p)) {
                 it = inv-&gt;yield_first();
                 player::RedrawInventory (inv);
                 it-&gt;drop(sc.actor, p);
@@ -3048,7 +3047,7 @@
 
     while (move_dir != NODIR) {
         p.move (move_dir);
-        if (Item *it = world::GetItem(p)) {
+        if (Item *it = GetItem(p)) {
             switch (get_id(it)) {
             case it_pipe_h:
                 if (!(move_dir == EAST || move_dir == WEST))
@@ -3090,7 +3089,7 @@
     return p;
 }
 
-
+
 /* -------------------- Chess stone -------------------- */
 
 namespace
@@ -3373,7 +3372,7 @@
     }
 }
 
-
+
 /* -------------------- Light Passenger Stone -------------------- */
 namespace
 {
@@ -3414,10 +3413,10 @@
                 set_anim(&quot;st-lightpassenger-blink&quot;); break;
             case BREAK:
                 GridPos p = get_pos();
-                bool NorthSouth = lasers::LightFrom(p,NORTH) &amp;&amp;
-		    lasers::LightFrom(p,SOUTH);
-                bool EastWest = lasers::LightFrom(p,EAST) &amp;&amp;
-		    lasers::LightFrom(p,WEST);
+                bool NorthSouth = LightFrom(p,NORTH) &amp;&amp;
+		    LightFrom(p,SOUTH);
+                bool EastWest = LightFrom(p,EAST) &amp;&amp;
+		    LightFrom(p,WEST);
                 sound_event (&quot;stonedestroy&quot;);
                 if(NorthSouth &amp;&amp; !EastWest)
                     set_anim(&quot;st-lightpassenger-break-v&quot;);
@@ -3495,10 +3494,10 @@
         void alarm() {
             if(isLighted &amp;&amp; (state == ACTIVE || state == BLINK)) {
                 GridPos p = get_pos();
-                int toSouth =    (lasers::LightFrom(p,NORTH)?1:0)
-                               + (lasers::LightFrom(p,SOUTH)?-1:0);
-                int toWest =   (lasers::LightFrom(p,EAST)?1:0)
-                             + (lasers::LightFrom(p,WEST)?-1:0);
+                int toSouth =    (LightFrom(p,NORTH)?1:0)
+                               + (LightFrom(p,SOUTH)?-1:0);
+                int toWest =   (LightFrom(p,EAST)?1:0)
+                             + (LightFrom(p,WEST)?-1:0);
                 if(toSouth * toWest != 0) {
                     // Light is coming from two directions. Choose the one you are
                     // *not* coming from (thus changing beams), in doubt: random.
@@ -3516,8 +3515,8 @@
                 if(skateDir == NODIR &amp;&amp; state != BLINK) {
                     // No direction but lighted? Seems to be lasers from
                     // two opposite directions. Be sure and then start blinking.
-                    if(lasers::LightFrom(p,EAST) || lasers::LightFrom(p,WEST) ||
-                       lasers::LightFrom(p,NORTH) || lasers::LightFrom(p,SOUTH)) {
+                    if(LightFrom(p,EAST) || LightFrom(p,WEST) ||
+                       LightFrom(p,NORTH) || LightFrom(p,SOUTH)) {
                         state = BLINK;
                         init_model();
                     }
@@ -3555,9 +3554,10 @@
                 MOVABLE_IRREGULAR);
 }
 
+
 // --------------------------------------------------------------------------------
 
-void stones::Init_complex()
+void Init_complex()
 {
     Register(new BolderStone);
     Register(&quot;st-bolder-n&quot;, new BolderStone(NORTH));
@@ -3741,3 +3741,7 @@
     Register(&quot;st-lightpassenger&quot;, new LightPassengerStone(true));
     Register(&quot;st-lightpassenger_off&quot;, new LightPassengerStone(false));
 }
+
+} // namespace enigma
+
+

Modified: trunk/src/stones_internal.hh
===================================================================
--- trunk/src/stones_internal.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/stones_internal.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -37,9 +37,7 @@
 
 
 
-namespace stones
-{
-    using namespace world;
+namespace enigma {
 
     void Init_simple();
     void Init_complex();
@@ -63,7 +61,7 @@
     // @@@ FIXME: alarms have to be disabled as well
 
     class YieldedGridStone {
-        world::Stone   *stone;
+        Stone   *stone;
         display::Model *model;
 
         YieldedGridStone(const YieldedGridStone&amp;);
@@ -104,7 +102,7 @@
 
         virtual void notify_onoff(bool /*on*/) {}
 
-        virtual Value on_message(const world::Message &amp;msg)
+        virtual Value on_message(const Message &amp;msg)
         {
             const std::string &amp;m = msg.message;
             if (m==&quot;onoff&quot;)
@@ -150,5 +148,6 @@
         }
     };
 
-}
+} // namespace enigma
+
 #endif

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/stones_simple.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -27,10 +27,10 @@
 #include &quot;stones_internal.hh&quot;
 
 using namespace std;
-using namespace world;
-using namespace stones;
 
-
+namespace enigma {
+
+
 /* -------------------- SimpleStoneTraits -------------------- */
 
 namespace
@@ -70,7 +70,7 @@
     vector&lt;SimpleStoneTraits*&gt; SimpleStoneTraits::simple_stone_traits;
 }
 
-
+
 /* -------------------- SimpleStone -------------------- */
 
 namespace
@@ -944,7 +944,7 @@
                     sound_event (&quot;stonepaint&quot;);
                     state = STONE;
                     set_model(&quot;st-greenbrown&quot;);
-                    lasers::MaybeRecalcLight(get_pos());
+                    MaybeRecalcLight(get_pos());
                 }
             }
         }
@@ -952,7 +952,6 @@
     };
 }
 
-
 /* -------------------- Wooden stone -------------------- */
 
 /** \page st-wood Wooden Stone
@@ -988,7 +987,7 @@
 
         void maybe_fall_or_stopfire() {
             GridPos p = get_pos();
-            if (world::IsLevelBorder(p))
+            if (IsLevelBorder(p))
                 return;
             if (Floor *fl = GetFloor(p)) {
                 const string &amp;k = fl-&gt;get_kind();
@@ -1057,8 +1056,8 @@
     private:
         void init_model() { set_anim(&quot;st-wood-growing&quot;); }
         void animcb() {
-            Stone *st = world::MakeStone (&quot;st-wood&quot;);
-            world::ReplaceStone (get_pos(), st);
+            Stone *st = MakeStone (&quot;st-wood&quot;);
+            ReplaceStone (get_pos(), st);
             SendMessage (st, &quot;fall&quot;); // instantly builds a bridge on fl-swamp etc
         }
         void actor_contact(Actor *a) {SendMessage(a, &quot;shatter&quot;);}
@@ -1078,8 +1077,8 @@
     private:
         void init_model() { set_anim(&quot;st-greenbrown-growing&quot;); }
         void animcb() {
-            Stone *st = world::MakeStone(&quot;st-greenbrown&quot;);
-            world::ReplaceStone(get_pos(), st);
+            Stone *st = MakeStone(&quot;st-greenbrown&quot;);
+            ReplaceStone(get_pos(), st);
         }
         void actor_contact(Actor *a) {SendMessage(a, &quot;shatter&quot;);}
         void actor_inside(Actor *a) {SendMessage(a, &quot;shatter&quot;);}
@@ -1096,8 +1095,8 @@
     private:
         void init_model() { set_anim(&quot;st-volcano-growing&quot;); }
         void animcb() {
-            Stone *st = world::MakeStone(&quot;st-volcano_active&quot;);
-            world::ReplaceStone(get_pos(), st);
+            Stone *st = MakeStone(&quot;st-volcano_active&quot;);
+            ReplaceStone(get_pos(), st);
         }
         void actor_contact(Actor *a) {SendMessage(a, &quot;shatter&quot;);}
         void actor_inside(Actor *a) {SendMessage(a, &quot;shatter&quot;);}
@@ -1108,7 +1107,7 @@
     DEF_TRAITS(VolcanoStone_Growing, &quot;st-volcano-growing&quot;, st_volcano_growing);
 }
 
-
+
 /* -------------------- Scissors stone -------------------- */
 
 /** \page st-scissors Scissors stone
@@ -1126,8 +1125,8 @@
         void actor_hit(const StoneContact &amp;sc) {
             sound_event(&quot;scissors&quot;);
             set_anim(&quot;st-scissors-snip&quot;);
-            if (world::KillRubberBands (sc.actor))
-                world::PerformAction(this, false);
+            if (KillRubberBands (sc.actor))
+                PerformAction(this, false);
         }
         void animcb() {
             set_model(&quot;st-scissors&quot;);
@@ -1139,7 +1138,7 @@
     DEF_TRAITS(ScissorsStone, &quot;st-scissors&quot;, st_scissors);
 }
 
-
+
 /* -------------------- Rubberband stone -------------------- */
 
 /** \page st-rubberband Rubberband stone
@@ -1169,7 +1168,7 @@
             double length = getAttr(&quot;length&quot;, 1.0);
             double minlength = getAttr(&quot;minlength&quot;);
 
-            world::RubberBandData rbd;
+            RubberBandData rbd;
             rbd.strength = strength;
             rbd.length = length;
             rbd.minlength = minlength;
@@ -1178,12 +1177,12 @@
             // other rubberbands to the actor will be cut of or not, true means they will. true is default.
             bool isScissor = to_bool(getAttr(&quot;scissor&quot;,&quot;true&quot;));
 
-            if (!world::HasRubberBand (sc.actor, this)) {
+            if (!HasRubberBand (sc.actor, this)) {
                 sound_event (&quot;rubberband&quot;);
                 if (isScissor) {
-                    world::KillRubberBand (sc.actor, (Stone*)0);
+                    KillRubberBand (sc.actor, (Stone*)0);
                 }
-                world::AddRubberBand (sc.actor, this, rbd);
+                AddRubberBand (sc.actor, this, rbd);
             }
             // if (player::wielded_item_is (sc.actor, &quot;it-magicwand&quot;))
             maybe_push_stone (sc);
@@ -1363,7 +1362,7 @@
     case FARTING:
     case BREAKING:
         if (state == IDLE) {
-            Object *ox = world::GetObjectTemplate(&quot;st-oxyd&quot;);
+            Object *ox = GetObjectTemplate(&quot;st-oxyd&quot;);
             SendMessage(ox, &quot;closeall&quot;);
             sound_event(&quot;fart&quot;);
             if (newstate == BREAKING) {
@@ -1407,7 +1406,7 @@
 
 
 
-
+
 /* -------------------- Thief -------------------- */
 namespace
 {
@@ -1483,7 +1482,7 @@
         enigma::Inventory *inv = player::GetInventory(m_affected_actor);
         if (inv &amp;&amp; inv-&gt;size() &gt; 0) {
             if (bag == NULL) {
-                bag = world::MakeItem(it_bag);
+                bag = MakeItem(it_bag);
                 bag-&gt;setOwnerPos(get_pos());
             }
             int i = IntegerRand (0, int (inv-&gt;size()-1));
@@ -1497,15 +1496,15 @@
 Value ThiefStone::message(const string &amp;msg, const Value &amp;v) {
     if(msg == &quot;capture&quot; &amp;&amp; state == IDLE) {
         state = CAPTURED;
-        Item * it =  world::GetItem(get_pos());
+        Item * it =  GetItem(get_pos());
         
         // add items on grid pos that can be picked up to our bag
         if (it != NULL &amp;&amp; !(it-&gt;get_traits().flags &amp; itf_static) &amp;&amp; bag != NULL) {
-            dynamic_cast&lt;ItemHolder *&gt;(bag)-&gt;add_item(world::YieldItem(get_pos()));
+            dynamic_cast&lt;ItemHolder *&gt;(bag)-&gt;add_item(YieldItem(get_pos()));
         }
         // drop bag if pos is not occupied by a static item
-        if (world::GetItem(get_pos()) == NULL)
-            world::SetItem(get_pos(), bag);
+        if (GetItem(get_pos()) == NULL)
+            SetItem(get_pos(), bag);
         bag = NULL;
         set_anim(string(get_kind()) + &quot;-captured&quot;);
         return Value(1);
@@ -1567,14 +1566,14 @@
 
         virtual Value message (const string &amp;msg, const Value &amp;) {
             if (msg == &quot;signal&quot;) {
-                world::EmitSignalByIndex (this, m_signalidx, 0);
+                EmitSignalByIndex (this, m_signalidx, 0);
                 m_signalidx += 1;
-                if (!world::EmitSignalByIndex (this, m_signalidx, 1)) {
+                if (!EmitSignalByIndex (this, m_signalidx, 1)) {
                     m_signalidx = 0;
-                    world::EmitSignalByIndex (this, m_signalidx, 1);
+                    EmitSignalByIndex (this, m_signalidx, 1);
                 }
             } else if (msg == &quot;init&quot;) {
-                world::EmitSignalByIndex (this, m_signalidx, 1);
+                EmitSignalByIndex (this, m_signalidx, 1);
             }
             return Value();
         }
@@ -1643,7 +1642,7 @@
     };
 }
 
-
+
 /* -------------------- Black Stones -------------------- */
 namespace
 {
@@ -1698,7 +1697,7 @@
 
 }
 
-
+
 /* -------------------- YinYang stones -------------------- */
 namespace
 {
@@ -1764,7 +1763,7 @@
     };
 }
 
-
+
 /* -------------------- BombStone -------------------- */
 
 namespace
@@ -1851,7 +1850,7 @@
     DEF_TRAITSM(MagicStone, &quot;st-magic&quot;, st_magic, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- DeathStone -------------------- */
 
 /** \page st-death Death's Head Stone
@@ -1888,7 +1887,7 @@
     DEF_TRAITS(DeathStone, &quot;st-death&quot;, st_death);
 }
 
-
+
 /* -------------------- Invisible DeathStone -------------------- */
 
 /** \page st-death_invisible Death's Head Stone invivible
@@ -1938,7 +1937,7 @@
     DEF_TRAITS(DeathStoneInvisible, &quot;st-death_invisible&quot;, st_death_invisible);
 }
 
-
+
 /* -------------------- Brake stone -------------------- */
 
 /** \page st-brake Brake
@@ -2004,7 +2003,7 @@
     DEF_TRAITSM(BrakeStone, &quot;st-brake&quot;, st_brake, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Disco stones -------------------- */
 namespace
 {
@@ -2098,7 +2097,7 @@
     };
 }
 
-
+
 /* -------------------- Knight stone -------------------- */
 namespace
 {
@@ -2136,7 +2135,7 @@
     DEF_TRAITSM(Knight, &quot;st-knight&quot;, st_knight, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Polarization Switch stone -------------------- */
 namespace
 {
@@ -2149,7 +2148,7 @@
         void actor_hit(const StoneContact &amp;sc) { set_on(!is_on()); }
         void init_model() { set_model(is_on() ? &quot;st-glass1&quot; : &quot;st-glass2&quot;); }
         bool is_transparent(Direction) const { return this-&gt;is_on(); }
-        void notify_onoff(bool) { lasers::MaybeRecalcLight(this-&gt;get_pos()); }
+        void notify_onoff(bool) { MaybeRecalcLight(this-&gt;get_pos()); }
 
         StoneResponse collision_response(const StoneContact &amp;sc) {
             if (sc.actor-&gt;is_invisible())
@@ -2162,7 +2161,7 @@
     DEF_TRAITS(PolarSwitchStone, &quot;st-polarswitch&quot;, st_polarswitch);
 }
 
-
+
 /* -------------------- Fire breakable stones -------------------- */
 
 /* These stones mimic the behaviour of the plain-looking stones in
@@ -2249,24 +2248,24 @@
                 MOVABLE_IRREGULAR);
 }
 
-
+
 /* -------------------- Functions -------------------- */
 
-void world::DefineSimpleStone(const std::string &amp;kind, 
+void DefineSimpleStone(const std::string &amp;kind, 
                               const std::string &amp;sound,
                               int hollow, int glass)
 {
     Register(new SimpleStone(kind, sound, hollow != 0, glass != 0));
 }
 
-void world::DefineSimpleStoneMovable(const std::string &amp;kind, 
+void DefineSimpleStoneMovable(const std::string &amp;kind, 
                                      const std::string &amp;sound, 
                                      int glass)
 {
     Register(new SimpleStoneMovable(kind, sound, glass != 0));
 }
 
-void stones::Init_simple()
+void Init_simple()
 {
     Register(new ActorImpulseStone);
     Register(new ActorImpulseStoneInvisible);
@@ -2334,3 +2333,5 @@
     Register(new Stone_firebreak);
     Register(new Stone_movefirebreak);
 }
+
+} // namespace enigma

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/world.cc	2007-10-29 23:30:45 UTC (rev 912)
@@ -42,15 +42,16 @@
 // #define VERBOSE_MESSAGES
 
 using namespace std;
-using namespace world;
 using namespace ecl;
 
 #include &quot;world_internal.hh&quot;
 
+namespace enigma {
+
 // Size of one time step -- do not change!
 const double ActorTimeStep = 0.0025;
 
-
+
 /* -------------------- Auxiliary functions -------------------- */
 
 namespace {
@@ -70,7 +71,7 @@
     }
 }
 
-
+
 /* -------------------- ActorInfo -------------------- */
 
 ActorInfo::ActorInfo() : pos(), gridpos(), field(NULL), vel(), forceacc(),
@@ -88,7 +89,7 @@
 }
  
 Message::Message (const std::string &amp;message_,
-                  const enigma::Value &amp;value_,
+                  const Value &amp;value_,
                   GridPos from_)
 : message (message_),
   value (value_),
@@ -96,7 +97,7 @@
 {
 }
 
-
+
 /* -------------------- Signals -------------------- */
 
 namespace
@@ -178,7 +179,7 @@
     }
 }
 
-
+
 /* -------------------- RubberBandData -------------------- */
 
 RubberBandData::RubberBandData () {
@@ -257,7 +258,7 @@
     model.update_second (get_p2());
 }
 
-
+
 /* -------------------- Field -------------------- */
 
 Field::Field()
@@ -274,7 +275,7 @@
     DisposeObject(stone);
 }
 
-
+
 /* -------------------- StoneContact -------------------- */
 
 //StoneContact::StoneContact(Actor *a, GridPos p,
@@ -293,10 +294,9 @@
   is_contact (false), outerCorner (false) {
 }
 
-DirectionBits
-world::contact_faces(const StoneContact &amp;sc)
+DirectionBits contact_faces(const StoneContact &amp;sc)
 {
-    using namespace enigma;
+//    using namespace enigma;
 
     int dirs = NODIRBIT;
 
@@ -312,8 +312,7 @@
     return DirectionBits(dirs);
 }
 
-Direction
-world::contact_face(const StoneContact &amp;sc)
+Direction contact_face(const StoneContact &amp;sc)
 {
     using namespace enigma;
     if (sc.normal == V2(-1,0))
@@ -328,7 +327,7 @@
         return NODIR;
 }
 
-
+
 /* -------------------- Global variables -------------------- */
 
 namespace
@@ -336,12 +335,12 @@
     auto_ptr&lt;World&gt; level;
 }
 
-enigma::Timer  world::GameTimer;
-bool           world::TrackMessages;
-Actor         *world::CurrentCollisionActor = 0;
+enigma::Timer  GameTimer;
+bool           TrackMessages;
+Actor         *CurrentCollisionActor = 0;
 
 
-
+
 /* -------------------- Layer implementation -------------------- */
 
 template &lt;class T&gt;
@@ -383,7 +382,7 @@
 
 
 
-
+
 /* -------------------- World -------------------- */
 
 const double World::contact_e = 0.02;  // epsilon distant limit for contacts
@@ -546,7 +545,7 @@
 
     GameTimer.tick(dtime);
 
-    lasers::RecalcLightNow();   // recalculate laser beams if necessary
+    RecalcLightNow();   // recalculate laser beams if necessary
 }
 
 /* ---------- Puzzle scrambling -------------------- */
@@ -710,14 +709,14 @@
     c.outerCorner = false;
     bool isInnerContact = false;
 
-    Stone *stone = (st != NULL) ? st : world::GetStone(p);
+    Stone *stone = (st != NULL) ? st : GetStone(p);
     if (!stone)
         return;
 
     bool isWindow = stone-&gt;get_traits().id == st_window;
     DirectionBits wsides;
     if (isWindow) {
-        wsides = dynamic_cast&lt;stones::ConnectiveStone *&gt;(stone)-&gt;get_connections();
+        wsides = dynamic_cast&lt;ConnectiveStone *&gt;(stone)-&gt;get_connections();
     }
     
     const ActorInfo &amp;ai = *a-&gt;get_actorinfo();
@@ -765,8 +764,8 @@
             else if ( ycorner &amp;&amp; xoff_neighbour) face = SOUTHBIT;
             
             // the faces that the neighbour window owns
-            stones::ConnectiveStone * neighbour = dynamic_cast&lt;stones::ConnectiveStone *&gt;
-                    (world::GetStone(GridPos(x+xoff_neighbour, y+yoff_neighbour)));
+            ConnectiveStone * neighbour = dynamic_cast&lt;ConnectiveStone *&gt;
+                    (GetStone(GridPos(x+xoff_neighbour, y+yoff_neighbour)));
             DirectionBits face_neighbour = (neighbour) ? neighbour-&gt;get_connections() : NODIRBIT;
             
             
@@ -952,9 +951,9 @@
  */
 void World::find_contact_with_edge(Actor *a, GridPos p0, GridPos p1, GridPos p2, 
         StoneContact &amp;c0, StoneContact &amp;c1, StoneContact &amp;c2, DirectionBits winFacesActorStone) {
-    Stone *s0 = world::GetStone(p0);
-    Stone *s1 = world::GetStone(p1);
-    Stone *s2 = world::GetStone(p2);
+    Stone *s0 = GetStone(p0);
+    Stone *s1 = GetStone(p1);
+    Stone *s2 = GetStone(p2);
     if (s0 != NULL) c0.response = s0-&gt;collision_response(c0);
     if (s1 != NULL) c1.response = s1-&gt;collision_response(c1);
     if (s2 != NULL) c2.response = s2-&gt;collision_response(c2);
@@ -1031,7 +1030,7 @@
     
     // info about a Window stone on the Gridpos of the actor that may cause
     // contacts within the grid
-    stones::ConnectiveStone * actorWinStone = dynamic_cast&lt;stones::ConnectiveStone *&gt;(world::GetStone(g));
+    ConnectiveStone * actorWinStone = dynamic_cast&lt;ConnectiveStone *&gt;(GetStone(g));
     DirectionBits winFacesActorStone = (actorWinStone) ? actorWinStone-&gt;get_connections() : NODIRBIT;
     
     // distinguish 9 squares within gridpos that may cause contacts
@@ -1176,7 +1175,7 @@
             bool slow_collision = length (ai.vel) &lt; 0.3;
             if (!has_nearby_contact(ai.last_contacts, ai.last_contacts_count, 
                     contact)) {
-                if (Stone *stone = world::GetStone(sc.stonepos)) {
+                if (Stone *stone = GetStone(sc.stonepos)) {
                     CurrentCollisionActor = a;
                     if (slow_collision) stone-&gt;actor_touch(sc);
                     else stone-&gt;actor_hit(sc);
@@ -1204,7 +1203,7 @@
         }
     }
     else if (sc.is_contact) {
-        if (Stone *stone = world::GetStone(sc.stonepos))
+        if (Stone *stone = GetStone(sc.stonepos))
             stone-&gt;actor_contact(sc.actor);
     }
 }
@@ -1632,35 +1631,35 @@
         if (Stone *stn = GetStone(move(p, WEST)))
             stn-&gt;freeze_check();
 
-        lasers::MaybeRecalcLight(p);
+        MaybeRecalcLight(p);
     }
 }
 
 
 
-
+
 /* -------------------- Functions -------------------- */
 
-void world::Resize (int w, int h)
+void Resize (int w, int h)
 {
     level.reset (new World(w,h));
     display::NewWorld(w, h);
     server::WorldInitialized = true;
 }
 
-void world::PrepareLevel ()
+void WorldPrepareLevel ()
 {
     GameTimer.clear();
     CurrentCollisionActor = 0;
     Resize (20, 13);
 }
 
-bool world::InitWorld()
+bool WorldInitLevel()
 {
     level-&gt;scramble_puzzles();
 
-    lasers::RecalcLight();
-    lasers::RecalcLightNow();    // recalculate laser beams if necessary
+    RecalcLight();
+    RecalcLightNow();    // recalculate laser beams if necessary
 
     bool seen_player0 = false;
 
@@ -1685,7 +1684,7 @@
     if (!seen_player0) 
         throw XLevelLoading(&quot;Error: No player 0 defined!&quot;);
 
-    world::BroadcastMessage(&quot;init&quot;, Value(),
+    BroadcastMessage(&quot;init&quot;, Value(),
         GridLayerBits(GRID_ITEMS_BIT | GRID_STONES_BIT | GRID_FLOOR_BIT));
 
     server::InitMoveCounter();
@@ -1698,12 +1697,12 @@
     return true;
 }
 
-void world::SetMouseForce(V2 f)
+void SetMouseForce(V2 f)
 {
     level-&gt;m_mouseforce.add_force(f);
 }
 
-void world::NameObject(Object *obj, const std::string &amp;name)
+void NameObject(Object *obj, const std::string &amp;name)
 {
     string old_name;
     if (Value v = obj-&gt;getAttr(&quot;name&quot;)) {
@@ -1715,12 +1714,12 @@
     level-&gt;name_object (obj, name);
 }
 
-void world::UnnameObject(Object *obj)
+void UnnameObject(Object *obj)
 {
     level-&gt;unname(obj);
 }
 
-void world::TransferObjectName (Object *source, Object *target)
+void TransferObjectName (Object *source, Object *target)
 {
     if (Value v = source-&gt;getAttr(&quot;name&quot;)) {
         string name(v);
@@ -1734,54 +1733,54 @@
     }
 }
 
-Object * world::GetNamedObject (const std::string &amp;name)
+Object * GetNamedObject (const std::string &amp;name)
 {
     return level-&gt;get_named (name);
 }
 
-std::list&lt;Object *&gt; world::GetNamedGroup(const std::string &amp;name) {
+std::list&lt;Object *&gt; GetNamedGroup(const std::string &amp;name) {
     return level-&gt;get_group(name);
 }
 
-bool world::IsLevelBorder(const GridPos &amp;p) {
+bool IsLevelBorder(const GridPos &amp;p) {
     return level-&gt;is_border(p);
 }
 
-bool world::IsInsideLevel(const GridPos &amp;p) {
+bool IsInsideLevel(const GridPos &amp;p) {
     return level-&gt;contains(p);
 }
 
 /* -------------------- Force fields -------------------- */
 
-void world::AddForceField(ForceField *ff)
+void AddForceField(ForceField *ff)
 {
     level-&gt;forces.push_back(ff);
 }
 
-void world::RemoveForceField(ForceField *ff) {
+void RemoveForceField(ForceField *ff) {
     level-&gt;remove (ff);
 }
 
-void world::SetConstantForce (V2 force) {
+void SetConstantForce (V2 force) {
     level-&gt;m_flatforce.set_force(force);
 }
 
 
 /* -------------------- Rubber bands -------------------- */
 
-void world::AddRubberBand (Actor *a, Stone *st, const RubberBandData &amp;d)
+void AddRubberBand (Actor *a, Stone *st, const RubberBandData &amp;d)
 {
     level-&gt;m_rubberbands.push_back(new RubberBand (a, st, d));
 }
 
-void world::AddRubberBand (Actor *a, Actor *a2, const RubberBandData &amp;d)
+void AddRubberBand (Actor *a, Actor *a2, const RubberBandData &amp;d)
 {
     RubberBandData rbd (d);
     rbd.length = ecl::Max (d.length, get_radius(a) + get_radius(a2));
     level-&gt;m_rubberbands.push_back(new RubberBand (a, a2, rbd));
 }
 
-bool world::KillRubberBands (Actor *a)
+bool KillRubberBands (Actor *a)
 {
     bool didKill = false;
     for (unsigned i=0; i&lt;level-&gt;m_rubberbands.size(); ) {
@@ -1798,7 +1797,7 @@
 }
 
 
-void world::KillRubberBand (Actor *a, Stone *st)
+void KillRubberBand (Actor *a, Stone *st)
 {
     ASSERT(a, XLevelRuntime, &quot;KillRubberBand: no actor attached&quot;);
     for (unsigned i=0; i&lt;level-&gt;m_rubberbands.size(); ) {
@@ -1813,7 +1812,7 @@
     }
 }
 
-void world::KillRubberBand (Actor *a, Actor *a2)
+void KillRubberBand (Actor *a, Actor *a2)
 {
     ASSERT(a, XLevelRuntime, &quot;KillRubberBand: no actor attached&quot;);
     for (unsigned i=0; i&lt;level-&gt;m_rubberbands.size(); ) {
@@ -1828,7 +1827,7 @@
     }
 }
 
-void world::KillRubberBands (Stone *st)
+void KillRubberBands (Stone *st)
 {
    for (unsigned i=0; i&lt;level-&gt;m_rubberbands.size(); ) {
         RubberBand &amp;r = *level-&gt;m_rubberbands[i];
@@ -1841,7 +1840,7 @@
     }
 }
 
-void world::GiveRubberBands (Stone *st, vector&lt;Rubber_Band_Info&gt; &amp;rubs) {
+void GiveRubberBands (Stone *st, vector&lt;Rubber_Band_Info&gt; &amp;rubs) {
    for (unsigned i=0; i&lt;level-&gt;m_rubberbands.size(); ) {
         RubberBand &amp;r = *level-&gt;m_rubberbands[i];
         if (r.get_stone() == st) {
@@ -1854,7 +1853,7 @@
     }
 }
 
-bool world::HasRubberBand (Actor *a, Stone *st)
+bool HasRubberBand (Actor *a, Stone *st)
 {
     for (unsigned i=0; i&lt;level-&gt;m_rubberbands.size(); ++i) {
         RubberBand &amp;r = *level-&gt;m_rubberbands[i];
@@ -1864,10 +1863,10 @@
     return false;
 }
 
- 
+
 /* -------------------- Signals -------------------- */
 
-void world::AddSignal (const GridLoc &amp;srcloc, 
+void AddSignal (const GridLoc &amp;srcloc, 
                        const GridLoc &amp;dstloc, 
                        const string &amp;msg)
 {
@@ -1885,7 +1884,7 @@
     }
 }
 
-bool world::HaveSignals (Object *src) 
+bool HaveSignals (Object *src) 
 {
     SignalList::const_iterator i=level-&gt;m_signals.begin(),
         end = level-&gt;m_signals.end();
@@ -1896,12 +1895,12 @@
 }
 
 
-bool world::EmitSignalByIndex (Object *src, int signalidx, int value) 
+bool EmitSignalByIndex (Object *src, int signalidx, int value) 
 {
     return emit_by_index (level-&gt;m_signals, src, signalidx, value);
 }
 
-bool world::GetSignalTargetPos (Object *src, GridPos &amp;pos, int signalidx) 
+bool GetSignalTargetPos (Object *src, GridPos &amp;pos, int signalidx) 
 {
     SignalList::const_iterator i = level-&gt;m_signals.begin(),
         end = level-&gt;m_signals.end();
@@ -1919,17 +1918,17 @@
 }
 
 
-Value world::SendMessage(Object *o, const std::string &amp;msg) 
+Value SendMessage(Object *o, const std::string &amp;msg) 
 {
     return SendMessage (o, Message (msg, Value()));
 }
 
-Value world::SendMessage(Object *o, const std::string &amp;msg, const Value&amp; value)
+Value SendMessage(Object *o, const std::string &amp;msg, const Value&amp; value)
 {
     return SendMessage (o, Message (msg, value));
 }
 
-Value world::SendMessage (Object *o, const Message &amp;m)
+Value SendMessage (Object *o, const Message &amp;m)
 {
     if (o) {
         if (TrackMessages)
@@ -1944,7 +1943,7 @@
 }
 
 
-void world::BroadcastMessage (const std::string&amp; msg, 
+void BroadcastMessage (const std::string&amp; msg, 
                               const Value&amp; value, 
                               GridLayerBits grids)
 {
@@ -1966,7 +1965,7 @@
 }
 
 
-void world::PerformAction (Object *o, bool onoff) 
+void PerformAction (Object *o, bool onoff) 
 {
     string action = &quot;idle&quot;;
     string target(o-&gt;getAttr(&quot;target&quot;));
@@ -2017,7 +2016,7 @@
     }
 }
 
-void world::SendExplosionEffect(GridPos center, ExplosionType type) 
+void SendExplosionEffect(GridPos center, ExplosionType type) 
 {
     const int AFFECTED_FIELDS       = 8;
 
@@ -2067,7 +2066,7 @@
     }
 }
 
-Object *world::GetObject (const GridLoc &amp;l)
+Object *GetObject (const GridLoc &amp;l)
 {
     switch (l.layer) {
     case GRID_FLOOR:  return GetFloor(l.pos);
@@ -2077,25 +2076,25 @@
     }
 }
 
-const Field *world::GetField (GridPos p)
+const Field *GetField (GridPos p)
 {
     return level-&gt;get_field(p);
 }
 
-
+
 /* -------------------- Floor manipulation -------------------- */
 
-void world::KillFloor(GridPos p) 
+void KillFloor(GridPos p) 
 {
     level-&gt;fl_layer.kill(p);
 }
 
-Floor *world::GetFloor(GridPos p) 
+Floor *GetFloor(GridPos p) 
 {
     return level-&gt;fl_layer.get(p);
 }
 
-void world::SetFloor(GridPos p, Floor* fl) 
+void SetFloor(GridPos p, Floor* fl) 
 {
     level-&gt;fl_layer.set(p,fl);
     if (!level-&gt;preparing_level)
@@ -2103,33 +2102,33 @@
             st-&gt;on_floor_change();
 }
 
-
+
 /* -------------------- Stone manipulation -------------------- */
 
-Stone * world::GetStone(GridPos p) {
+Stone * GetStone(GridPos p) {
     if (Field *f = level-&gt;get_field (p))
         return f-&gt;stone;
     else
         return level-&gt;st_layer.get(p);
 }
 
-void world::KillStone(GridPos p) {
+void KillStone(GridPos p) {
     level-&gt;st_layer.kill(p);
     level-&gt;changed_stones.push_back(p);
 }
 
-Stone * world::YieldStone(GridPos p) {
+Stone * YieldStone(GridPos p) {
     Stone *st = level-&gt;st_layer.yield(p);
     level-&gt;changed_stones.push_back(p);
     return st;
 }
 
-void world::SetStone(GridPos p, Stone* st) {
+void SetStone(GridPos p, Stone* st) {
     level-&gt;st_layer.set(p,st);
     level-&gt;changed_stones.push_back(p);
 }
 
-void world::ReplaceStone (GridPos p, Stone* st) {
+void ReplaceStone (GridPos p, Stone* st) {
     Stone *old = level-&gt;st_layer.get(p);
     if (old) {
         TransferObjectName(old, st);
@@ -2138,74 +2137,74 @@
     SetStone(p, st);
 }
 
-void world::MoveStone (GridPos oldPos, GridPos newPos) {
+void MoveStone (GridPos oldPos, GridPos newPos) {
     SetStone(newPos, YieldStone(oldPos));
 }
 
-void world::SetScrambleIntensity (int intensity) {
+void SetScrambleIntensity (int intensity) {
     level-&gt;scrambleIntensity = intensity;
 }
 
-void world::AddScramble(GridPos p, Direction d) {
+void AddScramble(GridPos p, Direction d) {
     level-&gt;add_scramble(p, d);
 }
 
-
+
 /* -------------------- Item manipulation -------------------- */
 
-void world::KillItem(GridPos p) 
+void KillItem(GridPos p) 
 {
-    lasers::MaybeRecalcLight(p);
+    MaybeRecalcLight(p);
     level-&gt;it_layer.kill(p);
 }
 
-Item *world::GetItem(GridPos p) {
+Item *GetItem(GridPos p) {
     return level-&gt;it_layer.get(p);
 }
 
-Item *world::YieldItem(GridPos p) {
-    lasers::MaybeRecalcLight(p);
+Item *YieldItem(GridPos p) {
+    MaybeRecalcLight(p);
     return level-&gt;it_layer.yield(p);
 }
 
-void world::SetItem (GridPos p, Item* it) 
+void SetItem (GridPos p, Item* it) 
 {
-    lasers::MaybeRecalcLight(p);
+    MaybeRecalcLight(p);
     level-&gt;it_layer.set(p,it);
 }
 
-void world::SetItem (GridPos p, ItemID id) 
+void SetItem (GridPos p, ItemID id) 
 {
     SetItem (p, MakeItem (id));
 }
 
-
+
 /* -------------------- Actor manipulation -------------------- */
 
-void world::AddActor(double x, double y, Actor* a) 
+void AddActor(double x, double y, Actor* a) 
 {
     level-&gt;add_actor (a, V2(x, y));
 }
 
-void world::AddActor (Actor *a)
+void AddActor (Actor *a)
 {
     level-&gt;add_actor (a);
 }
 
-void  world::DidMoveActor(Actor *a) {
+void  DidMoveActor(Actor *a) {
     level-&gt;did_move_actor(a);
 }
 
-Actor * world::YieldActor(Actor *a) 
+Actor * YieldActor(Actor *a) 
 {
     return level-&gt;yield_actor(a);
 }
 
-void world::KillActor (Actor *a) {
+void KillActor (Actor *a) {
     delete YieldActor (a);
 }
 
-void world::WarpActor(Actor *a, double newx, double newy, bool keep_velocity)
+void WarpActor(Actor *a, double newx, double newy, bool keep_velocity)
 {
     V2 newpos = V2(newx, newy);
     ASSERT(IsInsideLevel(GridPos(newpos)), XLevelRuntime,
@@ -2215,14 +2214,14 @@
     a-&gt;warp(newpos);
 }
 
-void world::FastRespawnActor(Actor *a, bool keep_velocity) {
+void FastRespawnActor(Actor *a, bool keep_velocity) {
     a-&gt;find_respawnpos();
     const V2&amp; p = a-&gt;get_respawnpos();
     WarpActor(a, p[0], p[1], keep_velocity);
 }
 
 
-void world::RespawnActor(Actor *a) {
+void RespawnActor(Actor *a) {
     a-&gt;find_respawnpos();
     a-&gt;respawn();
 }
@@ -2239,7 +2238,7 @@
     return 0;
 }
 
-unsigned world::CountActorsOfKind (ActorID id) 
+unsigned CountActorsOfKind (ActorID id) 
 {
     unsigned count = 0;
     ActorList::iterator i = level-&gt;actorlist.begin(),
@@ -2252,7 +2251,7 @@
     return count;
 }
 
-Actor *world::FindOtherMarble(Actor *thisMarble) 
+Actor *FindOtherMarble(Actor *thisMarble) 
 {
     if (!thisMarble) 
         return 0;
@@ -2265,7 +2264,7 @@
     }
 }
 
-bool world::ExchangeMarbles(Actor *marble1) {
+bool ExchangeMarbles(Actor *marble1) {
     Actor *marble2 = FindOtherMarble(marble1);
     if (marble2) {
         level-&gt;exchange_actors(marble1, marble2);
@@ -2275,17 +2274,17 @@
 }
 
 
-void world::GrabActor(Actor *a)
+void GrabActor(Actor *a)
 {
     a-&gt;get_actorinfo()-&gt;grabbed = true;
 }
 
-void world::ReleaseActor(Actor *a)
+void ReleaseActor(Actor *a)
 {
     a-&gt;get_actorinfo()-&gt;grabbed = false;
 }
 
-bool world::GetActorsInRange (ecl::V2 center, double range,
+bool GetActorsInRange (ecl::V2 center, double range,
                               vector&lt;Actor*&gt;&amp; actors)
 {
     ActorList &amp;al = level-&gt;actorlist;
@@ -2297,7 +2296,7 @@
     return !actors.empty();
 }
 
-bool world::GetActorsInsideField (const GridPos&amp; pos, vector&lt;Actor*&gt;&amp; actors)
+bool GetActorsInsideField (const GridPos&amp; pos, vector&lt;Actor*&gt;&amp; actors)
 {
     ActorList &amp;al = level-&gt;actorlist;
     for (ActorList::iterator i=al.begin(); i!=al.end(); ++i) {
@@ -2308,7 +2307,7 @@
     return !actors.empty();
 }
 
-void world::ShatterActorsInsideField (const GridPos &amp;p)
+void ShatterActorsInsideField (const GridPos &amp;p)
 {
     vector&lt;Actor *&gt; actors;
     GetActorsInsideField (p, actors);
@@ -2318,10 +2317,10 @@
         SendMessage(*i, &quot;shatter&quot;);
 }
 
-
+
 /* -------------------- Functions -------------------- */
 
-void world::addDelayedImpulse (const Impulse&amp; impulse, double delay, 
+void addDelayedImpulse (const Impulse&amp; impulse, double delay, 
                                const Stone *estimated_receiver) 
 {
     // @@@ FIXME: is a special handling necessary if several impulses hit same destination ?
@@ -2329,7 +2328,7 @@
     level-&gt;delayed_impulses.push_back(DelayedImpulse(impulse, delay, estimated_receiver));
 }
 
-void world::revokeDelayedImpulses(const Stone *target) {
+void revokeDelayedImpulses(const Stone *target) {
     // Any stone may call this function on deletion.
     // When the repository shuts down no world is existing thus check
     // world first.
@@ -2337,7 +2336,7 @@
         level-&gt;revoke_delayed_impulses(target);
 }
 
-float world::getVolume(const char *name, Object *obj, float def_volume)
+float getVolume(const char *name, Object *obj, float def_volume)
 {
     // See sound.hh and sound.cc for details.
     SoundDampingList::iterator i = level-&gt;sound_dampings.begin(),
@@ -2352,11 +2351,11 @@
     return def_volume;
 }
 
-void world::Tick(double dtime) {
+void WorldTick(double dtime) {
     level-&gt;tick (dtime);
 }
 
-void world::TickFinished () {
+void TickFinished () {
     for (unsigned i=0; i&lt;level-&gt;actorlist.size(); ++i) {
         level-&gt;actorlist[i]-&gt;move_screen();
     }
@@ -2366,16 +2365,16 @@
         level-&gt;m_rubberbands[i]-&gt;tick (0.0);
 }
 
-void world::Init()
+void InitWorld()
 {
     InitActors();
-    lasers::Init();
+    InitLasers();
     InitItems();
-    stones::Init();
+    InitStones();
     InitFloors();
 }
 
-void world::Shutdown()
+void ShutdownWorld()
 {
     level.reset();
     player::PlayerShutdown();
@@ -2475,7 +2474,7 @@
     vector&lt;Item *&gt; item_repos(it_COUNT);
 }
 
-void world::Register (const string &amp;kind, Object *obj) {
+void Register (const string &amp;kind, Object *obj) {
     if (!repos)
         repos = new ObjectRepos;
     if (kind.empty())
@@ -2485,22 +2484,22 @@
 }
 
 
-void world::Register (Object *obj) {
+void Register (Object *obj) {
     Register (obj-&gt;get_kind(), obj);
 }
 
-void world::Register (const string &amp;kind, Floor *obj)
+void Register (const string &amp;kind, Floor *obj)
 {
     Object *o = obj;
     Register(kind, o);
 }
 
-void world::Register (const string &amp;kind, Stone *obj) {
+void Register (const string &amp;kind, Stone *obj) {
     Object *o = obj;
     Register(kind, o);
 }
 
-void world::RegisterStone (Stone *stone) 
+void RegisterStone (Stone *stone) 
 {
     Register(static_cast&lt;Object*&gt;(stone));
     StoneID id = get_id(stone);
@@ -2509,7 +2508,7 @@
     stone_repos[id] = stone;
 }
 
-void world::RegisterActor (Actor *actor) 
+void RegisterActor (Actor *actor) 
 {
     Register(static_cast&lt;Object*&gt;(actor));
     ActorID id = get_id(actor);
@@ -2518,11 +2517,11 @@
     actor_repos[id] = actor;
 }
 
-void world::Repos_Shutdown() {
+void Repos_Shutdown() {
     delete repos;
 }
 
-Object * world::MakeObject(const char *kind) {
+Object * MakeObject(const char *kind) {
     static Object *last_templ = 0;
     static string last_kind;
 
@@ -2539,7 +2538,7 @@
     return o;
 }
 
-Object * world::GetObjectTemplate(const std::string &amp;kind) {
+Object * GetObjectTemplate(const std::string &amp;kind) {
     if (!repos-&gt;has_templ(kind)) {
         cerr &lt;&lt; &quot;GetObjectTemplate: unkown object name `&quot; &lt;&lt;kind&lt;&lt; &quot;'.\n&quot;;
         return 0;
@@ -2547,19 +2546,19 @@
         return repos-&gt;get_template(kind);
 }
 
-Floor* world::MakeFloor(const char *kind) {
+Floor* MakeFloor(const char *kind) {
     return dynamic_cast&lt;Floor*&gt;(MakeObject(kind));
 }
 
-Stone * world::MakeStone (const char *kind) {
+Stone * MakeStone (const char *kind) {
     return dynamic_cast&lt;Stone*&gt;(MakeObject(kind));
 }
 
-Actor * world::MakeActor (const char *kind) {
+Actor * MakeActor (const char *kind) {
     return dynamic_cast&lt;Actor*&gt;(MakeObject(kind));
 }
 
-Actor *world::MakeActor (ActorID id) 
+Actor *MakeActor (ActorID id) 
 {
     if (Actor *ac = actor_repos[id])
         return ac-&gt;clone();
@@ -2568,7 +2567,7 @@
     return 0;
 }
 
-Stone *world::MakeStone (StoneID id) 
+Stone *MakeStone (StoneID id) 
 {
     if (Stone *st = stone_repos[id])
         return st-&gt;clone();
@@ -2578,14 +2577,14 @@
 }
 
 
-void world::DisposeObject(Object *o) {
+void DisposeObject(Object *o) {
     if (o != 0) {
         UnnameObject(o);
         o-&gt;dispose();
     }
 }
 
-void world::DefineSimpleFloor(const std::string &amp;kind, double friction,
+void DefineSimpleFloor(const std::string &amp;kind, double friction,
                               double mousefactor, bool burnable,
                               const std::string &amp;firetransform)
 {
@@ -2594,19 +2593,19 @@
              firetransform.c_str(), &quot;&quot;));
 }
 
-void world::DumpObjectInfo() {
+void DumpObjectInfo() {
     repos-&gt;dump_info();
 }
 
 /* ------------------- Item repository ------------------- */
 
-void world::Register (const string &amp;kind, Item *obj) 
+void Register (const string &amp;kind, Item *obj) 
 {
     Object *o = obj;
-    world::Register(kind, o);
+    Register(kind, o);
 }
 
-void world::RegisterItem (Item *item) 
+void RegisterItem (Item *item) 
 {
     Register(static_cast&lt;Object*&gt;(item));
     ItemID id = get_id(item);
@@ -2615,7 +2614,7 @@
     item_repos[id] = item;
 }
 
-Item *world::MakeItem (ItemID id) 
+Item *MakeItem (ItemID id) 
 {
     if (Item *it = item_repos[id])
         return it-&gt;clone();
@@ -2624,6 +2623,7 @@
     return 0;
 }
 
-Item * world::MakeItem(const char *kind) {
+Item * MakeItem(const char *kind) {
     return dynamic_cast&lt;Item*&gt;(MakeObject(kind));
 }
+} // namespace enigma

Modified: trunk/src/world.hh
===================================================================
--- trunk/src/world.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/world.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -19,13 +19,13 @@
 #ifndef WORLD_HH_INCLUDED
 #define WORLD_HH_INCLUDED
 
+#include &quot;enigma.hh&quot;
 #include &quot;objects.hh&quot;
 #include &quot;util.hh&quot;
 
-namespace world
-{
-    using namespace enigma;
+namespace enigma {
 
+
 /* -------------------- Types -------------------- */
 
     using ecl::V2;
@@ -52,13 +52,13 @@
     struct Message {
         // Variables
         std::string    message;
-        enigma::Value  value;
+        Value  value;
         GridPos        gridpos;
 
         // Constructors
         Message ();
         Message (const std::string &amp;message,
-                 const enigma::Value &amp;value,
+                 const Value &amp;value,
                  GridPos gridpos = GridPos());
 
     };
@@ -146,22 +146,22 @@
 
 /* -------------------- World Management -------------------- */
 
-    void Init();
+    void InitWorld();
 
-    void PrepareLevel ();
+    void WorldPrepareLevel();
 
     /* Create a new, empty world with width `w' and height `h`. */
     void Resize (int w, int h);
 
     /* Initialize the world after loading it.  Call this after loading
        the world to force laser beams to be recalculated etc. */
-    bool InitWorld();
+    bool WorldInitLevel();
 
-    void Tick(double dtime);
+    void WorldTick(double dtime);
     void TickFinished ();
 
     // Destroy all objects and the complete object repository
-    void Shutdown();
+    void ShutdownWorld();
 
 
     bool IsLevelBorder(const GridPos &amp;p);
@@ -184,7 +184,7 @@
 
     void SetConstantForce (V2 force);
 
-
+
 /* -------------------- Rubbers Bands -------------------- */
 
     struct RubberBandData {
@@ -237,7 +237,7 @@
     void AddScramble(GridPos p, Direction d);
 
 
-
+
 /* -------------------- Signals &amp; Messages -------------------- */
 
     void    AddSignal (const GridLoc &amp;src, 
@@ -252,11 +252,11 @@
     /* Signal indices start at 0 */
     bool GetSignalTargetPos (Object *src, GridPos &amp;pos, int signalidx = 0);
 
-    void BroadcastMessage (const std::string&amp; msg, const enigma::Value&amp; value, 
+    void BroadcastMessage (const std::string&amp; msg, const Value&amp; value, 
                            GridLayerBits grids);
 
     Value SendMessage (Object *o, const string &amp;msg);
-    Value SendMessage (Object *o, const string &amp;msg, const enigma::Value&amp; value);
+    Value SendMessage (Object *o, const string &amp;msg, const Value&amp; value);
     Value SendMessage (Object *o, const Message &amp;m);
 
     /*! This function is used by all triggers, switches etc. that
@@ -265,7 +265,7 @@
       &quot;action&quot; and &quot;target&quot; attributes of `o'. */
     void PerformAction (Object *o, bool onoff);
 
-
+
 /* -------------------- Actors -------------------- */
 
     void   AddActor (Actor *a);
@@ -415,6 +415,7 @@
 
     /* Print information about all registered objects to stdout. */
     void DumpObjectInfo();
-}
+    
+} // namespace enigma
 
 #endif

Modified: trunk/src/world_internal.hh
===================================================================
--- trunk/src/world_internal.hh	2007-10-25 07:12:35 UTC (rev 911)
+++ trunk/src/world_internal.hh	2007-10-29 23:30:45 UTC (rev 912)
@@ -19,8 +19,8 @@
 
 #include &lt;memory&gt;
 
-namespace world
-{
+namespace enigma {
+
     struct Field;
     struct Signal;
 
@@ -372,5 +372,6 @@
 
         list&lt;Scramble&gt; scrambles;
     };
-}
+    
+} // namespace enigma
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000343.html">[Enigma-game-svn] r911 - trunk/src
</A></li>
	<LI>Next message: <A HREF="000345.html">[Enigma-game-svn] r913 - in trunk/src: . stones
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#344">[ date ]</a>
              <a href="thread.html#344">[ thread ]</a>
              <a href="subject.html#344">[ subject ]</a>
              <a href="author.html#344">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
