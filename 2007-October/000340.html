<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r908 - trunk/data/levels/lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2007-October/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r908%20-%20trunk/data/levels/lib&In-Reply-To=%3C200710201949.l9KJnRHf000593%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000339.html">
   <LINK REL="Next"  HREF="000341.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r908 - trunk/data/levels/lib</H1>
    <B>andreasl at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r908%20-%20trunk/data/levels/lib&In-Reply-To=%3C200710201949.l9KJnRHf000593%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r908 - trunk/data/levels/lib">andreasl at mail.berlios.de
       </A><BR>
    <I>Sat Oct 20 21:49:27 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000339.html">[Enigma-game-svn] r907 - in branches/eval/java/src/org/enigma_game:	lev util
</A></li>
        <LI>Next message: <A HREF="000341.html">[Enigma-game-svn] r909 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#340">[ date ]</a>
              <a href="thread.html#340">[ thread ]</a>
              <a href="subject.html#340">[ subject ]</a>
              <a href="author.html#340">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: andreasl
Date: 2007-10-20 21:49:26 +0200 (Sat, 20 Oct 2007)
New Revision: 908

Modified:
   trunk/data/levels/lib/libsoko-designlist.xml
   trunk/data/levels/lib/libsoko-endphase.xml
   trunk/data/levels/lib/libsoko.xml
Log:
Sokoban:
 - Continued works on endphase:
    - algorithm &quot;block&quot; complete
    - algorithm &quot;hide&quot; complete
    - algorithm &quot;gradients&quot; complete
    - algorithm &quot;magnets&quot; complete
    - algorithm &quot;fourswitch&quot; complete
    - important works for algorithms &quot;ralf&quot; and &quot;allcrack&quot;
 - Internally, libsoko now uses lists of special objects,
   like a list of all ways, or all outer walls which are
   near a way. This eases endphase programming.
 - Added st-invisible as default stone for outf, s.t.
   st-chess can't jump out of the level area. st-invisible
   is removed again before endphase.
 - Small changes to some designs
Todo:
 - Complete endphase algortihms &quot;ralf&quot;, &quot;allcrack&quot;, &quot;jumpyoxyds&quot;
   and &quot;vortex&quot;.
 - Add endphase information to the last 75 designs
 - externaldata-support in C++


Modified: trunk/data/levels/lib/libsoko-designlist.xml
===================================================================
--- trunk/data/levels/lib/libsoko-designlist.xml	2007-10-18 20:45:33 UTC (rev 907)
+++ trunk/data/levels/lib/libsoko-designlist.xml	2007-10-20 19:49:26 UTC (rev 908)
@@ -52,34 +52,62 @@
 --
 --   [5] = { outf = &quot;fl-leaves&quot;, inf = &quot;fl-leavesb&quot;, box = &quot;st-wood&quot;
 --           wall = {&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-leaves&quot;, &quot;al:random&quot;},
---           oxyd = &quot;a&quot;, white = true }
+--           oxyd = &quot;a&quot;, white = true,
+--           endp = {goal = {&quot;fl-abyss&quot;, &quot;it-none&quot;}, give = &quot;it-hammer&quot;,
+--                   alg = &quot;block:st-break_acwhite&quot;}}
 --
 --   will define design 5. The walls will alternate between
 --   st-glass/fl-wood and st-glass/fl-leaves. The goal will be
 --   it-trigger by default. The actor will be ac-whiteball.
+--   The boxes will be &quot;st-wood&quot;. There will be oxyds visible
+--   from the beginning, but they are blocked by st-break_acwhite.
+--   When all goals are filled, the st-wood are removed by setting
+--   fl-abyss (by which they become fl-stwood), the goal-item is
+--   removed. The player is finally given an it-hammer.
 --
 -- Possible flags:
 --
 --   white  : Use white marble and st-chess_white.
 --
--- Algorithms:
+-- Design-Algorithms:
 --
 --   checkerboard : default, up to 3 different floors in checkerboard pattern
 --   lines : arbitrary number of floors in diagonal lines
 --   waves : works best with 4 different floors
 --   random : arbitrary number of floors, randomly chosen
 --
-
+-- Endphase-Algorithms and their parameters:
+--
+--   circle         : arrange eight oxyds in a circle (default)
+--   hide           : position oxyds in the outer walls
+--     gradients:X  : like hide, create gradients, with force X
+--     magnets:X    : like hide, create magnets, with force X
+--   fourswitch     : create a fourswitch-puzzle
+--   ralf           : arrange oxyds with doors
+--     vortex       : like ralf, create vortices between way-clusters
+--     allcrack     : like ralf, create cracks everywhere
+--     jumpyoxyds   : like ralf, oxyds are movable by knocking on the door
+--   block:X        : create oxyds with blocking object X
+--   outside:X      : create X oxyd-pairs in the outside and outer walls
+  
 default_design = {
   wall = { &quot;st-rock3&quot;, &quot;fl-leaves&quot; },
    inf = { &quot;fl-wood&quot; },
-  outf = { &quot;fl-water&quot;, &quot;st-invisible&quot; },
+  outf = { &quot;fl-water&quot; },
    box = { &quot;st-brownie&quot; },
   goal = { &quot;it-trigger&quot; },
   oxyd = &quot;a&quot;,
-  endp = { alg = &quot;circle&quot; }
+  endp = { alg = &quot;circle&quot; },
+  outf_default_stone = &quot;st-invisible&quot;
 }
 
+-- outf_default_stone has the following meaning: When outf is drawn
+-- by set_element, but no stone is set, outf_default_stone is used
+-- instead. You can suppress this behaviour by explicitly setting
+-- outf = { &quot;fl-myfloor&quot;, &quot;st-none&quot; }.
+-- This is done to avoid a chess-stone from jumping into the void,
+-- as a present to the gamer.
+
 design_list = {
 
 -- endp-algs: circle, ralf, hide, outside, allcrack, block, fourswitch
@@ -101,7 +129,7 @@
      endp={goal=&quot;st-none&quot;, wall={&quot;st-none&quot;, &quot;fl-bluegray&quot;}, alg=&quot;outside&quot;}},
 [5]={box=&quot;st-wood&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-white&quot;,
      outf=&quot;fl-space&quot;, door=&quot;st-door_c&quot;, oxyd=&quot;c&quot;,
-     endp={goal={&quot;fl-abyss&quot;, &quot;it-none&quot;}, wall={&quot;st-bluegray_hole&quot;}, alg=&quot;outside&quot;}},
+     endp={goal={&quot;fl-abyss&quot;, &quot;it-none&quot;}, wall={&quot;st-bluegray_hole&quot;}, alg=&quot;outside:3&quot;}},
 [6]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-white&quot;,
      outf=&quot;fl-space&quot;, door=&quot;st-door_b&quot;, oxyd=&quot;c&quot;,
      endp={goal=&quot;st-greenbrown_hole&quot;, wall=&quot;st-thief&quot;, give=&quot;it-sword&quot;,
@@ -185,7 +213,7 @@
       endp={goal={&quot;fl-abyss&quot;, &quot;it-none&quot;}, give=&quot;it-hammer&quot;, alg=&quot;block:st-stone_break&quot;}},
 [31]={box=&quot;st-glass_move&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-tigris&quot;,
       outf=&quot;fl-space&quot;, door=&quot;st-door_b&quot;, oxyd=&quot;a&quot;,
-      endp={wall=&quot;st-grate1&quot;, give=&quot;it-cherry&quot;, alg=&quot;outside&quot;}},
+      endp={wall=&quot;st-grate1&quot;, give=&quot;it-cherry&quot;, alg=&quot;outside:3&quot;}},
 
 [32]={box=&quot;st-block&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-bluegray&quot;,
       outf=&quot;fl-space&quot;, door=&quot;st-blocker&quot;, oxyd=&quot;d&quot;,
@@ -218,14 +246,14 @@
 [41]={box=&quot;st-brownie&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-rough&quot;,
       outf=&quot;fl-space&quot;, door=&quot;st-door_a&quot;, oxyd=&quot;c&quot;,
       endp={goal={&quot;st-none&quot;, &quot;it-none&quot;, &quot;fl-hay&quot;}, wall=&quot;st-rock1_hole&quot;,
-            alg=&quot;outside&quot;}},
+            alg=&quot;outside:3&quot;}},
 [42]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-rough&quot;,
       outf=&quot;fl-sahara&quot;, door=&quot;st-door_b&quot;, oxyd=&quot;c&quot;,
       endp={goal=&quot;st-greenbrown&quot;, alg=&quot;vortex&quot;}},
 
 [43]={box=&quot;st-brownie&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
       outf=&quot;fl-space&quot;, door=&quot;st-door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-rock3_hole&quot;, wall=&quot;st-rock3_hole&quot;, alg=&quot;outside&quot;}},
+      endp={goal=&quot;st-rock3_hole&quot;, wall=&quot;st-rock3_hole&quot;, alg=&quot;outside:3&quot;}},
 [44]={box=&quot;st-marble_move&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
       outf=&quot;fl-rough-blue&quot;, door=&quot;st-door_b&quot;, oxyd=&quot;b&quot;,
       endp={&quot;st-marble_hole&quot;, alg=&quot;ralf&quot;}},
@@ -424,7 +452,9 @@
        outf={&quot;fl-abyss&quot;, &quot;st-grate1&quot;, &quot;st-none&quot;, &quot;st-none&quot;, &quot;st-none&quot;, &quot;st-none&quot;, &quot;st-none&quot;, &quot;st-none&quot;,
        &quot;st-none&quot;, &quot;st-none&quot;, &quot;st-none&quot;, &quot;st-none&quot;, &quot;al:random&quot;}, door=&quot;st-door_a&quot;, oxyd=&quot;c&quot;, white = true},
 [147]={box=&quot;st-wood&quot;, wall=&quot;st-whiteballs&quot;, inf=&quot;fl-gray&quot;, white = true,
-       outf={&quot;fl-gradient5&quot;, &quot;fl-gradient6&quot;, &quot;fl-gradient7&quot;, &quot;fl-gradient8&quot;, &quot;al:waves&quot;}, door=&quot;st-door_a&quot;, oxyd=&quot;a&quot;},
+       outf={&quot;fl-gradient5&quot;, &quot;fl-gradient6&quot;, &quot;fl-gradient7&quot;, &quot;fl-gradient8&quot;, &quot;al:waves&quot;},
+       door=&quot;st-door_a&quot;, oxyd=&quot;a&quot;,
+       endp={goal={&quot;st-none&quot;, &quot;it-none&quot;}, alg=&quot;gradients&quot;}},
 [148]={box=&quot;st-shogun-s&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-rough-blue&quot;, white = true,
        outf={&quot;fl-rough-red&quot;, &quot;fl-rough-blue&quot;, &quot;st-disco-light&quot;}, door=&quot;st-door_a&quot;, oxyd=&quot;a&quot;},
 [149]={box=&quot;st-shogun-s&quot;, wall=&quot;st-yellow&quot;, inf=&quot;fl-wood&quot;, outf=&quot;fl-swamp&quot;, door=&quot;st-door_a&quot;,

Modified: trunk/data/levels/lib/libsoko-endphase.xml
===================================================================
--- trunk/data/levels/lib/libsoko-endphase.xml	2007-10-18 20:45:33 UTC (rev 907)
+++ trunk/data/levels/lib/libsoko-endphase.xml	2007-10-20 19:49:26 UTC (rev 908)
@@ -27,24 +27,34 @@
 
 function goal_trigger(onoff, sender)
   local x, y = enigma.GetPos(sender)
-  local nr = enigma.GetAttrib(sender, &quot;sokoarea&quot;)
+  local nr = enigma.GetAttrib(sender, &quot;_sokoarea&quot;)
   local more_boxes = false  -- memorizes whether a box was added or removed
   if sokoarea[nr].endphase_started then
     return
   end
-  if(enigma.GetAttrib(sender, &quot;box&quot;) == 0) then
+
+  -- A new stone? Or has a stone been removed?
+  if(enigma.GetAttrib(sender, &quot;_box&quot;) == 0) then
     if enigma.GetStone(x,y) then
-      enigma.SetAttrib(sender, &quot;box&quot;, 1)
+      enigma.SetAttrib(sender, &quot;_box&quot;, 1)
       sokoarea[nr].goals_filled = sokoarea[nr].goals_filled + 1
+      more_boxes = true
+    else
+      -- blind alarm, probably a marble
+      return
     end
   else
-    enigma.SetAttrib(sender, &quot;box&quot;, 0)
+    enigma.SetAttrib(sender, &quot;_box&quot;, 0)
     sokoarea[nr].goals_filled = sokoarea[nr].goals_filled - 1
   end
+  
+  -- Call goal_hook, e.g. for algorithms &quot;ralf&quot; and &quot;allcrack&quot;.
   if type(goal_hook) == &quot;function&quot; then
     goal_hook(nr, sender, more_boxes, sokoarea[nr].goals_filled,
               sokoarea[nr].number_goals)
   end
+  
+  -- Start endphase?
   if sokoarea[nr].goals_filled == sokoarea[nr].number_goals then
     sokoarea[nr].endphase_started = true
     if type(sokoarea[nr].endphase_hook) == &quot;function&quot; then
@@ -56,6 +66,10 @@
 end
 
 function prepare_endphase(sokoarea_number)
+  -- ensure existence of goals
+  if sokoarea[1].number_goals &lt; 1 then
+    myerror(&quot;No goals defined!\n&quot;)
+  end
   -- ensure a correctly set endphase-attribute
   local endp = sokoarea[sokoarea_number].design.endp
   if not endp then
@@ -90,13 +104,15 @@
     -- nothing to prepare
   elseif (alg == &quot;ralf&quot;)
       or (alg == &quot;allcrack&quot;) then
-    endphase_set_block_oxyds(sokoarea_number, endp.door)
+    endphase_set_block_oxyds(sokoarea_number, sokoarea[sokoarea_number].design.door)
+    goal_hook = endphase_goal_hook_ralf
   elseif alg == &quot;block&quot; then
     endphase_set_block_oxyds(sokoarea_number, param)
   elseif (alg == &quot;outside&quot;) then
-    endphase_set_outside_oxyds(sokoarea_number)
+    endphase_set_outside_oxyds(sokoarea_number, param)
   elseif alg == &quot;jumpyoxyds&quot; then
     endphase_set_block_oxyds(sokoarea_number, &quot;jumpy&quot;)
+    goal_hook = endphase_goal_hook_ralf
   else
     mywarning(&quot;Endphase algorithm &quot;..alg..&quot; unknown! Will use 'circle' instead.&quot;)
   end
@@ -144,26 +160,25 @@
 
   if alg == &quot;circle&quot; then
     endphase_circle(sokoarea_number)
-  elseif alg == &quot;ralf&quot; then
-  
   elseif alg == &quot;hide&quot; then
-  
-  elseif alg == &quot;outside&quot; then
-  
+    endphase_set_hide_oxyds(sokoarea_number)  
+  elseif    (alg == &quot;ralf&quot;)
+         or (alg == &quot;outside&quot;)
+         or (alg == &quot;block&quot;)
+         or (alg == &quot;jumpyoxyds&quot;) then
+    endphase_ralf_open_doors(sokoarea_number)
   elseif alg == &quot;allcrack&quot; then
-  
-  elseif alg == &quot;block&quot; then
-    -- done in prepare_endphase
+    endphase_allcrack(sokoarea_number)
   elseif alg == &quot;fourswitch&quot; then
-  
+    endphase_fourswitch(sokoarea_number)
   elseif alg == &quot;vortex&quot; then
-  
+    -- ?
   elseif alg == &quot;gradients&quot; then
-  
+    endphase_set_hide_oxyds(sokoarea_number)
+    endphase_gradients(sokoarea_number, param)
   elseif alg == &quot;magnets&quot; then
-  
-  elseif alg == &quot;jumpyoxyds&quot; then
-
+    endphase_set_hide_oxyds(sokoarea_number)
+    endphase_magnets(sokoarea_number, param)
   else
     -- use default: &quot;circle&quot;
     endphase_circle(sokoarea_number)
@@ -175,29 +190,18 @@
   local endp = sokoarea[nr].design.endp
   local dx = sokoarea[nr].offset.x
   local dy = sokoarea[nr].offset.y
-  local mx = sokoarea[nr].array_width
-  local my = sokoarea[nr].array_height
 
-  -- If level_width and level_height are set, the level has been drawn
-  -- by create_sokoball. Hence we have to redraw everything outside
-  -- the level_array-area as well:
-  if endp.outf and sokoarea[nr].level_width and sokoarea[nr].level_height then
-    for x = 0, sokoarea[nr].level_width - 1 do
-      for y = 0, sokoarea[nr].level_height - 1 do
-        if (x &lt; dx) or (x &gt; mx+dx-1) or (y &lt; dy) or (y &gt; my+dy-1) then
-          set_element(x, y, nr, k, endp.outf)
-        end
-      end
-    end
-  end  
+  -- redraw outside
+  for p, v in pairs(sokoarea[nr].list_outside) do
+    set_element(v.lx, v.ly, nr, k, endp.outf)
+  end
 
-  -- Now redraw the area inside level_array:
-  for y = 0, my - 1 do
-    for x = 0, mx - 1 do
+  -- redraw the rest inside level_array:
+  for y = 0, sokoarea[nr].array_height - 1 do
+    for x = 0, sokoarea[nr].array_width - 1 do
       local ch = sokoarea[nr].level_array[y+1][x+1]
       for k, v in pairs(endp) do
-        if    ((k == &quot;outf&quot;) and char_is_outf(ch))
-           or ((k == &quot;inf&quot;)  and char_is_inf(ch))
+        if    ((k == &quot;inf&quot;)  and char_is_inf(ch))
            or ((k == &quot;wall&quot;) and char_is_wall(ch))
            or ((k == &quot;goal&quot;) and char_is_goal(ch)) then
           set_element(x+dx, y+dy, nr, k, v)
@@ -244,7 +248,11 @@
   oxyd_shuffle()
 end
 
-function endphase_set_outside_oxyds(sokoarea_number)
+-- endphase_set_outside_oxyds distributes oxyds over the outside and
+-- wall_two-area of the level. There will be 2 to 5 pairs of oxyds
+-- depending on the amount of space. PARAM may define a maximal
+-- number of oxyd pairs (good for outf = &quot;fl-space&quot;).
+function endphase_set_outside_oxyds(sokoarea_number, param)
   local places = {}
   local nr = sokoarea_number or 1
   local dx = sokoarea[nr].offset.x
@@ -253,118 +261,288 @@
   local my = sokoarea[nr].array_height
   local flavor = sokoarea[nr].design.oxyd or &quot;b&quot;
 
-  -- If level_width and level_height are set, there are more
-  -- oxyds possible than level_array alone would allow:
-  if sokoarea[nr].level_width and sokoarea[nr].level_height then
-    for x = 0, sokoarea[nr].level_width - 1 do
-      for y = 0, sokoarea[nr].level_height - 1 do
-        if (x &lt; dx) or (x &gt; mx+dx-1) or (y &lt; dy) or (y &gt; my+dy-1) then
-          table.insert(places, {x=x, y=y})
-        end
-      end
+  for p, v in pairs(combine_tables({sokoarea[nr].list_outside,
+                                    sokoarea[nr].list_wall_two})) do
+    if (mod(v.lx, 2) == 0) and (mod(v.ly, 2) == 0) then
+      table.insert(places, v)
     end
-  end  
+  end
 
-  -- Now outf-tiles inside level_array and far-away wall-tiles:
-  for y = 0, my - 1 do
-    for x = 0, mx - 1 do
-      local ch = sokoarea[nr].level_array[y+1][x+1]
-      if     char_is_outf(ch) 
-         or (char_is_wall(ch) and no_way_near(x+1, y+1, nr)) then
-        table.insert(places, {x=x+dx, y=y+dy})
+  -- Choose some appropriate subset
+  local max = table.getn(places)
+  local number_pairs = 2
+  if max &lt; 2 then
+    -- Not enough places? Then choose corners of level_array.
+    -- They should always be at least wall_two and far enough
+    -- away from each other.
+    places = { {lx = dx,           ly = dy},
+               {lx = dx + mx - 1,  ly = dy},
+               {lx = dx,           ly = dy + my - 1},
+               {lx = dx + mx - 1,  ly = dy + my - 1} }
+  else
+        if max &lt;  50 then  number_pairs = 3
+    elseif max &lt; 100 then  number_pairs = 4
+    else                   number_pairs = 5  end
+  end
+  if (type(param) ~= &quot;nil&quot;) and (param ~= &quot;&quot;) then
+    local max_pairs = tonumber(param)
+    if max_pairs &gt;= 2 then
+      number_pairs = math.min(max_pairs, number_pairs)
+    end    
+  end
+
+  shuffle_table(places)
+
+  for j = 1, number_pairs do
+    oxyd(places[2*j-1].lx, places[2*j-1].ly, flavor, j - 1)
+    oxyd(places[2*j].lx, places[2*j].ly, flavor, j - 1)
+  end
+  oxyd_shuffle()
+end
+
+function endphase_set_block_oxyds(sokoarea_number, blocker)
+  local places = {}
+  local nr = sokoarea_number or 1
+  local flavor = sokoarea[nr].design.oxyd or &quot;b&quot;
+
+  -- add all wall_two-elements with their wall_one.count == 1
+  for p, v in pairs(sokoarea[nr].list_wall_two) do
+    local entry = {lx = v.lx, ly = v.ly, ax = v.ax, ay = v.ay, wall_one = {}}
+    for q, w in pairs(v.wall_one) do
+      if w.count == 1 then
+        table.insert(entry.wall_one, w)
       end
     end
+    if table.getn(entry.wall_one) ~= 0 then
+      table.insert(places, entry)
+    end
   end
 
   -- Choose some appropriate subset
   local max = table.getn(places)
-  local number_pairs = 0
+  local number_pairs = 2
   if max &lt; 2 then
-    myerror(&quot;Not enough free places outside. This can't happen?!&quot;)
-  elseif max &lt;   4 then  number_pairs = 1
-  else                   number_pairs = 2  end
-  --elseif max &lt;   8 then  number_pairs = 2
-  --elseif max &lt;  30 then  number_pairs = 3
-  --elseif max &lt;  50 then  number_pairs = 4
-  --elseif max &lt;  80 then  number_pairs = 5
-  --elseif max &lt; 120 then  number_pairs = 6
-  --elseif max &lt; 180 then  number_pairs = 7
-  --else                   number_pairs = 8  end
-  for j = 1, max do
-    places[j].sort_field = math.random()
+    -- Not enough places? Then choose corners of level_array.
+    -- They should always be at least wall_two and far enough
+    -- away from each other.
+    places = { {lx = dx,           ly = dy},
+               {lx = dx + mx - 1,  ly = dy},
+               {lx = dx,           ly = dy + my - 1},
+               {lx = dx + mx - 1,  ly = dy + my - 1} }
+  else
+        if max &lt;  50 then  number_pairs = 3
+    elseif max &lt; 100 then  number_pairs = 4
+    else                   number_pairs = 5  end
   end
-  table.sort(places, function (a, b) return a.sort_field &lt; b.sort_field end)
-  for j = 1, number_pairs do
-    oxyd(places[2*j-1].x, places[2*j-1].y, flavor, j)
-    oxyd(places[2*j].x, places[2*j].y, flavor, j)
+  if (type(param) ~= &quot;nil&quot;) and (param ~= &quot;&quot;) then
+    local max_pairs = tonumber(param)
+    if max_pairs &gt;= 2 then
+      number_pairs = math.min(max_pairs, number_pairs)
+    end    
   end
+
+  shuffle_table(places)
+  sokoarea[sokoarea_number].list_oxyds = {}
+
+  function set_block(p)
+    --for q, w in pairs(places[p].wall_one) do
+    local w = places[p].wall_one[1]
+    set_element(w.lx, w.ly, sokoarea_number, &quot;inf&quot;)
+    set_stone(blocker, w.lx, w.ly)
+    --end
+  end
+  for j = 1, number_pairs do   -- Testlevel: 14
+    oxyd(places[2*j-1].lx, places[2*j-1].ly, flavor, j - 1)
+    oxyd(places[2*j].lx, places[2*j].ly, flavor, j - 1)
+    set_block(2*j-1)
+    set_block(2*j)
+    table.insert(sokoarea[sokoarea_number].list_oxyds, places[2*j-1])
+    table.insert(sokoarea[sokoarea_number].list_oxyds, places[2*j])
+  end
   oxyd_shuffle()
 end
 
-function endphase_set_block_oxyds(sokoarea_number, blocker)
+-- endphase_set_hide_oxyds distributes oxyds over the wall_one-walls.
+function endphase_set_hide_oxyds(sokoarea_number)
+  local flavor = sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
+  local places = {}
+  
+  -- add all wall_one-elements
+  for p, v in pairs(sokoarea[sokoarea_number].list_wall_one) do
+    table.insert(places, v)
+  end
 
-  if 1 + 1 == 2 then return end
+  shuffle_table(places)
   
+  -- choose number of oxyds
+  local max = table.getn(places)
+  local number_pairs = 1
+  if max &lt; 2 then
+    -- use circle instead
+    endphase_circle(sokoarea)
+  elseif max &lt;  6  then  number_pairs = 2
+  elseif max &lt; 10  then  number_pairs = 3
+  elseif max &lt; 30  then  number_pairs = 4
+  else                   number_pairs = 5 end
+  
+  -- set oxyds
+  for j = 1, number_pairs do
+    oxyd(places[2*j-1].lx, places[2*j-1].ly, flavor, j - 1)
+    oxyd(places[2*j].lx, places[2*j].ly, flavor, j - 1)
+  end
+  oxyd_shuffle()  
+end
+
+function endphase_gradients(sokoarea_number, param)
+  local force = tonumber(param) or 25.0
+  for p, v in pairs(sokoarea[sokoarea_number].list_way) do
+    local grad_type = random(1,12)
+    set_floor(&quot;fl-gradient&quot;, v.lx, v.ly, {type = grad_type, force = force})
+  end
+end
+
+function endphase_magnets(sokoarea_number, param)
+  local force = tonumber(param) or 50.0
   local places = {}
   local nr = sokoarea_number or 1
-  local dx = sokoarea[nr].offset.x
-  local dy = sokoarea[nr].offset.y
-  local mx = sokoarea[nr].array_width
-  local my = sokoarea[nr].array_height
   local flavor = sokoarea[nr].design.oxyd or &quot;b&quot;
 
-  -- If level_width and level_height are set, there are more
-  -- oxyds possible than level_array alone would allow:
-  if sokoarea[nr].level_width and sokoarea[nr].level_height then
-    for x = 0, sokoarea[nr].level_width - 1 do
-      for y = 0, sokoarea[nr].level_height - 1 do
-        local pos = one_tile_far_from_way(x+dx, y+dy, nr)
-        if pos then
-          table.insert(places, {x=x, y=y, door_x=pos.x, door_y=pos.y})
-          --set_stone(&quot;st-pull&quot;, x, y)
-          --set_floor(&quot;fl-red&quot;, pos.x, pos.y)
+  -- add all way-elements which are not goals
+  for p, v in pairs(sokoarea[nr].list_way) do
+    if not char_is_goal(sokoarea[nr].level_array[v.ay][v.ax]) then
+      table.insert(places, v)
+    end
+  end
+
+  shuffle_table(places)
+
+  -- choose number of magnets
+  local number_magnets = math.floor(table.getn(places)/6)
+
+  -- set magnets
+  for j = 1, number_magnets do
+    set_item(&quot;it-magnet-on&quot;, places[j].lx, places[j].ly,
+             {range = 5, strength = force})
+  end
+end
+
+function endphase_fourswitch(sokoarea_number)
+  local flavor = sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
+  local places = {}
+
+  -- add all wall_one-elements
+  for p, v in pairs(sokoarea[sokoarea_number].list_wall_one) do
+    table.insert(places, v)
+  end
+
+  shuffle_table(places)
+
+  -- choose number of fourswitchs/oxyds
+  local max = table.getn(places)
+  local number_pairs = 1
+  if max &lt; 2 then
+    -- use circle instead
+    endphase_circle(sokoarea)
+  elseif max &lt;  6  then  number_pairs = 2
+  elseif max &lt; 10  then  number_pairs = 3
+  else                   number_pairs = 4 end
+
+  function endphase_call_fourswitch(onoff, sender)
+    local j = enigma.GetAttrib(sender, &quot;_number&quot;)
+    places[j].current = places[j].current + 1
+    if places[j].current == 5 then
+      places[j].current = 1
+    end
+    if places[j].current == places[j].solve then
+      places[j].correct = true
+      set_stone(&quot;st-likeoxyda-open&quot;, places[j].lx, places[j].ly,
+          {_number=0})
+    end
+
+    if j ~= 1 then
+      -- Trigger all lower fourswitchs
+      local x = places[j-1].lx
+      local y = places[j-1].ly
+      if places[j-1].correct then
+        -- reset the fourswitch
+        mystone = set_stone(&quot;st-fourswitch&quot;, x, y, {_number = j - 1})
+        for k = 1, places[j-1].current do
+          SendMessage(mystone, &quot;trigger&quot;)
         end
+        enigma.SetAttrib(mystone, &quot;action&quot;, &quot;callback&quot;)
+        enigma.SetAttrib(mystone, &quot;target&quot;, &quot;endphase_call_fourswitch&quot;)
+        places[j-1].correct = false
       end
-    end
-  else
-    for y = 0, my - 1 do
-      for x = 0, mx - 1 do
-        local pos = one_tile_far_from_way(x+dx, y+dy, nr)
-        if pos then
-          table.insert(places, {x=x, y=y, door_x=pos.x, door_y=pos.y})
-          --set_stone(&quot;st-pull&quot;, x, y)
-          --set_floor(&quot;fl-red&quot;, pos.x, pos.y)
+      SendMessage(enigma.GetStone(x, y), &quot;trigger&quot;)
+    else
+      -- Check all fourswitchs
+      local correct = true
+      for k = 1, 2*number_pairs do
+        correct = correct and places[k].correct
+      end
+      if correct then
+        -- replace fourswitchs by oxyds
+        for k = 1, number_pairs do
+          oxyd(places[2*k-1].lx, places[2*k-1].ly, flavor, k - 1)
+          oxyd(places[2*k].lx, places[2*k].ly, flavor, k - 1)
         end
+        oxyd_shuffle()
       end
     end  
   end
+  
+  -- set fourswitchs
+  for j = 1, 2*number_pairs do
+    set_stone(&quot;st-fourswitch&quot;, places[j].lx, places[j].ly,
+        {action=&quot;callback&quot;, target=&quot;endphase_call_fourswitch&quot;, _number=j})
+    places[j].current = 4
+    places[j].solve = random(1,4)
+    places[j].correct = false
+  end
+  oxyd_shuffle()  
+end
 
+function endphase_allcrack(sokoarea_number)
+  for p, v in pairs(sokoarea[sokoarea_number].list_way) do
+    if not enigma.GetItem(v.lx, v.ly) then
+      set_item(&quot;it-crack3&quot;, v.lx, v.ly)
+    end
+  end  
+end
 
-  -- Choose some appropriate subset
-  local max = table.getn(places)
-  local number_pairs = 0
-  if max &lt; 2 then
-    myerror(&quot;Not enough free places outside. This can't happen?!&quot;)
-  elseif max &lt;   4 then  number_pairs = 1
-  else                   number_pairs = 2  end
-  --elseif max &lt;   8 then  number_pairs = 2
-  --elseif max &lt;  30 then  number_pairs = 3
-  --elseif max &lt;  50 then  number_pairs = 4
-  --elseif max &lt;  80 then  number_pairs = 5
-  --elseif max &lt; 120 then  number_pairs = 6
-  --elseif max &lt; 180 then  number_pairs = 7
-  --else                   number_pairs = 8  end
-  for j = 1, max do
-    places[j].sort_field = math.random()
+function endphase_goal_hook_ralf(sokoarea_number, sender, more_boxes,
+    goals_filled, number_goals)
+  -- verify correct sokoarea-number and existence of &quot;list_oxyds&quot;
+  if sokoarea_number ~= enigma.GetAttrib(sender, &quot;_sokoarea&quot;) then
+    myerror(&quot;libsoko: Inconsistent sokoarea numbers in goal hook!&quot;)
   end
-  table.sort(places, function (a, b) return a.sort_field &lt; b.sort_field end)
-  for j = 1, number_pairs do
-    oxyd(places[2*j-1].x, places[2*j-1].y, flavor, j)
-    oxyd(places[2*j].x, places[2*j].y, flavor, j)
+  if type(sokoarea[sokoarea_number].list_oxyds) ~= &quot;table&quot; then
+    myerror(&quot;libsoko: Oxyd list is missing during goal hook!&quot;)
   end
-  oxyd_shuffle()
+  -- identify the corresponding door and open it
+  local goal_number = enigma.GetAttrib(sender, &quot;_goal_number&quot;)
+  local number_oxyds = table.getn(sokoarea[sokoarea_number].list_oxyds)
+  if (goal_number ~= 1) and (goal_number &lt;= number_oxyds) then  
+    local oxyd_entry = sokoarea[sokoarea_number].list_oxyds[goal_number]
+    local door_x = oxyd_entry.wall_one[1].lx
+    local door_y = oxyd_entry.wall_one[1].ly
+    local st = enigma.GetStone(door_x, door_y)
+    if more_boxes then
+      SendMessage(st, &quot;open&quot;)
+    else
+      SendMessage(st, &quot;close&quot;)
+    end
+  end
 end
 
+function endphase_ralf_open_doors(sokoarea_number)
+  for j, v in pairs(sokoarea[sokoarea_number].list_oxyds) do
+    local door_x = v.wall_one[1].lx
+    local door_y = v.wall_one[1].ly
+    SendMessage(enigma.GetStone(door_x, door_y), &quot;open&quot;)
+  end
+end
+    
     ]]&gt;&lt;/el:luamain&gt;
     &lt;el:i18n&gt;
     &lt;/el:i18n&gt;

Modified: trunk/data/levels/lib/libsoko.xml
===================================================================
--- trunk/data/levels/lib/libsoko.xml	2007-10-18 20:45:33 UTC (rev 907)
+++ trunk/data/levels/lib/libsoko.xml	2007-10-20 19:49:26 UTC (rev 908)
@@ -61,14 +61,17 @@
 -- However, you can call endphase(sokoarea_number) yourself if neccessary.
 --
 --       list_outside - list of positions of outf-tiles
+--          list_wall - list of all walls
 --           list_way - list of all inside positions that the marble
---                      can reach on level-end
+--                      can reach on level-end (incl. goals)
 --      list_wall_one - list of outer walls near ways
---      list_wall_two - list of outer walls one tile away from ways,
---                      together with a list of neighboring wall_ones.
+--      list_wall_two - list of outer walls or outf one tile away from
+--                      ways, together with a list of neighboring wall_ones.
 --
--- Each list entry is a table: Entries x and y are absolute positions,
--- lx and ly are positions in the level_array, if existent (nil else).
+-- Each list entry is a table: Entries lx and ly are absolute positions
+-- (&quot;level&quot;), ax and ay are positions in the level_array, if existent
+-- (nil else). Some endphases also use list_oxyds as additional data
+-- structure.
 
 sokoarea = {}
 
@@ -122,6 +125,15 @@
   return result
 end
 
+-- shuffle_table resorts the table T randomly. Note that T has to be
+-- indexed with integers from 1 to table.getn(T). Type is not checked.
+function shuffle_table(t)
+  for p, v in pairs(t) do
+    t[p].sort_field = math.random()
+  end
+  table.sort(t, function (a, b) return a.sort_field &lt; b.sort_field end)
+end
+
 -- choose_among_multiples selects a number between 1 and COUNT
 -- based on the coordinates X and Y and the algorithm's name ALG.
 function choose_among_multiples(x, y, count, alg)
@@ -206,6 +218,130 @@
   return false
 end
 
+-- create_lists creates the special lists list_outside, list_wall,
+-- list_way, list_wall_one and list_wall_two for SOKOAREA_NUMBER.
+function create_lists(sokoarea_number)
+  local nr = sokoarea_number or 1
+  local dx = sokoarea[nr].offset.x
+  local dy = sokoarea[nr].offset.y
+  local mx = sokoarea[nr].array_width
+  local my = sokoarea[nr].array_height
+  sokoarea[nr].list_outside = {}
+  sokoarea[nr].list_way = {}
+  sokoarea[nr].list_wall_one = {}
+  sokoarea[nr].list_wall_two = {}
+  -- list_way, list_wall and list_outside (inside level_array)
+  for x = 0, mx - 1 do
+    for y = 0, my - 1 do
+      local ch = sokoarea[nr].level_array[y+1][x+1]
+      local entry = {lx = x+dx, ly = y+dy, ax = x+1, ay = y+1}
+      if char_is_outf(ch) then
+        sokoarea[nr].list_outside[(x+dx)..&quot;/&quot;..(y+dy)] = entry
+      elseif char_is_wall(ch) then
+        sokoarea[nr].list_wall[(x+dx)..&quot;/&quot;..(y+dy)] = entry
+      else
+        sokoarea[nr].list_way[(x+dx)..&quot;/&quot;..(y+dy)] = entry
+      end        
+    end
+  end
+  -- list_outside (outside level_array)
+  if sokoarea[nr].level_width and sokoarea[nr].level_height then
+    for x = 0, sokoarea[nr].level_width - 1 do
+      for y = 0, sokoarea[nr].level_height - 1 do
+        if (x &lt; dx) or (x &gt; mx+dx-1) or (y &lt; dy) or (y &gt; my+dy-1) then
+          sokoarea[nr].list_outside[x..&quot;/&quot;..y] = {lx = x, ly = y}
+        end
+      end
+    end
+  end
+  -- list_wall_one
+  -- There are three conditions for an element of list_wall_one:
+  -- (i) it's a wall, (ii) it's near or diagonal to outside,
+  -- (iii) it's near a way.
+  -- In addition, it counts the number of near ways.
+  for p, v in pairs(sokoarea[nr].list_wall) do
+    local x = v.lx
+    local y = v.ly
+    if    sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y)]
+       or sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y)]
+       or sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y-1)]
+       or sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y+1)]
+       or sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y+1)]
+       or sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y-1)]
+       or sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y+1)]
+       or sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y-1)] then
+      local count = 0
+      if sokoarea[nr].list_way[(x-1)..&quot;/&quot;..(y)] then  count = count + 1  end
+      if sokoarea[nr].list_way[(x+1)..&quot;/&quot;..(y)] then  count = count + 1  end
+      if sokoarea[nr].list_way[(x)..&quot;/&quot;..(y-1)] then  count = count + 1  end
+      if sokoarea[nr].list_way[(x)..&quot;/&quot;..(y+1)] then  count = count + 1  end
+      if count &gt; 0 then
+        sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] =
+            {lx = x, ly = y, ax = v.ax, ay = v.ay, count = count}
+      end
+    end
+  end
+  -- list_wall_two
+  -- There are three conditions for an element of list_wall_two:
+  -- (i) it's near a wall_one, (ii) it's not a wall_one,
+  -- (iii) it's wall or outside. Next function checks (ii) and (iii)
+  -- and adds the checked element to the list. In addition, the
+  -- neighboring wall_one are added into the list.
+  local function check_ii_and_iii(x, y, one_x, one_y)
+    if sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] then
+      return
+    end
+    if sokoarea[nr].list_way[x..&quot;/&quot;..y] then
+      return
+    end
+    if not sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] then
+      -- create new entry
+      sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] =
+          {lx = x, ly = y, ax = nil, ay = nil, wall_one = {}}
+    end
+    -- add the corresponding wall_one
+    local w = table.getn(sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one) + 1
+    sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one[w] =
+        sokoarea[nr].list_wall_one[one_x..&quot;/&quot;..one_y]
+  end
+  for p, v in pairs(sokoarea[nr].list_wall_one) do
+    check_ii_and_iii(v.lx+1, v.ly, v.lx, v.ly)
+    check_ii_and_iii(v.lx-1, v.ly, v.lx, v.ly)
+    check_ii_and_iii(v.lx, v.ly+1, v.lx, v.ly)
+    check_ii_and_iii(v.lx, v.ly-1, v.lx, v.ly)
+  end  
+end
+
+-- new_sokoarea initialises a new entry in the global
+-- sokoarea table and returns its number.
+function new_sokoarea()
+  sokoarea_number = table.getn(sokoarea) + 1
+  sokoarea[sokoarea_number] = {
+    level_array = {},
+    design = default_design,
+    number_goals = 0,
+    goals_filled = 0,
+    actor_count = 0,
+    endphase_started = false,
+    offset = {0, 0},
+    level_width = nil,
+    level_height = nil,
+    uses_chess = false,
+    goal_hook = nil,
+    endphase_hook = endphase,
+    list_outside = {},
+    list_wall = {},
+    list_way = {},
+    list_wall_one = {},
+    list_wall_two = {}
+  }
+  return sokoarea_number
+end
+
+------------------------------------------------------------------------
+-- Drawing Functions and Level Interpretation
+------------------------------------------------------------------------
+
 -- set_element sets element name EL_STR of area SOKOAREA_NUMBER at x, y.
 -- EL_DESIGN is optional and overrides the design of the given sokoarea.
 function set_element(x, y, sokoarea_number, el_str, el_design)
@@ -280,15 +416,16 @@
     else
       created_objects.it = set_item(itkind, x, y)
     end
-    if created_objects.it and not in_endphase then
-      enigma.SetAttrib(created_objects.it, &quot;action&quot;, &quot;callback&quot;)
-      enigma.SetAttrib(created_objects.it, &quot;target&quot;, &quot;goal_trigger&quot;)
-      enigma.SetAttrib(created_objects.it, &quot;box&quot;, 0)
-      enigma.SetAttrib(created_objects.it, &quot;sokoarea&quot;, sokoarea_number)
-    end
     if (el_str == &quot;goal&quot;) and not in_endphase then
-      sokoarea[sokoarea_number].number_goals = 
-          sokoarea[sokoarea_number].number_goals + 1
+      local gn = sokoarea[sokoarea_number].number_goals + 1
+      sokoarea[sokoarea_number].number_goals = gn
+      if created_objects.it and not in_endphase then
+        enigma.SetAttrib(created_objects.it, &quot;action&quot;, &quot;callback&quot;)
+        enigma.SetAttrib(created_objects.it, &quot;target&quot;, &quot;goal_trigger&quot;)
+        enigma.SetAttrib(created_objects.it, &quot;_box&quot;, 0)
+        enigma.SetAttrib(created_objects.it, &quot;_sokoarea&quot;, sokoarea_number)
+        enigma.SetAttrib(created_objects.it, &quot;_goal_number&quot;, gn)
+      end
     end
   end
   
@@ -550,27 +687,6 @@
   return trimmed_array
 end
 
--- new_sokoarea initialises a new entry in the global
--- sokoarea table and returns its number.
-function new_sokoarea()
-  sokoarea_number = table.getn(sokoarea) + 1
-  sokoarea[sokoarea_number] = {
-    level_array = {},
-    design = default_design,
-    number_goals = 0,
-    goals_filled = 0,
-    actor_count = 0,
-    endphase_started = false,
-    offset = {0, 0},
-    level_width = nil,
-    level_height = nil,
-    uses_chess = false,
-    goal_hook = nil,
-    endphase_hook = endphase
-  }
-  return sokoarea_number
-end
-
 ------------------------------------------------------------------------
 -- Choosing the Designnumber, Random numbers
 ------------------------------------------------------------------------
@@ -678,15 +794,13 @@
 --
 function number_from_level(level_array, list_length)
   local j = list_length + 1
-  local lastline = table.getn(level_array)
-  local maxwidth = table.getn(level_array[1])
-  mywarning(&quot;Calculating level design ...&quot;)
+  mydebug(&quot;Calculating number from level_array, modulus &quot;..list_length..&quot; ...&quot;)
   local l = 2
   repeat
     j = j - 1
     b = 0
-    for y = 1, lastline do
-      for x = 1, maxwidth do
+    for y = 1, table.getn(level_array) do
+      for x = 1, table.getn(level_array[1]) do
         if char_is_wall(level_array[y][x]) then
           if 2*b + 1 &lt; j then
             b = 2*b + 1
@@ -729,8 +843,29 @@
   else
     myerror(&quot;Can't make sense of design type &quot;..type(design)..&quot;.&quot;)
   end
-  -- fill chosen design with default values where neccessary, and return
-  return combine_tables({design, default_design})
+  -- fill chosen design with default values where neccessary
+  design = combine_tables({design, default_design})
+  -- No stone set for outf, not even &quot;st-none&quot;?
+  -- Use the default outf-stone instead, and remove it on endphase.
+  if type(design.outf) ~= &quot;table&quot; then
+    design.outf = {design.outf}
+  end
+  for j, v in pairs(design.outf) do
+    if is_stone(v) then
+      return design
+    end
+  end
+  table.insert(design.outf, default_design.outf_default_stone)
+  if type(design.endp.outf) ~= &quot;table&quot; then
+    design.endp.outf = {design.endp.outf}
+  end
+  for j, v in pairs(design.endp.outf) do
+    if is_stone(v) then
+      return design
+    end
+  end
+  table.insert(design.endp.outf, &quot;st-none&quot;)  
+  return design
 end
 
 
@@ -776,7 +911,7 @@
   sokoarea[1].level_height = levelh
   create_world(levelw, levelh)
   
-  -- Calculate padding
+  -- calculate padding
   local dx = 0
   local dy = 0
   if levelw &gt; sokoarea[1].array_width then
@@ -787,21 +922,20 @@
   end
   sokoarea[1].offset = {x = dx, y = dy}
 
-  sokoarea[1].design = 
-      design_from_description(design, sokoarea[1].level_array)
+  -- calculate design
+  sokoarea[1].design = design_from_description(design, sokoarea[1].level_array)
 
+  -- create special position lists
+  create_lists(nr)
+  
+  -- draw level
   for x = 0, levelw - 1 do
     for y = 0, levelh - 1 do
       set_element(x, y, 1, &quot;outf&quot;)
     end
   end
-
   draw_level_array(1, true, true)
-
-  if sokoarea[1].number_goals &lt; 1 then
-    myerror(&quot;No goals defined!\n&quot;)
-  end
-
+  
   -- prepare oxyds for end phase
   prepare_endphase(1)
 
@@ -823,7 +957,7 @@
   local nr = sokoarea_number or 1  
   sokoarea[nr].design =
       design_from_description(design, sokoarea[nr].level_array)
-  
+
   if sokoarea[nr].level_width and sokoarea[nr].level_height then
     for x = 0, sokoarea[nr].level_width - 1 do
       for y = 0, sokoarea[nr].level_height - 1 do
@@ -850,10 +984,6 @@
 
   draw_level_array(nr, true, false)
 
-  if sokoarea[nr].number_goals &lt; 1 then
-    myerror(&quot;No goals defined!\n&quot;)
-  end
-
   -- prepare oxyds for end phase
   prepare_endphase(nr)
   mywarning(sokoarea[nr].design.endp.alg)
@@ -895,6 +1025,7 @@
     sokoarea[nr].endphase_hook = endphase_hook
   end
   sokoarea[nr].goal_hook = goal_hook
+  create_lists(nr)
   draw_level_array(nr, false, draw_actor)
 end
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000339.html">[Enigma-game-svn] r907 - in branches/eval/java/src/org/enigma_game:	lev util
</A></li>
	<LI>Next message: <A HREF="000341.html">[Enigma-game-svn] r909 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#340">[ date ]</a>
              <a href="thread.html#340">[ thread ]</a>
              <a href="subject.html#340">[ subject ]</a>
              <a href="author.html#340">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
