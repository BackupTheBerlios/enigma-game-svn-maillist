<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1591 - in trunk: data/levels/lib doc/reference
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1591%20-%20in%20trunk%3A%20data/levels/lib%20doc/reference&In-Reply-To=%3C200903160055.n2G0tckx006368%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001020.html">
   <LINK REL="Next"  HREF="001022.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1591 - in trunk: data/levels/lib doc/reference</H1>
    <B>andreasl at mail.berlios.de</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1591%20-%20in%20trunk%3A%20data/levels/lib%20doc/reference&In-Reply-To=%3C200903160055.n2G0tckx006368%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1591 - in trunk: data/levels/lib doc/reference">andreasl at mail.berlios.de
       </A><BR>
    <I>Mon Mar 16 01:55:38 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001020.html">[Enigma-game-svn] r1590 - trunk/doc/reference
</A></li>
        <LI>Next message: <A HREF="001022.html">[Enigma-game-svn] r1592 - in trunk: doc src src/items
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1021">[ date ]</a>
              <a href="thread.html#1021">[ thread ]</a>
              <a href="subject.html#1021">[ subject ]</a>
              <a href="author.html#1021">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: andreasl
Date: 2009-03-16 01:55:33 +0100 (Mon, 16 Mar 2009)
New Revision: 1591

Added:
   trunk/data/levels/lib/libsoko_designlist.xml
Removed:
   trunk/data/levels/lib/libsoko-designlist.xml
   trunk/data/levels/lib/libsoko-endphase.xml
Modified:
   trunk/data/levels/lib/liblua.xml
   trunk/data/levels/lib/libmath.xml
   trunk/data/levels/lib/libsoko.xml
   trunk/doc/reference/enigma-ref.texi
Log:
Trunk:
 - Nearly complete rewrite of libsoko:
    - United libsoko and libsoko-endphase, using new API
      and position lists.
    - Renamed libsoko-designlist to libsoko_designlist,
      reformatted designs and finetuned them.
 - New function lib.math.steps:
    - Takes a number and a table of numbers and determines
      the index of the interval in which the number appears.
      Outsourced from libsoko.
 - New function lib.lua.to_string:
    - Takes anything and tries to return a sensible string
      describing the argument. Can be used with print() for
      debugging purposes.
 - Fix missing &quot;@end table&quot; in refman from rev. 1588.
Thanks:
 - Many thanks to Harry and Clifford for the most valuable
   feedback to the first version of libsoko (yes, that was
   a year ago)!
Todo:
 - Test levels.
 - Beautify lib.lua.to_string (nested tables are still ugly,
   combine with print_table somehow).


Modified: trunk/data/levels/lib/liblua.xml
===================================================================
--- trunk/data/levels/lib/liblua.xml	2009-03-14 23:58:47 UTC (rev 1590)
+++ trunk/data/levels/lib/liblua.xml	2009-03-16 00:55:33 UTC (rev 1591)
@@ -140,6 +140,8 @@
       print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. value)
     elseif type(value) == &quot;string&quot; then
       print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = \&quot;&quot; .. value .. &quot;\&quot;&quot;)
+    elseif type(value) == &quot;boolean&quot; then
+      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. lib.lua.cond(value, &quot;true&quot;, &quot;false&quot;))
     elseif type(value) == &quot;table&quot; then
       if (depth or 0) &lt; 5 then
         print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = |&quot;)
@@ -166,6 +168,62 @@
   end
 end
 
+function lib.lua.to_string(thing)
+  local t = type(thing)
+  if t == &quot;userdata&quot; then
+    t = usertype(thing)
+  end
+  local result = &quot;unknown type&quot;
+      if (t == &quot;nil&quot;) then
+    result = &quot;nil&quot;
+  elseif (t == &quot;string&quot;) then
+    if string.find(thing, &quot;\n&quot;, 1, true) then
+      result = &quot;string of several lines: \n&quot; .. thing
+    end
+    result = &quot;string: \&quot;&quot; .. thing .. &quot;\&quot;&quot;
+  elseif (t == &quot;number&quot;) then
+    result = &quot;number: &quot; .. thing
+  elseif (t == &quot;boolean&quot;) then
+    result = &quot;boolean: &quot; .. lib.lua.cond(thing, &quot;true&quot;, &quot;false&quot;)
+  elseif (t == &quot;table&quot;) then
+    result = &quot;table&quot;
+    if thing.type then
+      result = result .. &quot;/&quot; .. thing.type
+    end
+    result = result .. &quot;:\n&quot;
+    local found = false
+    for key, value in pairs(thing) do
+      found = true
+      result = result .. &quot;  &quot; .. lib.lua.to_string(key) .. &quot; -&gt; &quot; .. lib.lua.to_string(value) .. &quot;\n&quot;
+    end
+    if not found then
+      result = &quot;empty table&quot;
+      if thing.type then
+        result = result .. &quot;/&quot; .. thing.type
+      end
+    end
+  elseif (t == &quot;position&quot;) then
+    result = &quot;position: &quot; .. thing.x .. &quot;/&quot; .. thing.y
+  elseif (t == &quot;object&quot;) then
+    result = &quot;object with name '&quot; .. thing.name .. &quot;' at &quot; .. lib.lua.to_string(po(thing))
+  elseif (t == &quot;tile&quot;) then
+    result = &quot;tile&quot;
+  elseif (t == &quot;tiles&quot;) then
+    result = &quot;tiles&quot;
+  elseif (t == &quot;group&quot;) then
+    result = &quot;object group with &quot; .. #thing .. &quot; objects:\n&quot;
+    for obj in thing do
+      result = result .. &quot;  &quot; .. lib.lua.to_string(obj) .. &quot;\n&quot;
+    end
+  elseif (t == &quot;polist&quot;) then
+    result = &quot;position list with &quot; .. #thing .. &quot; positions:\n&quot;
+    for j = 1, #thing do
+      result = result .. &quot;  &quot; .. j .. &quot;: &quot; .. thing[j].x .. &quot;/&quot; .. thing[j].y .. &quot;\n&quot;
+    end
+  end
+  return result
+end
+
 ---------------------------------------------------------------------
 --  MATHEMATICAL  FUNCTIONS
 ---------------------------------------------------------------------

Modified: trunk/data/levels/lib/libmath.xml
===================================================================
--- trunk/data/levels/lib/libmath.xml	2009-03-14 23:58:47 UTC (rev 1590)
+++ trunk/data/levels/lib/libmath.xml	2009-03-16 00:55:33 UTC (rev 1591)
@@ -188,6 +188,38 @@
          + (a[4] or 0)*x*x + (a[3] or 0)*y + (a[2] or 0)*x + (a[1] or 0)
 end
 
+-- steps takes DISCRIMINATOR and returns a value dependend on where
+-- in the table STEPS of integers the discriminator is located.
+-- Example: lib.math.steps(x, {4, 8, 13}) returns:
+--     0: If        x &lt; 4
+--     1: If   4 &lt;= x &lt; 8
+--     2: If   8 &lt;= x &lt; 13
+--     3: If  13 &lt;= x
+-- Negative and non-integer values are allowed.
+function lib.math.steps(discriminator, steps)
+  if type(discriminator) ~= &quot;number&quot; then
+    error(&quot;lib.math.steps: First argument is &quot; .. type(discriminator)
+        .. &quot;/&quot; .. usertype(discriminator) .. &quot;, should be number.&quot;, 2)
+  end
+  if type(steps) ~= &quot;table&quot; then
+    error(&quot;lib.math.steps: Second argument is &quot; .. type(discriminator)
+        .. &quot;/&quot; .. usertype(discriminator) .. &quot;, should be table.&quot;, 2)
+  end
+  local result = 0
+  for _, height in ipairs(steps) do
+    if type(height) ~= &quot;number&quot; then
+      error(&quot;lib.math.steps: &quot; .. type(discriminator) .. &quot;/&quot; .. usertype(discriminator)
+          .. &quot; in table of second argument, should be number.&quot;, 2)
+    end
+    if discriminator &lt; height then
+      return result
+    else
+      result = result + 1
+    end
+  end
+  return result
+end
+
 ---------------------------------------------------------------------
 --  PERMUTATIONS  AND  RANDOM  NUMBERS
 ---------------------------------------------------------------------

Deleted: trunk/data/levels/lib/libsoko-designlist.xml
===================================================================
--- trunk/data/levels/lib/libsoko-designlist.xml	2009-03-14 23:58:47 UTC (rev 1590)
+++ trunk/data/levels/lib/libsoko-designlist.xml	2009-03-16 00:55:33 UTC (rev 1591)
@@ -1,731 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
-&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
-  &lt;el:protected&gt;
-    &lt;el:info el:type=&quot;library&quot;&gt;
-      &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libsoko-designlist&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;experimental&quot;/&gt;
-      &lt;el:author el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
-      &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
-      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
-      &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-      &lt;/el:compatibility&gt;
-      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
-      &lt;el:comments&gt;
-      &lt;/el:comments&gt;
-      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;-&quot;/&gt;
-    &lt;/el:info&gt;
-    &lt;el:luamain&gt;&lt;![CDATA[
-
--- This &quot;library&quot; is merely a collection of designs, outsourced from
--- libsoko.xml. Don't include this library with your levels (it won't
--- have any effect), but libsoko.xml.
-
-------------------------------------------------------------------------
--- Designs
-------------------------------------------------------------------------
-
--- This section holds a table with all default designs. Each design
--- is again a table consisting of the following entries:
---    wall, inf, outf, box, goal, oxyd, endp
--- Each of these entries is either a string representing the objects to
--- be used, or a table if several objects shall be used. Such a
--- combination of objects will be called &quot;element&quot;.
---
--- If object types (like floors) repeat in the table, they are used in
--- a checkerboard pattern. You can change this pattern by adding an
--- element of the form &quot;al:ALGORITHM&quot;, where ALGORITHM is one of the
--- algorithms listed below. Same for &quot;fr:1.23&quot; and &quot;ad:4.5&quot; for friction
--- and mouseforce. From all these attributes, only the last one will
--- be used, all others ignored. This contrasts with the situation of
--- the gaming objects (&quot;fl_&quot;, &quot;st_&quot;, &quot;it_&quot;), whose order doesn't matter.
---
--- &quot;oxyd&quot; only holds the oxyd's flavor, &quot;endp&quot; the way of resolving the
--- level from Sokoban to opening oxyds. Use &quot;st_nil&quot; and &quot;it_nil&quot; to
--- place spaces between stones/items.
---
--- The table might hold additional flags. Currently, only &quot;white&quot;
--- is implemented, which turns the marble and chess-knights white.
--- If an entry is missing, the corresponding entry from default_design
--- will be used.
---
--- Example:
---
---   [5] = { outf = &quot;fl-leaves&quot;, inf = &quot;fl-leavesb&quot;, box = &quot;st-wood&quot;
---           wall = {&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-leaves&quot;, &quot;al:random&quot;},
---           oxyd = &quot;a&quot;, white = true,
---           endp = {goal = {&quot;fl-abyss&quot;, &quot;it_nil&quot;}, give = &quot;it_hammer&quot;,
---                   alg = &quot;block:st-break_acwhite&quot;}}
---
---   will define design 5. The walls will alternate between
---   st-glass/fl-wood and st-glass/fl-leaves. The goal will be
---   it_trigger by default. The actor will be ac-whiteball.
---   The boxes will be &quot;st-wood&quot;. There will be oxyds visible
---   from the beginning, but they are blocked by st-break_acwhite.
---   When all goals are filled, the st-wood are removed by setting
---   fl-abyss (by which they become fl-stwood), the goal-item is
---   removed. The player is finally given an it_hammer.
---
--- Possible flags:
---
---   white  : Use white marble and st-chess_white.
---
--- Design-Algorithms:
---
---   checkerboard : default, up to 3 different floors in checkerboard pattern
---   lines : arbitrary number of floors in diagonal lines
---   waves : works best with 4 different floors
---   random : arbitrary number of floors, randomly chosen
---
--- Endphase-Algorithms and their parameters:
---
---   circle         : arrange eight oxyds in a circle (default)
---   hide           : position oxyds in the outer walls
---     gradients:X  : like hide, create gradients, with force X
---     magnets:X    : like hide, create magnets, with force X
---   fourswitch     : create a fourswitch-puzzle
---   ralf           : arrange oxyds with doors
---     vortex       : like ralf, create vortices between way-clusters
---     allcrack     : like ralf, create cracks everywhere
---     jumpyoxyds   : like ralf, oxyds are movable by knocking on the door (defunc)
---     knock        : like ralf, open doors on knocking on other doors
---   block:X        : create oxyds with blocking object X
---   outside:X      : create X oxyd-pairs in the outside and outer walls
-
-lib.soko.default_design = {
-  wall = { &quot;st-rock3&quot;, &quot;fl-leaves&quot; },
-   inf = { &quot;fl-wood&quot; },
-  outf = { &quot;fl-water&quot; },
-   box = { &quot;st-brownie&quot; },
-  goal = { &quot;it_trigger&quot; },
-  oxyd = &quot;a&quot;,
-  endp = { alg = &quot;circle&quot; },
-  outf_default_stone = &quot;st-invisible&quot;
-}
-
--- outf_default_stone has the following meaning: When outf is drawn
--- by set_element, but no stone is set, outf_default_stone is used
--- instead. You can suppress this behaviour by explicitly setting
--- outf = { &quot;fl-myfloor&quot;, &quot;st_nil&quot; }.
--- This is done to avoid a chess-stone from jumping into the void,
--- as a present to the gamer.
-
-lib.soko.design_list = {
-
--- endp-algs: circle, ralf, hide, outside, allcrack, block, fourswitch
---            vortex, gradients, magnets
-
--- Ralf's designs
-[1]={box=&quot;st-brownie&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-bluegray&quot;,
-     outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-     endp={goal=&quot;st_nil&quot;, alg=&quot;circle&quot;}},
-[2]={box=&quot;st-glass_move&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-bluegray&quot;,
-     outf=&quot;fl-water&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;a&quot;,
-     endp={goal=&quot;st-glass1_hole&quot;, alg=&quot;ralf&quot;}},
-[3]={box=&quot;st-wood-growing&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-bluegray&quot;,
-     outf=&quot;fl-abyss&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-     endp={goal={&quot;st_nil&quot;, &quot;fl-stwood&quot;, &quot;it_nil&quot;}, wall=&quot;st-thief&quot;, give=&quot;it_hammer&quot;,
-           alg=&quot;block:st-plain_cracked&quot;}},
-[4]={box=&quot;st-brownie&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-white&quot;,
-     outf=&quot;fl-sahara&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-     endp={goal=&quot;st_nil&quot;, wall={&quot;st_nil&quot;, &quot;fl-bluegray&quot;}, alg=&quot;outside&quot;}},
-[5]={box=&quot;st-wood&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-white&quot;,
-     outf=&quot;fl-space&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;c&quot;,
-     endp={goal={&quot;st_nil&quot;, &quot;fl-stwood&quot;, &quot;it_nil&quot;}, wall={&quot;st-bluegray_hole&quot;}, alg=&quot;outside:3&quot;}},
-[6]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-white&quot;,
-     outf=&quot;fl-space&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-     endp={goal=&quot;st-greenbrown_hole&quot;, wall=&quot;st-thief&quot;, give=&quot;it_sword&quot;,
-           alg=&quot;block:st_knight&quot;}},
-[7]={box=&quot;st-wood&quot;, wall=&quot;st-bluegray&quot;, inf=&quot;fl-white&quot;,
-     outf=&quot;fl-space&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;c&quot;,
-     endp={goal={&quot;st_nil&quot;, &quot;fl-stwood&quot;, &quot;it_nil&quot;}, alg=&quot;fourswitch&quot;}},
-
-[8]={box=&quot;st-rock3_move&quot;, wall=&quot;st_bluesand&quot;, inf=&quot;fl-light&quot;,
-     outf=&quot;fl-rough-blue&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;d&quot;,
-     endp={goal=&quot;st-rock3_break&quot;, give=&quot;it_hammer&quot;, alg=&quot;ralf&quot;}},
-[9]={box=&quot;st-block&quot;, wall=&quot;st_bluesand&quot;, inf=&quot;fl-light&quot;,
-     outf=&quot;fl-rough-blue&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;d&quot;,
-     endp={goal=&quot;st_nil&quot;, alg=&quot;circle&quot;}},
-[10]={box=&quot;st_shogun&quot;, wall=&quot;st_bluesand&quot;, inf=&quot;fl-rough&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_nil&quot;, alg=&quot;magnets&quot;}},
-[11]={box=&quot;st-marble_move&quot;, wall=&quot;st_bluesand&quot;, inf=&quot;fl-rough&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-marble&quot;, alg=&quot;vortex&quot;}},
-[12]={box=&quot;st_shogun&quot;, wall=&quot;st_bluesand&quot;, inf=&quot;fl-rough&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_nil&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-stone_break&quot;}},
-[13]={box=&quot;st-block&quot;, wall=&quot;st_bluesand&quot;, inf=&quot;fl-rough&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;b&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, alg=&quot;ralf&quot;}},
-
-[14]={box=&quot;st-brownie&quot;, wall={&quot;st-glass&quot;, &quot;fl-himalaya&quot;, &quot;fl-water&quot;},
-      inf=&quot;fl-himalaya&quot;, outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st_pull&quot;, alg=&quot;magnets&quot;}},
-[15]={box=&quot;st-brownie&quot;, wall={&quot;st-glass&quot;, &quot;fl-himalaya&quot;, &quot;fl-water&quot;},
-      inf=&quot;fl-himalaya&quot;, outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st_nil&quot;, alg=&quot;fourswitch&quot;}},
-[16]={box=&quot;st_shogun&quot;, wall={&quot;st-glass&quot;, &quot;fl-rough-red&quot;, &quot;fl-abyss&quot;},
-      inf=&quot;fl-rough-red&quot;, outf=&quot;fl-abyss&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-      goal=&quot;it_shogun_s&quot;,
-      endp={alg=&quot;circle&quot;}},
-[17]={box=&quot;st-brownie&quot;, wall={&quot;st-glass&quot;, &quot;fl-rough-red&quot;, &quot;fl-sahara&quot;},
-      inf=&quot;fl-rough-red&quot;, outf=&quot;fl-sahara&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-grate2&quot;, wall=&quot;st-grate2&quot;, alg=&quot;outside&quot;}},
-[18]={box=&quot;st-greenbrown_move&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-water&quot;},
-      inf=&quot;fl-wood&quot;, outf=&quot;fl-water&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-greenbrown_hole&quot;, alg=&quot;ralf&quot;}},
-[19]={box=&quot;st-block&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-abyss&quot;},
-      inf=&quot;fl-wood&quot;, outf=&quot;fl-abyss&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;d&quot;,
-      endp={goal={&quot;fl-abyss&quot;, &quot;it_nil&quot;}, alg=&quot;vortex&quot;}},
-[20]={box=&quot;st-wood-growing&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-abyss&quot;},
-      inf=&quot;fl-wood&quot;, outf=&quot;fl-abyss&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, alg=&quot;magnets&quot;}},
-[21]={box=&quot;st-wood&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-sahara&quot;},
-      inf=&quot;fl-wood&quot;, outf=&quot;fl-sahara&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;c&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, give=&quot;ac-bug&quot;, alg=&quot;block:st-bug&quot;}},
-[22]={box=&quot;st_shogun&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-leaves&quot;}, inf=&quot;fl-wood&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_nil&quot;, give=&quot;it_sword&quot;, alg=&quot;block:st_knight&quot;}},
-[23]={box=&quot;st-block&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-abyss&quot;},
-      inf=&quot;fl-wood&quot;, outf=&quot;fl-abyss&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;d&quot;,
-      endp={goal={&quot;st_nil&quot;, &quot;it_nil&quot;}, alg=&quot;allcrack:1&quot;}},
-[24]={box=&quot;st-brownie&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-sahara&quot;},
-      inf=&quot;fl-wood&quot;, outf=&quot;fl-sahara&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st_nil&quot;, give=&quot;ac-bug&quot;, alg=&quot;block:st-bug&quot;}},
-[25]={box=&quot;st-brownie&quot;, wall={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-leaves&quot;, &quot;it-cherry&quot;},
-      inf=&quot;fl-wood&quot;, outf=&quot;fl-leaves&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;st-glass&quot;, &quot;fl-wood&quot;, &quot;fl-leaves&quot;, &quot;it-cherry&quot;},
-            give=&quot;it-cherry&quot;, alg=&quot;outside&quot;}},
-
-[26]={box=&quot;st-brownie&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-acblack&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-grate1&quot;, alg=&quot;ralf&quot;}},
-[27]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-acblack&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-greenbrown_hole&quot;, alg=&quot;hide&quot;}},
-[28]={box=&quot;st-wood-growing&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-tigris&quot;,
-      outf=&quot;fl-sahara&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, alg=&quot;fourswitch&quot;}},
-[29]={box=&quot;st-brownie&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-tigris&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st_pull&quot;, give=&quot;it_sword&quot;, alg=&quot;block:st_knight&quot;}},
-[30]={box=&quot;st-wood-growing&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-tigris&quot;,
-      outf=&quot;fl-sahara&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;st_nil&quot;, &quot;fl-stwood&quot;, &quot;it_nil&quot;}, give=&quot;it_hammer&quot;, alg=&quot;block:st-stone_break&quot;}},
-[31]={box=&quot;st-glass_move&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-tigris&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;a&quot;,
-      endp={wall=&quot;st-grate1&quot;, give=&quot;it-cherry&quot;, alg=&quot;outside:3&quot;}},
-
-[32]={box=&quot;st-block&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-bluegray&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;d&quot;,
-      endp={goal={&quot;fl-abyss&quot;, &quot;it_nil&quot;}, alg=&quot;vortex&quot;}},
-[33]={box=&quot;st_shogun&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-bluegray&quot;,
-      outf=&quot;fl-rough-blue&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st-metal_hole&quot;, alg=&quot;magnets&quot;}},
-[34]={box=&quot;st_shogun&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-white&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_nil&quot;, alg=&quot;gradients&quot;}},
-[35]={box=&quot;st-block&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-white&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;b&quot;,
-      endp={box=&quot;fl-swamp&quot;, alg=&quot;ralf&quot;}},
-[36]={box=&quot;st_shogun&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-white&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={alg=&quot;circle&quot;}},
-
-[37]={box=&quot;st-wood-growing&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-light&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, wall=&quot;st-grate2&quot;, alg=&quot;outside&quot;}},
-[38]={box=&quot;st-glass_move&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-light&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;a&quot;,
-      endp={give=&quot;it-cherry&quot;, alg=&quot;ralf&quot;}},
-[39]={box=&quot;st-brownie&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-light&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-grate2&quot;, alg=&quot;fourswitch&quot;}},
-[40]={box=&quot;st-glass_move&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-light&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-glass1_hole&quot;, give=&quot;it_sword&quot;, alg=&quot;block:st_knight&quot;}},
-[41]={box=&quot;st-brownie&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-rough&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-      endp={goal={&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl-hay&quot;}, wall=&quot;st-rock1_hole&quot;,
-            alg=&quot;outside:3&quot;}},
-[42]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-rough&quot;,
-      outf=&quot;fl-sahara&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-greenbrown&quot;, alg=&quot;vortex&quot;}},
-
-[43]={box=&quot;st-brownie&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-rock3_hole&quot;, wall=&quot;st-rock3_hole&quot;, alg=&quot;outside:3&quot;}},
-[44]={box=&quot;st-marble_move&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-rough-blue&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;b&quot;,
-      endp={&quot;st-marble_hole&quot;, alg=&quot;ralf&quot;}},
-[45]={box=&quot;st-wood-growing&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, give=&quot;ac-bug&quot;, alg=&quot;block:st-bug&quot;}},
-[46]={box=&quot;st_shogun&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_nil&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-plain_cracked&quot;}},
-[47]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-sahara&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-greenbrown_hole&quot;, give=&quot;ac-bug&quot;, alg=&quot;block:st-bug&quot;}},
-[48]={box=&quot;st-glass_move&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;a&quot;,
-      endp={give=&quot;it-cherry&quot;, alg=&quot;ralf&quot;}},
-[49]={box=&quot;st-marble_move&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-rough-blue&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-marble_hole&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-plain_cracked&quot;}},
-[50]={box=&quot;st_shogun&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={alg=&quot;circle&quot;}},
-[51]={box=&quot;st-wood-growing&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;},
-            wall={&quot;st-plain_breaking&quot;, &quot;fl-sahara&quot;}, alg=&quot;outside&quot;}},
-[52]={box=&quot;st-wood&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;c&quot;,
-      endp={goal={&quot;st-grate1&quot;, &quot;it_nil&quot;}, alg=&quot;ralf&quot;}},
-[53]={box=&quot;st_shogun&quot;, wall=&quot;st-rock3&quot;, inf=&quot;fl-leaves&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;d&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal={&quot;st_nil&quot;, &quot;fl-swamp&quot;}, alg=&quot;fourswitch&quot;}},
-
-[54]={box=&quot;st_shogun&quot;, wall=&quot;st-rock4&quot;, inf=&quot;fl-himalaya&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={alg=&quot;vortex&quot;}},
-[55]={box=&quot;st-marble_move&quot;, wall=&quot;st-rock4&quot;, inf=&quot;fl-himalaya&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-marble_hole&quot;, alg=&quot;ralf&quot;}},
-[56]={box=&quot;st_shogun&quot;, wall=&quot;st-rock4&quot;, inf=&quot;fl-himalaya&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={alg=&quot;circle&quot;}},
-[57]={box=&quot;st-block&quot;, wall=&quot;st-rock4&quot;, inf=&quot;fl-rough-red&quot;,
-      outf=&quot;fl-rough-blue&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;d&quot;,
-      endp={goal=&quot;st-explosion&quot;, wall=&quot;st-explosion&quot;, alg=&quot;outside&quot;}},
-[58]={box=&quot;st-rock3_move&quot;, wall=&quot;st-rock4&quot;, inf=&quot;fl-rough-red&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;d&quot;,
-      endp={goal=&quot;st-plain_cracked&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-plain_cracked&quot;}},
-[59]={box=&quot;st_shogun&quot;, wall=&quot;st-rock4&quot;, inf=&quot;fl-rough-red&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_nil&quot;, alg=&quot;ralf&quot;}},
-[60]={box=&quot;st-rock3_move&quot;, wall=&quot;st-rock4&quot;, inf=&quot;fl-rough-red&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;d&quot;,
-      endp={goal=&quot;st-bug&quot;, give=&quot;ac-bug&quot;, alg=&quot;block:st-bug&quot;}},
-
-[61]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-greenbrown_hole&quot;, alg=&quot;fourswitch&quot;}},
-[62]={box=&quot;st-block&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;b&quot;,
-      endp={goal={&quot;fl-water&quot;, &quot;it_nil&quot;}, alg=&quot;vortex&quot;}},
-[63]={box=&quot;st-rock3_move&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;d&quot;,
-      endp={goal=&quot;st-plain_cracked&quot;, give=&quot;it_hammer&quot;,
-            alg=&quot;block:st-plain_cracked&quot;}},
-[64]={box=&quot;st-marble_move&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-marble_hole&quot;, alg=&quot;gradients&quot;}},
-[65]={box=&quot;st-wood-growing&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;st_nil&quot;, &quot;fl-stwood&quot;, &quot;it_nil&quot;}, alg=&quot;ralf&quot;}},
-[66]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-greenbrown&quot;, alg=&quot;vortex&quot;}},
-[67]={box=&quot;st-block&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;b&quot;,
-      endp={alg=&quot;circle&quot;}},
-[68]={box=&quot;st-brownie&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st_nil&quot;, alg=&quot;allcrack:1&quot;}},
-[69]={box=&quot;st-block&quot;, wall=&quot;st-rock5&quot;, inf=&quot;fl-samba&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;d&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, alg=&quot;ralf&quot;}},
-
-[70]={box=&quot;st-rock3_move&quot;, wall=&quot;st-rock6&quot;, inf=&quot;fl-acblack&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_b&quot;, oxyd=&quot;d&quot;,
-      endp={goal=&quot;st-plain_breaking&quot;, alg=&quot;ralf&quot;}},
-[71]={box=&quot;st_shogun&quot;, wall=&quot;st-rock6&quot;, inf=&quot;fl-acblack&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st-explosion&quot;, wall=&quot;st-explosion&quot;, alg=&quot;outside&quot;}},
-[72]={box=&quot;st-block&quot;, wall=&quot;st-rock6&quot;, inf=&quot;fl-acblack&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;d&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, alg=&quot;magnets&quot;}},
-[73]={box=&quot;st_shogun&quot;, wall=&quot;st-rock6&quot;, inf=&quot;fl-acblack&quot;,
-      outf=&quot;fl-leaves&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_knight&quot;, give=&quot;it_sword&quot;, alg=&quot;block:st_knight&quot;}},
-[74]={box=&quot;st_shogun&quot;, wall=&quot;st-rock6&quot;, inf=&quot;fl-tigris&quot;,
-      outf=&quot;fl-rough-blue&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st_nil&quot;, alg=&quot;fourswitch&quot;}},
-[75]={box=&quot;st_shogun&quot;, wall=&quot;st-rock6&quot;, inf=&quot;fl-tigris&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, goal=&quot;it_shogun_s&quot;,
-      endp={goal=&quot;st-explosion&quot;, alg=&quot;gradients&quot;}},
-
--- New designs
-[76]={box=&quot;st-glass1_move&quot;, wall=&quot;st-glass2&quot;, inf=&quot;fl-lightgray&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st_pull&quot;, alg=&quot;hide&quot;}},
-[77]={box=&quot;st-rock3_move&quot;, wall=&quot;st_brick&quot;, inf=&quot;fl-darkgray&quot;,
-      outf=&quot;fl-leavesb&quot;, door=&quot;st_door_d&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-plain_cracked&quot;, give=&quot;it_hammer&quot;, alg=&quot;knock&quot;}},
-[78]={box=&quot;st-rock3_move&quot;, wall=&quot;st-bumps&quot;, inf=&quot;fl-dunes&quot;,
-      outf=&quot;fl-sand&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-plain_break&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-plain_cracked&quot;}},
-[79]={box=&quot;st-flrock&quot;, wall=&quot;st-camouflage&quot;, inf=&quot;fl-gravel&quot;,
-      outf={&quot;fl-gravel&quot;, &quot;st_disco_medium&quot;}, door=&quot;st-camouflage&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-camouflage&quot;, open_door={&quot;st_nil&quot;, &quot;fl-leavesb&quot;}, alg=&quot;vortex&quot;}},
-[80]={box=&quot;st-flhay&quot;, wall=&quot;st-camouflage&quot;, inf=&quot;fl-leaves&quot;,
-      outf={&quot;fl-water:5&quot;, &quot;fl-swamp&quot;, &quot;al:random&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;},
-            wall={&quot;st-camouflage_hole&quot;, &quot;st_nil:2&quot;, &quot;fl-swamp&quot;, &quot;al:random&quot;},
-            give=&quot;it_umbrella&quot;, alg=&quot;outside:1&quot;}},
-[81]={box=&quot;st-glass2_move&quot;, wall={&quot;st-glass1&quot;, &quot;fl-lightgray&quot;}, inf=&quot;fl-black&quot;,
-      outf=&quot;fl-white&quot;, door=&quot;st-black4&quot;, oxyd=&quot;c&quot;, white=true,
-      endp={goal=&quot;st-yinyang2&quot;, open_door=&quot;st-white4&quot;, alg=&quot;ralf&quot;}},
-[82]={box=&quot;st-wood&quot;, wall={&quot;st-glass1&quot;, &quot;fl-water&quot;}, inf=&quot;fl-sand&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-      endp={goal={&quot;st_nil&quot;, &quot;fl-stwood&quot;, &quot;it_nil&quot;}, alg=&quot;fourswitch&quot;}},
-[83]={box=&quot;st-camouflage_move&quot;, wall=&quot;st-glass2&quot;, inf=&quot;fl-lightgray&quot;,
-      outf={&quot;fl-leavesb&quot;, &quot;st_disco_medium&quot;}, door=&quot;st-glass2&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-camouflage_hole&quot;, open_door=&quot;st-glass1_hole&quot;,
-            outf=&quot;st_nil&quot;, alg=&quot;ralf&quot;}},
-[84]={box=&quot;st-flrock&quot;, wall=&quot;st-glass2&quot;, inf=&quot;fl-sand&quot;,
-      outf={&quot;fl-water&quot;, &quot;st_disco_medium&quot;}, door=&quot;st_door_d&quot;, oxyd=&quot;b&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, alg=&quot;knock&quot;}},
-[85]={box=&quot;st-flrock&quot;, wall=&quot;st_brick&quot;, inf=&quot;fl-sand&quot;,
-      outf={&quot;fl-water&quot;, &quot;st_disco_medium&quot;}, door=&quot;st_door_d&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-black4&quot;, alg=&quot;ralf&quot;}},
-[86]={box=&quot;st-glass1_move&quot;, wall={&quot;st-glass3&quot;, &quot;fl-abyss_fake&quot;}, inf=&quot;fl-red&quot;,
-      outf=&quot;fl-space&quot;, door={&quot;st_nil&quot;, &quot;fire&quot;}, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-explosion&quot;, open_door=&quot;nofire&quot;, alg=&quot;ralf&quot;}},
-[87]={box=&quot;st-rock3_move&quot;, wall={&quot;st-glass3&quot;, &quot;fl-rough-blue&quot;}, inf=&quot;fl-plank&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st-glass3&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-rock7&quot;, open_door=&quot;st-glass1_hole&quot;, alg=&quot;vortex&quot;}},
-[88]={box=&quot;st-glass1_move&quot;, wall=&quot;st-likeoxyda&quot;, inf=&quot;fl-black&quot;,
-      outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-glass1_hole&quot;, alg=&quot;hide&quot;}},
-[89]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-likeoxyda-open&quot;, inf=&quot;fl-brick&quot;,
-      outf={&quot;fl-mortar&quot;, &quot;st_disco_medium&quot;}, door=&quot;st_door_d&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-grate2&quot;, alg=&quot;knock&quot;}},
-[90]={box=&quot;st-rock3_move&quot;, wall=&quot;st-likeoxydb&quot;, inf=&quot;fl-rough-red&quot;,
-      outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-plain_breaking&quot;, alg=&quot;hide&quot;}},
-[91]={box=&quot;st-flhay&quot;, wall=&quot;st-likeoxydb-open&quot;, inf=&quot;fl-rough-blue&quot;,
-      outf={&quot;fl-swamp&quot;, &quot;st_disco_light&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-break_gray&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-break_gray&quot;}},
-[92]={box=&quot;st-glass2_move&quot;, wall=&quot;st-likeoxydc&quot;, inf=&quot;fl-sahara&quot;,
-      outf={&quot;fl-water&quot;, &quot;st_disco_light&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-glass1_hole&quot;, alg=&quot;hide&quot;}},
-[93]={box=&quot;st-glass_move&quot;, wall=&quot;st-likeoxydc-open&quot;, inf=&quot;fl-red&quot;,
-      outf={&quot;st-blackballs&quot;, &quot;st-whiteballs&quot;, &quot;fl-abyss&quot;, &quot;al:random&quot;},
-      door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-      endp={goal=&quot;st-black4&quot;, alg=&quot;fourswitch&quot;}},
-[94]={box=&quot;st-glass2_move&quot;, wall=&quot;st-likeoxydd&quot;, inf=&quot;fl-concrete&quot;,
-      outf=&quot;fl-sand&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-      endp={goal=&quot;st-glass1_hole&quot;, alg=&quot;hide&quot;}},
-[95]={box=&quot;st-flrock&quot;, wall=&quot;st-likeoxydd-open&quot;, inf=&quot;fl-marble&quot;,
-      outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-      endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, outf=&quot;fl-swamp&quot;,
-            give=&quot;it_hammer&quot;, wall=&quot;st-break_gray&quot;, alg=&quot;outside&quot;}},
-[96]={box=&quot;st-flrock&quot;, wall=&quot;st-marble&quot;, inf=&quot;fl-marble&quot;,
-      outf={&quot;fl-leavesc3&quot;, &quot;fl-leavesd3&quot;}, door=&quot;st_door_d&quot;, oxyd=&quot;a&quot;,
-      endp={goal={&quot;st-grate2&quot;, &quot;it_nil&quot;}, alg=&quot;knock&quot;}},
-[97]={box=&quot;st-camouflage_move&quot;, wall=&quot;st-marble&quot;, inf=&quot;fl-leaves&quot;,
-      outf={&quot;fl-leaves&quot;, &quot;st-marble&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-      endp={goal=&quot;st-camouflage_hole&quot;, wall=&quot;st-marble_hole&quot;,
-            outf=&quot;st-marble_hole&quot;, alg=&quot;outside&quot;}},
-[98]={box=&quot;st-rock1_move&quot;, wall=&quot;st-redrock&quot;, inf=&quot;fl-acblack&quot;,
-      outf={&quot;fl-acblack&quot;, &quot;st-redrock&quot;}, door=&quot;st-rock6&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-rock6&quot;, open_door=&quot;st_nil&quot;, alg=&quot;vortex&quot;}},
-[99]={box=&quot;st-glass1_move&quot;, wall=&quot;st-redrock&quot;, inf=&quot;fl-mortar&quot;,
-      outf=&quot;fl-brick&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-      endp={goal=&quot;st-glass1_hole&quot;, wall={&quot;st-glass1_hole&quot;, &quot;fl-tigris&quot;}, alg=&quot;outside&quot;}},
-[100]={box=&quot;st-block&quot;, wall=&quot;st-redrock&quot;, inf=&quot;fl-mortar&quot;,
-       outf=&quot;fl-water&quot;, door=&quot;st_door_d&quot;, oxyd=&quot;b&quot;,
-       endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, alg=&quot;ralf&quot;}},
-[101]={box=&quot;st-glass2_move&quot;, wall=&quot;st-redrock&quot;, inf=&quot;fl-leavesb&quot;,
-       outf={&quot;fl-leavesc3&quot;, &quot;fl-leavesd4&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st-glass1_hole&quot;, alg=&quot;hide&quot;}},
-[102]={box=&quot;st-camouflage_move&quot;, wall=&quot;st-rock2&quot;, inf=&quot;fl-rock&quot;,
-       outf={&quot;fl-rock&quot;, &quot;st_disco_medium&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-       endp={goal={&quot;it_nil&quot;, &quot;st_disco_light&quot;, &quot;fl-leavesb&quot;},
-             wall={&quot;st_disco_light&quot;, &quot;fl-gray&quot;}, alg=&quot;outside:3&quot;}},
-[103]={box=&quot;st-glass2_move&quot;, wall=&quot;st-rock2&quot;, inf=&quot;fl-stone&quot;,
-       outf={&quot;fl-water&quot;, &quot;st_disco_medium&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-       endp={goal={&quot;st_pull&quot;, &quot;it_nil&quot;, &quot;fl-black&quot;}, alg=&quot;fourswitch&quot;}},
-[104]={box=&quot;st-wood&quot;, wall=&quot;st-rock2&quot;, inf=&quot;fl-lightgray&quot;,
-       outf=&quot;fl-space&quot;, door=&quot;st_door_d&quot;, oxyd=&quot;b&quot;,
-       endp={goal={&quot;st_nil&quot;, &quot;fl-marble&quot;, &quot;it_nil&quot;}, alg=&quot;knock&quot;}},
-[105]={box=&quot;st-camouflage_move&quot;, wall=&quot;st-rock7&quot;, inf=&quot;fl-woven&quot;,
-       outf=&quot;fl-gravel&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal={&quot;fl-bluegreenx&quot;, &quot;it_nil&quot;, &quot;st_nil&quot;}, alg=&quot;magnets&quot;}},
-[106]={box=&quot;st-brownie&quot;, wall=&quot;st-rock7&quot;, inf=&quot;fl-black&quot;,
-       outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-       endp={goal=&quot;st-bug&quot;, give={&quot;ac-bug&quot;, &quot;it_hammer&quot;}, alg=&quot;block:st-plain_cracked&quot;}},
-[107]={box=&quot;st-glass_move&quot;, wall=&quot;st-rock8&quot;, inf=&quot;fl-plank&quot;,
-       outf={&quot;fl-plank&quot;, &quot;st-rock8&quot;}, door=&quot;st_door_d&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st-explosion&quot;, alg=&quot;knock&quot;}},
-[108]={box=&quot;st-glass2_move&quot;, wall={&quot;st-rock8&quot;, &quot;fl-water&quot;}, inf=&quot;fl-leaves&quot;,
-       outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-       endp={goal=&quot;st_pull&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-break_gray&quot;}},
-[109]={box=&quot;st-marble_move&quot;, wall={&quot;st-rock8&quot;, &quot;fl-abyss_fake&quot;}, inf=&quot;fl-stone&quot;,
-       outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-       endp={goal={&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl-hay&quot;}, wall={&quot;st_nil&quot;, &quot;fl-darkgray&quot;},
-             alg=&quot;outside:3&quot;}},
-[110]={box=&quot;st-greenbrown_move&quot;, wall=&quot;st-rock9&quot;, inf=&quot;fl-rock&quot;,
-       outf={&quot;fl-rock&quot;, &quot;st-rock9&quot;}, door=&quot;st-rock9&quot;, oxyd=&quot;b&quot;,
-       endp={goal=&quot;st-rock9&quot;, open_door=&quot;st_nil&quot;, alg=&quot;vortex&quot;}},
-[111]={box=&quot;st-glass_move&quot;, wall=&quot;st-rock9&quot;, inf=&quot;fl-sand&quot;,
-       outf=&quot;fl-water&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;c&quot;,
-       endp={goal=&quot;st-grate2&quot;, alg=&quot;ralf&quot;}},
-[112]={box=&quot;st-camouflage_move&quot;, wall=&quot;st-rock9&quot;, inf=&quot;fl-stone&quot;,
-       outf=&quot;fl-swamp&quot;, door=&quot;st_door_d&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st-camouflage_hole&quot;, alg=&quot;knock&quot;}},
-[113]={box=&quot;st-block&quot;, wall=&quot;st-rock10&quot;, inf=&quot;fl-bluegreen&quot;,
-       outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal={&quot;st-explosion&quot;, &quot;it_nil&quot;, &quot;fl-bluegreenx&quot;},
-             wall={&quot;st-explosion&quot;, &quot;fl-marble&quot;}, give=&quot;it_umbrella&quot;, alg=&quot;outside:1&quot;}},
-[114]={box=&quot;st-wood&quot;, wall=&quot;st-rock10&quot;, inf=&quot;fl-sand&quot;,
-       outf={&quot;fl-sand&quot;, &quot;st-rock10&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-       endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, give=&quot;it_sword&quot;, alg=&quot;block:st_knight&quot;}},
-[115]={box=&quot;st-glass2_move&quot;, wall=&quot;st-stone1&quot;, inf={&quot;fl-lightgray&quot;, &quot;fl-white&quot;},
-       outf={&quot;fl-space&quot;, &quot;fl-abyss&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st-glass1_hole&quot;, wall=&quot;st-grate1&quot;, give=&quot;it_umbrella&quot;,
-             open_door=&quot;st-grate1&quot;, alg=&quot;block:st-stone1&quot;}},
-[116]={box=&quot;st-rock1_move&quot;, wall=&quot;st-stone1&quot;, inf=&quot;fl-stwood&quot;,
-       outf=&quot;fl-water&quot;, door=&quot;st-stone1&quot;, oxyd=&quot;b&quot;,
-       endp={goal=&quot;st-rock1_hole&quot;, open_door=&quot;st-grate1&quot;, alg=&quot;ralf&quot;}},
-[117]={box=&quot;st-glass_move&quot;, wall=&quot;st-stone1&quot;, inf=&quot;fl-black&quot;,
-       outf=&quot;st-stone1&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={outf=&quot;st-likeoxydd&quot;, wall=&quot;st-likeoxydd&quot;, inf=&quot;fl-ice&quot;,
-             goal={&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl-ice&quot;}, alg=&quot;hide:1&quot;}},
-[118]={box=&quot;st-glass_move&quot;, wall=&quot;st-stone2&quot;, inf=&quot;fl-black&quot;,
-       outf=&quot;fl-gravel&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;,
-       endp={goal=&quot;st-glass&quot;, alg=&quot;vortex&quot;}},
-[119]={box=&quot;st-block&quot;, wall=&quot;st-stone2&quot;, inf=&quot;fl-rough-red&quot;,
-       outf={&quot;fl-rough-blue&quot;, &quot;st_disco_light&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st_nil&quot;, alg=&quot;allcrack:1&quot;}},
-[120]={box=&quot;st-rock3_move&quot;, wall={&quot;st-marble&quot;, &quot;st-stone2&quot;}, inf=&quot;fl-black&quot;,
-       outf={&quot;st-marble&quot;, &quot;st-stone2&quot;}, oxyd=&quot;b&quot;,
-       endp={goal=&quot;st-plain_cracked&quot;, give=&quot;it_hammer&quot;, open_door=&quot;st_nil&quot;,
-             alg=&quot;ralf&quot;}},
-[121]={box=&quot;st-wood&quot;, wall=&quot;st-panel&quot;, inf=&quot;fl-wood&quot;,
-       outf={&quot;fl-leavesd3&quot;, &quot;fl-leavesd2&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal={&quot;it_nil&quot;, &quot;fl-swamp&quot;}, open_door=&quot;fl-swamp&quot;, alg=&quot;block:st-wood&quot;}},
-[122]={box=&quot;st-block&quot;, wall=&quot;st-panel&quot;, inf=&quot;fl-leaves&quot;,
-       outf=&quot;fl-leavesb&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal={&quot;it_nil&quot;, &quot;fl-swamp&quot;}, alg=&quot;fourswitch&quot;}},
-[123]={box=&quot;st-glass1_move&quot;, wall=&quot;st-woven&quot;, inf=&quot;fl-dunes&quot;,
-       outf=&quot;fl-bluegreen&quot;, door=&quot;st-glass1&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st_pull&quot;, open_door=&quot;st_pull&quot;, alg=&quot;ralf&quot;}},
-[124]={box=&quot;st-marble_move&quot;, wall=&quot;st-woven&quot;, inf=&quot;fl-hay&quot;,
-       outf=&quot;fl-water&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st-marble_hole&quot;, wall={&quot;st_nil&quot;, &quot;fl-woven&quot;},
-       give=&quot;it_umbrella&quot;, alg=&quot;outside:1&quot;}},
-[125]={box=&quot;st-rock3_move&quot;, wall=&quot;st-yellow&quot;, inf=&quot;fl-leavesb&quot;,
-       outf=&quot;fl-leaves&quot;, door=&quot;st_door_c&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st-grate2&quot;, alg=&quot;ralf&quot;}},
-[126]={box=&quot;st-glass_move&quot;, wall=&quot;st-yellow&quot;, inf=&quot;fl-rough-blue&quot;,
-       outf=&quot;fl-abyss&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal={&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl-ice&quot;}, give=&quot;ac-bug&quot;, alg=&quot;block:st-bug&quot;}},
-[127]={box=&quot;st-block&quot;, wall=&quot;st-yellow&quot;, inf=&quot;fl-lightgray&quot;,
-       outf=&quot;fl-space&quot;, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal={&quot;fl-abyss&quot;, &quot;it_nil&quot;}, alg=&quot;vortex&quot;}},
-[128]={box=&quot;st-glass1_move&quot;, wall=&quot;st-rock7&quot;, inf=&quot;fl-himalaya&quot;,
-       outf={&quot;fl-himalaya&quot;, &quot;st-rock8&quot;, &quot;st-rock7&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st-explosion&quot;, alg=&quot;magnets&quot;}},
-[129]={box=&quot;st-camouflage_move&quot;, wall={&quot;st-rock9&quot;, &quot;fl-leavesb&quot;}, inf=&quot;fl-dunes&quot;,
-       outf={&quot;fl-leavese1&quot;, &quot;fl-leavese2&quot;, &quot;fl-leavese3&quot;, &quot;fl-leavese4&quot;, &quot;al:waves&quot;},
-       door={&quot;fl_bridge_bw&quot;, &quot;fl_bridge_bn&quot;, &quot;al:random&quot;, &quot;st_nil&quot;}, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st-camouflage_hole&quot;, alg=&quot;ralf&quot;}},
-[130]={box=&quot;st-glass1_move&quot;, wall=&quot;st-redrock&quot;, inf=&quot;fl-darkgray&quot;,
-       outf={&quot;fl-black&quot;, &quot;st-redrock&quot;, &quot;st-invisible:3&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st_nil&quot;, alg=&quot;gradients&quot;}},
-[131]={box=&quot;st-glass1_move&quot;, wall={&quot;st-yellow&quot;, &quot;st-yellow&quot;, &quot;st-redrock&quot;, &quot;st-redrock&quot;, &quot;al:waves&quot;},
-       inf=&quot;fl-wood&quot;,
-       outf={&quot;fl-wood&quot;, &quot;st-yellow&quot;, &quot;st-yellow&quot;, &quot;st-redrock&quot;, &quot;st-redrock&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal={&quot;st-glass1_hole&quot;}, give=&quot;it_hammer&quot;, alg=&quot;block:st-plain_break&quot;}},
-[132]={box=&quot;st-wood&quot;, wall=&quot;st-camouflage&quot;, inf=&quot;fl-leavesb&quot;, oxyd=&quot;d&quot;,
-       outf={&quot;fl-water:3&quot;, &quot;fl-swamp&quot;,&quot;al:random&quot;}, door={&quot;fl-water&quot;, &quot;st-glass1_hole&quot;},
-       endp={goal={&quot;fl-swamp&quot;, &quot;it_nil&quot;}, inf={&quot;fl-leavesb&quot;, &quot;fl-swamp&quot;, &quot;al:random&quot;},
-             open_door=&quot;fl-swamp&quot;, alg=&quot;ralf&quot;}},
-[133]={box=&quot;st-glass2_move&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-metal&quot;,
-       outf={&quot;fl-space&quot;, &quot;fl-abyss:3&quot;, &quot;al:random&quot;}, door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st-glass1_hole&quot;, give=&quot;it_sword&quot;, alg=&quot;block:st_knight&quot;}},
-[134]={box=&quot;st-marble_move&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-white&quot;,
-       outf={&quot;fl-abyss&quot;, &quot;st-grate1&quot;, &quot;st-invisible:3&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st-marble_hole&quot;, alg=&quot;fourswitch&quot;}},
-[135]={box=&quot;st-glass_move&quot;, wall=&quot;st-likeoxydc&quot;, inf=&quot;fl-white&quot;,
-       outf={&quot;fl-white&quot;, &quot;st-rock1&quot;, &quot;st-invisible:3&quot;, &quot;al:random&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;c&quot;,
-       endp={goal={&quot;st-glass1_hole&quot;, &quot;it_nil&quot;}, alg=&quot;hide&quot;}},
-[136]={box=&quot;st-block&quot;, wall={&quot;st_oneway_white_n&quot;, &quot;st_oneway_white_s&quot;, &quot;st_oneway_white_e&quot;, &quot;st_oneway_white_w&quot;, &quot;al:random&quot;},
-       inf=&quot;fl-rough&quot;, oxyd=&quot;b&quot;,
-       outf={&quot;st_oneway_white_n&quot;, &quot;st_oneway_white_s&quot;, &quot;st_oneway_white_e&quot;, &quot;st_oneway_white_w&quot;, &quot;al:random&quot;},
-       endp={alg=&quot;circle&quot;}},
-[137]={box={&quot;st_mirror_slab_nm&quot;, &quot;st_mirror_slab_em&quot;, &quot;st_mirror_slab_sm&quot;, &quot;st_mirror_slab_wm&quot;, &quot;al:random&quot;},
-       wall={&quot;st-glass3&quot;, &quot;fl-abyss&quot;}, inf=&quot;fl-metal&quot;, oxyd=&quot;b&quot;,
-       outf={&quot;st_mirror_slab_n&quot;, &quot;st_mirror_slab_e&quot;, &quot;st_mirror_slab_s&quot;, &quot;st_mirror_slab_w&quot;, &quot;al:random&quot;},
-       door=&quot;st-glass3&quot;,
-       endp={goal={&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl-darkgray&quot;},
-             open_door=&quot;st-glass1_hole&quot;, alg=&quot;ralf&quot;}},
-[138]={box=&quot;st_shogun_s&quot;, wall=&quot;st-panel&quot;, inf=&quot;fl-stwood&quot;, goal=&quot;it_shogun_s&quot;,
-       outf=&quot;fl-water&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st_nil&quot;, alg=&quot;ralf&quot;, open_door=&quot;st_nil&quot;}},
-[139]={box=&quot;st_shogun_s&quot;, wall=&quot;st_blocker&quot;, inf=&quot;fl-black&quot;,
-       outf={&quot;st-white1&quot;, &quot;st-black1&quot;, &quot;fl-springboard&quot;, &quot;fl-abyss_fake&quot;},
-       door=&quot;st_blocker&quot;, oxyd=&quot;b&quot;,
-       endp={goal={&quot;st_nil&quot;, &quot;it_nil&quot;}, inf={&quot;fl-springboard&quot;, &quot;fl-abyss_fake&quot;},
-             alg=&quot;ralf&quot;}},
-[140]={box=&quot;st-brownie&quot;, wall={&quot;st-stone1&quot;, &quot;fl-leavesb&quot;}, inf={&quot;fl-floor_001&quot;, &quot;fr:3.0&quot;},
-       outf={&quot;fl-leavese4&quot;, &quot;fl-leavese2&quot;, &quot;fl-leavese1&quot;, &quot;fl-leavese3&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal={&quot;st-grate1&quot;, &quot;it_nil&quot;}, alg=&quot;fourswitch&quot;}},
-[141]={box=&quot;st-brownie&quot;, wall={&quot;st-rock4&quot;, &quot;fl-leavesb&quot;}, inf={&quot;fl-bluegreenx&quot;, &quot;ad:1.0&quot;, &quot;fr:3.0&quot;},
-       outf={&quot;fl-water&quot;, &quot;st-rock10&quot;, &quot;st-invisible:3&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st_nil&quot;, give=&quot;it_sword&quot;, alg=&quot;block:st_knight&quot;}},
-[142]={box=&quot;st-glass2_move&quot;, wall={&quot;st-glass1&quot;, &quot;fl-leavesb&quot;}, inf=&quot;fl-leavesb&quot;,
-       outf={&quot;fl-leavesc4&quot;, &quot;fl-leavesd2&quot;, &quot;fl-leavesc2&quot;, &quot;fl-leavese3&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st-glass1_hole&quot;, alg=&quot;hide&quot;}},
-[143]={box=&quot;st-block&quot;, wall={&quot;st-rock5&quot;, &quot;fl-stwood&quot;}, inf=&quot;fl-wood&quot;,
-       outf={&quot;st_disco_light&quot;, &quot;fl-wood1:3&quot;, &quot;fl-wood2&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal={&quot;fl-abyss&quot;, &quot;it_nil&quot;}, alg=&quot;vortex&quot;}},
-[144]={box=&quot;st-wood&quot;, wall=&quot;st-rock6&quot;, inf=&quot;fl-bluegreen&quot;,
-       outf={&quot;fl-space&quot;, &quot;it-squashed&quot;, &quot;it_nil:3&quot;, &quot;al:random&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;d&quot;,
-       endp={goal=&quot;st-glass2_hole&quot;, wall=&quot;st-glass1_hole&quot;, alg=&quot;outside:3&quot;}},
-[145]={box=&quot;st-glass1_move&quot;, wall={&quot;st-greenbrown&quot;, &quot;fl-sand&quot;}, inf=&quot;fl-dunes&quot;,
-       outf={&quot;fl-sand&quot;, &quot;it_landmine:3&quot;, &quot;it-booze-broken&quot;, &quot;it_nil:15&quot;, &quot;al:random&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st-glass1_hole&quot;, alg=&quot;allcrack:1&quot;}},
-[146]={box=&quot;st-wood&quot;, wall=&quot;st-rock1&quot;, inf=&quot;fl-black&quot;,
-       outf={&quot;fl-abyss&quot;, &quot;st-grate1&quot;, &quot;st_nil:10&quot;, &quot;al:random&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;b&quot;, white = true,
-       endp={goal={&quot;st-grate1&quot;, &quot;it_nil&quot;}, alg=&quot;magnets&quot;}},
-[147]={box=&quot;st-wood&quot;, wall=&quot;st-whiteballs&quot;, inf=&quot;fl-gray&quot;, white = true,
-       outf={&quot;fl-gradient5&quot;, &quot;fl-gradient6&quot;, &quot;fl-gradient7&quot;, &quot;fl-gradient8&quot;, &quot;al:waves&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal={&quot;st_nil&quot;, &quot;it_nil&quot;}, alg=&quot;gradients&quot;}},
-[148]={box=&quot;st_shogun_s&quot;, wall=&quot;st-metal&quot;, inf=&quot;fl-rough-blue&quot;, white = true,
-       outf={&quot;fl-rough-red&quot;, &quot;fl-rough-blue&quot;, &quot;st_disco_light&quot;},
-       door=&quot;st_door_a&quot;, oxyd=&quot;a&quot;,
-       endp={goal=&quot;st-break_acblack&quot;, give=&quot;it_hammer&quot;, alg=&quot;block:st-break_acblack&quot;}},
-[149]={box=&quot;st_shogun_s&quot;, wall=&quot;st-yellow&quot;, inf=&quot;fl-samba&quot;,
-       outf=&quot;fl-swamp&quot;, door=&quot;st_door_a&quot;,
-       oxyd=&quot;c&quot;, goal=&quot;it_shogun_s&quot;, white = true,
-       endp={goal=&quot;st-explosion&quot;, wall={&quot;st-explosion&quot;, &quot;fl-tigris&quot;}, alg=&quot;outside&quot;}},
-
-[150]={box=&quot;st-flrock&quot;, wall=&quot;st-redrock&quot;, inf=&quot;fl-brick&quot;,
-       outf=&quot;fl-space&quot;, door=&quot;st_blocker&quot;, oxyd=&quot;a&quot;, white=true,
-       endp={goal={&quot;st_nil&quot;, &quot;fl-rock&quot;, &quot;it_nil&quot;}, alg=&quot;ralf&quot;}},
-}
-
--- endp-algs: circle, ralf, hide, outside, allcrack, block, fourswitch
---            vortex, gradients, magnets
-
-
--- The 75 first designs use the following boxes:
---  st-block  -&gt;  st-black, st_blocker, st-brake, st-laser, fl-swamp
---  st-brownie  -&gt;  st-coinslot, st_pull
---  st-glass_move  -&gt;  cherry
---  st-greenbrown_move  -&gt;  hole
---  st-marble_move  -&gt;  hole
---  st-rock3_move  -&gt;  *
---  st_shogun  -&gt;  st_shogun-m (not completely!)
---  st-wood[-growing]  -&gt;  fl-swamp
-
--- Next follows a table to convert the codes Ralf used in his levels
--- and ralf_sokoban to libsoko-designs. Note that there is a shift
--- by -1 of the ralfcode in his library, except for design 0.
--- Hence, when you start an old sokoban level with
---   play_sokoban(level,715)
--- then ralf_sokoban.init is called with argument 714, which corresponds
--- to libsoko-design 4. Use
---   create_sokoban(..., ..., ralfcode_conversion_table[715])
--- to activate it.
---
-lib.soko.ralfcode_conversion_table = {
-     [0]   = 1,
-   [714+1] = 4,
-   [715+1] = 70,
-   [716+1] = 37,
-   [718+1] = 18,
-   [719+1] = 57,
-   [720+1] = 43,
-   [764+1] = 28,
-   [765+1] = 10,
-   [766+1] = 61,
-   [767+1] = 19,
-   [768+1] = 14,
-   [769+1] = 44,
-   [770+1] = 5,
-   [771+1] = 71,
-   [772+1] = 38,
-   [773+1] = 62,
-   [775+1] = 58,
-   [776+1] = 45,
-   [777+1] = 34,
-   [867+1] = 46,
-   [868+1] = 2,
-   [869+1] = 74,
-   [870+1] = 41,
-   [871+1] = 63,
-   [872+1] = 20,
-   [873+1] = 54,
-   [874+1] = 47,
-   [875+1] = 32,
-   [876+1] = 29,
-   [877+1] = 11,
-   [910+1] = 6,
-   [911+1] = 72,
-   [912+1] = 39,
-   [913+1] = 64,
-   [914+1] = 21,
-   [915+1] = 59,
-   [916+1] = 48,
-   [917+1] = 35,
-   [918+1] = 26,
-   [919+1] = 8,
-   [920+1] = 65,
-   [921+1] = 22,
-   [922+1] = 16,
-  [1184+1] = 30,
-  [1185+1] = 12,
-  [1186+1] = 66,
-  [1187+1] = 23,
-  [1188+1] = 15,
-  [1189+1] = 49,
-  [1190+1] = 7,
-  [1191+1] = 73,
-  [1192+1] = 40,
-  [1193+1] = 67,
-  [1194+1] = 24,
-  [1195+1] = 60,
-  [1196+1] = 50,
-  [1196+1] = 51,
-  [1197+1] = 36,
-  [1198+1] = 27,
-  [1199+1] = 9,
-  [1200+1] = 68,
-  [1232+1] = 3,
-  [1233+1] = 75,
-  [1234+1] = 42,
-  [1235+1] = 69,
-  [1236+1] = 25,
-  [1237+1] = 55,
-  [1237+1] = 56,
-  [1238+1] = 52,
-  [1239+1] = 33,
-  [1240+1] = 31,
-  [1241+1] = 13,
-  [1314+1] = 17,
-  [1315+1] = 53
-}
-
-    ]]&gt;&lt;/el:luamain&gt;
-    &lt;el:i18n&gt;
-    &lt;/el:i18n&gt;
-  &lt;/el:protected&gt;
-&lt;/el:level&gt;

Deleted: trunk/data/levels/lib/libsoko-endphase.xml
===================================================================
--- trunk/data/levels/lib/libsoko-endphase.xml	2009-03-14 23:58:47 UTC (rev 1590)
+++ trunk/data/levels/lib/libsoko-endphase.xml	2009-03-16 00:55:33 UTC (rev 1591)
@@ -1,825 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
-&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
-  &lt;el:protected&gt;
-    &lt;el:info el:type=&quot;library&quot;&gt;
-      &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libsoko-endphase&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;5&quot; el:status=&quot;experimental&quot;/&gt;
-      &lt;el:author el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
-      &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
-      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
-      &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-      &lt;/el:compatibility&gt;
-      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
-      &lt;el:comments&gt;
-      &lt;/el:comments&gt;
-      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;-&quot;/&gt;
-    &lt;/el:info&gt;
-    &lt;el:luamain&gt;&lt;![CDATA[
-
--- This &quot;library&quot; holds those functions and algorithms needed by libsoko.xml
--- that are used for triggering goals and preparing and executing the sokoball-
--- endphases. Don't include this library with your levels (it won't
--- have any effect), but libsoko.xml.
-
-lib.soko.GOAL_HOOK_RALF = 1
-lib.soko.ENDPHASE_HOOK_DEFAULT = 1
-
-------------------------------------------------------------------------
--- Goal Trigger and Endphase Main Functions
-------------------------------------------------------------------------
-
-function lib_soko_goal_trigger(onoff, sender)
-  local nr = sender._sokoarea
-  local more_boxes = false  -- memorizes whether a box was added or removed
-  if lib.soko.sokoarea[nr].endphase_started then
-    return
-  end
-
-  -- A new stone? Or has a stone been removed?
-  if(sender._box == 0) then
-    if -wo:st(sender) then
-      sender._box = 1
-      lib.soko.sokoarea[nr].goals_filled = lib.soko.sokoarea[nr].goals_filled + 1
-      more_boxes = true
-    else
-      -- blind alarm, probably a marble
-      return
-    end
-  else
-    sender._box = 0
-    lib.soko.sokoarea[nr].goals_filled = lib.soko.sokoarea[nr].goals_filled - 1
-  end
-
-  -- Call goal_hook, e.g. for algorithms &quot;ralf&quot; and &quot;allcrack&quot;.
-  if type(lib.soko.sokoarea[nr].goal_hook) == &quot;number&quot; then
-    if lib.soko.sokoarea[nr].goal_hook == lib.soko.GOAL_HOOK_RALF then
-      lib.soko.endphase_goal_hook_ralf(nr, sender, more_boxes,
-          lib.soko.sokoarea[nr].goals_filled, lib.soko.sokoarea[nr].number_goals)
-    else
-      lib.soko.error(&quot;libsoko: Unknown goal hook.&quot;)
-    end
-  end
-  
-  -- Start endphase?
-  if lib.soko.sokoarea[nr].goals_filled == lib.soko.sokoarea[nr].number_goals then
-    lib.soko.sokoarea[nr].endphase_started = true
-    if type(lib.soko.sokoarea[nr].endphase_hook) == &quot;number&quot; then
-      if lib.soko.sokoarea[nr].endphase_hook == lib.soko.ENDPHASE_HOOK_DEFAULT then
-        lib.soko.endphase(nr)
-      else
-        lib.soko.error(&quot;libsoko: Unknown endphase hook number &quot; .. 
-          lib.soko.sokoarea[nr].endphase_hook .. &quot;.&quot;)
-      end
-    else
-      lib.soko.error(&quot;libsoko: Unknown endphase hook of type &quot;
-        .. type(lib.soko.sokoarea[nr].endphase_hook) .. &quot;.&quot;)
-    end
-  end
-end
-
-function lib.soko.prepare_endphase(sokoarea_number)
-  local nr = sokoarea_number
-  -- ensure existence of goals
-  if lib.soko.sokoarea[nr].number_goals &lt; 1 then
-    lib.soko.error(&quot;No goals defined!\n&quot;)
-  end
-  -- ensure a correctly set endphase-attribute
-  local endp = lib.soko.sokoarea[nr].design.endp
-  if not endp then
-    lib.soko.sokoarea[nr].design.endp = lib.lua.deep_copy(lib.soko.default_design.endp)
-    endp = lib.soko.sokoarea[nr].design.endp
-  end
-  if type(endp) ~= &quot;table&quot; then
-    lib.soko.error(&quot;This design's endphase is given as &quot;..type(endp)
-            ..&quot;, should be table.&quot;)
-  end
-  local alg = endp.alg
-  if alg == nil then
-    lib.soko.sokoarea[nr].design.endp.alg = lib.lua.deep_copy(lib.soko.default_design.endp.alg)
-    alg = endp.alg
-  end
-  if type(alg) ~= &quot;string&quot; then
-    lib.soko.error(&quot;This design's endphase algorithm is given as &quot;..type(alg)
-            ..&quot;, should be string.&quot;)
-  end
-
-  -- decompose alg into algorithm name and additional parameter
-  local param = &quot;&quot;
-  local sep = string.find(alg, &quot;:&quot;)
-  if sep then
-    alg = string.sub(endp.alg, 1, sep - 1)
-    param = string.sub(endp.alg, sep + 1)
-  end
-  
-  -- prepare oxyds
-  if     (alg == &quot;circle&quot;)
-      or (alg == &quot;hide&quot;)
-      or (alg == &quot;fourswitch&quot;)
-      or (alg == &quot;gradients&quot;)
-      or (alg == &quot;magnets&quot;) then
-    -- nothing to prepare
-  elseif (alg == &quot;ralf&quot;)
-      or (alg == &quot;allcrack&quot;)
-      or (alg == &quot;vortex&quot;) then
-    lib.soko.endphase_set_block_oxyds(nr, (lib.soko.sokoarea[nr].design.door or
-        lib.soko.sokoarea[nr].design.wall or &quot;st_nil&quot;), param)
-    lib.soko.sokoarea[nr].goal_hook = lib.soko.GOAL_HOOK_RALF
-  elseif (alg == &quot;block&quot;) then
-    lib.soko.endphase_set_block_oxyds(nr, param)
-  elseif (alg == &quot;outside&quot;) then
-    lib.soko.endphase_set_outside_oxyds(nr, param)
-  elseif (alg == &quot;knock&quot;) then
-    lib.soko.endphase_set_block_oxyds(nr, lib.soko.sokoarea[nr].design.door, 3)
-    lib.soko.endphase_set_knocking(nr, param)
-  -- &quot;Jumpyoxyds&quot; deactivated for once
-  --elseif (alg == &quot;jumpyoxyds&quot;) then
-  --  endphase_set_block_oxyds(nr, &quot;jumpy&quot;)
-  --  goal_hook = lib.soko.GOAL_HOOK_RALF
-  else
-    lib.soko.warning(&quot;Endphase algorithm &quot;..alg..&quot; unknown! Will use 'circle' instead.&quot;)
-  end
-end
-
-function lib.soko.endphase(sokoarea_number)
-  -- Correct structure of endp-attribute has been checked
-  -- by prepare_endphase, we trust it blindly.
-  local endp = lib.lua.deep_copy(lib.soko.sokoarea[sokoarea_number].design.endp)
-  local alg = endp.alg
-  local param = &quot;&quot;
-  local marble = po(no[&quot;marble_&quot;..sokoarea_number..&quot;_1&quot;])
-
-  -- decompose alg into algorithm name and additional parameter
-  local sep = string.find(alg, &quot;:&quot;)
-  if sep then
-    alg = string.sub(endp.alg, 1, sep - 1)
-    param = string.sub(endp.alg, sep + 1)
-  end
-  if param == &quot;&quot; then
-    lib.soko.debug(&quot;Endphase starts of type &quot;..alg..&quot;, no parameter.&quot;)
-  else
-    lib.soko.debug(&quot;Endphase starts of type &quot;..alg..&quot;, parameter &quot;..param..&quot;.&quot;)
-  end
-
-  -- redraw level and give items
-  lib.soko.endphase_redraw_level_array(sokoarea_number)
-  local give = lib.lua.deep_copy(endp.give)
-  if type(give) == &quot;string&quot; then
-    give = {give}
-  end
-  if type(give) == &quot;table&quot; then
-    for k, v in pairs(give) do
-      if is_item(v) or is_stone(v) or is_floor(v) then
-        lib.soko.set_element(marble, sokoarea_number, &quot;&quot;, v)
-      elseif is_actor(v) then
-        wo[marble] = {v, 0.5, 0.5}
-      elseif v == &quot;rubberball&quot; then
-        local old_actor = no[&quot;marble_&quot;..sokoarea_number..&quot;_1&quot;]
-        local actor_kind = &quot;ac-whiteball&quot;
-        if lib.soko.sokoarea[sokoarea_number].design.white then
-          actor_kind = &quot;ac-blackball&quot;
-        end
-        wo[marble] = {actor_kind, &quot;rubberball_sokoarea_&quot;..sokoarea_number,
-                        0.5, 0.5, controllers = 0}
-        wo:add({&quot;ot_rubberband&quot;, anchor1 = no[&quot;marble_&quot;..sokoarea_number],
-            anchor2 = no[&quot;rubberball_sokoarea_&quot;..sokoarea_number], strength = 50})
-      else
-        lib.soko.error(&quot;Can't give &quot;..v..&quot;.&quot;)
-      end
-    end
-  elseif type(give) ~= &quot;nil&quot; then
-    lib.soko.error(&quot;Can't give something of type &quot;..type(v)..&quot;.&quot;)
-  end
-
-  if alg == &quot;circle&quot; then
-    lib.soko.endphase_circle(sokoarea_number)
-  elseif alg == &quot;hide&quot; then
-    lib.soko.endphase_set_hide_oxyds(sokoarea_number, param)
-  elseif    (alg == &quot;ralf&quot;)
-         or (alg == &quot;outside&quot;)
-         --or (alg == &quot;jumpyoxyds&quot;)
-         or (alg == &quot;block&quot;) then
-    lib.soko.endphase_ralf_open_doors(sokoarea_number)
-  elseif alg == &quot;allcrack&quot; then
-    lib.soko.endphase_ralf_open_doors(sokoarea_number)
-    lib.soko.endphase_allcrack(sokoarea_number)
-  elseif alg == &quot;fourswitch&quot; then
-    lib.soko.endphase_fourswitch(sokoarea_number)
-  elseif alg == &quot;vortex&quot; then
-    lib.soko.endphase_ralf_open_doors(sokoarea_number)
-    lib.soko.endphase_vortex(sokoarea_number)
-  elseif alg == &quot;gradients&quot; then
-    lib.soko.endphase_set_hide_oxyds(sokoarea_number)
-    lib.soko.endphase_gradients(sokoarea_number, param)
-  elseif alg == &quot;magnets&quot; then
-    lib.soko.endphase_set_hide_oxyds(sokoarea_number)
-    lib.soko.endphase_magnets(sokoarea_number, param)
-  elseif alg == &quot;knock&quot; then
-    -- don't do anything; endphase_call_knocking
-    -- queries endphase_started.
-  else
-    -- use default: &quot;circle&quot;
-    lib.soko.endphase_circle(sokoarea_number)
-  end
-end
-
-function lib.soko.endphase_redraw_level_array(sokoarea_number)
-  local nr = sokoarea_number or 1
-  local endp = lib.lua.deep_copy(lib.soko.sokoarea[nr].design.endp)
-  local offset = lib.soko.sokoarea[nr].offset
-  
-  -- small routine to check the walls and outside
-  local function is_oxyd_or_blocker(x,y)
-    if lib.soko.sokoarea[nr].list_oxyd[x..&quot;/&quot;..y] then
-      return true
-    elseif lib.soko.sokoarea[nr].list_blocker[x..&quot;/&quot;..y] then
-      return true
-    end
-    return false
-  end
-  
-  -- redraw outside
-  for p, v in pairs(lib.soko.sokoarea[nr].list_outside) do
-    if not is_oxyd_or_blocker(v.abs.x, v.abs.y) then
-      lib.soko.set_element(v.abs, nr, k, endp.outf)
-    end
-  end
-  
-  -- redraw the rest inside level_array:
-  for y = 0, lib.soko.sokoarea[nr].array_height - 1 do
-    for x = 0, lib.soko.sokoarea[nr].array_width - 1 do
-      if not is_oxyd_or_blocker(x + offset.x, y + offset.y) then
-        local ch = lib.soko.sokoarea[nr].level_array[y+1][x+1]
-        for k, v in pairs(endp) do
-          if    ((k == &quot;inf&quot;)  and char_is_inf(ch))
-             or ((k == &quot;wall&quot;) and char_is_wall(ch))
-             or ((k == &quot;goal&quot;) and char_is_goal(ch)) then
-            lib.soko.set_element(offset + {x,y}, nr, k, v)
-          end
-        end
-      end
-    end
-  end
-  
-  -- if existent, redraw blocker floors
-  if (lib.soko.sokoarea[nr].list_blocker) and (endp.inf) then
-    for p, v in pairs(lib.soko.sokoarea[nr].list_blocker) do
-      lib.soko.set_element(v.abs, nr, &quot;inf&quot;, endp.inf)
-    end
-  end 
-end
-
-------------------------------------------------------------------------
--- Endphase Games and Algorithms
-------------------------------------------------------------------------
-
-function lib.soko.endphase_circle(sokoarea_number)
-  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
-  local actor = no[&quot;marble_&quot;..sokoarea_number..&quot;_1&quot;]
-  if not -actor then
-    actor = no[&quot;marble&quot;]
-    if not -actor then
-      lib.soko.error(&quot;No marble found. Please name it 'marble'.&quot;)  
-    end
-  end
-  local abs = po(actor)
-  if abs.x &gt; 10 then
-    abs = abs + {-2,0}
-  end
-  if abs.y &gt; 6 then
-    abs = abs + {0,-2}
-  end
-  for j = 0, 2 do
-    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {j,-1}}, flavor, 2*j)
-    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {-1,j}}, flavor, 2*j)
-    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {j,3}},  flavor, 2*j+1)
-    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {3,j}},  flavor, 2*j+1)
-    for k = 0, 2 do
-      wo:st(abs + {j,k}):kill()
-      wo:it(abs + {j,k}):kill()
-      lib.soko.set_element(abs + {j,k}, sokoarea_number, &quot;inf&quot;)
-    end
-  end
-  wo[abs + {1,1}] = {&quot;st_fart&quot;, _sokoarea = sokoarea_number}
-  wo:shuffleOxyd()
-end
-
--- endphase_set_outside_oxyds distributes oxyds over the outside and
--- wall_two-area of the level. There will be 2 to 5 pairs of oxyds
--- depending on the amount of space. PARAM may define a maximal
--- number of oxyd pairs (good for outf = &quot;fl-space&quot;).
-function lib.soko.endphase_set_outside_oxyds(sokoarea_number, param)
-  local places = {}
-  local nr = sokoarea_number or 1
-  local offset = lib.soko.sokoarea[nr].offset
-  local mx = lib.soko.sokoarea[nr].array_width
-  local my = lib.soko.sokoarea[nr].array_height
-  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
-
-  -- Select all places outside or in the walls, unreachable
-  -- for the marble.
-  for p, v in pairs(lib.lua.combine_tables(lib.soko.sokoarea[nr].list_outside,
-                lib.soko.sokoarea[nr].list_wall_two)) do
-    if (v.abs.x % 2 == 0) and (v.abs.y % 2 == 0) then
-      table.insert(places, v)
-    end
-  end
-
-  -- Choose some appropriate subset
-  local max = table.getn(places)
-  local number_pairs = 2
-  if max &lt; 2 then
-    -- Not enough places? Then choose corners of level_array.
-    -- They should always be at least wall_two and far enough
-    -- away from each other.
-    places = { {abs = offset},
-               {abs = offset + {mx - 1, 0}},
-               {abs = offset + {0, my - 1}},
-               {abs = offset + {mx - 1, my - 1}}}
-  elseif max &lt;  20 then  number_pairs = 2
-  elseif max &lt;  50 then  number_pairs = 3
-  elseif max &lt; 100 then  number_pairs = 4
-  else                   number_pairs = 5
-  end
-  if (type(param) ~= &quot;nil&quot;) and (param ~= &quot;&quot;) then
-    local max_pairs = tonumber(param)
-    if max_pairs then
-      number_pairs = math.min(max_pairs, number_pairs)
-    end    
-  end
-
-  places = lib.lua.shuffle(places)
-
-  for j = 1, number_pairs do
-    lib.soko.set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
-    lib.soko.set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
-  end
-  wo:shuffleOxyd()
-end
-
-function lib.soko.endphase_set_block_oxyds(sokoarea_number, blocker, max_pairs)
-  local oxyds = {}
-  local nr = sokoarea_number or 1
-  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
-
-  -- Add all wall_one-elements with exactly one way near as blocker,
-  -- and the opposite position as oxyd, if it is of type wall_two.
-  -- Make sure that each possible oxyd position is assigned at most once,
-  -- and that no other oxyds or blockers are near.
-  local function opposite_as_oxyd(xy, dxy)
-    if     lib.soko.sokoarea[nr].list_way[(xy.x+dxy.x)..&quot;/&quot;..(xy.y+dxy.y)]
-       and lib.soko.sokoarea[nr].list_wall_two[(xy.x-dxy.x)..&quot;/&quot;..(xy.y-dxy.y)] then
-      -- Check that no oxyd has been set on this position before
-      -- and no other oxyd or blocker is near the new oxyd or its
-      -- blocker.
-      for j, w in pairs(oxyds) do
-        if    (lib.math.manhattan_distance(w.blocker.abs, xy) &lt;= 1)
-           or (lib.math.manhattan_distance(w.abs, xy) &lt;= 1)
-           or (lib.math.manhattan_distance(w.blocker.abs, xy - dxy) &lt;= 1)
-           or (lib.math.manhattan_distance(w.abs, xy - dxy) &lt;= 1) then
-          return
-        end
-      end
-      table.insert(oxyds, {abs = xy - dxy,
-          blocker = {abs = xy, oxyd = {abs = xy - dxy}}, way = {abs = xy + dxy}})
-      return
-    end
-    return
-  end
-  local directions = {po({-1,0}), po({1,0}), po({0,-1}), po({0,1})}
-  for p, v in pairs(lib.soko.sokoarea[nr].list_wall_one) do
-    if v.count == 1 then
-      for _, dir in ipairs(directions) do
-        opposite_as_oxyd(v.abs, dir)
-      end
-    end
-  end
-
-  -- Choose some appropriate subset
-  local max = table.getn(oxyds)
-  local number_pairs = 2
-  if max &lt; 4 then
-    -- Not enough places? Choose &quot;circle&quot;-algorithm instead.
-    lib.soko.sokoarea[nr].design.endp.alg = &quot;circle&quot;
-    return
-  elseif max &lt;  8 then  number_pairs = 2
-  elseif max &lt; 16 then  number_pairs = 3
-  elseif max &lt; 28 then  number_pairs = 4
-  else                  number_pairs = 5
-  end
-  if (type(max_pairs) ~= &quot;nil&quot;) and (max_pairs ~= &quot;&quot;) then
-    if tonumber(max_pairs) &gt;= 1 then
-      number_pairs = math.min(tonumber(max_pairs), number_pairs)
-    end    
-  end
-
-  oxyds = lib.lua.shuffle(oxyds)
-
-  -- set oxyds and blockers
-  local function set_block(w)
-    local myblocker = lib.lua.deep_copy(blocker)
-    -- If there's an entry &quot;st_door_d&quot;, choose the faces.
-    if type(myblocker) == &quot;string&quot; then
-      myblocker = {myblocker}
-    end
-    for j, v in pairs(myblocker) do
-      if v == &quot;st_door_d&quot; then
-        if w.abs.x == w.oxyd.abs.x then
-          myblocker[j] = &quot;st_door_d&quot;
-        else
-          myblocker[j] = &quot;st_door_d_ew&quot;
-        end        
-      end
-    end
-    -- now set in-floor and blocker, and add to list_blocker.
-    lib.soko.set_element(w.abs, nr, &quot;inf&quot;)
-    lib.soko.set_element(w.abs, nr, &quot;&quot;, myblocker)
-    lib.soko.sokoarea[nr].list_blocker[(w.abs.x)..&quot;/&quot;..(w.abs.y)] = lib.lua.deep_copy(w)
-  end
-  for j = 1, number_pairs do   -- Testlevel: 14
-    lib.soko.set_oxyd(nr, oxyds[2*j-1], flavor, j - 1)
-    lib.soko.set_oxyd(nr, oxyds[2*j], flavor, j - 1)
-    set_block(oxyds[2*j-1].blocker)
-    set_block(oxyds[2*j].blocker)
-  end
-  wo:shuffleOxyd()
-
-  -- assign goals to blockers
-  -- Note: There might be more goals as blockers, and, vice versa,
-  --       there might be more blockers as goals.
-  local goal_table = {}
-  for p, v in pairs(lib.soko.sokoarea[nr].list_goal) do
-    table.insert(goal_table, v)
-  end
-  goal_table = lib.lua.shuffle(goal_table)
-  for j = 2, math.min(table.getn(goal_table), table.getn(oxyds)) do
-    lib.soko.sokoarea[nr].goal_to_blocker[goal_table[j].goal_number] = oxyds[j].blocker
-  end
-end
-
--- endphase_set_hide_oxyds distributes oxyds over the wall_one-walls.
--- PARAM is a maximal number of oxyd pairs.
-function lib.soko.endphase_set_hide_oxyds(sokoarea_number, param)
-  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
-  local places = {}
-  
-  -- add all wall_one-elements
-  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_wall_one) do
-    table.insert(places, v)
-  end
-
-  places = lib.lua.shuffle(places)
-  
-  -- choose number of oxyds
-  local max = table.getn(places)
-  local number_pairs = 1
-  if max &lt; 2 then
-    -- use circle instead
-    lib.soko.endphase_circle(sokoarea)
-    return
-  elseif max &lt;  6  then  number_pairs = 2
-  elseif max &lt; 10  then  number_pairs = 3
-  elseif max &lt; 30  then  number_pairs = 4
-  else                   number_pairs = 5 end
-  if (type(param) ~= &quot;nil&quot;) and (param ~= &quot;&quot;) then
-    local max_pairs = tonumber(param)
-    if max_pairs then
-      number_pairs = math.min(max_pairs, number_pairs)
-    end    
-  end
-  
-  -- set oxyds
-  for j = 1, number_pairs do
-    lib.soko.set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
-    lib.soko.set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
-  end
-  wo:shuffleOxyd()
-end
-
-function lib.soko.endphase_gradients(sokoarea_number, param)
-  local force = tonumber(param) or 25.0
-  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_way) do
-    local grad_type = random(1,12)
-    wo[v.abs] = {&quot;fl-gradient&quot;, type = grad_type, force = force}
-  end
-end
-
-function lib.soko.endphase_magnets(sokoarea_number, param)
-  local force = tonumber(param) or 30.0
-  local places = {}
-  local nr = sokoarea_number or 1
-  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
-
-  -- add all way-elements which are not goals
-  for p, v in pairs(lib.soko.sokoarea[nr].list_way) do
-    if not char_is_goal(lib.soko.sokoarea[nr].level_array[v.rel.y][v.rel.x]) then
-      table.insert(places, v)
-    end
-  end
-
-  places = lib.lua.shuffle(places)
-
-  -- choose number of magnets
-  local number_magnets = math.floor(table.getn(places)/6)
-
-  -- set magnets
-  for j = 1, number_magnets do
-    wo[places[j].abs] = {&quot;it_magnet_on&quot;, range = 5, strength = force}
-  end
-end
-
-function lib.soko.endphase_fourswitch(sokoarea_number)
-  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
-  local places = {}
-
-  -- add all wall_one-elements
-  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_wall_one) do
-    table.insert(places, v)
-  end
-
-  places = lib.lua.shuffle(places)
-
-  -- choose number of fourswitchs/oxyds
-  local max = table.getn(places)
-  local number_pairs = 1
-  if max &lt; 2 then
-    -- use circle instead
-    lib.soko.endphase_circle(sokoarea_number)
-    return
-  elseif max &lt;  6  then  number_pairs = 2
-  elseif max &lt; 10  then  number_pairs = 3
-  else                   number_pairs = 4 end
-  
-  -- set fourswitchs
-  for j = 1, 2*number_pairs do
-    wo[places[j].abs] =
-        {&quot;st_fourswitch&quot;, target = &quot;lib_soko_endphase_call_fourswitch&quot;, _number = j,
-         _sokoarea = sokoarea_number}
-    places[j].current = 4
-    places[j].solve = random(1,4)
-    places[j].correct = false
-  end
-  places.number_pairs = number_pairs
-  lib.soko.sokoarea[sokoarea_number].places = lib.lua.deep_copy(places)
-end
-
-function lib_soko_endphase_call_fourswitch(onoff, sender)
-  local j = sender._number
-  local nr = sender._sokoarea
-  local places = lib.soko.sokoarea[nr].places
-
-  -- When fourswitch is knocked, count it.
-  places[j].current = places[j].current + 1
-  if places[j].current == 5 then
-    places[j].current = 1
-  end
-  
-  -- When count is correct, make it &quot;st-likeoxyda-open&quot;.
-  if places[j].current == places[j].solve then
-    places[j].correct = true
-    wo[places[j].abs] = {&quot;st-likeoxyda-open&quot;, _number = 0, _sokoarea = sokoarea_number}
-  end
-
-  -- Now the difficult part: If it's the first fourswitch (the one
-  -- fourswitch that doesn't change any other), check all fourswitchs
-  -- and replace them by oxyds if all are correct. Else, recreate the
-  -- next fourswitch in hierarchy, set it to the old number, then
-  -- set the callback function and call it once by triggering another
-  -- time (making it show the new number). This means: Recursion!
-  if j ~= 1 then
-    -- Trigger all lower fourswitchs
-    local xy = places[j-1].abs
-    if places[j-1].correct then
-      -- reset the fourswitch
-      wo[xy] = {&quot;st_fourswitch&quot;, _number = j - 1, _sokoarea = sokoarea_number}
-      mystone = wo:st(xy)
-      for k = 1, places[j-1].current do
-        mystone:toggle()
-      end
-      mystone.target = &quot;lib_soko_endphase_call_fourswitch&quot;
-      places[j-1].correct = false
-    end
-    wo:st(xy):toggle()
-  else
-    -- Check all fourswitchs
-    local correct = true
-    for k = 1, 2*places.number_pairs do
-      correct = correct and places[k].correct
-    end
-    if correct then
-      -- replace fourswitchs by oxyds
-      for k = 1, places.number_pairs do
-        lib.soko.set_oxyd(sokoarea_number, places[2*k-1], flavor, k - 1)
-        lib.soko.set_oxyd(sokoarea_number, places[2*k], flavor, k - 1)
-      end
-      wo:shuffleOxyd()
-    end
-  end  
-end
-
-
-function lib.soko.endphase_allcrack(sokoarea_number)
-  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_way) do
-    if not -wo:it(v.abs) then
-      wo[v.abs] = {&quot;it-crack3&quot;}
-    end
-  end  
-end
-
-function lib.soko.endphase_goal_hook_ralf(sokoarea_number, sender, more_boxes,
-    goals_filled, number_goals)
-  local nr = sokoarea_number or 1
-  -- verify correct sokoarea-number and existence of &quot;goal_to_blocker&quot;
-  if nr ~= sender._sokoarea then
-    lib.soko.error(&quot;libsoko: Inconsistent sokoarea numbers in goal hook!&quot;)
-  end
-  if type(lib.soko.sokoarea[nr].goal_to_blocker) ~= &quot;table&quot; then
-    lib.soko.error(&quot;libsoko: Blocker list is missing during goal hook!&quot;)
-  end
-  -- identify the corresponding door and open it
-  local blocker = lib.soko.sokoarea[nr].goal_to_blocker[sender._goal_number]
-  if blocker then
-    lib.soko.endphase_ralf_open_door(nr, more_boxes, blocker.abs)
-  end
-end
-
-function lib.soko.endphase_ralf_open_doors(sokoarea_number)
-  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_blocker) do
-    lib.soko.endphase_ralf_open_door(sokoarea_number, true, v.abs)
-  end
-end
-
--- endphase_ralf_open_door opens or closes a door at position
--- (X,Y), dependend on the boolean OPEN.
-function lib.soko.endphase_ralf_open_door(sokoarea_number, open, xy)
-  local door_kind = lib.soko.sokoarea[sokoarea_number].design.endp.open_door
-  if door_kind then
-    if not open then
-      door_kind =    lib.soko.sokoarea[sokoarea_number].design.door
-                  or lib.soko.sokoarea[sokoarea_number].design.wall or &quot;st_nil&quot;
-    end
-    lib.soko.set_element(xy, sokoarea_number, &quot;&quot;, door_kind)
-  else
-    -- use default &quot;open&quot;/&quot;close&quot;-messages instead
-    local st = wo:st(xy)
-    local it = wo:it(xy)
-    local fl = wo:fl(xy)
-    if -st and st._sokoarea then
-      st:message(lib.lua.cond(open, &quot;open&quot;, &quot;close&quot;))
-    end
-    if -it and it._sokoarea then
-      it:message(lib.lua.cond(open, &quot;open&quot;, &quot;close&quot;))
-    end
-    if -fl then
-      fl:message(lib.lua.cond(open, &quot;close&quot;, &quot;open&quot;))
-    end
-  end  
-end
-
-function lib.soko.endphase_vortex(sokoarea_number)
-  local nr = sokoarea_number or 1
-  local list_way = 
-    lib.lua.combine_tables(lib.soko.sokoarea[nr].list_way, lib.soko.sokoarea[nr].list_blocker)
-  local components = 0
-  local component = {}
-
-  -- Remove old component-entries, in case there are still some left.
-  for p, v in pairs(list_way) do
-    list_way[p].component = nil
-  end
-
-  -- Analyse connected components of list_way, separated by goals.
-  local function mark_component(xy)
-    if     (list_way[xy.x..&quot;/&quot;..xy.y])
-       and (not list_way[xy.x..&quot;/&quot;..xy.y].component)
-       and (not lib.soko.sokoarea[nr].list_goal[xy.x..&quot;/&quot;..xy.y]) then
-      list_way[xy.x..&quot;/&quot;..xy.y].component = components
-      --set_floor(({&quot;fl-leaves&quot;, &quot;fl-ice&quot;, &quot;fl-red&quot;, &quot;fl-black&quot;, &quot;fl-white&quot;,
-      --    &quot;fl-sahara&quot;, &quot;fl-light&quot;, &quot;fl-gray&quot;, &quot;fl-lightgray&quot;, &quot;fl-rough&quot;,
-      --    &quot;fl-marble&quot;, &quot;fl-tigris&quot;})[components] or &quot;fl-sand&quot;, lx, ly)
-      table.insert(component[components], {abs = xy})
-      mark_component(xy + {1,0})
-      mark_component(xy + {-1,0})
-      mark_component(xy + {0,1})
-      mark_component(xy + {0,-1})
-    end
-  end
-  for p, v in pairs(list_way) do
-    if (not list_way[p].component) and (not lib.soko.sokoarea[nr].list_goal[p]) then
-      components = components + 1
-      component[components] = {oxyds = 0}
-      mark_component(v.abs)
-    end    
-  end
-
-  -- If only one component, exit, player will find his or her way alone.
-  if components &lt; 2 then
-    return
-  end
-
-  -- Analyse oxyds and to which components they belong to.
-  for p, v in pairs(lib.soko.sokoarea[nr].list_oxyd) do
-    local component_number = list_way[v.blocker.abs.x..&quot;/&quot;..v.blocker.abs.y].component or -1
-    if component_number == -1 then
-      lib.soko.error(&quot;Error in component calculation.&quot;)
-    else
-      component[component_number].oxyds = component[component_number].oxyds + 1
-    end
-  end  
-
-  -- Let there be at most max(5, number-of-oxyd-components)
-  -- components, plus the one the marble actually occupies.
-  local t = {}  -- helper table: components with oxyds or marble
-  local u = {}  -- helper table: all components except t
-  local mx, my = po(no[&quot;marble_&quot;..nr..&quot;_1&quot;]):xy()
-  local marble_component = (list_way[mx..&quot;/&quot;..my] or {}).component
-  for j = 1, components do
-    if (component[j].oxyds &gt; 0) or (j == marble_component) then
-      table.insert(t, component[j])
-    else
-      table.insert(u, component[j])
-    end
-  end
-  u = lib.lua.shuffle(u)
-  while (table.getn(t) &lt; 5) and (table.getn(u) &gt; 0) do
-    table.insert(t, u[table.getn(u)])
-    table.remove(u)
-  end
-  component = t
-  components = table.getn(component)
-
-  -- From each component, choose one tile and save the position
-  local vortex = {}
-  for j = 1, components do
-    table.insert(vortex, component[j][random(1, table.getn(component[j]))])
-  end
-  
-  -- Find a cyclic permutation (i.e. with only one cycle) to connect the
-  -- vortices (each vortex shall be reached by starting from any other).
-  local connect = lib.math.cyclic_permutation(components)
-
-  -- Now set and connect the vortices
-  for j, v in ipairs(vortex) do
-    local w = vortex[connect[j]]
-    -- Remember: We also allow (we need!) vortices at old blocker-positions.
-    -- There could still be a stone over this. This stone might be st-blocker,
-    -- which turns to it-blocker and has therefore to be removed. Better
-    -- we remove all stones:
-    wo:st(v.abs):kill()
-    wo[v.abs] = {&quot;it_vortex_open&quot;, destination = w.abs}
-  end  
-end
-
-function lib.soko.endphase_set_knocking(sokoarea_number, param)
-  local nr = sokoarea_number
-  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
-  local places = {}
-
-  -- add all blockers
-  for p, v in pairs(lib.soko.sokoarea[nr].list_blocker) do
-    table.insert(places, v)
-  end
-
-  places = lib.lua.shuffle(places)
-
-  -- set attributes of door
-  for j, v in ipairs(places) do
-    local st = wo:st(v.abs)
-    if -st then
-      st.action = &quot;callback&quot;
-      st.target = &quot;lib_soko_endphase_call_knocking&quot;
-      st._close = places[lib.lua.mod(j, table.getn(places)) + 1].abs
-      st._open = places[lib.lua.mod(j+1, table.getn(places)) + 1].abs
-      st._number = j
-    end
-  end
-end
-
-function lib_soko_endphase_call_knocking(onoff, sender)
-  local j = sender._number
-  local nr = sender._sokoarea
-  if (not nr) or (not j) then
-    lib.soko.error(&quot;libsoko: Knocking's source has no number or no sokoarea.&quot;)
-  end
-  lib.soko.debug(&quot;Knocked on &quot;..j..&quot;/&quot;..lib.soko.sokoarea[nr].number_oxyds)
-  -- Deactivate the first door until endphase has started.
-  if (j == 1) and (not lib.soko.sokoarea[nr].endphase_started) then
-    lib.soko.debug(&quot;Door deactivated until endphase.&quot;)
-    return
-  end
-  -- Open or close the neccessary doors given as attributes.
-  if sender._sokoarea == nr then
-    if wo:st(sender._close):is(&quot;st_door&quot;) then
-      wo:st(sender._close):close()
-    end
-    if wo:st(sender._open):is(&quot;st_door&quot;) then
-      wo:st(sender._open):open()
-    end
-  end
-end
-
-    ]]&gt;&lt;/el:luamain&gt;
-    &lt;el:i18n&gt;
-    &lt;/el:i18n&gt;
-  &lt;/el:protected&gt;
-&lt;/el:level&gt;
-

Modified: trunk/data/levels/lib/libsoko.xml
===================================================================
--- trunk/data/levels/lib/libsoko.xml	2009-03-14 23:58:47 UTC (rev 1590)
+++ trunk/data/levels/lib/libsoko.xml	2009-03-16 00:55:33 UTC (rev 1591)
@@ -3,15 +3,15 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;library&quot;&gt;
       &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libsoko&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;experimental&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;5&quot; el:status=&quot;released&quot;/&gt;
       &lt;el:author el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
-      &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
+      &lt;el:copyright&gt;Copyright &#169; 2007, 2008, 2009 Enigma Team&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
         &lt;el:dependency el:path=&quot;lib/liblua&quot; el:id=&quot;lib/liblua&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
         &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
-        &lt;el:dependency el:path=&quot;lib/libsoko-designlist&quot; el:id=&quot;lib/libsoko-designlist&quot; el:release=&quot;1&quot; el:preload=&quot;false&quot;/&gt;
-        &lt;el:dependency el:path=&quot;lib/libsoko-endphase&quot; el:id=&quot;lib/libsoko-endphase&quot; el:release=&quot;1&quot; el:preload=&quot;false&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libimport&quot; el:id=&quot;lib/libimport&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libsoko_designlist&quot; el:id=&quot;lib/libsoko_designlist&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:comments&gt;
@@ -24,644 +24,59 @@
     &lt;/el:info&gt;
     &lt;el:luamain&gt;&lt;![CDATA[
 
--- libsoko.xml uses data from libsoko-designlist.xml and functions from
--- libsoko-endphase.xml. Please read the comments in libsoko-designlist.xml
--- to understand design tables, and libsoko-endphase.xml for goal-triggering
--- and endphases.
-
 lib.soko = {}
 setmetatable(lib.soko, getmetatable(lib))
+lib.soko.keys_to_field_names = {[&quot;  &quot;] = &quot;inf&quot;, [&quot;- &quot;] = &quot;outf&quot;, [&quot;$ &quot;] = &quot;box&quot;,
+    [&quot;# &quot;] = &quot;wall&quot;, [&quot; .&quot;] = &quot;goal&quot;, [&quot;D &quot;] = &quot;door&quot;, [&quot;d &quot;] = &quot;open_door&quot;}
+    
+-- The following constants are defined in libsoko_designlist:
+-- RESOLVE_ALL = 0
+-- RESOLVE_RANDOM = 1
+-- RESOLVE_CHECKERBOARD = 2
+-- RESOLVE_LINES = 3
+-- RESOLVE_WAVES = 4
+-- RESOLVE_ORIENTED = 5
+GOAL_HOOK_DEFAULT = 0
+GOAL_HOOK_RALF = 1
 
-enigma.LoadLib(&quot;lib/libsoko-designlist&quot;)
-enigma.LoadLib(&quot;lib/libsoko-endphase&quot;)
+lib.soko.resolver_info = {}
+lib.soko.area = {}
+lib.soko.endphase_started = false
+lib.soko.initially_completed_goals = 0
+lib.soko.goal_hook = GOAL_HOOK_DEFAULT
 
 ------------------------------------------------------------------------
--- Global variables
+-- lib.soko.area
 ------------------------------------------------------------------------
 
--- The global table &quot;sokoarea&quot; holds all sokoban parts a level
--- creates. I.e., lib.soko.sokoarea[1] holds information about the first
--- part, lib.soko.sokoarea[2] about the second etc. In most cases, only
--- lib.soko.sokoarea[1] will be used.
--- Each lib.soko.sokoarea[j] is again a table with the following entries:
---
---        level_array - a 2D-array of characters defining the sokoban part
---        array_width - width of level_array
---       array_height - height of level_array
---             design - the used design table
---       number_goals - number of goals this part controls
---       goals_filled - number of filled goals
---        actor_count - number of actors in this sokoban part
---   endphase_started - a flag to mark completed sokobans
---             offset - position of the level_array within the whole level
---         uses_chess - flag to note that st-chess was used (no shogun-triggers)
---        level_width - width of whole level (create_sokoban only)
---       level_height - height of whole level (create_sokoban only)
---          goal_hook - describes the function to call when a goal is activated/deactivated
---      endphase_hook - describes the function to call when all triggers are filled
---
--- However, you can call endphase(sokoarea_number) yourself if neccessary.
---
---       list_outside - list of positions of outf-tiles
---          list_wall - list of all walls
---           list_way - list of all inside positions that the marble
---                      can reach on level-end (incl. goals)
---      list_wall_one - list of outer walls near ways
---      list_wall_two - list of outer walls or outf one tile away from
---                      ways, together with a list of neighboring wall_ones.
---          list_goal - list of all goals
---
--- Each list entry is a table: Entries lx and ly are absolute positions
--- (&quot;level&quot;), ax and ay are positions in the level_array, if existent
--- (nil else). Some endphases also use list_oxyd, list_blocker,
--- goal_to_blocker and/or number_oxyds as additional data structures.
-
-lib.soko.sokoarea = {}
-
-------------------------------------------------------------------------
--- Tools
-------------------------------------------------------------------------
-
-function lib.soko.debug(st)
-  print(st)
-end
-function lib.soko.warning(st)
-  print(st)
-end
-function lib.soko.error(st)
-  error(st, 2)
-end
-
-function is_floor(s)        return string.sub(s, 1, 2) == &quot;fl&quot;  end
-function is_stone(s)        return string.sub(s, 1, 2) == &quot;st&quot;  end
-function is_item(s)         return string.sub(s, 1, 2) == &quot;it&quot;  end
-function is_actor(s)        return string.sub(s, 1, 2) == &quot;ac&quot;  end
-function char_is_outf(ch)   return string.find(ch, &quot;[ ]&quot;)       == 1  end
-function char_is_inf(ch)    return not char_is_outf(ch)               end
-function char_is_wall(ch)   return string.find(ch, &quot;[#]&quot;)       == 1  end
-function char_is_goal(ch)   return string.find(ch, &quot;[\.\*\+N]&quot;) == 1  end
-function char_is_box(ch)    return string.find(ch, &quot;[$\*]&quot;)     == 1  end
-function char_is_chess(ch)  return string.find(ch, &quot;[nN]&quot;)      == 1  end
-function char_is_player(ch) return string.find(ch, &quot;[@\+]&quot;)     == 1  end
-
--- choose_among_multiples selects a number between 1 and COUNT
--- based on the coordinates X and Y and the algorithm's name ALG.
-function lib.soko.choose_among_multiples(abs, count, alg)
-  if alg == &quot;checkerboard&quot; then
-    return (((abs.x%2) + (abs.y%2)) % count) + 1
-  elseif alg == &quot;lines&quot; then
-    return ((abs.x + abs.y) % count) + 1
-  elseif alg == &quot;waves&quot; then
-    local x, y = abs:xy()
-    return ((x + y * y + x*y*x + 3*y*x*y*x) % count) + 1
-  elseif alg == &quot;random&quot; then
-    return math.random(count)
-  end
-end
-
--- check_chess returns a boolean whether a chess stone is used
--- in the sokoarea SOKOAREA_NUMBER.
-function lib.soko.check_chess(sokoarea_number)
-  for y = 1, lib.soko.sokoarea[sokoarea_number].array_height do
-    for x = 1, lib.soko.sokoarea[sokoarea_number].array_width do
-      local ch = lib.soko.sokoarea[sokoarea_number].level_array[y][x]
-      if char_is_chess(ch) then
-        return true
-      end
-    end
-  end
-  return false
-end
-
--- set_oxyd sets an oxyd with given flavor and color and adds
--- the neccessary entry to list_oxyd.
-function lib.soko.set_oxyd(sokoarea_number, list_entry, flavor, color)
-  local entry = lib.lua.deep_copy(list_entry)
-  entry.flavor = flavor
-  entry.color = color
-  wo[entry.abs] = {&quot;st_oxyd&quot;, flavor = flavor, oxydcolor = color}
-  lib.soko.sokoarea[sokoarea_number].list_oxyd[entry.abs.x..&quot;/&quot;..entry.abs.y] = entry
-  lib.soko.sokoarea[sokoarea_number].number_oxyds =
-      lib.soko.sokoarea[sokoarea_number].number_oxyds + 1
-end
-
--- create_lists creates the special lists list_outside, list_wall,
--- list_way, list_wall_one and list_wall_two for SOKOAREA_NUMBER.
-function lib.soko.create_lists(sokoarea_number)
-  local nr = sokoarea_number or 1
-  local offset = lib.soko.sokoarea[nr].offset
-  local mx = lib.soko.sokoarea[nr].array_width
-  local my = lib.soko.sokoarea[nr].array_height
-  lib.soko.sokoarea[nr].list_outside = {}
-  lib.soko.sokoarea[nr].list_way = {}
-  lib.soko.sokoarea[nr].list_wall_one = {}
-  lib.soko.sokoarea[nr].list_wall_two = {}
-  -- list_way, list_wall and list_outside (inside level_array)
-  for x = 0, mx - 1 do
-    for y = 0, my - 1 do
-      local ch = lib.soko.sokoarea[nr].level_array[y+1][x+1]
-      local entry = {abs = offset + {x,y}, rel = po({x+1, y+1})}
-      local sig = entry.abs.x..&quot;/&quot;..entry.abs.y
-      if char_is_outf(ch) then
-        lib.soko.sokoarea[nr].list_outside[sig] = entry
-      elseif char_is_wall(ch) then
-        lib.soko.sokoarea[nr].list_wall[sig] = entry
-      else
-        lib.soko.sokoarea[nr].list_way[sig] = entry
-      end
-    end
-  end
-  -- list_outside (outside level_array)
-  if lib.soko.sokoarea[nr].level_width and lib.soko.sokoarea[nr].level_height then
-    for x = 0, lib.soko.sokoarea[nr].level_width - 1 do
-      for y = 0, lib.soko.sokoarea[nr].level_height - 1 do
-        if    (x &lt; offset.x) or (x &gt; mx + offset.x - 1)
-           or (y &lt; offset.y) or (y &gt; my + offset.y - 1) then
-          lib.soko.sokoarea[nr].list_outside[x..&quot;/&quot;..y] = {abs = po({x,y})}
+-- lib.soko.area provides a way to save information about specific
+-- positions of the current level (see it as &quot;attributes for positions&quot;).
+function lib.soko.area_get(self, index)
+    if usertype(index) == &quot;position&quot; then
+        local signature = index.x .. &quot;/&quot; .. index.y
+        if not rawget(self, signature) then
+            rawset(self, signature, {})
         end
-      end
-    end
-  end
-  -- list_wall_one
-  -- There are three conditions for an element of list_wall_one:
-  -- (i) it's a wall, (ii) it's near or diagonal to outside,
-  -- (iii) it's near a way.
-  -- In addition, it counts the number of near ways.
-  for p, v in pairs(lib.soko.sokoarea[nr].list_wall) do
-    local x = v.abs.x
-    local y = v.abs.y
-    if    lib.soko.sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y)]
-       or lib.soko.sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y)]
-       or lib.soko.sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y-1)]
-       or lib.soko.sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y+1)]
-       or lib.soko.sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y+1)]
-       or lib.soko.sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y-1)]
-       or lib.soko.sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y+1)]
-       or lib.soko.sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y-1)] then
-      local count = 0
-      if lib.soko.sokoarea[nr].list_way[(x-1)..&quot;/&quot;..(y)] then  count = count + 1  end
-      if lib.soko.sokoarea[nr].list_way[(x+1)..&quot;/&quot;..(y)] then  count = count + 1  end
-      if lib.soko.sokoarea[nr].list_way[(x)..&quot;/&quot;..(y-1)] then  count = count + 1  end
-      if lib.soko.sokoarea[nr].list_way[(x)..&quot;/&quot;..(y+1)] then  count = count + 1  end
-      if count &gt; 0 then
-        lib.soko.sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] =
-            {abs = v.abs, rel = v.rel, count = count}
-      end
-    end
-  end
-  -- list_wall_two
-  -- There are three conditions for an element of list_wall_two:
-  -- (i) it's near a wall_one, (ii) it's not a wall_one,
-  -- (iii) it's wall or outside. Next function lib.soko.checks (ii) and (iii)
-  -- and adds the checked element to the list. In addition, the
-  -- neighboring wall_one are added into the list.
-  local function check_ii_and_iii(x, y, one_x, one_y)
-    if lib.soko.sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] then
-      return
-    end
-    if lib.soko.sokoarea[nr].list_way[x..&quot;/&quot;..y] then
-      return
-    end
-    if not lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] then
-      -- create new entry
-      lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] =
-          {abs = po({x,y}), rel = nil, wall_one = {}}
-    end
-    -- add the corresponding wall_one
-    local w = table.getn(lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one) + 1
-    lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one[w] =
-        lib.soko.sokoarea[nr].list_wall_one[one_x..&quot;/&quot;..one_y]
-  end
-  for p, v in pairs(lib.soko.sokoarea[nr].list_wall_one) do
-    check_ii_and_iii(v.abs.x+1, v.abs.y, v.abs.x, v.abs.y)
-    check_ii_and_iii(v.abs.x-1, v.abs.y, v.abs.x, v.abs.y)
-    check_ii_and_iii(v.abs.x, v.abs.y+1, v.abs.x, v.abs.y)
-    check_ii_and_iii(v.abs.x, v.abs.y-1, v.abs.x, v.abs.y)
-  end  
-end
-
--- new_sokoarea initialises a new entry in the global
--- sokoarea table and returns its number.
-function lib.soko.new_sokoarea()
-  sokoarea_number = table.getn(lib.soko.sokoarea) + 1
-  lib.soko.sokoarea[sokoarea_number] = {
-    level_array = {},
-    design = lib.soko.default_design,
-    algorithms = {},
-    number_goals = 0,
-    goals_filled = 0,
-    actor_count = 0,
-    endphase_started = false,
-    offset = po({0, 0}),
-    level_width = nil,
-    level_height = nil,
-    uses_chess = false,
-    goal_hook = nil,
-    endphase_hook = lib.soko.ENDPHASE_HOOK_DEFAULT,
-    list_outside = {},
-    list_wall = {},
-    list_way = {},
-    list_wall_one = {},
-    list_wall_two = {},
-    list_goal = {},
-    list_oxyd = {},
-    list_blocker = {},
-    goal_to_blocker = {},
-    number_oxyds = 0
-  }
-  return sokoarea_number
-end
-
-------------------------------------------------------------------------
--- Drawing Functions and Level Interpretation
-------------------------------------------------------------------------
-
--- lib.soko.set_element sets element name EL_STR of area SOKOAREA_NUMBER at x, y.
--- EL_DESIGN is optional and overrides the design of the given sokoarea.
-function lib.soko.set_element(abs, sokoarea_number, el_str, el_design)
-  if type(lib.soko.sokoarea[sokoarea_number]) ~= &quot;table&quot; then
-    lib.soko.error(&quot;Sokoarea table number &quot;..sokoarea_number..&quot; broken or not existing.&quot;)
-  end
-  local el = el_design or lib.soko.sokoarea[sokoarea_number].design[el_str]
-  local in_endphase = lib.soko.sokoarea[sokoarea_number].endphase_started
-
-  if (usertype(abs) ~= &quot;position&quot;) then
-    lib.soko.error(&quot;libsoko.lib.soko.set_element: Coordinate is not a position!&quot;)
-    return
-  end
-
-  if type(el) == &quot;string&quot; then
-    el = {el}
-  end
-
-  local fl = {}
-  local st = {}
-  local it = {}
-  local multiple_alg = &quot;checkerboard&quot;
-  local friction = nil
-  local adhesion = nil
-  local fire = nil
-
-  -- Now analyse EL: Decompose its entries into fl,st,it.
-  -- Each entry might in turn hold a &quot;:NUMBER&quot;, which multiplicates it.
-  for j, v in pairs(el or {}) do
-    if type(v) == &quot;string&quot; then
-      -- Separate the multiplicator or argument (separated by &quot;:&quot;)
-      local s = v
-      local nr = 1
-      local sep = string.find(v, &quot;:&quot;)
-      local arg = nil
-      if sep then
-        s = string.sub(v, 1, sep - 1)
-        arg = string.sub(v, sep + 1)
-      end
-
-      -- Now sort the entry into tables
-      for j = 1, tonumber(arg) or 1 do
-            if is_floor(s)    then  table.insert(fl, s)
-        elseif is_stone(s)    then  table.insert(st, s)
-        elseif is_item(s)     then  table.insert(it, s)
-        elseif s == &quot;al&quot;      then  multiple_alg = arg
-        elseif s == &quot;fr&quot;      then  friction = tonumber(arg) or 1
-        elseif s == &quot;ad&quot;      then  adhesion = tonumber(arg) or 1
-        elseif s == &quot;fire&quot;    then  fire = true
-        elseif s == &quot;nofire&quot;  then  fire = false
-        else
-          lib.soko.warning(&quot;Unknown entry &quot;..j..&quot;=&quot;..s..&quot; in design element.&quot;)
-        end
-      end
+        return rawget(self, signature)
+    elseif (type(index) == &quot;string&quot;) and (index == &quot;type&quot;) then
+        return &quot;lib.soko.area&quot;
     else
-      lib.soko.warning(&quot;In design element, entry &quot;..j..&quot; is of type &quot;
-                ..type(v)..&quot;, not string.&quot;)      
+        error(&quot;lib.soko: Internal error: Read access to area_get with wrong &quot;
+            .. &quot;type (&quot; .. type(index) .. &quot;/&quot; .. usertype(index) .. &quot;).&quot;, 2)
     end
-  end
-
-  local created_objects = {}
-
-  ----------- floor --------------
-  if table.getn(fl) &gt; 0 then
-    local flkind = fl[lib.soko.choose_among_multiples(abs, table.getn(fl), multiple_alg)]
-    if flkind == &quot;fl-bridge_x&quot; then
-      wo[abs] = {&quot;fl-bridge&quot;, type = &quot;x&quot;, burnable = false, eternal = true}
-    elseif flkind == &quot;fl-bridge_y&quot; then
-      wo[abs] = {&quot;fl-bridge&quot;, type = &quot;y&quot;, burnable = false, eternal = true}
-    else
-      wo[abs] = {flkind, burnable = false, eternal = true}
-    end
-    created_objects.fl = wo:fl(abs)
-    if type(friction) == &quot;number&quot; then
-      created_objects.fl.friction = friction
-    end
-    if type(adhesion) == &quot;number&quot; then
-      created_objects.fl.adhesion = adhesion
-    end
-  end
-
-  ----------- stone ---------------
-  if table.getn(st) &gt; 0 then
-    local stkind = st[lib.soko.choose_among_multiples(abs, table.getn(st), multiple_alg)]
-    if (not -wo:st(abs)) or (not wo:st(abs):is(&quot;st_oxyd&quot;)) then
-      wo[abs] = {stkind, _sokoarea = sokoarea_number}
-      created_objects.st = wo:st(abs)
-    end
-  end
-
-  ----------- item ----------------
-  if table.getn(it) &gt; 0 then
-    local itkind = it[lib.soko.choose_among_multiples(abs, table.getn(it), multiple_alg)]
-    if lib.soko.sokoarea[sokoarea_number].uses_chess and not in_endphase then
-      itkind = &quot;it_trigger&quot;
-    end
-    wo[abs] = {itkind}
-    created_objects.it = wo:it(abs)
-    if (el_str == &quot;goal&quot;) and not in_endphase then
-      local gn = lib.soko.sokoarea[sokoarea_number].number_goals + 1
-      lib.soko.sokoarea[sokoarea_number].number_goals = gn
-      lib.soko.sokoarea[sokoarea_number].list_goal[abs.x..&quot;/&quot;..abs.y] =
-          {abs = abs, goal_number = gn}
-      if created_objects.it and not in_endphase then
-        created_objects.it.action = &quot;callback&quot;
-        created_objects.it.target = &quot;lib_soko_goal_trigger&quot;
-        created_objects.it._box = 0
-        created_objects.it._sokoarea = sokoarea_number
-        created_objects.it._goal_number = gn
-      end
-    end
-  end
-
-  ----------- fire ----------------
-  if fire ~= nil then
-    local myfloor = wo:fl(abs)
-    if myfloor then
-      if fire then
-        myfloor.burnable = true
-        myfloor.eternal = true
-        myfloor:message(&quot;forcefire&quot;)
-      else
-        myfloor:message(&quot;stopfire&quot;)
-        myfloor.burnable = false
-        myfloor.eternal = true
-      end
-    end
-  end
-
-  return created_objects
 end
 
--- draw_level_array draws the sokoarea SOKOAREA_NUMBER at offset DX, DY.
--- If OUTSIDE is true, the outside will be drawn as well.
--- DRAW_ACTOR determines whether the actor should be placed.
--- draw_level_array will NOT
---  - create the world
---  - set global variables
---  - prepare oxyds
---  - solve the level
--- This function lib.soko.is not intended to be used in level programming
--- directly, use &quot;draw_sokoball&quot; instead.
-function lib.soko.draw_level_array(sokoarea_number, outside, draw_actor)
-  local nr = sokoarea_number or 1
-  local design = lib.soko.sokoarea[nr].design
-  local offset = lib.soko.sokoarea[nr].offset
-  lib.soko.sokoarea[nr].list_goal = {}
-
-  -- create level
-  for y = 0, lib.soko.sokoarea[nr].array_height - 1 do
-    for x = 0, lib.soko.sokoarea[nr].array_width - 1 do
-      local ch = lib.soko.sokoarea[nr].level_array[y+1][x+1]
-      local obj = {}
-      local abs = offset + {x,y}
-      
-      -- set floor outside or floor inside
-      if (ch == &quot; &quot;) then -- note: space stands for outside, &quot;-&quot; for inside!
-        if outside then
-          wo:st(abs):kill()
-          wo:it(abs):kill()
-          lib.soko.set_element(abs, nr, &quot;outf&quot;)
-        end
-      else
-        wo:st(abs):kill()
-        wo:it(abs):kill()
-        obj = lib.soko.set_element(abs, nr, &quot;inf&quot;)
-        obj.fl.freeze_check = true
-      end
-      
-      -- Walls
-      if char_is_wall(ch) then
-        obj = lib.soko.set_element(abs, nr, &quot;wall&quot;)
-      end
-      
-      -- Goals
-      if char_is_goal(ch) then
-        obj = lib.soko.set_element(abs, nr, &quot;goal&quot;)
-        wo:fl(abs).freeze_check = false
-      end
-      
-      -- Boxes
-      if char_is_box(ch) then
-        obj = lib.soko.set_element(abs, nr, &quot;box&quot;)
-        obj.st.freeze_check = true
-      end
-      
-      -- Chess-Stones
-      if char_is_chess(ch) then
-        if design[&quot;white&quot;] then
-          wo[abs] = {&quot;st-chess_white&quot;}
-        else
-          wo[abs] = {&quot;st-chess_black&quot;}
-        end
-      end
-      
-      -- Actors
-      if char_is_player(ch) and draw_actor then
-        lib.soko.sokoarea[nr].actor_count = lib.soko.sokoarea[nr].actor_count + 1
-        local acname = &quot;marble_&quot;..nr..&quot;_&quot;..lib.soko.sokoarea[nr].actor_count
-        if design[&quot;white&quot;] then
-          wo[abs] = {&quot;#ac-whiteball&quot;, acname, controllers = 1, player = 0}
-        else
-          wo[abs] = {&quot;#ac-blackball&quot;, acname}
-        end
-      end
-    end
-  end  
+function lib.soko.area_set(self, newindex, value)
+    error(&quot;lib.soko: Internal error: area_set used inappropriately.&quot;, 2)
 end
 
--- Sokoban level strings are typically a string with the following characters:
---        # = Wall
---        @ = Player
---        + = Player on goal square
---        $ = Box
---        * = Box on goal square
---        . = Goal square
---  - _ spc = Floor
---     \n | = next line
---   number = runlength encoding
---
--- Enigma additionally uses the following:
---        n = st-chess_black/white
---        N = st-chess_black/white on goal square
---
--- This format has to be transcoded to an array, which is done by unpack_level.
--- Furthermore the string LEVEL can hold several levels (it's a multilevel),
--- in which case SUBLEVEL determines the number of the level to unpack.
--- Default of SUBLEVEL is 1.
---
-function lib.soko.unpack_level(multilevel, sublevel_number)
-  if type(multilevel) ~= &quot;string&quot; then
-    lib.soko.error(&quot;Can't make sense of level type &quot;..type(level)..&quot;.&quot;)
-  end
-  local current_level = 0
-  local level = &quot;&quot;
+lib.soko.area_metatable = {
+  __index = lib.soko.area_get,
+  __newindex = lib.soko.area_set
+}
 
-  -- search the correct sublevel by pattern matching, line for line
-  local level_line_match = 
-      &quot;[ \-\#\_\$\.@\*0-9Nn\+]*&quot;  -- all allowed characters except line ending
-    ..&quot;[\#\$\.@\*Nn\+]+&quot;          -- at least one non-space character
-    ..&quot;[ \-\#\_\$\.@\*0-9Nn\+]*&quot;  -- again all allowed characters except line ending
-  local in_level = false
-  for line in string.gfind(multilevel, &quot;([^\n\|]*)[\n\|]&quot;) do
-    local start_match, end_match = string.find(line, level_line_match)
-    if (start_match == 1) and (end_match == string.len(line)) then
-      if in_level then
-        if current_level == (sublevel_number or 1) then
-          level = level..line..&quot;\n&quot;
-        end
-      else
-        -- we just entered a new level
-        in_level = true
-        current_level = current_level + 1
-        if current_level == (sublevel_number or 1) then
-          level = line..&quot;\n&quot;
-        end
-      end
-      lib.soko.debug(&quot;Level &quot;..current_level..&quot; : |&quot;..line..&quot;|&quot;)
-    else
-      in_level = false
-    end
-  end
-  
-  lib.soko.debug(level)
-  
-  if level == &quot;&quot; then
-    lib.soko.error(&quot;libsoko.unpack_level: Multilevel holds less than &quot;
-            ..sublevel_number..&quot; levels!&quot;)
-  end
+setmetatable(lib.soko.area, lib.soko.area_metatable)
 
-  -- parse the string LEVEL
-  local level_array = {}
-  local line = 1
-  level_array[line] = {}
-  local count = 0   -- (a simple counter for runlength encoding)
-  for j = 1, string.len(level) do
-    local ch = string.sub(level, j, j)
-    if tonumber(ch) then
-      -- add number for runlength encoding
-      count = 10*count + tonumber(ch)
-    elseif (ch == &quot;\n&quot;) or (ch == &quot;|&quot;) then
-      -- discard multiple newlines, e.g. from &quot;|\n&quot;
-      if table.getn(level_array[line]) ~= 0 then
-        line = line + 1
-        level_array[line] = {}
-        count = 0  -- discard empty counters
-      end
-    else
-      -- unify format: &quot;_&quot; and space become &quot;-&quot;
-      if (ch == &quot;_&quot;) or (ch == &quot; &quot;) then
-        ch = &quot;-&quot;
-      end
-      if count &lt; 1 then
-        count = 1
-      end
-      for j = 1, count do
-        table.insert(level_array[line], ch)
-      end
-      count = 0
-    end    
-  end
-  
-  -- normalize level width
-  local maxwidth = 0
-  local maxheight = table.getn(level_array)
-  for j = 1, maxheight do
-    maxwidth = math.max(maxwidth, table.getn(level_array[j]))
-  end
-  for j = 1, maxheight do
-    while table.getn(level_array[j]) &lt; maxwidth do
-      table.insert(level_array[j], &quot;-&quot;)
-    end
-  end  
-
-  -- mark outside floor fields from the border
-  local function check_for_outside(x, y)
-    if level_array[y][x] == &quot;-&quot; then
-      level_array[y][x] = &quot; &quot;
-      if y &gt; 1         then  check_for_outside(x, y - 1)  end
-      if y &lt; maxheight then  check_for_outside(x, y + 1)  end
-      if x &gt; 1         then  check_for_outside(x - 1, y)  end
-      if x &lt; maxwidth  then  check_for_outside(x + 1, y)  end
-    end
-  end
-  for y = 1, maxheight do
-    check_for_outside(1, y)
-    check_for_outside(maxwidth, y)
-  end
-  for x = 1, maxwidth do
-    check_for_outside(x, 1)
-    check_for_outside(x, maxheight)
-  end
-
-  -- replace redundant walls by outside
-  for x = 1, maxwidth do
-    for y = 1, maxheight do
-      if char_is_wall(level_array[y][x]) then
-        local redundant = true
-        for dx = -1, 1 do
-          for dy = -1, 1 do
-            local ch = (level_array[y+dy] or {})[x+dx] or &quot; &quot;
-            redundant = redundant
-                          and (char_is_wall(ch) or (ch == &quot; &quot;))
-          end
-        end
-        if redundant then
-          level_array[y][x] = &quot; &quot;
-        end
-      end
-    end
-  end
-
-  -- trim level
-  local border_n = maxheight
-  local border_s = 1
-  local border_w = maxwidth
-  local border_e = 1
-  for x = 1, maxwidth do
-    for y = 1, maxheight do
-      if not char_is_outf(level_array[y][x]) then
-        border_n = math.min(border_n, y)
-        border_s = math.max(border_s, y)
-        border_w = math.min(border_w, x)
-        border_e = math.max(border_e, x)        
-      end
-    end
-  end
-  if (border_n &gt;= border_s) or (border_w &gt;= border_e) then
-    lib.soko.error(&quot;libsoko: Level is empty or trimming code is corrupt.&quot;)
-  end
-  lib.soko.debug(&quot;N: &quot;..border_n..&quot;, S: &quot;..border_s
-      ..&quot;, W: &quot;..border_w..&quot;, E: &quot;..border_e)
-  local trimmed_array = {}
-  for y = border_n, border_s do
-    trimmed_array[y - border_n + 1] = {}
-    line = &quot;&quot;
-    for x = border_w, border_e do
-      trimmed_array[y - border_n + 1][x - border_w + 1] = level_array[y][x]
-      line = line .. level_array[y][x]
-    end
-    lib.soko.debug(&quot;|&quot;..line..&quot;|&quot;)
-  end
-  lib.soko.debug(table.getn(trimmed_array)..&quot; : &quot;..table.getn(trimmed_array[1]))
-  return trimmed_array
-end
-
 ------------------------------------------------------------------------
 -- Choosing the Designnumber, Random numbers
 ------------------------------------------------------------------------
@@ -672,9 +87,9 @@
 -- chaotic. To illustrate, why we don't use a simpler calculation
 -- using random seeds pseudo-random number generators, we expose on
 -- this nice mathematical problem a bit deeper. And although the
--- algorithm we use to determine design numbers is as well be used
--- in other situations in this library, we stick to the design number
--- as concrete example.
+-- algorithm we use to determine design numbers can as well be used
+-- in other situations, we stick to the design number as concrete
+-- example.
 --
 -- Main Problem:
 --
@@ -767,282 +182,814 @@
 -- See also: Landau function lib.soko.g(n) for determining the maximal
 --           order of an element in the symmetric group S(n).
 --
-function lib.soko.number_from_level(level_array, list_length)
-  local j = list_length + 1
-  lib.soko.debug(&quot;Calculating number from level_array, modulus &quot;..list_length..&quot; ...&quot;)
-  local l = 2
-  repeat
-    j = j - 1
-    b = 0
-    for y = 1, table.getn(level_array) do
-      for x = 1, table.getn(level_array[1]) do
-        if char_is_wall(level_array[y][x]) then
-          if 2*b + 1 &lt; j then
-            b = 2*b + 1
-          else
-            b = 2*(j-1-b)
-          end
+function lib.soko.number_from_level(map, list_length)
+    local j = list_length + 1
+    local l = 2
+    local b
+    repeat
+        j = j - 1
+        b = 0
+        for y = 1, map.height do
+            local line = map[y]
+            for x = 1, map.width do
+                -- works only for keylength = 2
+                if string.sub(line, 2*x - 1, 2*x - 1) == &quot;#&quot; then
+                    if 2*b + 1 &lt; j then
+                        b = 2*b + 1
+                    else
+                        b = 2 * (j - 1 - b)
+                    end
+                end
+                b = (b + 1) % j
+            end
         end
-        if b == j - 1 then
-          b = 0
+    until (b == 0) or (j == 1)
+    return j
+end
+
+function lib.soko.design_from_description(map, design_description, maxdesignnumber)
+    -- choose design
+    local design = {}
+    if type(design_description) == &quot;number&quot; then
+        design = lib.lua.deep_copy(lib.soko_designlist.list[design_description])
+    elseif type(design_description) == &quot;table&quot; then
+        design = lib.lua.deep_copy(design_description)
+    elseif (type(design_description) == &quot;nil&quot;) and (type(map) == &quot;table&quot;) then
+        design = lib.lua.deep_copy(lib.soko_designlist.list[lib.soko.number_from_level(
+                     map, maxdesignnumber or #lib.soko_designlist.list)])
+    else
+        error(&quot;lib.soko: Can't make sense of design type &quot;..type(design)..&quot;.&quot;, 2)
+    end
+    return design
+end
+
+------------------------------------------------------------------------
+-- Level Drawing
+------------------------------------------------------------------------
+
+function lib.soko.define_tiles(design)
+    local function field_to_tiles(field, key)
+        if type(field) == &quot;string&quot; then
+            if (field == &quot;st_door&quot;) or (field == &quot;st_door_d&quot;) then
+                lib.soko.resolver_info[key] = {RESOLVE_ORIENTED}
+                ti[key .. &quot;:&quot; .. NORTH] = {&quot;st_door&quot;, faces = &quot;sn&quot;}
+                ti[key .. &quot;:&quot; .. SOUTH] = {&quot;st_door&quot;, faces = &quot;sn&quot;}
+                ti[key .. &quot;:&quot; .. EAST] = {&quot;st_door&quot;, faces = &quot;ew&quot;}
+                ti[key .. &quot;:&quot; .. WEST] = {&quot;st_door&quot;, faces = &quot;ew&quot;}
+            else
+                ti[key] = {field}
+            end
+        elseif usertype(field) == &quot;tile&quot; then
+            ti[key] = field
+        elseif type(field) == &quot;nil&quot; then
+            ti[key] = {}
+        elseif type(field) == &quot;table&quot; then
+            for j, subfield in pairs(field) do
+                if j ~= &quot;res&quot; then
+                    field_to_tiles(subfield, key .. &quot;:&quot; .. j)
+                end
+            end
+            -- We collect all neccessary information for the resolver.
+            if type(field.res) == &quot;nil&quot; then
+                lib.soko.resolver_info[key] = {RESOLVE_ALL}
+            elseif type(field.res) == &quot;number&quot; then
+                lib.soko.resolver_info[key] = {field.res}
+            elseif type(field.res) == &quot;table&quot; then
+                lib.soko.resolver_info[key] = field.res
+            else
+                error(&quot;lib.soko.define_tiles: Can't understand type &quot; .. type(field.res)
+                    .. &quot; in resolver info for key '&quot; .. key .. &quot;'.&quot;, 2)
+            end
+            lib.soko.resolver_info[key]._count = #field
+            -- For RESOLVE_RANDOM, we calculate the total frequency,
+            -- so we don't have to do it during resolution, and fill
+            -- in missing values.
+            if lib.soko.resolver_info[key][1] == RESOLVE_RANDOM then
+                local frequency_sum = 0
+                for j = 1, lib.soko.resolver_info[key]._count do
+                    local freq = lib.soko.resolver_info[key][j + 1]
+                    if not freq then
+                        lib.soko.resolver_info[key][j + 1] = 1
+                        freq = 1
+                    elseif (type(freq) ~= &quot;number&quot;) or (freq &lt; 0) then
+                        error(&quot;lib.soko.define_tiles: Frequency values must be &quot;
+                            .. &quot;non-negative (key '&quot; .. key .. &quot;').&quot;, 2)
+                    end
+                    frequency_sum = frequency_sum + freq
+                end
+                lib.soko.resolver_info[key]._sum = frequency_sum
+            end
         else
-          b = b + 1
+            error(&quot;lib.soko.define_tiles: Can't understand type &quot; .. type(field)
+                .. &quot; in design description for key '&quot; .. key .. &quot;'.&quot;, 2)
         end
-      end
+    end 
+
+    for key, field_name in pairs(lib.soko.keys_to_field_names) do
+        field_to_tiles(lib.soko_designlist.default[field_name], key .. &quot;:1&quot;)
+        field_to_tiles(design[field_name], key .. &quot;:2&quot;)
+        lib.soko.resolver_info[key] = {RESOLVE_ALL, _count = 2}
+        field_to_tiles(design.endp[field_name], key .. &quot;:endp&quot;)
     end
-  until (b == 0) or (j == 1)
-  lib.soko.debug(&quot;Calculation ended. Result: &quot;..j)
-  return j
+
+    ti[&quot;O &quot;] = {&quot;st_oxyd&quot;, &quot;oxyd#&quot;, flavor = design.oxyd or lib.soko_designlist.default.oxyd}
+    if design.white then
+        ti[&quot;@ &quot;] = {&quot;#ac_marble_white&quot;, &quot;marble#&quot;, owner = YIN, controllers = CTRL_YIN}
+        ti[&quot;n &quot;] = {&quot;st_chess_white&quot;}
+    else
+        ti[&quot;@ &quot;] = {&quot;#ac_marble&quot;, &quot;marble#&quot;}
+        ti[&quot;n &quot;] = {&quot;st_chess&quot;}
+    end    
 end
 
-function lib.soko.design_from_level(level_array, list_length)
-  return lib.soko.design_list[lib.soko.number_from_level(level_array,
-            list_length or table.getn(design_list))]
+function lib.soko.resolver(key, x, y)
+    local method = (lib.soko.resolver_info[key] or {})[1]
+    local count = (lib.soko.resolver_info[key] or {})._count
+    local resolve_to = nil
+    if not method then
+        return ti[key]
+    elseif method == RESOLVE_ALL then
+        local tile = ti{}
+        for j = 1, count do
+            tile = tile .. lib.soko.resolver(key .. &quot;:&quot; .. j, x, y)
+        end
+        return tile
+    elseif method == RESOLVE_RANDOM then
+        resolve_to = 1
+        local r = math.random(lib.soko.resolver_info[key]._sum)
+        local s = lib.soko.resolver_info[key][resolve_to + 1]
+        while (s &lt; r) and (resolve_to &lt; count) do
+            resolve_to = resolve_to + 1
+            s = s + lib.soko.resolver_info[key][resolve_to + 1]
+        end
+    elseif method == RESOLVE_CHECKERBOARD then
+        resolve_to = (((x%2) + (y%2)) % count) + 1
+    elseif method == RESOLVE_LINES then
+        resolve_to = ((x + y) % count) + 1
+    elseif method == RESOLVE_WAVES then
+        resolve_to = ((x + y * y + x*y*x + 3*y*x*y*x) % count) + 1
+    elseif method == RESOLVE_ORIENTED then
+        resolve_to = lib.soko.area[po(x,y)].orientation
+    -- Unknown method, throw error.
+    elseif type(method) == &quot;number&quot; then
+        error(&quot;lib.soko.resolver: Unknown resolver method number &quot;
+            .. method .. &quot;.&quot;, 2)
+    else
+        error(&quot;lib.soko.resolver: Unknown resolver method of &quot;
+            .. &quot; type '&quot; .. type(method) .. &quot;', usertype '&quot;
+            .. usertype(method) .. &quot;').&quot;, 2)
+    end
+    if resolve_to then
+        return lib.soko.resolver(key .. &quot;:&quot; .. resolve_to, x ,y)
+    else
+        return ti{}
+    end
 end
 
--- design_from_description takes a description of the design as argument
--- and returns the corresponding table. A description can be:
---  - a table specifying the design by itself
---  - a number specifying the number of the design in the design list
---  - &quot;nil&quot; plus a level_array from which a design from the design
---    list will be chosen.
-function lib.soko.design_from_description(design_description, level_array, maxdesignnumber)
-  -- choose design
-  local design = {}
-  if type(design_description) == &quot;number&quot; then
-    design = lib.lua.deep_copy(lib.soko.design_list[design_description])
-  elseif type(design_description) == &quot;table&quot; then
-    design = lib.lua.deep_copy(design_description)
-  elseif (type(design_description) == &quot;nil&quot;) and (type(level_array) == &quot;table&quot;) then
-    design = lib.lua.deep_copy(lib.soko.design_from_level(level_array, maxdesignnumber))
-  else
-    lib.soko.error(&quot;Can't make sense of design type &quot;..type(design)..&quot;.&quot;)
-  end
-  -- fill chosen design with default values where neccessary
-  design = lib.lua.combine_tables({design, lib.soko.default_design})
-  -- No stone set for outf, not even &quot;st_nil&quot;?
-  -- Use the default outf-stone instead, and remove it on endphase.
-  if type(design.outf) ~= &quot;table&quot; then
-    design.outf = {design.outf}
-  end
-  for j, v in pairs(design.outf) do
-    if is_stone(v) then
-      return design
+function lib.soko.resolver_endphase(key, x, y)
+    local key1 = string.sub(key, 1, 1) .. &quot; &quot; .. &quot;:endp&quot;
+    local key2 = &quot; &quot; .. string.sub(key, 2, 2) .. &quot;:endp&quot;
+    return    (lib.soko.resolver(key1, x, y) or ti{})
+           .. (lib.soko.resolver(key2, x, y) or ti{})
+end
+
+------------------------------------------------------------------------
+-- Attributes and Endphase Preparation
+------------------------------------------------------------------------
+
+function lib.soko.setup_attributes_and_polists(map)
+    lib.soko.polist = {}
+    for _, field in pairs({&quot;way&quot;, &quot;wall&quot;, &quot;outf&quot;, &quot;goal&quot;, &quot;wall_one&quot;, &quot;wall_two&quot;}) do
+        lib.soko.polist[field] = po(grp({}))
     end
-  end
-  table.insert(design.outf, lib.soko.default_design.outf_default_stone)
-  if type(design.endp.outf) ~= &quot;table&quot; then
-    design.endp.outf = {design.endp.outf}
-  end
-  for j, v in pairs(design.endp.outf) do
-    if is_stone(v) then
-      return design
+    local function mark_as(pos, field)
+        lib.soko.polist[field] = lib.soko.polist[field] .. pos
+        lib.soko.area[pos][&quot;is_&quot;..field] = true
     end
-  end
-  table.insert(design.endp.outf, &quot;st_nil&quot;)  
-  return design
+    for x = 0, map.width do
+        for y = 0, map.height do
+            local key = map[{x,y}]
+            local key1 = string.sub(key, 1, 1)
+            local key2 = string.sub(key, 2, 2)
+                if key1 == &quot; &quot; then  mark_as(po(x,y), &quot;way&quot;)
+            elseif key1 == &quot;-&quot; then  mark_as(po(x,y), &quot;outf&quot;)
+            elseif key1 == &quot;$&quot; then  mark_as(po(x,y), &quot;way&quot;)
+                                     st(x,y):set({name = &quot;box#&quot;})
+            elseif key1 == &quot;#&quot; then  mark_as(po(x,y), &quot;wall&quot;)
+            elseif key1 == &quot;@&quot; then  mark_as(po(x,y), &quot;way&quot;)
+            elseif key1 == &quot;n&quot; then  mark_as(po(x,y), &quot;way&quot;)
+                                     st(x,y):set({name = &quot;chess#&quot;})
+            end
+            if key2 == &quot;.&quot; then
+                mark_as(po(x,y), &quot;goal&quot;)
+                it(x,y):set({name = &quot;goal#&quot;, safeaction = true, target = &quot;lib_soko_goal_trigger&quot;})
+                if (key1 == &quot;$&quot;) or (key1 == &quot;n&quot;) then
+                    it(x,y)._completed = true
+                    lib.soko.initially_completed_goals = lib.soko.initially_completed_goals + 1
+                else
+                    it(x,y)._completed = false
+                end
+            end
+        end
+    end
+    
+    lib.soko.polist.inf = lib.soko.polist.way .. lib.soko.polist.wall
+
+    -- polist.wall_one
+    -- There are three conditions for an element of polist.wall_one:
+    -- (i) it's a wall, (ii) it's near or diagonal to outside,
+    -- (iii) it's near a way.
+    -- In addition, it counts the number of near ways.
+    for i = 1, #lib.soko.polist.wall do
+        local pos = lib.soko.polist.wall[i]
+        local outside = false
+        for j = 1, #NEIGHBORS_8 do
+            local delta = NEIGHBORS_8[j]
+            outside = outside or lib.soko.area[pos + delta].is_outf
+        end
+        if outside then
+            local count = 0
+            local last_orientation
+            for _, dir in ipairs({{N, NORTH}, {S, SOUTH}, {E, EAST}, {W, WEST}}) do
+                if lib.soko.area[pos + dir[1]].is_way then
+                    count = count + 1
+                    last_orientation = dir[2]
+                end
+            end
+            if count &gt; 0 then
+                mark_as(pos, &quot;wall_one&quot;)
+                lib.soko.area[pos].ways = count
+                if count == 1 then
+                    lib.soko.area[pos].orientation = last_orientation
+                end
+            end
+        end
+    end
+    -- polist.wall_two
+    -- There are three conditions for an element of polist.wall_two:
+    -- (i) it's near a wall_one, (ii) it's not a wall_one,
+    -- (iii) it's wall or outside. In addition, the neighboring
+    -- wall_one are added into the list.
+    for i = 1, #lib.soko.polist.wall_one do
+        local wall_one = lib.soko.polist.wall_one[i]
+        for j = 1, #NEIGHBORS_4 do
+            local delta = NEIGHBORS_4[j]
+            local check = wall_one + delta
+            if not (lib.soko.area[check].is_way or lib.soko.area[check].is_wall_one) then
+                mark_as(check, &quot;wall_two&quot;)
+                lib.soko.area[check].wall_one =
+                    (lib.soko.area[check].wall_one or po(grp({}))) .. wall_one
+            end
+        end
+    end
 end
 
+function lib.soko.prepare_endphase(map, design)
+    -- ensure existence of goals
+    if #lib.soko.polist.goal &lt; 1 then
+        error(&quot;libsoko: No goals defined.&quot;, 2)
+    end
+    -- ensure a correctly set endphase-attribute
+    if not design.endp then
+        design.endp = lib.lua.deep_copy(lib.soko_designlist.default.endp)
+    end
+    if type(design.endp) ~= &quot;table&quot; then
+        error(&quot;lib.soko.prepare_endphase: This design's endphase is given as &quot;
+            .. type(design.endp) .. &quot;, but should be table.&quot;)
+    end
+    if design.endp.alg == nil then
+        design.endp.alg = lib.lua.deep_copy(lib.soko_designlist.default.endp.alg)
+    end
+    if type(design.endp.alg) ~= &quot;string&quot; then
+        error(&quot;lib.soko.prepare_endphase: This design's endphase algorithm &quot;
+            .. &quot;is given as &quot; .. type(design.endp.alg) ..&quot;, but should be string.&quot;)
+    end
 
+    -- save map and design for later
+    lib.soko.map = map
+    lib.soko.design = design
+    
+    -- prepare oxyds and blockers (a &quot;blocker&quot; is a generalized door)
+    local alg = design.endp.alg
+    if       (alg == &quot;circle&quot;)
+          or (alg == &quot;hide&quot;)
+          or (alg == &quot;fourswitch&quot;)
+          or (alg == &quot;gradients&quot;)
+          or (alg == &quot;magnets&quot;) then
+        -- nothing to prepare
+    elseif   (alg == &quot;ralf&quot;)
+          or (alg == &quot;allcrack&quot;)
+          or (alg == &quot;vortex&quot;) then
+        -- design.door or design.wall or &quot;st_nil&quot;
+        lib.soko.goal_hook = GOAL_HOOK_RALF
+        lib.soko.endphase_set_block_oxyds(design.endp.max_pairs)
+    elseif   (alg == &quot;block&quot;) then
+        lib.soko.endphase_set_block_oxyds(design.endp.max_pairs)
+    elseif   (alg == &quot;outside&quot;) then
+        lib.soko.endphase_set_outside_oxyds(design.endp.max_pairs)
+    elseif   (alg == &quot;knock&quot;) then
+        lib.soko.endphase_set_block_oxyds(tonumber(design.endp.max_pairs) or 3)
+        lib.soko.endphase_set_knocking()
+    else
+        error(&quot;lib.soko.prepare_endphase: Endphase algorithm &quot; .. alg .. &quot; unknown.&quot;, 2)
+    end
+end
+
 ------------------------------------------------------------------------
--- Interface functions
+-- Goal Trigger and Endphase Main Functions
 ------------------------------------------------------------------------
 
--- create_sokoball creates a sokoball-level from the string LEVEL.
--- This string can be a multilevel, in which case SUBLEVEL determines
--- the number of the level, starting with 1. Default is 1.
--- The design can be chosen by the DESIGN variable. This is either
--- a number (see section &quot;Designs&quot;) or a table with the corresponding
--- design entries. A missing entry will be interpreted as the entry
--- from default_design. If the DESIGN variable is omitted, a check-
--- number is created from LEVEL which uniquely* determines a design
--- from the design list, with MAXDESIGNNUMBER as highest possible
--- design number. *Uniquely means: The design might change when the
--- design list is enlarged.
--- Returns width and height of new level.
---
-function lib.soko.create_sokoball(level, sublevel, design, maxdesignnumber)
-  -- check that this is the first sokoarea, and initialise it.
-  if type(lib.soko.sokoarea) ~= &quot;table&quot; then
-    lib.soko.error(&quot;No sense in sokoarea of type &quot;..type(sokoarea)..&quot;.&quot;)
-  end
-  if table.getn(lib.soko.sokoarea) ~= 0 then
-    lib.soko.error(&quot;Tried to use create_sokoball twice. Use draw_sokoball instead.&quot;)
-  end
-  lib.soko.new_sokoarea()
+function lib_soko_goal_trigger(is_on, sender)
+    if lib.soko.endphase_started then
+        return
+    end
+    if (-wo:st(sender)) ~= sender._completed then
+        sender._completed = -wo:st(sender)
+        if lib.soko.goal_hook == GOAL_HOOK_RALF then
+            lib.soko.endphase_goal_hook_ralf(sender)
+        end
+        no[&quot;goal_counter&quot;]:signal(sender._completed)
+    end
+end
 
-  -- unpack level
-  lib.soko.sokoarea[1].level_array = lib.soko.unpack_level(level, sublevel)
+function lib_soko_endphase()
+    -- Correct structure of endp-attribute has been checked
+    -- by prepare_endphase, we trust it blindly.
+    lib.soko.endphase_started = true
+    local endp = lib.lua.deep_copy(lib.soko.design.endp)
+    local alg = endp.alg
+    local marbles = no[&quot;marble#*&quot;]
+    -- redraw level and give items
+    wo:drawMap(lib.soko.resolver_endphase, po(0,0), lib.soko.map)
+    local give = lib.lua.deep_copy(endp.give)
+    if type(give) == &quot;string&quot; then
+        give = {{give}}
+    elseif usertype(give) == &quot;tile&quot; then
+        give = {give}
+    end
+    if type(give) == &quot;table&quot; then
+        for _, v in pairs(give) do
+            if (type(v) == &quot;string&quot;) and string.find(v, &quot;ac_&quot;) then
+                wo[marbles] = {v}
+            elseif (type(v) == &quot;table&quot;) and string.find(v[1], &quot;ac_&quot;) then
+                wo[marbles] = v
+            elseif v == &quot;rubberball&quot; then
+                local kind = lib.lua.cond(design.white, &quot;#ac_marble&quot;, &quot;#ac_marble_white&quot;)
+                for j = 1, #marbles do
+                    wo[marbles[j]] = {kind, &quot;rubberball_&quot; .. j, controllers = CTRL_NONE}
+                    wo:add({&quot;ot_rubberband&quot;, anchor1 = &quot;rubberball_&quot; .. j,
+                        anchor2 = marbles[j], strength = 50})
+                end
+            elseif type(v) == &quot;string&quot; then
+                wo:add(YIN, {v})
+            else
+                wo:add(YIN, v)
+            end
+        end
+    elseif type(give) ~= &quot;nil&quot; then
+        error(&quot;libsoko: Error in design: Can't give something of type &quot;..type(v)..&quot;.&quot;, 2)
+    end
 
-  -- calculate screen position
-  -- Important Note: level_array is reversely indexed, i.e.
-  --                 level_array[y-coordinate][x-coordinate]
-  lib.soko.sokoarea[1].array_width = table.getn(lib.soko.sokoarea[1].level_array[1])
-  lib.soko.sokoarea[1].array_height = table.getn(lib.soko.sokoarea[1].level_array)
-  lib.soko.sokoarea[1].uses_chess = lib.soko.check_chess(1)
-  local levelw = math.max(lib.soko.sokoarea[1].array_width, 20)
-  local levelh = math.max(lib.soko.sokoarea[1].array_height, 13)
-  lib.soko.sokoarea[1].level_width = levelw
-  lib.soko.sokoarea[1].level_height = levelh
-  ti[&quot; &quot;] = {&quot;fl-abyss&quot;}
-  wo(ti, &quot; &quot;, levelw, levelh)
-  
-  -- calculate padding
-  local dx = 0
-  local dy = 0
-  if levelw &gt; lib.soko.sokoarea[1].array_width then
-    dx = math.floor((levelw - lib.soko.sokoarea[1].array_width) / 2)
-  end
-  if levelh &gt; lib.soko.sokoarea[1].array_height then
-    dy = math.floor((levelh - lib.soko.sokoarea[1].array_height) / 2)
-  end
-  lib.soko.sokoarea[1].offset = po({dx, dy})
+    if alg == &quot;circle&quot; then
+        lib.soko.endphase_circle()
+    elseif alg == &quot;outside&quot; then
+        -- Don't do anything; redrawing the level was enough.
+    elseif alg == &quot;hide&quot; then
+        lib.soko.endphase_set_hide_oxyds(endp.max_pairs)
+    elseif    (alg == &quot;ralf&quot;)
+           or (alg == &quot;outside&quot;)
+           or (alg == &quot;block&quot;) then
+        lib.soko.endphase_ralf_open_doors()
+    elseif alg == &quot;allcrack&quot; then
+        lib.soko.endphase_ralf_open_doors()
+        lib.soko.endphase_allcrack()
+    elseif alg == &quot;fourswitch&quot; then
+        lib.soko.endphase_fourswitch()
+    elseif alg == &quot;vortex&quot; then
+        lib.soko.endphase_ralf_open_doors()
+        lib.soko.endphase_vortex()
+    elseif alg == &quot;gradients&quot; then
+        lib.soko.endphase_set_hide_oxyds(endp.max_pairs)
+        lib.soko.endphase_gradients(endp.strength)
+    elseif alg == &quot;magnets&quot; then
+        lib.soko.endphase_set_hide_oxyds(endp.max_pairs)
+        lib.soko.endphase_magnets(endp.strength)
+    elseif alg == &quot;knock&quot; then
+        -- Don't do anything; endphase_call_knocking queries endphase_started.
+    else
+        -- Use default: &quot;circle&quot;
+        lib.soko.endphase_circle()
+    end
+end
 
-  -- calculate design
-  lib.soko.sokoarea[1].design =
-    lib.soko.design_from_description(design, lib.soko.sokoarea[1].level_array, maxdesignnumber)
+------------------------------------------------------------------------
+-- Endphase and Endphase Preparation Smaller Functions
+------------------------------------------------------------------------
 
-  -- create special position lists
-  lib.soko.create_lists(nr)
-  
-  -- draw level
-  for x = 0, levelw - 1 do
-    for y = 0, levelh - 1 do
-      lib.soko.set_element(po({x,y}), 1, &quot;outf&quot;)
+function lib.soko.endphase_circle()
+    if (not no[&quot;marble#*&quot;]) or (#no[&quot;marble#*&quot;] == 0) then
+       error(&quot;lib.soko.endphase_circle: Internal error: Marble not found.&quot;, 2)
     end
-  end
-  lib.soko.draw_level_array(1, true, true)
-  
-  -- prepare oxyds for end phase
-  lib.soko.prepare_endphase(1)
+    local pos = po(no[&quot;marble#*&quot;][1])
+    if pos.x &gt; 10 then  pos = pos + {-2,0}  end
+    if pos.y &gt;  6 then  pos = pos + {0,-2}  end
+    st(NEIGHBORS_8 + (pos + po(1, 1))):kill()
+    it(NEIGHBORS_8 + (pos + po(1, 1))):kill()
+    ti[&quot;Q &quot;] = {&quot;st_quake&quot;}
+    wo:drawMap(lib.soko.resolver, pos + po(-1, -1), &quot;i &quot;, {
+        &quot;i O O O i &quot;,
+        &quot;O       O &quot;,
+        &quot;O   Q   O &quot;,
+        &quot;O       O &quot;,
+        &quot;i O O O i &quot;})
+    wo:shuffleOxyd()
+    if #no[&quot;marble#*&quot;] &gt; 1 then
+        wo:add(YIN, {&quot;it_hammer&quot;})
+    end
+end
 
-  -- Enigma's global variables
-  wo[&quot;ConserveLevel&quot;] = false
-  wo[&quot;ShowMoves&quot;] = true
-  wo[&quot;FollowGrid&quot;] = false
-  wo[&quot;FollowMethod&quot;] = FOLLOW_SCROLL
+function lib.soko.endphase_set_hide_oxyds(max_pairs)
+    local places = fl(lib.soko.polist.wall_one)
+    -- choose number of oxyds
+    local number_pairs = lib.math.steps(#places, {2, 6, 10, 30}) + 1
+    if number_pairs &lt; 2 then
+        -- use circle instead
+        lib.soko.endphase_circle()
+        return
+    end
+    if max_pairs and tonumber(max_pairs) then
+        number_pairs = math.min(tonumber(max_pairs), number_pairs)
+    end
+    places = (places:shuffle()):sub(2 * number_pairs)
+    -- Draw the oxyds and save positions in map and polists.
+    wo[places] = ti[&quot;O &quot;]
+    wo:shuffleOxyd()
+    lib.soko.map[po(places)] = &quot;O &quot;
+    lib.soko.polist.oxyd = po(places)
+    for _, field in pairs({&quot;outf&quot;, &quot;wall&quot;, &quot;wall_one&quot;, &quot;wall_two&quot;}) do
+        lib.soko.polist[field] = po(fl(lib.soko.polist[field]) - places)
+    end
+end
 
-  -- return level width and height
-  return levelw, levelh
+function lib.soko.endphase_set_block_oxyds(max_pairs)
+    local oxyds = po(grp({}))
+    local blockers = po(grp({}))    
+    -- Add all wall_one-elements with exactly one way near as blocker,
+    -- and the opposite position as oxyd, if it is of type wall_two.
+    -- Make sure that each possible oxyd position is assigned at most once,
+    -- and that no other oxyds or blockers are near.
+    for j = 1, #lib.soko.polist.wall_one do
+        local blocker = lib.soko.polist.wall_one[j]
+        if lib.soko.area[blocker].ways == 1 then
+            for k = 1, #NEIGHBORS_4 do
+                local dir = NEIGHBORS_4[k]
+                if     lib.soko.area[blocker + dir].is_way
+                   and lib.soko.area[blocker - dir].is_wall_two then
+                    -- Check that no oxyd has been set on this position before and
+                    -- no other oxyd or blocker is near the new oxyd or its blocker.
+                    local occupied = false
+                    for l = 1, #oxyds do
+                        occupied = occupied
+                            or (lib.math.manhattan_distance(blockers[l], blocker) &lt;= 1)
+                            or (lib.math.manhattan_distance(oxyds[l],    blocker) &lt;= 1)
+                            or (lib.math.manhattan_distance(blockers[l], blocker - dir) &lt;= 1)
+                            or (lib.math.manhattan_distance(oxyds[l],    blocker - dir) &lt;= 1)
+                    end
+                    if not occupied then
+                        lib.soko.area[blocker].oxyd = blocker - dir
+                        lib.soko.area[blocker - dir].blocker = blocker
+                        lib.soko.area[blocker].way = blocker + dir
+                        blockers = blockers .. blocker
+                        oxyds = oxyds .. (blocker - dir)
+                    end
+                end
+            end
+        end
+    end
+    -- Choose some appropriate subset
+    local number_pairs = lib.math.steps(#oxyds, {4, 8, 16, 28}) + 1
+    if number_pairs &lt; 2 then
+        -- Not enough places? Choose &quot;circle&quot;-algorithm instead.
+        lib.soko.design.endp.alg = &quot;circle&quot;
+        return
+    end
+    if max_pairs and tonumber(max_pairs) and (tonumber(max_pairs) &gt;= 1) then
+        number_pairs = math.min(tonumber(max_pairs), number_pairs)
+    end
+    oxyds = (fl(oxyds):shuffle()):sub(2 * number_pairs)
+    -- Draw the oxyds and save positions in map and polists.
+    wo[oxyds] = ti[&quot;O &quot;]
+    wo:shuffleOxyd()
+    lib.soko.map[oxyds] = &quot;O &quot;
+    lib.soko.polist.oxyd = po(oxyds)
+    lib.soko.polist.blocker = po(grp({}))
+    for ox in oxyds do
+        local blocker = lib.soko.area[po(ox)].blocker
+        lib.soko.polist.blocker = lib.soko.polist.blocker .. blocker
+        wo[blocker] =    lib.soko.resolver(&quot;# &quot;, blocker.x, blocker.y)
+                      .. lib.soko.resolver(&quot;D &quot;, blocker.x, blocker.y)
+    end
+    blockers = fl(lib.soko.polist.blocker)
+    lib.soko.map[blockers] = &quot;D &quot;
+    for _, field in pairs({&quot;outf&quot;, &quot;wall&quot;, &quot;wall_one&quot;, &quot;wall_two&quot;}) do
+        lib.soko.polist[field] = po((fl(lib.soko.polist[field]) - oxyds) - blockers)
+    end
+    -- Assign goals to blockers.
+    -- Note: There might be more goals as blockers, and, vice versa,
+    --       there might be more blockers as goals.
+    local goals = fl(lib.soko.polist.goal):shuffle()
+    for j = 2, math.min(#goals, #blockers) do
+        lib.soko.area[po(goals[j])].open = po(blockers[j])
+        if lib.soko.goal_hook == GOAL_HOOK_RALF then
+            lib.soko.endphase_ralf_open_door(it(goals[j])._completed, po(blockers[j]))
+        end
+    end
 end
 
--- recreate_sokoball is used for design development only.
--- It redraws the sokoarea with number sokoarea_number (or 1)
--- from scratch, but not the world and doesn't add another
--- actor.
---
-function lib.soko.recreate_sokoball(design, maxdesignnumber, sokoarea_number)
-  local nr = sokoarea_number or 1
+function lib.soko.endphase_set_outside_oxyds(max_pairs)
+    local places = grp({})  -- a group of floors
+    -- Select all places outside or in the walls, unreachable
+    -- for the marble.
+    local common_list = lib.soko.polist.outf .. lib.soko.polist.wall_two
+    for j = 1, #common_list do
+        if (common_list[j].x % 2 == 0) and (common_list[j].y % 2 == 0) then
+            places = places + fl(common_list[j])
+        end
+    end
+    -- Choose some appropriate subset
+    local number_pairs = lib.math.steps(#places, {2, 20, 50, 100}) + 1
+    if number_pairs &lt; 2 then
+        -- Not enough places? Then choose the four corners. They should always
+        -- be at least wall_two and far enough away from each other.
+        places = grp(fl(lib.soko.map.width - 1, 0), fl(0, lib.soko.map.height - 1),
+            fl(0,0), fl(lib.soko.map.width - 1, lib.soko.map.height - 1))
+        number_pairs = 2
+    end
+    if max_pairs and tonumber(max_pairs) then
+        number_pairs = math.min(tonumber(max_pairs), number_pairs)
+    end
+    places = (places:shuffle()):sub(2 * number_pairs)
+    -- Draw the oxyds and save positions in map and polists.
+    wo[places] = ti[&quot;O &quot;]
+    wo:shuffleOxyd()
+    lib.soko.map[po(places)] = &quot;O &quot;
+    lib.soko.polist.oxyd = po(places)
+    for _, field in pairs({&quot;outf&quot;, &quot;wall&quot;, &quot;wall_one&quot;, &quot;wall_two&quot;}) do
+        lib.soko.polist[field] = po(fl(lib.soko.polist[field]) - places)
+    end
+end
 
-  lib.soko.sokoarea[nr].design =
-      lib.soko.design_from_description(design, lib.soko.sokoarea[nr].level_array, maxdesignnumber)
+function lib.soko.endphase_set_knocking()
+    local blockers = po(fl(lib.soko.polist.blocker):shuffle())
+    -- set attributes of doors
+    for j = 1, #blockers do
+        if -st(blockers[j]) then
+            st(blockers[j]):set({action = &quot;callback&quot;, target = &quot;lib_soko_endphase_call_knocking&quot;,
+                _close = blockers[(j % #blockers) + 1], _number = j,
+                _open = blockers[((j + 1) % #blockers) + 1]})
+        end
+    end
+end
 
-  if lib.soko.sokoarea[nr].level_width and lib.soko.sokoarea[nr].level_height then
-    for x = 0, lib.soko.sokoarea[nr].level_width - 1 do
-      for y = 0, lib.soko.sokoarea[nr].level_height - 1 do
-        wo:st(x, y):kill()
-        wo:it(x, y):kill()
-        lib.soko.set_element(po({x,y}), nr, &quot;outf&quot;)
-      end
+function lib_soko_endphase_call_knocking(is_on, sender)
+    -- Deactivate the first door until endphase has started.
+    if (tonumber(sender._number) ~= 1) or lib.soko.endphase_started then
+        -- Open or close the neccessary doors given as attributes.
+        st(sender._close):close()
+        st(sender._open ):open()
     end
-  else
-    for x = 0, lib.soko.sokoarea[nr].array_width - 1 do
-      for y = 0, lib.soko.sokoarea[nr].array_height - 1 do
-        local abs = lib.soko.sokoarea[nr].offset + {x,y}
-        wo:st(abs):kill()
-        wo:it(abs):kill()
-        lib.soko.set_element(abs, nr, &quot;outf&quot;)
-      end
+end
+
+function lib.soko.endphase_fourswitch()
+    local places = fl(lib.soko.polist.wall_one):shuffle()
+    -- choose number of fourswitchs/oxyds
+    local number_pairs = lib.math.steps(#places, {2, 6, 10}) + 1
+    if number_pairs &lt; 2 then
+        -- use circle instead
+        lib.soko.endphase_circle()
+        return
     end
-  end
+    places = po(places:sub(2 * number_pairs))
+    -- set fourswitchs
+    for j = 1, #places do
+        wo[places[j]] = {&quot;st_fourswitch&quot;, _number = j, _correct = false,
+            target = &quot;lib_soko_endphase_call_fourswitch&quot;, safeaction = true}
+        lib.soko.area[places[j]].current = NORTH
+        lib.soko.area[places[j]].solve = ({NORTH, SOUTH, EAST, WEST})[random(1,4)]
+    end
+    lib.soko.fourswitchs = places
+end
 
-  lib.soko.sokoarea[nr].number_goals = 0
-  lib.soko.sokoarea[nr].goals_filled = 0
-  lib.soko.sokoarea[nr].endphase_started = false
-  lib.soko.sokoarea[nr].goal_to_blocker = {}
-  lib.soko.sokoarea[nr].list_goal = {}
-  lib.soko.sokoarea[nr].list_oxyd = {}
-  lib.soko.sokoarea[nr].list_blocker = {}
-  lib.soko.sokoarea[nr].number_oxyds = 0
-  lib.soko.sokoarea[nr].goal_to_blocker = {}
-  lib.soko.sokoarea[nr].goal_hook = nil
-  lib.soko.sokoarea[nr].endphase_hook = lib.soko.ENDPHASE_HOOK_DEFAULT
+function lib_soko_endphase_call_fourswitch(is_on, sender)
+    local j = sender._number
+    lib.soko.area[po(sender)].current = sender.state
+    -- When count is correct, make it &quot;st_fake_oxyda&quot;.
+    if sender.state == lib.soko.area[po(sender)].solve then
+        wo[sender] = {&quot;st_fake_oxyda&quot;, state = OPEN, _correct = true}
+    end
+    -- If it's the first fourswitch (the one fourswitch that doesn't change
+    -- any other), check all fourswitchs and replace them by oxyds if all
+    -- are correct. Else, recreate the next fourswitch in hierarchy. Call
+    -- it once by toggling. This means: Recursion!
+    if j == 1 then
+        -- Check all fourswitchs, replace by oxyds if all are correct.
+        for k = 1, #lib.soko.fourswitchs do
+            if not st(lib.soko.fourswitchs[k])._correct then
+                return
+            end
+        end
+        wo[lib.soko.fourswitchs] = ti[&quot;O &quot;]
+        wo:shuffleOxyd()
+    else
+        -- Trigger all lower fourswitchs and recreate if neccessary.
+        if st(lib.soko.fourswitchs[j - 1])._correct then
+            wo[lib.soko.fourswitchs[j - 1]] = {&quot;st_fourswitch&quot;, _number = j - 1,
+                target = &quot;lib_soko_endphase_call_fourswitch&quot;, safeaction = true,
+                state = lib.soko.area[lib.soko.fourswitchs[j - 1]].current, _correct = false}
+        end
+        st(lib.soko.fourswitchs[j - 1]):toggle()
+    end  
+end
 
-  --lib.soko.sokoarea[nr].list_outside = {}
-  --lib.soko.sokoarea[nr].list_wall = {}
-  --lib.soko.sokoarea[nr].list_way = {}
-  --lib.soko.sokoarea[nr].list_wall_one = {}
-  --lib.soko.sokoarea[nr].list_wall_two = {}
+function lib.soko.endphase_vortex()
+    local list_way = (fl(lib.soko.polist.way) + fl(lib.soko.polist.blocker))
+                                              - fl(lib.soko.polist.goal)
+    local component = {}
+    list_way._component = nil
+    -- Analyse connected components of list_way
+    local function mark_component(floor, current)
+        if not floor._component then
+            floor._component = current
+            component[current].floors = component[current].floors + floor
+            for next_floor in fl(NEIGHBORS_4 + po(floor)) * list_way do
+                mark_component(next_floor, current)
+            end
+        end
+    end
+    for floor in list_way do
+        if not floor._component then
+            component[1 + #component] = {has_oxyds = false, floors = grp({})}
+            mark_component(floor, #component)
+        end    
+    end
+    -- If only one component, exit, player will find his or her way alone.
+    if #component &lt; 2 then
+        return
+    end
+    -- Analyse oxyds and to which components they belong to.
+    for floor in fl(lib.soko.polist.blocker) do
+        if floor._component then
+            component[floor._component].has_oxyds = true
+        else
+            error(&quot;lib.soko.endphase_vortes: Error in component calculation.&quot;, 2)
+        end
+    end  
+    -- Let there be at most max(5, number-of-oxyd-components)
+    -- components, plus the one the marble actually occupies.
+    local t = {}  -- helper table: components with oxyds or marble
+    local u = {}  -- helper table: all components except t
+    local marble_component = fl(no[&quot;marble#*&quot;][1])._component
+    for j = 1, #component do
+        if component[j].has_oxyds or (j == marble_component) then
+            table.insert(t, component[j])
+        else
+            table.insert(u, component[j])
+        end
+    end
+    u = lib.lua.shuffle(u)
+    while (#t &lt; 5) and (#u &gt; 0) do
+        table.insert(t, table.remove(u))
+    end
+    component = t
+    -- Find a cyclic permutation (i.e. with only one cycle) to connect the
+    -- vortices (each vortex shall be reached by starting from any other).
+    local connect = lib.math.cyclic_permutation(#component)
+    -- Shuffle floors of each component.
+    for j = 1, #component do
+        component[j].floors = (component[j].floors):shuffle()
+    end    
+    -- Now set and connect the vortices
+    for j = 1, #component do
+        local dest = po(component[connect[j]].floors[1])
+        -- Remember: We also allow (we need!) vortices at old blocker-positions.
+        -- There could still be a stone over this. This stone might be st_blocker,
+        -- which turns to it_blocker and has therefore to be removed.
+        st(component[j].floors[1]):kill()
+        wo[component[j].floors[1]] = {&quot;it_vortex_open&quot;, destination = dest}
+    end
+end
 
-  lib.soko.draw_level_array(nr, true, false)
+function lib.soko.endphase_allcrack()
+    for j = 1, #lib.soko.polist.way do
+        if not -it(lib.soko.polist.way[j]) then
+            wo[lib.soko.polist.way[j]] = {&quot;it_crack_m&quot;}
+        end
+    end  
+end
 
-  -- prepare oxyds for end phase
-  lib.soko.prepare_endphase(nr)
-  lib.soko.debug(&quot;Prepared for endphase &quot;..lib.soko.sokoarea[nr].design.endp.alg..&quot;.&quot;)
+function lib.soko.endphase_gradients(strength)
+    for j = 1, #lib.soko.polist.way do
+        local kind = &quot;fl_slope_&quot; .. ({&quot;pw&quot;, &quot;ps&quot;, &quot;pe&quot;, &quot;pn&quot;, &quot;inw&quot;, &quot;isw&quot;,
+            &quot;ise&quot;, &quot;ine&quot;, &quot;onw&quot;, &quot;osw&quot;, &quot;ose&quot;, &quot;one&quot;})[random(1,12)]
+        wo[lib.soko.polist.way[j]] = {kind, strength = tonumber(strength) or 25.0}
+    end
 end
 
--- draw_sokoball draws a sokoball level from argument LEVEL, sublevel
--- number SUBLEVEL with design DESIGN (see create_sokoball) at offset
--- OFFSET. It's arguments are identical to those of create_sokoball.
--- Whereas create_sokoball should be used for sokoball-only levels,
--- draw_sokoball can be used to add a sokoban type area to a larger
--- level. The difference is as follows:
--- draw_sokoball will NOT:
---  - create the world before drawing to it
---  - draw the outside, such that it doesn't overwrite the rest of your
---    level
---  - draw any oxyds
---  - solve the level when all triggers are activated.
--- DRAW_ACTOR determines if an actor should be placed.
--- ENDPHASE_HOOK describes the function to be called when all goals are filled.
--- GOAL_HOOK describes the function to be called when a single goal is
--- triggered (see libsoko-endphase). If it's nil, the standard
--- function from this library will be called. This might be
--- broken as no oxyds have been prepared.
--- Note: Overwriting one sokoarea with another creates problems
---       with the triggers.
---
-function lib.soko.draw_sokoball(offset, level, sublevel, design, draw_actor,
-                       endphase_hook, goal_hook)
-  local nr = lib.soko.new_sokoarea()
-  -- unpack level
-  lib.soko.sokoarea[nr].level_array = lib.soko.unpack_level(level, sublevel)
-  lib.soko.sokoarea[nr].array_width = table.getn(lib.soko.sokoarea[nr].level_array[1])
-  lib.soko.sokoarea[nr].array_height = table.getn(lib.soko.sokoarea[nr].level_array)
-  lib.soko.sokoarea[nr].uses_chess = lib.soko.check_chess(nr)
-  lib.soko.sokoarea[nr].offset = offset
-  lib.soko.sokoarea[nr].design = 
-    lib.soko.design_from_description(design, lib.soko.sokoarea[nr].level_array)
-  if hook ~= nil then
-    lib.soko.sokoarea[nr].endphase_hook = lib.soko.ENDPHASE_HOOK_DEFAULT
-  end
-  lib.soko.sokoarea[nr].goal_hook = goal_hook
-  lib.soko.create_lists(nr)
-  lib.soko.draw_level_array(nr, false, draw_actor)
+function lib.soko.endphase_magnets(strength)
+  local places = fl(lib.soko.polist.way) - fl(lib.soko.polist.goal)
+  places = (places:shuffle()):sub(math.floor(#places/6))
+  wo[places] = {&quot;it_magnet_on&quot;, range = 5, strength = tonumber(strength) or 30.0}
 end
 
--- design_statistics uses lib.soko.warning to output statistics of
--- the used algorithms
-function lib.soko.design_statistics()
-  alglist = {}
-  for k, v in pairs(design_list) do
-    if v.endp then
-      alg = v.endp.alg
-      if alg then
-        alglist[alg] = (alglist[alg] or 0) + 1
-      end
+function lib.soko.endphase_goal_hook_ralf(sender)
+    -- identify the corresponding blocker (door) and open it
+    if lib.soko.area[po(sender)].open then
+        lib.soko.endphase_ralf_open_door(sender._completed, lib.soko.area[po(sender)].open)
+    end
+end
+
+function lib.soko.endphase_ralf_open_doors()
+    for j = 1, #lib.soko.polist.blocker do
+        lib.soko.endphase_ralf_open_door(true, lib.soko.polist.blocker[j])
+    end
+end
+
+-- endphase_ralf_open_door opens or closes a door at position
+-- POS, dependend on the boolean OPEN.
+function lib.soko.endphase_ralf_open_door(open, pos)
+    if lib.soko.design.open_door then
+        wo[pos] =    lib.soko.resolver(lib.lua.cond(open, &quot;  &quot;, &quot;# &quot;), pos.x, pos.y)
+                  .. lib.soko.resolver(lib.lua.cond(open, &quot;d &quot;, &quot;D &quot;), pos.x, pos.y)
     else
-      alglist[&quot;default&quot;] = (alglist[&quot;default&quot;] or 0) + 1
+        -- use default &quot;open&quot;/&quot;close&quot;-messages instead
+        if -st(pos) then  st(pos):message(lib.lua.cond(open, &quot;open&quot;, &quot;close&quot;))  end
+        if -it(pos) then  it(pos):message(lib.lua.cond(open, &quot;open&quot;, &quot;close&quot;))  end
+        if -fl(pos) then  fl(pos):message(lib.lua.cond(open, &quot;close&quot;, &quot;open&quot;))  end
     end
-  end
-  for k, v in pairs(alglist) do
-    lib.soko.warning(k..&quot;: &quot;..v)
-  end
 end
 
+------------------------------------------------------------------------
+-- Interface functions
+------------------------------------------------------------------------
+
+-- create_sokoball creates a sokoball-level from the string MULTILEVEL.
+-- This string can be a multilevel, in which case SUBLEVEL_NUMBER
+-- determines the number of the level, starting with 1. Default is 1.
+-- The design can be chosen by the DESIGNARG variable. This is either
+-- a number (see section &quot;Designs&quot;) or a table with the corresponding
+-- design entries. A missing entry will be interpreted as the entry
+-- from lib.soko_designlist.default. If the DESIGN variable is omitted,
+-- a check-number is created from the level which uniquely* determines
+-- a design from the design list, with MAXDESIGNNUMBER as highest
+-- possible design number. *Uniquely means: The design might change
+-- when the design list is enlarged.
+-- Returns width and height of new level.
+--
+function lib.soko.create_sokoball(multilevel, sublevel_number, designarg, maxdesignnumber)
+    local small_map = lib.import.map_sokoban(multilevel, sublevel_number)
+    local design = lib.soko.design_from_description(small_map, designarg, maxdesignnumber)
+
+    -- Extend map to 20x13 if possible
+    local final_width = math.max(20, small_map.width)
+    local final_height = math.max(13, small_map.height)
+    local map = wo:newMap(&quot;- &quot;, final_width, final_height)
+    local dx = math.floor((final_width - small_map.width) / 2)
+    local dy = math.floor((final_height - small_map.height) / 2)
+    small_map.defaultkey = &quot;- &quot;
+    map:paste(small_map, po(dx, dy))
+    map.defaultkey = &quot;  &quot;
+
+    wo[&quot;ConserveLevel&quot;] = false
+    wo[&quot;ShowMoves&quot;] = true
+    wo[&quot;FollowGrid&quot;] = false
+    wo[&quot;FollowMethod&quot;] = FOLLOW_SCROLL
+    wo[&quot;AllowSingleOxyds&quot;] = true
+    wo[&quot;Fragility&quot;] = 1.0
+    wo[&quot;CrackSpreading&quot;] = 0.0
+    
+    lib.soko.define_tiles(design)
+    
+    wo(res.composer(lib.soko.resolver), &quot;  &quot;, map)
+    lib.soko.setup_attributes_and_polists(map)
+    lib.soko.prepare_endphase(map, design)
+    
+    -- If we have a chessoban, make sure all goals are it_trigger.
+    -- (Remember that st_shogun can press it_trigger as well.)
+    if #no[&quot;chess#*&quot;] ~= 0 then
+        wo[lib.soko.polist.goal] = {&quot;it_trigger&quot;, &quot;trigger#&quot;,
+             target = &quot;lib_soko_goal_trigger&quot;, safeaction = true}
+    end
+    
+    wo:add({&quot;ot_counter&quot;, &quot;goal_counter&quot;, safeaction = true,
+            state = lib.soko.initially_completed_goals,
+            [&quot;action_&quot; .. (#lib.soko.polist.goal)] = &quot;callback&quot;,
+            [&quot;target_&quot; .. (#lib.soko.polist.goal)] = &quot;lib_soko_endphase&quot;})
+    
+    return map.width, map.height
+end
+
     ]]&gt;&lt;/el:luamain&gt;
     &lt;el:i18n&gt;
     &lt;/el:i18n&gt;
   &lt;/el:protected&gt;
 &lt;/el:level&gt;
-

Added: trunk/data/levels/lib/libsoko_designlist.xml
===================================================================
--- trunk/data/levels/lib/libsoko_designlist.xml	2009-03-14 23:58:47 UTC (rev 1590)
+++ trunk/data/levels/lib/libsoko_designlist.xml	2009-03-16 00:55:33 UTC (rev 1591)
@@ -0,0 +1,1549 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
+&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
+  &lt;el:protected&gt;
+    &lt;el:info el:type=&quot;library&quot;&gt;
+      &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libsoko_designlist&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:author el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
+      &lt;el:copyright&gt;Copyright &#169; 2007, 2008, 2009 Enigma Team&lt;/el:copyright&gt;
+      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
+      &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
+      &lt;/el:compatibility&gt;
+      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
+      &lt;el:comments&gt;
+      &lt;/el:comments&gt;
+      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;-&quot;/&gt;
+    &lt;/el:info&gt;
+    &lt;el:luamain&gt;&lt;![CDATA[
+
+-- This &quot;library&quot; is merely a collection of designs, outsourced from
+-- libsoko.xml.
+
+------------------------------------------------------------------------
+-- Designs
+------------------------------------------------------------------------
+
+-- This section holds a table with all predefined designs. Each design
+-- is again a table consisting of the following entries, called &quot;fields&quot;:
+--   inf, outf, box, wall, goal, door, open_door, oxyd, white, endp
+-- Each of these entries is either a string or tile representing the
+-- objects to be used, or a table if several objects shall be used.
+-- Such a declaration of one or more objects will be called &quot;element&quot;.
+--
+-- An element consists of a sequence of other elements, plus a single
+-- entry called &quot;res&quot;, holding the information how to resolve the
+-- subelements. If no &quot;res&quot; is given, all subelements will be resolved.
+-- An example:
+--   wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_sahara&quot;, res = RESOLVE_CHECKERBOARD}}
+-- This means, that whenever a wall should be drawn, it will consist
+-- of an &quot;st_rawglass&quot;, plus one of the floors &quot;fl_wood&quot; or &quot;fl_sahara&quot;,
+-- which will be used in a checkerboard manner.
+--
+-- The fields oxyd, white and endp are special. &quot;oxyd&quot; only holds
+-- the oxyd's flavor, &quot;white&quot; can be a boolean to define the main actor
+-- to be the white marble. &quot;endp&quot; defines what happens after the Sokoban
+-- part of the level has been completed, i.e. how to redraw the level
+-- and how to open the oxyds.
+--
+-- Example:
+--
+--  [129] = {inf = ti{&quot;fl_dunes&quot;, friction = 3.0, adhesion = 1.0},
+--           outf = {&quot;fl_lawn_e1&quot;, &quot;fl_lawn_e2&quot;, &quot;fl_lawn_e3&quot;, &quot;fl_lawn_e4&quot;, res = RESOLVE_WAVES},
+--           wall = {&quot;st_ancient&quot;, &quot;fl_lawn_b&quot;},
+--           box = &quot;st_camouflage_movable&quot;,
+--           door = {{&quot;fl_bridge_bw&quot;, &quot;fl_bridge_bn&quot;, res = RESOLVE_RANDOM}, &quot;st_nil&quot;},
+--           oxyd = &quot;d&quot;,
+--         endp = {goal = &quot;st_camouflage_hollow&quot;,
+--                 alg = &quot;ralf&quot;}},
+--
+--   will define design 129. The walls will be &quot;st_ancient&quot; on &quot;fl_lawn_b&quot;,
+--   the inner floor is &quot;fl_dunes&quot; with higher friction values. The outer
+--   floor will be in a special lawn-pattern due to RESOLVE_WAVES.
+--   The boxes are movable camouflage stones, which become hollow after
+--   all boxes are on triggers. The end phase algorithm to be used is
+--   &quot;ralf&quot;, i.e. all but one oxyd can be reached during the Sokoban
+--   part, the corresponding doors are randomly oriented bridges.
+--
+-- Design-Algorithms:
+--
+--   RESOLVE_ALL = 0          : default, used for elements which can be rendered simultaneously
+--   RESOLVE_RANDOM = 1       : choose randomly among the elements
+--   RESOLVE_CHECKERBOARD = 2 : up to 3 different elements in checkerboard pattern
+--   RESOLVE_LINES = 3        : arbitrary number of elements in diagonal lines
+--   RESOLVE_WAVES = 4        : works best with 4 different elements
+--   RESOLVE_ORIENTED = 5     : special version for st_door, used internally
+--
+--   RESOLVE_RANDOM may take additional attributes to define the
+--   percentages of the subelements. Example:
+--     outf = {&quot;fl_water&quot;, &quot;fl_swamp&quot;, res = {RESOLVE_RANDOM, 5, 1}}
+--   The outer floor will be 5 parts water to 1 part swamp.
+--
+-- Endphase-Algorithms:
+--
+--   circle         : arrange eight oxyds in a circle (default)
+--   hide           : position oxyds in the outer walls
+--     gradients    : like hide, create gradients
+--     magnets      : like hide, create magnets
+--   fourswitch     : create a fourswitch puzzle
+--   block          : arrange oxyds with doors
+--   ralf           : arrange oxyds with doors, which open by triggers
+--     vortex       : like ralf, create vortices between clusters
+--     allcrack     : like ralf, create cracks everywhere
+--     knock        : like ralf, open doors on knocking on other doors
+--   outside        : create oxyds in the outside and outer walls
+--
+--   You can use &quot;max_pairs&quot; to determine the maximal number of
+--   oxyd pairs in &quot;block&quot;, &quot;ralf&quot;, &quot;vortex&quot;, &quot;allcrack&quot;, &quot;knock&quot;,
+--   and &quot;outside&quot;; and &quot;strength&quot; to determine the strength of
+--   the gradients and magnets in &quot;gradients&quot; and &quot;magnets&quot;.
+--
+
+lib.soko_designlist = {}
+setmetatable(lib.soko_designlist, getmetatable(lib))
+
+RESOLVE_ALL = 0
+RESOLVE_RANDOM = 1
+RESOLVE_CHECKERBOARD = 2
+RESOLVE_LINES = 3
+RESOLVE_WAVES = 4
+RESOLVE_ORIENTED = 5
+
+-- The default design must not be nested!
+lib.soko_designlist.default = {
+    wall = &quot;st_plaster&quot;,
+     inf = &quot;fl_wood&quot;,
+    outf = &quot;st_invisible_hollow&quot;,
+     box = &quot;st_brownie&quot;,
+    goal = &quot;it_trigger&quot;,
+    oxyd = &quot;b&quot;,
+    endp = {alg = &quot;circle&quot;},
+}
+
+-- outf_default_stone has the following meaning: When outf is drawn
+-- by set_element, but no stone is set, outf_default_stone is used
+-- instead. You can suppress this behaviour by explicitly setting
+-- outf = { &quot;fl_myfloor&quot;, &quot;st_nil&quot; }.
+-- This is done to avoid a chess-stone from jumping into the void,
+-- as a present to the gamer.
+
+lib.soko_designlist.list = {
+
+-- endp-algs: circle, ralf, hide, outside, allcrack, block, fourswitch
+--            vortex, gradients, magnets
+
+
+  [1] = {inf = &quot;fl_bluegray&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_bluegray&quot;,
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;circle&quot;}},
+  [2] = {inf = &quot;fl_bluegray&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_bluegray&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;ralf&quot;}},
+  [3] = {inf = &quot;fl_bluegray&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_bluegray&quot;,
+         box = &quot;st_box_wood_growing&quot;,
+         door = &quot;st_flat_cracked&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_wood_framed&quot;, &quot;it_nil&quot;},
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+  [4] = {inf = &quot;fl_bright&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = &quot;st_bluegray&quot;,
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {wall = {&quot;st_nil&quot;, &quot;fl_bluegray&quot;},
+                 goal = &quot;st_nil&quot;,
+                 alg = &quot;outside&quot;}},
+  [5] = {inf = &quot;fl_bright&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_bluegray&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {wall = &quot;st_bluegray_hollow&quot;,
+                 goal = {&quot;st_nil&quot;, &quot;fl_wood_framed&quot;, &quot;it_nil&quot;},
+                 alg = &quot;outside&quot;, max_pairs = 3}},
+  [6] = {inf = &quot;fl_bright&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_bluegray&quot;,
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_greenbrown_hollow&quot;,
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+  [7] = {inf = &quot;fl_bright&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_bluegray&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_wood_framed&quot;, &quot;it_nil&quot;},
+                 alg = &quot;fourswitch&quot;}},
+  [8] = {inf = &quot;fl_ivory&quot;,
+         outf = &quot;fl_blueslab&quot;,
+         wall = &quot;st_bluesand&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_plaster_breakable&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;ralf&quot;}},
+  [9] = {inf = &quot;fl_ivory&quot;,
+         outf = &quot;fl_blueslab&quot;,
+         wall = &quot;st_bluesand&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;circle&quot;}},
+ [10] = {inf = &quot;fl_rough&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_bluesand&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;magnets&quot;}},
+ [11] = {inf = &quot;fl_rough&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_bluesand&quot;,
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_redbrown&quot;,
+                 alg = &quot;vortex&quot;}},
+ [12] = {inf = &quot;fl_rough&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_bluesand&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_break_oxydc&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [13] = {inf = &quot;fl_rough&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_bluesand&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+ [14] = {inf = &quot;fl_himalaya&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_himalaya&quot;, &quot;fl_water&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_pull&quot;,
+                 alg = &quot;magnets&quot;}},
+ [15] = {inf = &quot;fl_himalaya&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_himalaya&quot;, &quot;fl_water&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;fourswitch&quot;}},
+ [16] = {inf = &quot;fl_redslab&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_redslab&quot;, &quot;fl_abyss&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {alg = &quot;circle&quot;}},
+ [17] = {inf = &quot;fl_redslab&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_redslab&quot;, &quot;fl_sahara&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {wall = &quot;st_grate_framed&quot;,
+                 goal = &quot;st_grate_framed&quot;,
+                 alg = &quot;outside&quot;}},
+ [18] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_water&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_greenbrown_movable&quot;,
+         door = {&quot;st_door_b&quot;, &quot;fl_wood&quot;},
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_greenbrown_hollow&quot;,
+                 alg = &quot;ralf&quot;}},
+ [19] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_abyss&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_plop&quot;,
+         door = {&quot;st_blocker&quot;, &quot;fl_wood&quot;},
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_granite&quot;,
+                 alg = &quot;vortex&quot;}},
+ [20] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_abyss&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_box_wood_growing&quot;,
+         door = {&quot;st_door_c&quot;, &quot;fl_wood&quot;},
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;magnets&quot;}},
+ [21] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_sahara&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_break_bug&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 give = &quot;#ac_bug&quot;,
+                 alg = &quot;block&quot;}},
+ [22] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_lawn_a&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+ [23] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_abyss&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_plop&quot;,
+         door = {&quot;st_blocker&quot;, &quot;fl_wood&quot;},
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_nil&quot;},
+                 alg = &quot;allcrack&quot;, max_pairs = 1}},
+ [24] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = {&quot;st_rawglass&quot;, {&quot;fl_wood&quot;, &quot;fl_sahara&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_break_bug&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 give = &quot;#ac_bug&quot;,
+                 alg = &quot;block&quot;}},
+ [25] = {inf = &quot;fl_wood&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = {&quot;st_rawglass&quot;, &quot;it_cherry&quot;, {&quot;fl_wood&quot;, &quot;fl_lawn_a&quot;, res = RESOLVE_CHECKERBOARD}},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;st_rawglass&quot;, &quot;it_cherry&quot;, {&quot;fl_wood&quot;, &quot;fl_lawn_a&quot;, res = RESOLVE_CHECKERBOARD}},
+                 give = &quot;it_cherry&quot;,
+                 alg = &quot;outside&quot;}},
+ [26] = {inf = ti{&quot;fl_yinyang_yin&quot;, invisible = true},
+         outf = &quot;fl_water&quot;,
+         wall = ti{&quot;st_fake_oxydc&quot;, state = OPEN},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_grate_cross&quot;,
+                 alg = &quot;ralf&quot;}},
+ [27] = {inf = ti{&quot;fl_yinyang_yin&quot;, invisible = true},
+         outf = &quot;fl_water&quot;,
+         wall = ti{&quot;st_fake_oxydc&quot;, state = OPEN},
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_greenbrown_hollow&quot;,
+                 alg = &quot;hide&quot;}},
+ [28] = {inf = &quot;fl_tigris&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = ti{&quot;st_fake_oxydc&quot;, state = OPEN},
+         box = &quot;st_box_wood_growing&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;fourswitch&quot;}},
+ [29] = {inf = &quot;fl_tigris&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = ti{&quot;st_fake_oxydc&quot;, state = OPEN},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_pull&quot;,
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+ [30] = {inf = &quot;fl_tigris&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = ti{&quot;st_fake_oxydc&quot;, state = OPEN},
+         box = &quot;st_box_wood_growing&quot;,
+         door = &quot;st_break_oxydc&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_wood_framed&quot;, &quot;it_nil&quot;},
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [31] = {inf = &quot;fl_tigris&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = ti{&quot;st_fake_oxydc&quot;, state = OPEN},
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_rawglass_movable&quot;,  -- could be chess stones!
+                 wall = &quot;st_grate_cross&quot;,
+                 give = &quot;it_cherry&quot;,
+                 alg = &quot;outside&quot;, max_pairs = 3}},
+ [32] = {inf = &quot;fl_bluegray&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_granite&quot;,
+                 alg = &quot;vortex&quot;}},
+ [33] = {inf = &quot;fl_bluegray&quot;,
+         outf = &quot;fl_blueslab&quot;,
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_metal_hollow&quot;,
+                 alg = &quot;magnets&quot;}},
+ [34] = {inf = &quot;fl_bright&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;gradients&quot;}},
+ [35] = {inf = &quot;fl_bright&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;fl_swamp&quot;,
+                 alg = &quot;ralf&quot;}},
+ [36] = {inf = &quot;fl_bright&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {alg = &quot;circle&quot;}},
+ [37] = {inf = &quot;fl_ivory&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_granite&quot;,
+         box = &quot;st_box_wood_growing&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {wall = &quot;st_grate_framed&quot;,
+                 goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;outside&quot;}},
+ [38] = {inf = &quot;fl_ivory&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_granite&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_rawglass_movable&quot;,  -- could be chess stones!
+                 give = {&quot;it_cherry&quot;, &quot;it_cherry&quot;, &quot;it_cherry&quot;, &quot;it_cherry&quot;, &quot;it_cherry&quot;, &quot;it_cherry&quot;, &quot;it_cherry&quot;},
+                 alg = &quot;ralf&quot;, max_pairs = 1}},
+ [39] = {inf = &quot;fl_ivory&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_granite&quot;,
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_grate_framed&quot;,
+                 alg = &quot;fourswitch&quot;}},
+ [40] = {inf = &quot;fl_ivory&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_granite&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+ [41] = {inf = &quot;fl_rough&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_granite&quot;,
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {wall = &quot;st_granite_hollow&quot;,
+                 goal = {&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl_hay&quot;},
+                 alg = &quot;outside&quot;, max_pairs = 3}},
+ [42] = {inf = &quot;fl_rough&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = &quot;st_granite&quot;,
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_greenbrown&quot;,
+                 alg = &quot;vortex&quot;}},
+ [43] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {wall = &quot;st_plaster_hollow&quot;,
+                 goal = &quot;st_plaster_hollow&quot;,
+                 alg = &quot;outside&quot;, max_pairs = 3}},
+ [44] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_blueslab&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_redbrown_hollow&quot;,
+                 alg = &quot;ralf&quot;}},
+ [45] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_box_wood_growing&quot;,
+         door = &quot;st_break_bug&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 give = &quot;#ac_bug&quot;,
+                 alg = &quot;block&quot;}},
+ [46] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_flat_cracked&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [47] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_sahara&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_break_bug&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_greenbrown_hollow&quot;,
+                 give = &quot;#ac_bug&quot;,
+                 alg = &quot;block&quot;}},
+ [48] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_flat&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_rawglass_movable&quot;,  -- could be chess stones!
+                 wall = &quot;st_flat_breakable&quot;,
+                 give = {&quot;it_cherry&quot;, &quot;it_cherry&quot;, &quot;it_cherry&quot;, &quot;it_hammer&quot;},
+                 alg = &quot;ralf&quot;}},
+ [49] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_blueslab&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_flat_cracked&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_redbrown_hollow&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [50] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {alg = &quot;circle&quot;}},
+ [51] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_box_wood_growing&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {wall = {&quot;st_flat_breaking&quot;, &quot;fl_sahara&quot;},
+                 goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;outside&quot;}},
+ [52] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = {&quot;st_grate_cross&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+ [53] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_plaster&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_swamp&quot;},
+                 alg = &quot;fourswitch&quot;}},
+ [54] = {inf = &quot;fl_himalaya&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_purplemarble&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_purplemarble&quot;,
+                 alg = &quot;vortex&quot;}},
+ [55] = {inf = &quot;fl_himalaya&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_purplemarble&quot;,
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_redbrown_hollow&quot;,
+                 alg = &quot;ralf&quot;}},
+ [56] = {inf = &quot;fl_himalaya&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_purplemarble&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {alg = &quot;circle&quot;}},
+ [57] = {inf = &quot;fl_redslab&quot;,
+         outf = &quot;fl_blueslab&quot;,
+         wall = &quot;st_purplemarble&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {wall = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 goal = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 alg = &quot;outside&quot;}},
+ [58] = {inf = &quot;fl_redslab&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_purplemarble&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_flat_cracked&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_flat_cracked&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [59] = {inf = &quot;fl_redslab&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_purplemarble&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;ralf&quot;}},
+ [60] = {inf = &quot;fl_redslab&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_purplemarble&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_break_bug&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_break_bug&quot;,
+                 give = &quot;#ac_bug&quot;,
+                 alg = &quot;block&quot;}},
+ [61] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_greenbrown_hollow&quot;,
+                 alg = &quot;fourswitch&quot;}},
+ [62] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_blocker&quot;,
+                 alg = &quot;vortex&quot;}},
+ [63] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_flat_cracked&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_flat_cracked&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [64] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_redbrown_hollow&quot;,
+                 alg = &quot;gradients&quot;}},
+ [65] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_box_wood_growing&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_wood_framed&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+ [66] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_greenbrown&quot;,
+                 alg = &quot;vortex&quot;}},
+ [67] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {alg = &quot;circle&quot;}},
+ [68] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;allcrack&quot;, max_pairs = 1}},
+ [69] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_tigris&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+ [70] = {inf = ti{&quot;fl_yinyang_yin&quot;, invisible = true},
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_purplegray&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_door_b&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_flat_breaking&quot;,
+                 alg = &quot;ralf&quot;}},
+ [71] = {inf = ti{&quot;fl_yinyang_yin&quot;, invisible = true},
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_purplegray&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {wall = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 goal = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 alg = &quot;outside&quot;}},
+ [72] = {inf = ti{&quot;fl_yinyang_yin&quot;, invisible = true},
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_purplegray&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;magnets&quot;}},
+ [73] = {inf = ti{&quot;fl_yinyang_yin&quot;, invisible = true},
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_purplegray&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_knight&quot;,
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+ [74] = {inf = &quot;fl_tigris&quot;,
+         outf = &quot;fl_blueslab&quot;,
+         wall = &quot;st_purplegray&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;fourswitch&quot;}},
+ [75] = {inf = &quot;fl_tigris&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_purplegray&quot;,
+         box = &quot;st_shogun&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 alg = &quot;gradients&quot;}},
+ [76] = {inf = &quot;fl_platinum&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_darkglass&quot;,
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_pull&quot;,
+                 alg = &quot;hide&quot;}},
+ [77] = {inf = &quot;fl_darkgray&quot;,
+         outf = &quot;fl_lawn_b&quot;,
+         wall = &quot;st_brick&quot;,
+         box = &quot;st_flat_movable&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_flat_cracked&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;knock&quot;}},
+ [78] = {inf = ti{&quot;fl_dunes&quot;, friction = 3.0, adhesion = 1.0},
+         outf = &quot;fl_sand&quot;,
+         wall = &quot;st_pinkbumps&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_flat_cracked&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_flat_breakable&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [79] = {inf = &quot;fl_gravel&quot;,
+         outf = {&quot;fl_gravel&quot;, &quot;st_disco_medium&quot;},
+         wall = &quot;st_camouflage&quot;,
+         box = &quot;st_box_rock&quot;,
+         door = &quot;st_camouflage&quot;,
+         open_door = {&quot;st_nil&quot;, &quot;fl_lawn_b&quot;},
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_camouflage&quot;,
+                 alg = &quot;vortex&quot;}},
+ [80] = {inf = &quot;fl_lawn_a&quot;,
+         outf = {&quot;fl_water&quot;, &quot;fl_swamp&quot;, res = {RESOLVE_RANDOM, 5, 1}},
+         wall = &quot;st_camouflage&quot;,
+         box = &quot;st_box_hay&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {wall = {&quot;fl_swamp&quot;, {&quot;st_camouflage_hollow&quot;, &quot;st_nil&quot;, res = {RESOLVE_RANDOM, 1, 2}}},
+                 goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 give = &quot;it_umbrella&quot;,
+                 alg = &quot;outside&quot;, max_pairs = 1}},
+ [81] = {inf = &quot;fl_dark&quot;,
+         outf = &quot;fl_bright&quot;,
+         wall = {&quot;st_lightglass&quot;, &quot;fl_platinum&quot;},
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_passage_black_frame&quot;,
+         open_door = &quot;st_passage_white_frame&quot;,
+         oxyd = &quot;c&quot;,
+         white = true,
+         endp = {goal = &quot;st_blur_straight&quot;,
+                 alg = &quot;ralf&quot;}},
+ [82] = {inf = &quot;fl_sand&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = {&quot;st_lightglass&quot;, &quot;fl_water&quot;},
+         box = &quot;st_box_wood&quot;,
+         door = {&quot;st_door_a&quot;, &quot;fl_sand&quot;},
+         oxyd = &quot;c&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_wood_framed&quot;, &quot;it_nil&quot;},
+                 alg = &quot;fourswitch&quot;}},
+ [83] = {inf = &quot;fl_platinum&quot;,
+         outf = {&quot;fl_lawn_b&quot;, &quot;st_disco_medium&quot;},
+         wall = &quot;st_darkglass&quot;,
+         box = &quot;st_camouflage_movable&quot;,
+         door = &quot;st_darkglass&quot;,
+         open_door = &quot;st_lightglass_hollow&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {outf = &quot;st_nil&quot;,
+                 goal = &quot;st_camouflage_hollow&quot;,
+                 alg = &quot;ralf&quot;}},
+ [84] = {inf = &quot;fl_sand&quot;,
+         outf = {&quot;fl_water&quot;, &quot;st_disco_medium&quot;},
+         wall = &quot;st_darkglass&quot;,
+         box = &quot;st_box_rock&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;knock&quot;}},
+ [85] = {inf = &quot;fl_sand&quot;,
+         outf = {&quot;fl_water&quot;, &quot;st_disco_medium&quot;},
+         wall = &quot;st_brick&quot;,
+         box = &quot;st_box_rock&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_passage_black_frame&quot;,
+                 alg = &quot;ralf&quot;}},
+ [86] = {inf = ti{&quot;fl_red&quot;, burnable = false, friction = 3.0},
+         outf = &quot;fl_space&quot;,
+         wall = {&quot;st_redfiber&quot;, &quot;fl_fake_abyss&quot;},
+         box = &quot;st_lightglass_movable&quot;,
+         door = {&quot;st_nil&quot;, ti{&quot;fl_red&quot;, burnable = true, eternal = true, friction = 3.0}, &quot;it_burnable_ignited&quot;},
+         open_door = {&quot;it_nil&quot;, ti{&quot;fl_red&quot;, burnable = false, friction = 3.0}},
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 alg = &quot;ralf&quot;}},
+ [87] = {inf = &quot;fl_plank&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = {&quot;st_redfiber&quot;, &quot;fl_blueslab&quot;},
+         box = &quot;st_flat_movable&quot;,
+         door = &quot;st_redfiber&quot;,
+         open_door = &quot;st_lightglass_hollow&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_greengray&quot;,
+                 alg = &quot;vortex&quot;}},
+ [88] = {inf = &quot;fl_dark&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_fake_oxyda&quot;,
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;hide&quot;}},
+ [89] = {inf = &quot;fl_brick&quot;,
+         outf = {&quot;fl_mortar&quot;, &quot;st_disco_medium&quot;},
+         wall = ti{&quot;st_fake_oxyda&quot;, state = OPEN},
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_grate_framed&quot;,
+                 alg = &quot;knock&quot;}},
+ [90] = {inf = &quot;fl_redslab&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_fake_oxydb&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_flat_breaking&quot;,
+                 alg = &quot;hide&quot;}},
+ [91] = {inf = &quot;fl_blueslab&quot;,
+         outf = {&quot;fl_swamp&quot;, &quot;st_disco_light&quot;},
+         wall = ti{&quot;st_fake_oxydb&quot;, state = OPEN},
+         box = &quot;st_box_hay&quot;,
+         door = &quot;st_break_plain&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_break_plain&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+ [92] = {inf = &quot;fl_sahara&quot;,
+         outf = {&quot;fl_water&quot;, &quot;st_disco_light&quot;},
+         wall = &quot;st_fake_oxydc&quot;,
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;hide&quot;}},
+ [93] = {inf = ti{&quot;fl_red&quot;, friction = 3.0},
+         outf = {&quot;fl_abyss&quot;, {&quot;st_jamb_black&quot;, &quot;st_jamb_white&quot;, res = RESOLVE_RANDOM}},
+         wall = ti{&quot;st_fake_oxydc&quot;, state = OPEN},
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_passage_black_frame&quot;,
+                 alg = &quot;fourswitch&quot;}},
+ [94] = {inf = &quot;fl_concrete&quot;,
+         outf = &quot;fl_sand&quot;,
+         wall = &quot;st_fake_oxydd&quot;,
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;hide&quot;}},
+ [95] = {inf = &quot;fl_marble&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = ti{&quot;st_fake_oxydd&quot;, state = OPEN},
+         box = &quot;st_box_rock&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {outf = &quot;fl_swamp&quot;,
+                 wall = &quot;st_break_plain&quot;,
+                 goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;outside&quot;}},
+ [96] = {inf = &quot;fl_marble&quot;,
+         outf = {&quot;fl_lawn_c3&quot;, &quot;fl_lawn_d3&quot;, res = RESOLVE_CHECKERBOARD},
+         wall = &quot;st_redbrown&quot;,
+         box = &quot;st_box_rock&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;st_grate_framed&quot;, &quot;it_nil&quot;},
+                 alg = &quot;knock&quot;}},
+ [97] = {inf = &quot;fl_lawn_a&quot;,
+         outf = {&quot;fl_lawn_a&quot;, &quot;st_redbrown&quot;},
+         wall = &quot;st_redbrown&quot;,
+         box = &quot;st_camouflage_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {outf = &quot;st_redbrown_hollow&quot;,
+                 wall = &quot;st_redbrown_hollow&quot;,
+                 goal = &quot;st_camouflage_hollow&quot;,
+                 alg = &quot;outside&quot;}},
+ [98] = {inf = ti{&quot;fl_yinyang_yin&quot;, invisible = true},
+         outf = {ti{&quot;fl_yinyang_yin&quot;, invisible = true}, &quot;st_redrock&quot;},
+         wall = &quot;st_redrock&quot;,
+         box = &quot;st_granite_movable&quot;,
+         door = &quot;st_purplegray&quot;,
+         open_door = &quot;st_nil&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_purplegray&quot;,
+                 alg = &quot;vortex&quot;}},
+ [99] = {inf = &quot;fl_mortar&quot;,
+         outf = &quot;fl_brick&quot;,
+         wall = &quot;st_redrock&quot;,
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {wall = {&quot;st_lightglass_hollow&quot;, &quot;fl_tigris&quot;},
+                 goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;outside&quot;}},
+[100] = {inf = &quot;fl_mortar&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_redrock&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+[101] = {inf = &quot;fl_lawn_b&quot;,
+         outf = {&quot;fl_lawn_c3&quot;, &quot;fl_lawn_d4&quot;, res = RESOLVE_CHECKERBOARD},
+         wall = &quot;st_redrock&quot;,
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;hide&quot;}},
+[102] = {inf = &quot;fl_rock&quot;,
+         outf = {&quot;fl_rock&quot;, &quot;st_disco_medium&quot;},
+         wall = &quot;st_darkgray&quot;,
+         box = &quot;st_camouflage_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {wall = {&quot;st_disco_light&quot;, &quot;fl_gray&quot;},
+                 goal = {&quot;it_nil&quot;, &quot;st_disco_light&quot;, &quot;fl_lawn_b&quot;},
+                 alg = &quot;outside&quot;, max_pairs = 3}},
+[103] = {inf = ti{&quot;fl_stone&quot;, friction = 3.0, adhesion = 1.0},
+         outf = {&quot;fl_water&quot;, &quot;st_disco_medium&quot;},
+         wall = &quot;st_darkgray&quot;,
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;st_pull&quot;, &quot;it_nil&quot;, &quot;fl_dark&quot;},
+                 alg = &quot;fourswitch&quot;}},
+[104] = {inf = &quot;fl_platinum&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_darkgray&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_marble&quot;, &quot;it_nil&quot;},
+                 alg = &quot;knock&quot;}},
+[105] = {inf = &quot;fl_woven&quot;,
+         outf = &quot;fl_gravel&quot;,
+         wall = &quot;st_greengray&quot;,
+         box = &quot;st_camouflage_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;fl_aquamarine&quot;, &quot;it_nil&quot;, &quot;st_nil&quot;},
+                 alg = &quot;magnets&quot;}},
+[106] = {inf = &quot;fl_dark&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_greengray&quot;,
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_flat_cracked&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_break_bug&quot;,
+                 give = {&quot;#ac_bug&quot;, &quot;it_hammer&quot;},
+                 alg = &quot;block&quot;}},
+[107] = {inf = &quot;fl_plank&quot;,
+         outf = {&quot;fl_plank&quot;, &quot;st_concrete&quot;},
+         wall = &quot;st_concrete&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 alg = &quot;knock&quot;}},
+[108] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = {&quot;st_concrete&quot;, &quot;fl_water&quot;},
+         box = &quot;st_darkglass_movable&quot;,
+         door = {&quot;st_break_plain&quot;, &quot;fl_lawn_a&quot;},
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_pull&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+[109] = {inf = ti{&quot;fl_stone&quot;, friction = 3.0, adhesion = 1.0},
+         outf = &quot;fl_space&quot;,
+         wall = {&quot;st_concrete&quot;, &quot;fl_fake_abyss&quot;},
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {wall = {&quot;st_nil&quot;, &quot;fl_darkgray&quot;},
+                 goal = {&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl_hay&quot;},
+                 alg = &quot;outside&quot;, max_pairs = 3}},
+[110] = {inf = &quot;fl_rock&quot;,
+         outf = {&quot;fl_rock&quot;, &quot;st_ancient&quot;},
+         wall = &quot;st_ancient&quot;,
+         box = &quot;st_greenbrown_movable&quot;,
+         door = &quot;st_ancient&quot;,
+         open_door = &quot;st_nil&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_ancient&quot;,
+                 alg = &quot;vortex&quot;}},
+[111] = {inf = &quot;fl_sand&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_ancient&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = &quot;st_grate_framed&quot;,
+                 alg = &quot;ralf&quot;}},
+[112] = {inf = ti{&quot;fl_stone&quot;, friction = 3.0, adhesion = 1.0},
+         outf = &quot;fl_swamp&quot;,
+         wall = &quot;st_ancient&quot;,
+         box = &quot;st_camouflage_movable&quot;,
+         door = &quot;st_door_d&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_camouflage_hollow&quot;,
+                 alg = &quot;knock&quot;}},
+[113] = {inf = &quot;fl_bluegreen&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_brownmarble&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {wall = {{&quot;st_nil&quot;, &quot;it_explosion&quot;}, &quot;fl_marble&quot;},
+                 goal = {{&quot;st_nil&quot;, &quot;it_explosion&quot;}, &quot;it_nil&quot;, &quot;fl_aquamarine&quot;},
+                 give = &quot;it_umbrella&quot;,
+                 alg = &quot;outside&quot;, max_pairs = 1}},
+[114] = {inf = &quot;fl_sand&quot;,
+         outf = {&quot;fl_sand&quot;, &quot;st_brownmarble&quot;},
+         wall = &quot;st_brownmarble&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+[115] = {inf = {&quot;fl_platinum&quot;, &quot;fl_bright&quot;, res = RESOLVE_CHECKERBOARD},
+         outf = {&quot;fl_space&quot;, &quot;fl_abyss&quot;, res = RESOLVE_CHECKERBOARD},
+         wall = &quot;st_brownpyramide&quot;,
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_brownpyramide&quot;,
+         open_door = &quot;st_grate_cross&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {wall = &quot;st_grate_cross&quot;,
+                 goal = &quot;st_lightglass_hollow&quot;,
+                 give = &quot;it_umbrella&quot;,
+                 alg = &quot;block&quot;}},
+[116] = {inf = &quot;fl_wood_framed&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_brownpyramide&quot;,
+         box = &quot;st_granite_movable&quot;,
+         door = &quot;st_brownpyramide&quot;,
+         open_door = &quot;st_grate_cross&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_granite_hollow&quot;,
+                 alg = &quot;ralf&quot;}},
+[117] = {inf = &quot;fl_dark&quot;,
+         outf = &quot;st_brownpyramide&quot;,
+         wall = &quot;st_brownpyramide&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {inf = &quot;fl_ice&quot;,
+                 outf = &quot;st_fake_oxydd&quot;,
+                 wall = &quot;st_fake_oxydd&quot;,
+                 goal = {&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl_ice&quot;},
+                 alg = &quot;hide&quot;, max_pairs = 1}},
+[118] = {inf = &quot;fl_dark&quot;,
+         outf = &quot;fl_gravel&quot;,
+         wall = &quot;st_redmarble&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_rawglass&quot;,
+                 alg = &quot;vortex&quot;}},
+[119] = {inf = &quot;fl_redslab&quot;,
+         outf = {&quot;fl_blueslab&quot;, &quot;st_disco_light&quot;},
+         wall = &quot;st_redmarble&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;allcrack&quot;, max_pairs = 1}},
+[120] = {inf = &quot;fl_dark&quot;,
+         outf = {&quot;st_redbrown&quot;, &quot;st_redmarble&quot;, res = RESOLVE_CHECKERBOARD},
+         wall = {&quot;st_redbrown&quot;, &quot;st_redmarble&quot;, res = RESOLVE_CHECKERBOARD},
+         box = &quot;st_plaster_movable&quot;,
+         open_door = &quot;st_nil&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = &quot;st_flat_cracked&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;ralf&quot;}},
+[121] = {inf = &quot;fl_wood&quot;,
+         outf = {&quot;fl_lawn_d3&quot;, &quot;fl_lawn_d2&quot;, res = RESOLVE_CHECKERBOARD},
+         wall = &quot;st_panel&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_box_wood&quot;,
+         open_door = &quot;fl_swamp&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;it_nil&quot;, &quot;fl_swamp&quot;},
+                 alg = &quot;block&quot;}},
+[122] = {inf = &quot;fl_lawn_a&quot;,
+         outf = &quot;fl_lawn_b&quot;,
+         wall = &quot;st_panel&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = {&quot;it_nil&quot;, &quot;fl_swamp&quot;},
+                 alg = &quot;fourswitch&quot;}},
+[123] = {inf = ti{&quot;fl_dunes&quot;, friction = 3.0, adhesion = 1.0},
+         outf = &quot;fl_bluegreen&quot;,
+         wall = &quot;st_woven&quot;,
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_lightglass&quot;,
+         open_door = &quot;st_pull&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_pull&quot;,
+                 alg = &quot;ralf&quot;}},
+[124] = {inf = &quot;fl_hay&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = &quot;st_woven&quot;,
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {wall = {&quot;st_nil&quot;, &quot;fl_woven&quot;},
+                 goal = &quot;st_redbrown_hollow&quot;,
+                 give = &quot;it_umbrella&quot;,
+                 alg = &quot;outside&quot;, max_pairs = 1}},
+[125] = {inf = &quot;fl_lawn_b&quot;,
+         outf = &quot;fl_lawn_a&quot;,
+         wall = &quot;st_yellow&quot;,
+         box = &quot;st_plaster_movable&quot;,
+         door = &quot;st_door_c&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_grate_framed&quot;,
+                 alg = &quot;ralf&quot;}},
+[126] = {inf = &quot;fl_blueslab&quot;,
+         outf = &quot;fl_abyss&quot;,
+         wall = &quot;st_yellow&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_break_bug&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl_ice&quot;},
+                 give = &quot;#ac_bug&quot;,
+                 alg = &quot;block&quot;}},
+[127] = {inf = &quot;fl_platinum&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_yellow&quot;,
+         box = &quot;st_plop&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_brownmarble&quot;,
+                 alg = &quot;vortex&quot;}},
+[128] = {inf = &quot;fl_himalaya&quot;,
+         outf = {&quot;fl_himalaya&quot;, {&quot;st_concrete&quot;, &quot;st_greengray&quot;, res = RESOLVE_CHECKERBOARD}},
+         wall = &quot;st_greengray&quot;,
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 alg = &quot;magnets&quot;}},
+[129] = {inf = ti{&quot;fl_dunes&quot;, friction = 3.0, adhesion = 1.0},
+         outf = {&quot;fl_lawn_e1&quot;, &quot;fl_lawn_e2&quot;, &quot;fl_lawn_e3&quot;, &quot;fl_lawn_e4&quot;, res = RESOLVE_WAVES},
+         wall = {&quot;st_ancient&quot;, &quot;fl_lawn_b&quot;},
+         box = &quot;st_camouflage_movable&quot;,
+         door = {{&quot;fl_bridge_bw&quot;, &quot;fl_bridge_bn&quot;, res = RESOLVE_RANDOM}, &quot;st_nil&quot;},
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_camouflage_hollow&quot;,
+                 alg = &quot;ralf&quot;}},
+[130] = {inf = &quot;fl_darkgray&quot;,
+         outf = {&quot;fl_dark&quot;, {&quot;st_redrock&quot;, &quot;st_invisible&quot;, &quot;st_invisible&quot;, &quot;st_invisible&quot;, res = RESOLVE_WAVES}},
+         wall = &quot;st_redrock&quot;,
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;gradients&quot;}},
+[131] = {inf = &quot;fl_wood&quot;,
+         outf = {&quot;fl_wood&quot;, {&quot;st_yellow&quot;, &quot;st_yellow&quot;, &quot;st_redrock&quot;, &quot;st_redrock&quot;, res = RESOLVE_WAVES}},
+         wall = {&quot;st_yellow&quot;, &quot;st_yellow&quot;, &quot;st_redrock&quot;, &quot;st_redrock&quot;, res = RESOLVE_WAVES},
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_flat_breakable&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+[132] = {inf = &quot;fl_lawn_b&quot;,
+         outf = {&quot;fl_water&quot;, &quot;fl_swamp&quot;, res = {RESOLVE_RANDOM, 3, 1}},
+         wall = &quot;st_camouflage&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = {&quot;fl_water&quot;, &quot;st_lightglass_hollow&quot;},
+         open_door = &quot;fl_swamp&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {inf = {&quot;fl_lawn_b&quot;, &quot;fl_swamp&quot;, res = RESOLVE_RANDOM},
+                 goal = {&quot;fl_swamp&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+[133] = {inf = &quot;fl_metal&quot;,
+         outf = {&quot;fl_space&quot;, &quot;fl_abyss&quot;, res = {RESOLVE_RANDOM, 1, 3}},
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+[134] = {inf = &quot;fl_bright&quot;,
+         outf = {&quot;fl_abyss&quot;, {&quot;st_grate_cross&quot;, &quot;st_invisible&quot;, &quot;st_invisible&quot;, &quot;st_invisible&quot;, res = RESOLVE_WAVES}},
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_redbrown_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_redbrown_hollow&quot;,
+                 alg = &quot;fourswitch&quot;}},
+[135] = {inf = &quot;fl_bright&quot;,
+         outf = {&quot;fl_bright&quot;, {&quot;st_granite&quot;, &quot;st_invisible&quot;, res = {RESOLVE_RANDOM, 1, 3}}},
+         wall = &quot;st_fake_oxydc&quot;,
+         box = &quot;st_rawglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         endp = {goal = {&quot;st_lightglass_hollow&quot;, &quot;it_nil&quot;},
+                 alg = &quot;hide&quot;}},
+[136] = {inf = &quot;fl_rough&quot;,
+         outf = {&quot;st_oneway_white_n&quot;, &quot;st_oneway_white_s&quot;, &quot;st_oneway_white_e&quot;, &quot;st_oneway_white_w&quot;, res = RESOLVE_RANDOM},
+         wall = {&quot;st_oneway_white_n&quot;, &quot;st_oneway_white_s&quot;, &quot;st_oneway_white_e&quot;, &quot;st_oneway_white_w&quot;, res = RESOLVE_RANDOM},
+         box = &quot;st_plop&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {alg = &quot;circle&quot;}},
+[137] = {inf = &quot;fl_metal&quot;,
+         outf = {&quot;st_mirror_slab_n&quot;, &quot;st_mirror_slab_e&quot;, &quot;st_mirror_slab_s&quot;, &quot;st_mirror_slab_w&quot;, res = RESOLVE_RANDOM},
+         wall = {&quot;st_redfiber&quot;, &quot;fl_abyss&quot;},
+         box = {&quot;st_mirror_slab_nm&quot;, &quot;st_mirror_slab_em&quot;, &quot;st_mirror_slab_sm&quot;, &quot;st_mirror_slab_wm&quot;, res = RESOLVE_RANDOM},
+         door = &quot;st_redfiber&quot;,
+         open_door = &quot;st_lightglass_hollow&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_nil&quot;, &quot;fl_darkgray&quot;},
+                 alg = &quot;ralf&quot;}},
+[138] = {inf = &quot;fl_wood_framed&quot;,
+         outf = &quot;fl_water&quot;,
+         wall = {ti{&quot;st_panel&quot;, cluster = 1}, ti{&quot;st_panel&quot;, cluster = 2}, res = RESOLVE_RANDOM},
+         box = &quot;st_shogun_s&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         open_door = &quot;st_nil&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 alg = &quot;ralf&quot;}},
+[139] = {inf = &quot;fl_dark&quot;,
+         outf = {{&quot;st_passage_white_square&quot;, &quot;fl_white&quot;}, {&quot;st_passage_black_square&quot;, &quot;fl_fake_abyss&quot;}, res = RESOLVE_CHECKERBOARD},
+         wall = &quot;st_blocker&quot;,
+         box = &quot;st_shogun_s&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;b&quot;,
+         endp = {inf = {&quot;fl_white&quot;, &quot;fl_fake_abyss&quot;, res = RESOLVE_CHECKERBOARD},
+                 goal = {&quot;st_nil&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+[140] = {inf = ti{&quot;fl_bast&quot;, friction = 3.0},
+         outf = {&quot;fl_lawn_e4&quot;, &quot;fl_lawn_e2&quot;, &quot;fl_lawn_e1&quot;, &quot;fl_lawn_e3&quot;, res = RESOLVE_WAVES},
+         wall = {&quot;st_brownpyramide&quot;, &quot;fl_lawn_b&quot;},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = {&quot;st_grate_cross&quot;, &quot;it_nil&quot;},
+                 alg = &quot;fourswitch&quot;}},
+[141] = {inf = ti{&quot;fl_aquamarine&quot;, adhesion = 1.0, friction = 3.0},
+         outf = {&quot;fl_water&quot;, {&quot;st_brownmarble&quot;, &quot;st_invisible&quot;, &quot;st_invisible&quot;, &quot;st_invisible&quot;, res = RESOLVE_WAVES}},
+         wall = {&quot;st_purplemarble&quot;, &quot;fl_lawn_b&quot;},
+         box = &quot;st_brownie&quot;,
+         door = &quot;st_knight&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_nil&quot;,
+                 give = &quot;it_sword&quot;,
+                 alg = &quot;block&quot;}},
+[142] = {inf = &quot;fl_lawn_b&quot;,
+         outf = {&quot;fl_lawn_c4&quot;, &quot;fl_lawn_d2&quot;, &quot;fl_lawn_c2&quot;, &quot;fl_lawn_e3&quot;, res = RESOLVE_WAVES},
+         wall = {&quot;st_lightglass&quot;, &quot;fl_lawn_b&quot;},
+         box = &quot;st_darkglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;hide&quot;}},
+[143] = {inf = &quot;fl_wood&quot;,
+         outf = {&quot;st_disco_light&quot;, {&quot;fl_wood_h&quot;, &quot;fl_wood_h&quot;, &quot;fl_wood_h&quot;, &quot;fl_wood_v&quot;, res = RESOLVE_WAVES}},
+         wall = {&quot;st_tigris&quot;, &quot;fl_wood_framed&quot;},
+         box = &quot;st_plop&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_purplemarble&quot;,
+                 alg = &quot;vortex&quot;}},
+[144] = {inf = &quot;fl_bluegreen&quot;,
+         outf = {&quot;fl_space&quot;, {&quot;it_squashed&quot;, &quot;it_nil&quot;, res = {RESOLVE_RANDOM, 1, 3}}},
+         wall = &quot;st_purplegray&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;d&quot;,
+         endp = {wall = &quot;st_lightglass_hollow&quot;,
+                 goal = &quot;st_darkglass_hollow&quot;,
+                 alg = &quot;outside&quot;, max_pairs = 3}},
+[145] = {inf = ti{&quot;fl_dunes&quot;, friction = 3.0, adhesion = 1.0},
+         outf = {&quot;fl_sand&quot;, {&quot;it_landmine&quot;, &quot;it_bottle_broken&quot;, &quot;it_nil&quot;, res = {RESOLVE_RANDOM, 3, 1, 15}}},
+         wall = {&quot;st_greenbrown&quot;, &quot;fl_sand&quot;},
+         box = &quot;st_lightglass_movable&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         endp = {goal = &quot;st_lightglass_hollow&quot;,
+                 alg = &quot;allcrack&quot;, max_pairs = 1}},
+[146] = {inf = &quot;fl_dark&quot;,
+         outf = {&quot;fl_abyss&quot;, {&quot;st_grate_cross&quot;, &quot;st_nil&quot;, res = {RESOLVE_RANDOM, 1, 10}}},
+         wall = &quot;st_granite&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;b&quot;,
+         white = true,
+         endp = {goal = {&quot;st_grate_cross&quot;, &quot;it_nil&quot;},
+                 alg = &quot;magnets&quot;}},
+[147] = {inf = &quot;fl_gray&quot;,
+         outf = {&quot;fl_slope_ose&quot;, &quot;fl_slope_osw&quot;, &quot;fl_slope_one&quot;, &quot;fl_slope_onw&quot;, res = RESOLVE_WAVES},
+         wall = &quot;st_jamb_white&quot;,
+         box = &quot;st_box_wood&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;a&quot;,
+         white = true,
+         endp = {goal = {&quot;st_nil&quot;, &quot;it_nil&quot;},
+                 alg = &quot;gradients&quot;}},
+[148] = {inf = &quot;fl_blueslab&quot;,
+         outf = {{&quot;fl_redslab&quot;, &quot;fl_blueslab&quot;, res = RESOLVE_CHECKERBOARD}, &quot;st_disco_light&quot;},
+         wall = &quot;st_metal&quot;,
+         box = &quot;st_shogun_s&quot;,
+         door = &quot;st_break_white&quot;,
+         oxyd = &quot;a&quot;,
+         white = true,
+         endp = {goal = &quot;st_break_white&quot;,
+                 give = &quot;it_hammer&quot;,
+                 alg = &quot;block&quot;}},
+[149] = {inf = &quot;fl_samba&quot;,
+         outf = &quot;fl_swamp&quot;,
+         wall = &quot;st_yellow&quot;,
+         box = &quot;st_shogun_s&quot;,
+         goal = &quot;it_shogun_s&quot;,
+         door = &quot;st_door_a&quot;,
+         oxyd = &quot;c&quot;,
+         white = true,
+         endp = {wall = {{&quot;st_nil&quot;, &quot;it_explosion&quot;}, &quot;fl_tigris&quot;},
+                 goal = {&quot;st_nil&quot;, &quot;it_explosion&quot;},
+                 alg = &quot;outside&quot;}},
+[150] = {inf = &quot;fl_brick&quot;,
+         outf = &quot;fl_space&quot;,
+         wall = &quot;st_redrock&quot;,
+         box = &quot;st_box_rock&quot;,
+         door = &quot;st_blocker&quot;,
+         oxyd = &quot;a&quot;,
+         white = true,
+         endp = {goal = {&quot;st_nil&quot;, &quot;fl_rock&quot;, &quot;it_nil&quot;},
+                 alg = &quot;ralf&quot;}},
+}
+
+-- Next follows a table to convert the codes Ralf used in his levels
+-- and ralf_sokoban to libsoko-designs. Note that there is a shift
+-- by -1 of the ralfcode in his library, except for design 0.
+-- Hence, when you start an old sokoban level with
+--   play_sokoban(level,715)
+-- then ralf_sokoban.init is called with argument 714, which corresponds
+-- to libsoko-design 4. Use
+--   lib.soko.create_sokoball(..., ...,
+--        lib.soko_designlist.ralfcode_conversion_table[715])
+-- to activate it manually.
+--
+lib.soko_designlist.ralfcode_conversion_table = {
+     [0]   = 1,
+   [714+1] = 4,
+   [715+1] = 70,
+   [716+1] = 37,
+   [718+1] = 18,
+   [719+1] = 57,
+   [720+1] = 43,
+   [764+1] = 28,
+   [765+1] = 10,
+   [766+1] = 61,
+   [767+1] = 19,
+   [768+1] = 14,
+   [769+1] = 44,
+   [770+1] = 5,
+   [771+1] = 71,
+   [772+1] = 38,
+   [773+1] = 62,
+   [775+1] = 58,
+   [776+1] = 45,
+   [777+1] = 34,
+   [867+1] = 46,
+   [868+1] = 2,
+   [869+1] = 74,
+   [870+1] = 41,
+   [871+1] = 63,
+   [872+1] = 20,
+   [873+1] = 54,
+   [874+1] = 47,
+   [875+1] = 32,
+   [876+1] = 29,
+   [877+1] = 11,
+   [910+1] = 6,
+   [911+1] = 72,
+   [912+1] = 39,
+   [913+1] = 64,
+   [914+1] = 21,
+   [915+1] = 59,
+   [916+1] = 48,
+   [917+1] = 35,
+   [918+1] = 26,
+   [919+1] = 8,
+   [920+1] = 65,
+   [921+1] = 22,
+   [922+1] = 16,
+  [1184+1] = 30,
+  [1185+1] = 12,
+  [1186+1] = 66,
+  [1187+1] = 23,
+  [1188+1] = 15,
+  [1189+1] = 49,
+  [1190+1] = 7,
+  [1191+1] = 73,
+  [1192+1] = 40,
+  [1193+1] = 67,
+  [1194+1] = 24,
+  [1195+1] = 60,
+  [1196+1] = 50,
+  [1196+1] = 51,
+  [1197+1] = 36,
+  [1198+1] = 27,
+  [1199+1] = 9,
+  [1200+1] = 68,
+  [1232+1] = 3,
+  [1233+1] = 75,
+  [1234+1] = 42,
+  [1235+1] = 69,
+  [1236+1] = 25,
+  [1237+1] = 55,
+  [1237+1] = 56,
+  [1238+1] = 52,
+  [1239+1] = 33,
+  [1240+1] = 31,
+  [1241+1] = 13,
+  [1314+1] = 17,
+  [1315+1] = 53
+}
+
+-- statistics uses print to output statistics
+-- of the used endphase algorithms.
+function lib.soko_designlist.statistics()
+    alglist = {}
+    for k, v in pairs(lib.soko.design_list) do
+        if v.endp then
+            alg = v.endp.alg
+            if alg then
+                alglist[alg] = (alglist[alg] or 0) + 1
+            end
+        else
+            alglist[&quot;default&quot;] = (alglist[&quot;default&quot;] or 0) + 1
+        end
+    end
+    for k, v in pairs(alglist) do
+        print(k..&quot;: &quot;..v)
+    end
+end
+
+    ]]&gt;&lt;/el:luamain&gt;
+    &lt;el:i18n&gt;
+    &lt;/el:i18n&gt;
+  &lt;/el:protected&gt;
+&lt;/el:level&gt;

Modified: trunk/doc/reference/enigma-ref.texi
===================================================================
--- trunk/doc/reference/enigma-ref.texi	2009-03-14 23:58:47 UTC (rev 1590)
+++ trunk/doc/reference/enigma-ref.texi	2009-03-16 00:55:33 UTC (rev 1591)
@@ -13746,6 +13746,7 @@
 * lib.lua.mod::             A modulo operation.
 * lib.lua.print_table::     Print tables for debug reasons.
 * lib.lua.shuffle::         Shuffle arbitrary anonymous Lua-tables.
+* lib.lua.to_string::       Takes anything as argument and tries to return a sensible description.
 @end menu
 
 @c ----------------- combine_tables --------------------
@@ -14022,6 +14023,46 @@
 @end example
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- to_string --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> lib.lua.to_string
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> lib.lua.to_string
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{to_string} is a debug function. It may take anything as argument, and
+tries to return a sensible string describing the type and, if possible, the
+content of the argument.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.lua.to_string}(@i{arg})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{arg}
+The argument to be described.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+print(lib.lua.to_string(strange_variable))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{to_string} is meant for debugging Lua code. Sometimes it happens that a
+variable is not what the author expected to be, and selecting the correct
+output method becomes try-and-error. @samp{to_string} is a fast shortcut to
+this. It returns the content of strings, numbers, booleans, tables, positions,
+and groups. It distinguishes ordinary tables from @ref{libmap}-maps. For
+objects, it returns their name and position, for position lists, it returns the
+total number of positions. It further recognizes nil, tile and tiles.
+
+Use @samp{to_string} only for debugging and testing, it
+is not meant as an element of gameplay.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
 @c ----------------- libmath --------------------
 @node libmath
 @section libmath
@@ -14045,6 +14086,7 @@
 * lib.math.manhattan_distance:: Calculates the Manhattan distance of positions.
 * lib.math.permutation::        Random permutation.
 * lib.math.random_vector::      A table with random entries.
+* lib.math.steps::              A function to classify a number in intervals.
 @end menu
 
 @c ----------------- combinations --------------------
@@ -14383,7 +14425,54 @@
 @end example
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- steps --------------------
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> lib.math.steps
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> lib.math.steps
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{steps} takes a number @samp{d} and a table of numbers as arguments and
+returns the index of the first number larger or equal @samp{d}, minus one.
+I.e. it classifies @samp{d} into the intervals given by the table, starting
+with zero, when @samp{d} is smaller than the first number in the table, one,
+when @samp{d} is larger or equal to the first, but smaller than the second
+number, and so on.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.math.steps}(@i{discriminator}, @i{steps})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{discriminator}
+A number.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{steps}
+A table of numbers.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+number_pairs = lib.math.steps(total_places, {2, 6, 10, 30})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Negative and non-integer values are allowed. However, the numbers in the
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{steps}-table should be monotonously increasing (not neccessarily strictly
+monotonously), as otherwise the result might be counterintuitive.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+lib.math.steps(x, {4, 8, 13})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+returns:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+     0  if        x &lt; 4
+     1  if   4 &lt;= x &lt; 8
+     2  if   8 &lt;= x &lt; 13
+     3  if  13 &lt;= x
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
 @node libmap
 @section libmap
 
@@ -14840,7 +14929,7 @@
 
 @table @asis
 @item @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{lib.import.unpack_multilevel}(multilevel, sublevel_number, format)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.import.unpack_multilevel}(@i{multilevel}, @i{sublevel_number}, @i{format})
 @table @asis
 @item @i{multilevel}
 A multilevel string.
@@ -14866,6 +14955,7 @@
 be determined by line endings, which can be quite different. In contrast to
 this, an Enigma map is a table of strings, with each line in a separate entry
 of the table. Hence, at least the line endings have to be dealt with.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
 
 @c ----------------- uncompress_rle --------------------
 
@@ -14877,7 +14967,7 @@
 
 @table @asis
 @item @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{lib.import.uncompress_rle}(level, attribs)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.import.uncompress_rle}(@i{level}, @i{attribs})
 @table @asis
 @item @i{level}
 A level string.
@@ -14905,6 +14995,7 @@
 you can hand a string to the attribute @samp{error_on_multiple}. Any character
 in this string is then forbidden to be repeated. Remember that the @samp{new
 line}-character is represented by @samp{\n} in Lua.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
 
 @c ----------------- level_to_map --------------------
 
@@ -14916,7 +15007,7 @@
 
 @table @asis
 @item @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{lib.import.level_to_map}(level, line_ending, default_key)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.import.level_to_map}(@i{level}, @i{line_ending}, @i{default_key})
 @table @asis
 @item @i{level}
 A level string.
@@ -14939,6 +15030,7 @@
 
 Make sure that the last line of the level ends in a proper line ending, and only
 one line ending. Otherwise, the returned map will be too short or too long.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
 
 @c ----------------- map_sokoban --------------------
 
@@ -14950,7 +15042,7 @@
 
 @table @asis
 @item @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{lib.import.map_sokoban}(multilevel, sublevel_number, keylength_one)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.import.map_sokoban}(@i{multilevel}, @i{sublevel_number}, @i{keylength_one})
 @table @asis
 @item @i{multilevel}
 A multilevel string.
@@ -14998,6 +15090,7 @@
 default key. Hence, if you want to paste the map into another one
 (@ref{Connecting Two Maps}), you will have to switch the default key to
 @samp{-} or @samp{- } in beforehand to yield a good result.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
 
 @c ----------------- map_wanderer --------------------
 @node lib.import.map_wanderer
@@ -15009,7 +15102,7 @@
 
 @table @asis
 @item @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{lib.import.map_wanderer}(monolevel)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.import.map_wanderer}(@i{monolevel})
 @table @asis
 @item @i{monolevel}
 A monolevel string.
@@ -15041,6 +15134,7 @@
 
 Note that Enigma does not yet support the game elements of Wanderer, hence this
 function currently is only of use to developers.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
 
 @c ----------------- libsoko --------------------
 @node libsoko
@@ -15055,16 +15149,58 @@
   &lt;@i{el}:@b{dependency} @i{el}:@b{path}=&quot;@var{lib/libsoko}&quot; @i{el}:@b{id}=&quot;@var{lib/libsoko}&quot; @i{el}:@b{release}=&quot;@var{1}&quot; @i{el}:@b{preload}=&quot;@var{true}&quot;/&gt;
 @end example
 
-It preloads automatically the libraries @ref{libimport}, @ref{libmap} and
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at ref</A>{liblua}.
+It preloads automatically the libraries @ref{libimport}, @ref{libmap},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{libmath}, and @ref{liblua}.
 
+The only function which is meant to be used in levels is
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{lib.soko.create_sokoball}.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at menu</A>
-* lib.soko.create::
-* lib.soko.recreate::
-* lib.soko.draw::
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> menu
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{lib.soko.create_sokoball}(@i{multilevel}, @i{sublevel_number}, @i{design}, @i{maxdesignnumber})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{multilevel}
+A multilevel string in the sense of @ref{libimport}.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{sublevel_number}
+A number determining the number of the level in @code{multilevel}. Default is
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{1}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{design}
+Optionally a number or a design table, see below.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{maxdesignnumber}
+Optionally, see below.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+lib.soko.create_sokoball(many_levels, 13, 48)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{create_sokoball} creates a sokoball-level from the string
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{multilevel}. This string can be a multilevel, in which case
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{sublevel_number} determines the number of the level, starting with 1
+(default is 1).
+
+The design can be chosen by @samp{design}. This is either a number, which refers
+to the list of predefined designs in @code{libsoko_designlist.xml}, or a table
+with the corresponding design entries. A missing entry will be interpreted as
+the entry from lib.soko_designlist.default. If the @samp{design} variable is
+omitted, a check-number is created from the level which uniquely* determines
+a design from the design list, with @code{maxdesignnumber} as highest possible
+design number.
+
+*Uniquely means: The design might change when the design list is enlarged.
+
+To define own designs, please consult
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{data/levels/lib/libsoko_designlist.xml}.
+
+Returns width and height of new Enigma level.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
 @c ===================  Advanced Features  =======================
 
 @node Advanced Features


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001020.html">[Enigma-game-svn] r1590 - trunk/doc/reference
</A></li>
	<LI>Next message: <A HREF="001022.html">[Enigma-game-svn] r1592 - in trunk: doc src src/items
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1021">[ date ]</a>
              <a href="thread.html#1021">[ thread ]</a>
              <a href="subject.html#1021">[ subject ]</a>
              <a href="author.html#1021">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
