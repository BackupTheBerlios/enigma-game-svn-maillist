<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1606 - trunk/lib-src/lua
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1606%20-%20trunk/lib-src/lua&In-Reply-To=%3C200903312145.n2VLjGXP027082%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001035.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1606 - trunk/lib-src/lua</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1606%20-%20trunk/lib-src/lua&In-Reply-To=%3C200903312145.n2VLjGXP027082%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1606 - trunk/lib-src/lua">ral at mail.berlios.de
       </A><BR>
    <I>Tue Mar 31 23:45:16 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001035.html">[Enigma-game-svn] r1605 - trunk/data/levels/lib
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1036">[ date ]</a>
              <a href="thread.html#1036">[ thread ]</a>
              <a href="subject.html#1036">[ subject ]</a>
              <a href="author.html#1036">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2009-03-31 23:45:14 +0200 (Tue, 31 Mar 2009)
New Revision: 1606

Modified:
   trunk/lib-src/lua/lapi.c
   trunk/lib-src/lua/lapi.h
   trunk/lib-src/lua/lauxlib.c
   trunk/lib-src/lua/lauxlib.h
   trunk/lib-src/lua/lbaselib.c
   trunk/lib-src/lua/lcode.c
   trunk/lib-src/lua/lcode.h
   trunk/lib-src/lua/ldblib.c
   trunk/lib-src/lua/ldebug.c
   trunk/lib-src/lua/ldebug.h
   trunk/lib-src/lua/ldo.c
   trunk/lib-src/lua/ldo.h
   trunk/lib-src/lua/ldump.c
   trunk/lib-src/lua/lfunc.c
   trunk/lib-src/lua/lfunc.h
   trunk/lib-src/lua/lgc.c
   trunk/lib-src/lua/lgc.h
   trunk/lib-src/lua/linit.c
   trunk/lib-src/lua/liolib.c
   trunk/lib-src/lua/llex.c
   trunk/lib-src/lua/llex.h
   trunk/lib-src/lua/llimits.h
   trunk/lib-src/lua/lmathlib.c
   trunk/lib-src/lua/lmem.c
   trunk/lib-src/lua/lmem.h
   trunk/lib-src/lua/loadlib.c
   trunk/lib-src/lua/lobject.c
   trunk/lib-src/lua/lobject.h
   trunk/lib-src/lua/lopcodes.c
   trunk/lib-src/lua/lopcodes.h
   trunk/lib-src/lua/loslib.c
   trunk/lib-src/lua/lparser.c
   trunk/lib-src/lua/lparser.h
   trunk/lib-src/lua/lstate.c
   trunk/lib-src/lua/lstate.h
   trunk/lib-src/lua/lstring.c
   trunk/lib-src/lua/lstring.h
   trunk/lib-src/lua/lstrlib.c
   trunk/lib-src/lua/ltable.c
   trunk/lib-src/lua/ltable.h
   trunk/lib-src/lua/ltablib.c
   trunk/lib-src/lua/ltm.c
   trunk/lib-src/lua/ltm.h
   trunk/lib-src/lua/lua.h
   trunk/lib-src/lua/luaconf.h
   trunk/lib-src/lua/lualib.h
   trunk/lib-src/lua/lundump.c
   trunk/lib-src/lua/lundump.h
   trunk/lib-src/lua/lvm.c
   trunk/lib-src/lua/lvm.h
   trunk/lib-src/lua/lzio.c
   trunk/lib-src/lua/lzio.h
Log:
Trunk 1.1:
- update Lua to 5.1.4

Modified: trunk/lib-src/lua/lapi.c
===================================================================
--- trunk/lib-src/lua/lapi.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lapi.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lapi.c,v 2.55 2006/06/07 12:37:17 roberto Exp $
+** $Id: lapi.c,v 2.55.1.5 2008/07/04 18:41:18 roberto Exp $
 ** Lua API
 ** See Copyright Notice in lua.h
 */
@@ -93,15 +93,14 @@
 
 
 LUA_API int lua_checkstack (lua_State *L, int size) {
-  int res;
+  int res = 1;
   lua_lock(L);
-  if ((L-&gt;top - L-&gt;base + size) &gt; LUAI_MAXCSTACK)
+  if (size &gt; LUAI_MAXCSTACK || (L-&gt;top - L-&gt;base + size) &gt; LUAI_MAXCSTACK)
     res = 0;  /* stack overflow */
-  else {
+  else if (size &gt; 0) {
     luaD_checkstack(L, size);
     if (L-&gt;ci-&gt;top &lt; L-&gt;top + size)
       L-&gt;ci-&gt;top = L-&gt;top + size;
-    res = 1;
   }
   lua_unlock(L);
   return res;
@@ -123,6 +122,11 @@
 }
 
 
+LUA_API void lua_setlevel (lua_State *from, lua_State *to) {
+  to-&gt;nCcalls = from-&gt;nCcalls;
+}
+
+
 LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
   lua_CFunction old;
   lua_lock(L);
@@ -749,7 +753,7 @@
       res = 0;
       break;
   }
-  luaC_objbarrier(L, gcvalue(o), hvalue(L-&gt;top - 1));
+  if (res) luaC_objbarrier(L, gcvalue(o), hvalue(L-&gt;top - 1));
   L-&gt;top--;
   lua_unlock(L);
   return res;
@@ -925,10 +929,13 @@
         g-&gt;GCthreshold = g-&gt;totalbytes - a;
       else
         g-&gt;GCthreshold = 0;
-      while (g-&gt;GCthreshold &lt;= g-&gt;totalbytes)
+      while (g-&gt;GCthreshold &lt;= g-&gt;totalbytes) {
         luaC_step(L);
-      if (g-&gt;gcstate == GCSpause)  /* end of cycle? */
-        res = 1;  /* signal it */
+        if (g-&gt;gcstate == GCSpause) {  /* end of cycle? */
+          res = 1;  /* signal it */
+          break;
+        }
+      }
       break;
     }
     case LUA_GCSETPAUSE: {

Modified: trunk/lib-src/lua/lapi.h
===================================================================
--- trunk/lib-src/lua/lapi.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lapi.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lapi.h,v 2.2 2005/04/25 19:24:10 roberto Exp $
+** $Id: lapi.h,v 2.2.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Auxiliary functions from Lua API
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lauxlib.c
===================================================================
--- trunk/lib-src/lua/lauxlib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lauxlib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lauxlib.c,v 1.159 2006/03/21 19:31:09 roberto Exp $
+** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
 ** Auxiliary functions for building Lua libraries
 ** See Copyright Notice in lua.h
 */
@@ -244,7 +244,7 @@
   if (libname) {
     int size = libsize(l);
     /* check whether lib already exists */
-    luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, size);
+    luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 1);
     lua_getfield(L, -1, libname);  /* get _LOADED[libname] */
     if (!lua_istable(L, -1)) {  /* not found? */
       lua_pop(L, 1);  /* remove previous result */
@@ -535,7 +535,7 @@
     return &quot;\n&quot;;
   }
   if (feof(lf-&gt;f)) return NULL;
-  *size = fread(lf-&gt;buff, 1, LUAL_BUFFERSIZE, lf-&gt;f);
+  *size = fread(lf-&gt;buff, 1, sizeof(lf-&gt;buff), lf-&gt;f);
   return (*size &gt; 0) ? lf-&gt;buff : NULL;
 }
 
@@ -570,9 +570,8 @@
     while ((c = getc(lf.f)) != EOF &amp;&amp; c != '\n') ;  /* skip first line */
     if (c == '\n') c = getc(lf.f);
   }
-  if (c == LUA_SIGNATURE[0] &amp;&amp; lf.f != stdin) {  /* binary file? */
-    fclose(lf.f);
-    lf.f = fopen(filename, &quot;rb&quot;);  /* reopen in binary mode */
+  if (c == LUA_SIGNATURE[0] &amp;&amp; filename) {  /* binary file? */
+    lf.f = freopen(filename, &quot;rb&quot;, lf.f);  /* reopen in binary mode */
     if (lf.f == NULL) return errfile(L, &quot;reopen&quot;, fnameindex);
     /* skip eventual `#!...' */
    while ((c = getc(lf.f)) != EOF &amp;&amp; c != LUA_SIGNATURE[0]) ;
@@ -581,7 +580,7 @@
   ungetc(c, lf.f);
   status = lua_load(L, getF, &amp;lf, lua_tostring(L, -1));
   readstatus = ferror(lf.f);
-  if (lf.f != stdin) fclose(lf.f);  /* close file (even in case of errors) */
+  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
   if (readstatus) {
     lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
     return errfile(L, &quot;read&quot;, fnameindex);

Modified: trunk/lib-src/lua/lauxlib.h
===================================================================
--- trunk/lib-src/lua/lauxlib.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lauxlib.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lauxlib.h,v 1.88 2006/04/12 20:31:15 roberto Exp $
+** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Auxiliary functions for building Lua libraries
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lbaselib.c
===================================================================
--- trunk/lib-src/lua/lbaselib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lbaselib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lbaselib.c,v 1.191 2006/06/02 15:34:00 roberto Exp $
+** $Id: lbaselib.c,v 1.191.1.6 2008/02/14 16:46:22 roberto Exp $
 ** Basic library
 ** See Copyright Notice in lua.h
 */
@@ -114,11 +114,11 @@
 }
 
 
-static void getfunc (lua_State *L) {
+static void getfunc (lua_State *L, int opt) {
   if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
   else {
     lua_Debug ar;
-    int level = luaL_optint(L, 1, 1);
+    int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);
     luaL_argcheck(L, level &gt;= 0, 1, &quot;level must be non-negative&quot;);
     if (lua_getstack(L, level, &amp;ar) == 0)
       luaL_argerror(L, 1, &quot;invalid level&quot;);
@@ -131,7 +131,7 @@
 
 
 static int luaB_getfenv (lua_State *L) {
-  getfunc(L);
+  getfunc(L, 1);
   if (lua_iscfunction(L, -1))  /* is a C function? */
     lua_pushvalue(L, LUA_GLOBALSINDEX);  /* return the thread's global env. */
   else
@@ -142,7 +142,7 @@
 
 static int luaB_setfenv (lua_State *L) {
   luaL_checktype(L, 2, LUA_TTABLE);
-  getfunc(L);
+  getfunc(L, 0);
   lua_pushvalue(L, 2);
   if (lua_isnumber(L, 1) &amp;&amp; lua_tonumber(L, 1) == 0) {
     /* change environment of current thread */
@@ -344,10 +344,12 @@
   luaL_checktype(L, 1, LUA_TTABLE);
   i = luaL_optint(L, 2, 1);
   e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
+  if (i &gt; e) return 0;  /* empty range */
   n = e - i + 1;  /* number of elements */
-  if (n &lt;= 0) return 0;  /* empty range */
-  luaL_checkstack(L, n, &quot;table too big to unpack&quot;);
-  for (; i&lt;=e; i++)  /* push arg[i...e] */
+  if (n &lt;= 0 || !lua_checkstack(L, n))  /* n &lt;= 0 means arith. overflow */
+    return luaL_error(L, &quot;too many results to unpack&quot;);
+  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
+  while (i++ &lt; e)  /* push arg[i + 1...e] */
     lua_rawgeti(L, 1, i);
   return n;
 }
@@ -477,19 +479,56 @@
 ** =======================================================
 */
 
+#define CO_RUN	0	/* running */
+#define CO_SUS	1	/* suspended */
+#define CO_NOR	2	/* 'normal' (it resumed another coroutine) */
+#define CO_DEAD	3
+
+static const char *const statnames[] =
+    {&quot;running&quot;, &quot;suspended&quot;, &quot;normal&quot;, &quot;dead&quot;};
+
+static int costatus (lua_State *L, lua_State *co) {
+  if (L == co) return CO_RUN;
+  switch (lua_status(co)) {
+    case LUA_YIELD:
+      return CO_SUS;
+    case 0: {
+      lua_Debug ar;
+      if (lua_getstack(co, 0, &amp;ar) &gt; 0)  /* does it have frames? */
+        return CO_NOR;  /* it is running */
+      else if (lua_gettop(co) == 0)
+          return CO_DEAD;
+      else
+        return CO_SUS;  /* initial state */
+    }
+    default:  /* some error occured */
+      return CO_DEAD;
+  }
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
+  lua_pushstring(L, statnames[costatus(L, co)]);
+  return 1;
+}
+
+
 static int auxresume (lua_State *L, lua_State *co, int narg) {
-  int status;
+  int status = costatus(L, co);
   if (!lua_checkstack(co, narg))
     luaL_error(L, &quot;too many arguments to resume&quot;);
-  if (lua_status(co) == 0 &amp;&amp; lua_gettop(co) == 0) {
-    lua_pushliteral(L, &quot;cannot resume dead coroutine&quot;);
+  if (status != CO_SUS) {
+    lua_pushfstring(L, &quot;cannot resume %s coroutine&quot;, statnames[status]);
     return -1;  /* error flag */
   }
   lua_xmove(L, co, narg);
+  lua_setlevel(L, co);
   status = lua_resume(co, narg);
   if (status == 0 || status == LUA_YIELD) {
     int nres = lua_gettop(co);
-    if (!lua_checkstack(L, nres))
+    if (!lua_checkstack(L, nres + 1))
       luaL_error(L, &quot;too many results to resume&quot;);
     lua_xmove(co, L, nres);  /* move yielded values */
     return nres;
@@ -556,39 +595,10 @@
 }
 
 
-static int luaB_costatus (lua_State *L) {
-  lua_State *co = lua_tothread(L, 1);
-  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
-  if (L == co) lua_pushliteral(L, &quot;running&quot;);
-  else {
-    switch (lua_status(co)) {
-      case LUA_YIELD:
-        lua_pushliteral(L, &quot;suspended&quot;);
-        break;
-      case 0: {
-        lua_Debug ar;
-        if (lua_getstack(co, 0, &amp;ar) &gt; 0)  /* does it have frames? */
-          lua_pushliteral(L, &quot;normal&quot;);  /* it is running */
-        else if (lua_gettop(co) == 0)
-            lua_pushliteral(L, &quot;dead&quot;);
-        else
-          lua_pushliteral(L, &quot;suspended&quot;);  /* initial state */
-        break;
-      }
-      default:  /* some error occured */
-        lua_pushliteral(L, &quot;dead&quot;);
-        break;
-    }
-  }
-  return 1;
-}
-
-
 static int luaB_corunning (lua_State *L) {
   if (lua_pushthread(L))
-    return 0;  /* main thread is not a coroutine */
-  else
-    return 1;
+    lua_pushnil(L);  /* main thread is not a coroutine */
+  return 1;
 }
 
 

Modified: trunk/lib-src/lua/lcode.c
===================================================================
--- trunk/lib-src/lua/lcode.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lcode.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lcode.c,v 2.25 2006/03/21 19:28:49 roberto Exp $
+** $Id: lcode.c,v 2.25.1.3 2007/12/28 15:32:23 roberto Exp $
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */
@@ -35,15 +35,20 @@
 void luaK_nil (FuncState *fs, int from, int n) {
   Instruction *previous;
   if (fs-&gt;pc &gt; fs-&gt;lasttarget) {  /* no jumps to current position? */
-    if (fs-&gt;pc == 0)  /* function start? */
-      return;  /* positions are already clean */
-    if (GET_OPCODE(*(previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1])) == OP_LOADNIL) {
-      int pfrom = GETARG_A(*previous);
-      int pto = GETARG_B(*previous);
-      if (pfrom &lt;= from &amp;&amp; from &lt;= pto+1) {  /* can connect both? */
-        if (from+n-1 &gt; pto)
-          SETARG_B(*previous, from+n-1);
-        return;
+    if (fs-&gt;pc == 0) {  /* function start? */
+      if (from &gt;= fs-&gt;nactvar)
+        return;  /* positions are already clean */
+    }
+    else {
+      previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1];
+      if (GET_OPCODE(*previous) == OP_LOADNIL) {
+        int pfrom = GETARG_A(*previous);
+        int pto = GETARG_B(*previous);
+        if (pfrom &lt;= from &amp;&amp; from &lt;= pto+1) {  /* can connect both? */
+          if (from+n-1 &gt; pto)
+            SETARG_B(*previous, from+n-1);
+          return;
+        }
       }
     }
   }
@@ -657,10 +662,16 @@
   if (constfolding(op, e1, e2))
     return;
   else {
+    int o2 = (op != OP_UNM &amp;&amp; op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
     int o1 = luaK_exp2RK(fs, e1);
-    int o2 = (op != OP_UNM &amp;&amp; op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
-    freeexp(fs, e2);
-    freeexp(fs, e1);
+    if (o1 &gt; o2) {
+      freeexp(fs, e1);
+      freeexp(fs, e2);
+    }
+    else {
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+    }
     e1-&gt;u.s.info = luaK_codeABC(fs, op, 0, o1, o2);
     e1-&gt;k = VRELOCABLE;
   }
@@ -688,7 +699,7 @@
   e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
   switch (op) {
     case OPR_MINUS: {
-      if (e-&gt;k == VK)
+      if (!isnumeral(e))
         luaK_exp2anyreg(fs, e);  /* cannot operate on non-numeric constants */
       codearith(fs, OP_UNM, e, &amp;e2);
       break;
@@ -718,10 +729,15 @@
       luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
       break;
     }
-    default: {
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
       if (!isnumeral(v)) luaK_exp2RK(fs, v);
       break;
     }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
   }
 }
 

Modified: trunk/lib-src/lua/lcode.h
===================================================================
--- trunk/lib-src/lua/lcode.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lcode.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lcode.h,v 1.48 2006/03/21 19:28:03 roberto Exp $
+** $Id: lcode.h,v 1.48.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/ldblib.c
===================================================================
--- trunk/lib-src/lua/ldblib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ldblib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ldblib.c,v 1.104 2005/12/29 15:32:11 roberto Exp $
+** $Id: ldblib.c,v 1.104.1.3 2008/01/21 13:11:21 roberto Exp $
 ** Interface from Lua to its debug API
 ** See Copyright Notice in lua.h
 */
@@ -255,24 +255,25 @@
 
 
 static int db_sethook (lua_State *L) {
-  int arg;
+  int arg, mask, count;
+  lua_Hook func;
   lua_State *L1 = getthread(L, &amp;arg);
   if (lua_isnoneornil(L, arg+1)) {
     lua_settop(L, arg+1);
-    lua_sethook(L1, NULL, 0, 0);  /* turn off hooks */
+    func = NULL; mask = 0; count = 0;  /* turn off hooks */
   }
   else {
     const char *smask = luaL_checkstring(L, arg+2);
-    int count = luaL_optint(L, arg+3, 0);
     luaL_checktype(L, arg+1, LUA_TFUNCTION);
-    lua_sethook(L1, hookf, makemask(smask, count), count);
+    count = luaL_optint(L, arg+3, 0);
+    func = hookf; mask = makemask(smask, count);
   }
-  gethooktable(L1);
-  lua_pushlightuserdata(L1, L1);
+  gethooktable(L);
+  lua_pushlightuserdata(L, L1);
   lua_pushvalue(L, arg+1);
-  lua_xmove(L, L1, 1);
-  lua_rawset(L1, -3);  /* set new hook */
-  lua_pop(L1, 1);  /* remove hook table */
+  lua_rawset(L, -3);  /* set new hook */
+  lua_pop(L, 1);  /* remove hook table */
+  lua_sethook(L1, func, mask, count);  /* set hooks */
   return 0;
 }
 
@@ -286,11 +287,10 @@
   if (hook != NULL &amp;&amp; hook != hookf)  /* external hook? */
     lua_pushliteral(L, &quot;external hook&quot;);
   else {
-    gethooktable(L1);
-    lua_pushlightuserdata(L1, L1);
-    lua_rawget(L1, -2);   /* get hook */
-    lua_remove(L1, -2);  /* remove hook table */
-    lua_xmove(L1, L, 1);
+    gethooktable(L);
+    lua_pushlightuserdata(L, L1);
+    lua_rawget(L, -2);   /* get hook */
+    lua_remove(L, -2);  /* remove hook table */
   }
   lua_pushstring(L, unmakemask(mask, buff));
   lua_pushinteger(L, lua_gethookcount(L1));

Modified: trunk/lib-src/lua/ldebug.c
===================================================================
--- trunk/lib-src/lua/ldebug.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ldebug.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ldebug.c,v 2.29 2005/12/22 16:19:56 roberto Exp $
+** $Id: ldebug.c,v 2.29.1.6 2008/05/08 16:56:26 roberto Exp $
 ** Debug Interface
 ** See Copyright Notice in lua.h
 */
@@ -275,12 +275,12 @@
 
 static int precheck (const Proto *pt) {
   check(pt-&gt;maxstacksize &lt;= MAXSTACK);
-  lua_assert(pt-&gt;numparams+(pt-&gt;is_vararg &amp; VARARG_HASARG) &lt;= pt-&gt;maxstacksize);
-  lua_assert(!(pt-&gt;is_vararg &amp; VARARG_NEEDSARG) ||
+  check(pt-&gt;numparams+(pt-&gt;is_vararg &amp; VARARG_HASARG) &lt;= pt-&gt;maxstacksize);
+  check(!(pt-&gt;is_vararg &amp; VARARG_NEEDSARG) ||
               (pt-&gt;is_vararg &amp; VARARG_HASARG));
   check(pt-&gt;sizeupvalues &lt;= pt-&gt;nups);
   check(pt-&gt;sizelineinfo == pt-&gt;sizecode || pt-&gt;sizelineinfo == 0);
-  check(GET_OPCODE(pt-&gt;code[pt-&gt;sizecode-1]) == OP_RETURN);
+  check(pt-&gt;sizecode &gt; 0 &amp;&amp; GET_OPCODE(pt-&gt;code[pt-&gt;sizecode-1]) == OP_RETURN);
   return 1;
 }
 
@@ -346,9 +346,18 @@
           int dest = pc+1+b;
           check(0 &lt;= dest &amp;&amp; dest &lt; pt-&gt;sizecode);
           if (dest &gt; 0) {
-            /* cannot jump to a setlist count */
-            Instruction d = pt-&gt;code[dest-1];
-            check(!(GET_OPCODE(d) == OP_SETLIST &amp;&amp; GETARG_C(d) == 0));
+            int j;
+            /* check that it does not jump to a setlist count; this
+               is tricky, because the count from a previous setlist may
+               have the same value of an invalid setlist; so, we must
+               go all the way back to the first of them (if any) */
+            for (j = 0; j &lt; dest; j++) {
+              Instruction d = pt-&gt;code[dest-1-j];
+              if (!(GET_OPCODE(d) == OP_SETLIST &amp;&amp; GETARG_C(d) == 0)) break;
+            }
+            /* if 'j' is even, previous value is not a setlist (even if
+               it looks like one) */
+            check((j&amp;1) == 0);
           }
         }
         break;
@@ -363,7 +372,11 @@
     }
     switch (op) {
       case OP_LOADBOOL: {
-        check(c == 0 || pc+2 &lt; pt-&gt;sizecode);  /* check its jump */
+        if (c == 1) {  /* does it jump? */
+          check(pc+2 &lt; pt-&gt;sizecode);  /* check its jump */
+          check(GET_OPCODE(pt-&gt;code[pc+1]) != OP_SETLIST ||
+                GETARG_C(pt-&gt;code[pc+1]) != 0);
+        }
         break;
       }
       case OP_LOADNIL: {
@@ -428,18 +441,23 @@
       }
       case OP_SETLIST: {
         if (b &gt; 0) checkreg(pt, a + b);
-        if (c == 0) pc++;
+        if (c == 0) {
+          pc++;
+          check(pc &lt; pt-&gt;sizecode - 1);
+        }
         break;
       }
       case OP_CLOSURE: {
-        int nup;
+        int nup, j;
         check(b &lt; pt-&gt;sizep);
         nup = pt-&gt;p[b]-&gt;nups;
         check(pc + nup &lt; pt-&gt;sizecode);
-        for (; nup&gt;0; nup--) {
-          OpCode op1 = GET_OPCODE(pt-&gt;code[pc+nup]);
+        for (j = 1; j &lt;= nup; j++) {
+          OpCode op1 = GET_OPCODE(pt-&gt;code[pc + j]);
           check(op1 == OP_GETUPVAL || op1 == OP_MOVE);
         }
+        if (reg != NO_REG)  /* tracing? */
+          pc += nup;  /* do not 'execute' these pseudo-instructions */
         break;
       }
       case OP_VARARG: {
@@ -561,8 +579,8 @@
 
 
 void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
-  if (ttisstring(p1)) p1 = p2;
-  lua_assert(!ttisstring(p1));
+  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1) &amp;&amp; !ttisnumber(p1));
   luaG_typeerror(L, p1, &quot;concatenate&quot;);
 }
 

Modified: trunk/lib-src/lua/ldebug.h
===================================================================
--- trunk/lib-src/lua/ldebug.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ldebug.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ldebug.h,v 2.3 2005/04/25 19:24:10 roberto Exp $
+** $Id: ldebug.h,v 2.3.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Auxiliary functions from Debug Interface module
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/ldo.c
===================================================================
--- trunk/lib-src/lua/ldo.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ldo.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ldo.c,v 2.38 2006/06/05 19:36:14 roberto Exp $
+** $Id: ldo.c,v 2.38.1.3 2008/01/18 22:31:22 roberto Exp $
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */
@@ -83,7 +83,7 @@
   L-&gt;base = L-&gt;ci-&gt;base;
   luaF_close(L, L-&gt;base);  /* close eventual pending closures */
   luaD_seterrorobj(L, status, L-&gt;base);
-  L-&gt;nCcalls = 0;
+  L-&gt;nCcalls = L-&gt;baseCcalls;
   L-&gt;allowhook = 1;
   restore_stack_limit(L);
   L-&gt;errfunc = 0;
@@ -332,7 +332,7 @@
   ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
   luaD_callhook(L, LUA_HOOKRET, -1);
   if (f_isLua(L-&gt;ci)) {  /* Lua function? */
-    while (L-&gt;ci-&gt;tailcalls--)  /* call hook for eventual tail calls */
+    while ((L-&gt;hookmask &amp; LUA_MASKRET) &amp;&amp; L-&gt;ci-&gt;tailcalls--) /* tail calls */
       luaD_callhook(L, LUA_HOOKTAILRET, -1);
   }
   return restorestack(L, fr);
@@ -417,22 +417,24 @@
 LUA_API int lua_resume (lua_State *L, int nargs) {
   int status;
   lua_lock(L);
-  if (L-&gt;status != LUA_YIELD) {
-    if (L-&gt;status != 0)
-      return resume_error(L, &quot;cannot resume dead coroutine&quot;);
-    else if (L-&gt;ci != L-&gt;base_ci)
+  if (L-&gt;status != LUA_YIELD &amp;&amp; (L-&gt;status != 0 || L-&gt;ci != L-&gt;base_ci))
       return resume_error(L, &quot;cannot resume non-suspended coroutine&quot;);
-  }
+  if (L-&gt;nCcalls &gt;= LUAI_MAXCCALLS)
+    return resume_error(L, &quot;C stack overflow&quot;);
   luai_userstateresume(L, nargs);
-  lua_assert(L-&gt;errfunc == 0 &amp;&amp; L-&gt;nCcalls == 0);
+  lua_assert(L-&gt;errfunc == 0);
+  L-&gt;baseCcalls = ++L-&gt;nCcalls;
   status = luaD_rawrunprotected(L, resume, L-&gt;top - nargs);
   if (status != 0) {  /* error? */
     L-&gt;status = cast_byte(status);  /* mark thread as `dead' */
     luaD_seterrorobj(L, status, L-&gt;top);
     L-&gt;ci-&gt;top = L-&gt;top;
   }
-  else
+  else {
+    lua_assert(L-&gt;nCcalls == L-&gt;baseCcalls);
     status = L-&gt;status;
+  }
+  --L-&gt;nCcalls;
   lua_unlock(L);
   return status;
 }
@@ -441,7 +443,7 @@
 LUA_API int lua_yield (lua_State *L, int nresults) {
   luai_userstateyield(L, nresults);
   lua_lock(L);
-  if (L-&gt;nCcalls &gt; 0)
+  if (L-&gt;nCcalls &gt; L-&gt;baseCcalls)
     luaG_runerror(L, &quot;attempt to yield across metamethod/C-call boundary&quot;);
   L-&gt;base = L-&gt;top - nresults;  /* protect stack slots below */
   L-&gt;status = LUA_YIELD;

Modified: trunk/lib-src/lua/ldo.h
===================================================================
--- trunk/lib-src/lua/ldo.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ldo.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ldo.h,v 2.7 2005/08/24 16:15:49 roberto Exp $
+** $Id: ldo.h,v 2.7.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/ldump.c
===================================================================
--- trunk/lib-src/lua/ldump.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ldump.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ldump.c,v 1.15 2006/02/16 15:53:49 lhf Exp $
+** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
 ** save precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lfunc.c
===================================================================
--- trunk/lib-src/lua/lfunc.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lfunc.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lfunc.c,v 2.12 2005/12/22 16:19:56 roberto Exp $
+** $Id: lfunc.c,v 2.12.1.2 2007/12/28 14:58:43 roberto Exp $
 ** Auxiliary functions to manipulate prototypes and closures
 ** See Copyright Notice in lua.h
 */
@@ -55,7 +55,7 @@
   GCObject **pp = &amp;L-&gt;openupval;
   UpVal *p;
   UpVal *uv;
-  while ((p = ngcotouv(*pp)) != NULL &amp;&amp; p-&gt;v &gt;= level) {
+  while (*pp != NULL &amp;&amp; (p = ngcotouv(*pp))-&gt;v &gt;= level) {
     lua_assert(p-&gt;v != &amp;p-&gt;u.value);
     if (p-&gt;v == level) {  /* found a corresponding upvalue? */
       if (isdead(g, obj2gco(p)))  /* is it dead? */
@@ -96,7 +96,7 @@
 void luaF_close (lua_State *L, StkId level) {
   UpVal *uv;
   global_State *g = G(L);
-  while ((uv = ngcotouv(L-&gt;openupval)) != NULL &amp;&amp; uv-&gt;v &gt;= level) {
+  while (L-&gt;openupval != NULL &amp;&amp; (uv = ngcotouv(L-&gt;openupval))-&gt;v &gt;= level) {
     GCObject *o = obj2gco(uv);
     lua_assert(!isblack(o) &amp;&amp; uv-&gt;v != &amp;uv-&gt;u.value);
     L-&gt;openupval = uv-&gt;next;  /* remove from `open' list */

Modified: trunk/lib-src/lua/lfunc.h
===================================================================
--- trunk/lib-src/lua/lfunc.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lfunc.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lfunc.h,v 2.4 2005/04/25 19:24:10 roberto Exp $
+** $Id: lfunc.h,v 2.4.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Auxiliary functions to manipulate prototypes and closures
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lgc.c
===================================================================
--- trunk/lib-src/lua/lgc.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lgc.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lgc.c,v 2.38 2006/05/24 14:34:06 roberto Exp $
+** $Id: lgc.c,v 2.38.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lgc.h
===================================================================
--- trunk/lib-src/lua/lgc.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lgc.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lgc.h,v 2.15 2005/08/24 16:15:49 roberto Exp $
+** $Id: lgc.h,v 2.15.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/linit.c
===================================================================
--- trunk/lib-src/lua/linit.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/linit.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: linit.c,v 1.14 2005/12/29 15:32:11 roberto Exp $
+** $Id: linit.c,v 1.14.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Initialization of libraries for lua.c
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/liolib.c
===================================================================
--- trunk/lib-src/lua/liolib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/liolib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: liolib.c,v 2.73 2006/05/08 20:14:16 roberto Exp $
+** $Id: liolib.c,v 2.73.1.3 2008/01/18 17:47:43 roberto Exp $
 ** Standard I/O (and system) library
 ** See Copyright Notice in lua.h
 */
@@ -51,7 +51,7 @@
 }
 
 
-#define topfile(L)	((FILE **)luaL_checkudata(L, 1, LUA_FILEHANDLE))
+#define tofilep(L)	((FILE **)luaL_checkudata(L, 1, LUA_FILEHANDLE))
 
 
 static int io_type (lua_State *L) {
@@ -70,7 +70,7 @@
 
 
 static FILE *tofile (lua_State *L) {
-  FILE **f = topfile(L);
+  FILE **f = tofilep(L);
   if (*f == NULL)
     luaL_error(L, &quot;attempt to use a closed file&quot;);
   return *f;
@@ -93,19 +93,31 @@
 
 
 /*
-** this function has a separated environment, which defines the
-** correct __close for 'popen' files
+** function to (not) close the standard files stdin, stdout, and stderr
 */
+static int io_noclose (lua_State *L) {
+  lua_pushnil(L);
+  lua_pushliteral(L, &quot;cannot close standard file&quot;);
+  return 2;
+}
+
+
+/*
+** function to close 'popen' files
+*/
 static int io_pclose (lua_State *L) {
-  FILE **p = topfile(L);
+  FILE **p = tofilep(L);
   int ok = lua_pclose(L, *p);
   *p = NULL;
   return pushresult(L, ok, NULL);
 }
 
 
+/*
+** function to close regular files
+*/
 static int io_fclose (lua_State *L) {
-  FILE **p = topfile(L);
+  FILE **p = tofilep(L);
   int ok = (fclose(*p) == 0);
   *p = NULL;
   return pushresult(L, ok, NULL);
@@ -128,18 +140,18 @@
 
 
 static int io_gc (lua_State *L) {
-  FILE *f = *topfile(L);
-  /* ignore closed files and standard files */
-  if (f != NULL &amp;&amp; f != stdin &amp;&amp; f != stdout &amp;&amp; f != stderr)
+  FILE *f = *tofilep(L);
+  /* ignore closed files */
+  if (f != NULL)
     aux_close(L);
   return 0;
 }
 
 
 static int io_tostring (lua_State *L) {
-  FILE *f = *topfile(L);
+  FILE *f = *tofilep(L);
   if (f == NULL)
-    lua_pushstring(L, &quot;file (closed)&quot;);
+    lua_pushliteral(L, &quot;file (closed)&quot;);
   else
     lua_pushfstring(L, &quot;file (%p)&quot;, f);
   return 1;
@@ -155,6 +167,10 @@
 }
 
 
+/*
+** this function has a separated environment, which defines the
+** correct __close for 'popen' files
+*/
 static int io_popen (lua_State *L) {
   const char *filename = luaL_checkstring(L, 1);
   const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
@@ -280,7 +296,7 @@
     char *p = luaL_prepbuffer(&amp;b);
     if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
       luaL_pushresult(&amp;b);  /* close buffer */
-      return (lua_strlen(L, -1) &gt; 0);  /* check whether read something */
+      return (lua_objlen(L, -1) &gt; 0);  /* check whether read something */
     }
     l = strlen(p);
     if (l == 0 || p[l-1] != '\n')
@@ -308,7 +324,7 @@
     n -= nr;  /* still have to read `n' chars */
   } while (n &gt; 0 &amp;&amp; nr == rlen);  /* until end of count or eof */
   luaL_pushresult(&amp;b);  /* close buffer */
-  return (n == 0 || lua_strlen(L, -1) &gt; 0);
+  return (n == 0 || lua_objlen(L, -1) &gt; 0);
 }
 
 
@@ -502,31 +518,36 @@
     lua_pushvalue(L, -1);
     lua_rawseti(L, LUA_ENVIRONINDEX, k);
   }
-  lua_setfield(L, -2, fname);
+  lua_pushvalue(L, -2);  /* copy environment */
+  lua_setfenv(L, -2);  /* set it */
+  lua_setfield(L, -3, fname);
 }
 
 
+static void newfenv (lua_State *L, lua_CFunction cls) {
+  lua_createtable(L, 0, 1);
+  lua_pushcfunction(L, cls);
+  lua_setfield(L, -2, &quot;__close&quot;);
+}
+
+
 LUALIB_API int luaopen_io (lua_State *L) {
   createmeta(L);
   /* create (private) environment (with fields IO_INPUT, IO_OUTPUT, __close) */
-  lua_createtable(L, 2, 1);
+  newfenv(L, io_fclose);
   lua_replace(L, LUA_ENVIRONINDEX);
   /* open library */
   luaL_register(L, LUA_IOLIBNAME, iolib);
   /* create (and set) default files */
+  newfenv(L, io_noclose);  /* close function for default files */
   createstdfile(L, stdin, IO_INPUT, &quot;stdin&quot;);
   createstdfile(L, stdout, IO_OUTPUT, &quot;stdout&quot;);
   createstdfile(L, stderr, 0, &quot;stderr&quot;);
-  /* create environment for 'popen' */
+  lua_pop(L, 1);  /* pop environment for default files */
   lua_getfield(L, -1, &quot;popen&quot;);
-  lua_createtable(L, 0, 1);
-  lua_pushcfunction(L, io_pclose);
-  lua_setfield(L, -2, &quot;__close&quot;);
-  lua_setfenv(L, -2);
+  newfenv(L, io_pclose);  /* create environment for 'popen' */
+  lua_setfenv(L, -2);  /* set fenv for 'popen' */
   lua_pop(L, 1);  /* pop 'popen' */
-  /* set default close function */
-  lua_pushcfunction(L, io_fclose);
-  lua_setfield(L, LUA_ENVIRONINDEX, &quot;__close&quot;);
   return 1;
 }
 

Modified: trunk/lib-src/lua/llex.c
===================================================================
--- trunk/lib-src/lua/llex.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/llex.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: llex.c,v 2.20 2006/03/09 18:14:31 roberto Exp $
+** $Id: llex.c,v 2.20.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/llex.h
===================================================================
--- trunk/lib-src/lua/llex.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/llex.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: llex.h,v 1.58 2006/03/23 18:23:32 roberto Exp $
+** $Id: llex.h,v 1.58.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/llimits.h
===================================================================
--- trunk/lib-src/lua/llimits.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/llimits.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: llimits.h,v 1.69 2005/12/27 17:12:00 roberto Exp $
+** $Id: llimits.h,v 1.69.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Limits, basic types, and some other `installation-dependent' definitions
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lmathlib.c
===================================================================
--- trunk/lib-src/lua/lmathlib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lmathlib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lmathlib.c,v 1.67 2005/08/26 17:36:32 roberto Exp $
+** $Id: lmathlib.c,v 1.67.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Standard mathematical library
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lmem.c
===================================================================
--- trunk/lib-src/lua/lmem.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lmem.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lmem.c,v 1.70 2005/12/26 13:35:47 roberto Exp $
+** $Id: lmem.c,v 1.70.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Interface to Memory Manager
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lmem.h
===================================================================
--- trunk/lib-src/lua/lmem.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lmem.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lmem.h,v 1.31 2005/04/25 19:24:10 roberto Exp $
+** $Id: lmem.h,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Interface to Memory Manager
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/loadlib.c
===================================================================
--- trunk/lib-src/lua/loadlib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/loadlib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: loadlib.c,v 1.52 2006/04/10 18:27:23 roberto Exp $
+** $Id: loadlib.c,v 1.52.1.3 2008/08/06 13:29:28 roberto Exp $
 ** Dynamic library loader for Lua
 ** See Copyright Notice in lua.h
 **
@@ -16,9 +16,9 @@
 #define loadlib_c
 #define LUA_LIB
 
+#include &quot;lua.h&quot;
+
 #include &quot;lauxlib.h&quot;
-#include &quot;lobject.h&quot;
-#include &quot;lua.h&quot;
 #include &quot;lualib.h&quot;
 
 
@@ -98,7 +98,7 @@
   char buff[MAX_PATH + 1];
   char *lb;
   DWORD nsize = sizeof(buff)/sizeof(char);
-  DWORD n = GetModuleFileName(NULL, buff, nsize);
+  DWORD n = GetModuleFileNameA(NULL, buff, nsize);
   if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
     luaL_error(L, &quot;unable to get ModuleFileName&quot;);
   else {
@@ -112,7 +112,7 @@
 static void pusherror (lua_State *L) {
   int error = GetLastError();
   char buffer[128];
-  if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
       NULL, error, 0, buffer, sizeof(buffer), NULL))
     lua_pushstring(L, buffer);
   else
@@ -125,7 +125,7 @@
 
 
 static void *ll_load (lua_State *L, const char *path) {
-  HINSTANCE lib = LoadLibrary(path);
+  HINSTANCE lib = LoadLibraryA(path);
   if (lib == NULL) pusherror(L);
   return lib;
 }
@@ -356,15 +356,16 @@
   path = lua_tostring(L, -1);
   if (path == NULL)
     luaL_error(L, LUA_QL(&quot;package.%s&quot;) &quot; must be a string&quot;, pname);
-  lua_pushstring(L, &quot;&quot;);  /* error accumulator */
+  lua_pushliteral(L, &quot;&quot;);  /* error accumulator */
   while ((path = pushnexttemplate(L, path)) != NULL) {
     const char *filename;
     filename = luaL_gsub(L, lua_tostring(L, -1), LUA_PATH_MARK, name);
+    lua_remove(L, -2);  /* remove path template */
     if (readable(filename))  /* does file exist and is readable? */
       return filename;  /* return that file name */
-    lua_pop(L, 2);  /* remove path template and file name */ 
-    luaO_pushfstring(L, &quot;\n\tno file &quot; LUA_QS, filename);
-    lua_concat(L, 2);
+    lua_pushfstring(L, &quot;\n\tno file &quot; LUA_QS, filename);
+    lua_remove(L, -2);  /* remove file name */
+    lua_concat(L, 2);  /* add entry to possible error message */
   }
   return NULL;  /* not found */
 }
@@ -423,8 +424,8 @@
   funcname = mkfuncname(L, name);
   if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {
     if (stat != ERRFUNC) loaderror(L, filename);  /* real error */
-    luaO_pushfstring(L, &quot;\n\tno module &quot; LUA_QS &quot; in file &quot; LUA_QS,
-                        name, filename);
+    lua_pushfstring(L, &quot;\n\tno module &quot; LUA_QS &quot; in file &quot; LUA_QS,
+                       name, filename);
     return 1;  /* function not found */
   }
   return 1;
@@ -438,7 +439,7 @@
     luaL_error(L, LUA_QL(&quot;package.preload&quot;) &quot; must be a table&quot;);
   lua_getfield(L, -1, name);
   if (lua_isnil(L, -1))  /* not found? */
-    luaO_pushfstring(L, &quot;\n\tno field package.preload['%s']&quot;, name);
+    lua_pushfstring(L, &quot;\n\tno field package.preload['%s']&quot;, name);
   return 1;
 }
 
@@ -462,7 +463,7 @@
   lua_getfield(L, LUA_ENVIRONINDEX, &quot;loaders&quot;);
   if (!lua_istable(L, -1))
     luaL_error(L, LUA_QL(&quot;package.loaders&quot;) &quot; must be a table&quot;);
-  lua_pushstring(L, &quot;&quot;);  /* error message accumulator */
+  lua_pushliteral(L, &quot;&quot;);  /* error message accumulator */
   for (i=1; ; i++) {
     lua_rawgeti(L, -2, i);  /* get a loader */
     if (lua_isnil(L, -1))
@@ -505,8 +506,10 @@
 
 static void setfenv (lua_State *L) {
   lua_Debug ar;
-  lua_getstack(L, 1, &amp;ar);
-  lua_getinfo(L, &quot;f&quot;, &amp;ar);
+  if (lua_getstack(L, 1, &amp;ar) == 0 ||
+      lua_getinfo(L, &quot;f&quot;, &amp;ar) == 0 ||  /* get calling function */
+      lua_iscfunction(L, -1))
+    luaL_error(L, LUA_QL(&quot;module&quot;) &quot; not called from a Lua function&quot;);
   lua_pushvalue(L, -2);
   lua_setfenv(L, -2);
   lua_pop(L, 1);
@@ -646,8 +649,8 @@
   setpath(L, &quot;path&quot;, LUA_PATH, LUA_PATH_DEFAULT);  /* set field `path' */
   setpath(L, &quot;cpath&quot;, LUA_CPATH, LUA_CPATH_DEFAULT); /* set field `cpath' */
   /* store config information */
-  lua_pushstring(L, LUA_DIRSEP &quot;\n&quot; LUA_PATHSEP &quot;\n&quot; LUA_PATH_MARK &quot;\n&quot;
-                    LUA_EXECDIR &quot;\n&quot; LUA_IGMARK);
+  lua_pushliteral(L, LUA_DIRSEP &quot;\n&quot; LUA_PATHSEP &quot;\n&quot; LUA_PATH_MARK &quot;\n&quot;
+                     LUA_EXECDIR &quot;\n&quot; LUA_IGMARK);
   lua_setfield(L, -2, &quot;config&quot;);
   /* set field `loaded' */
   luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 2);

Modified: trunk/lib-src/lua/lobject.c
===================================================================
--- trunk/lib-src/lua/lobject.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lobject.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lobject.c,v 2.22 2006/02/10 17:43:52 roberto Exp $
+** $Id: lobject.c,v 2.22.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Some generic functions over Lua objects
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lobject.h
===================================================================
--- trunk/lib-src/lua/lobject.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lobject.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lobject.h,v 2.20 2006/01/18 11:37:34 roberto Exp $
+** $Id: lobject.h,v 2.20.1.2 2008/08/06 13:29:48 roberto Exp $
 ** Type definitions for Lua objects
 ** See Copyright Notice in lua.h
 */
@@ -208,7 +208,7 @@
 
 
 #define getstr(ts)	cast(const char *, (ts) + 1)
-#define svalue(o)       getstr(tsvalue(o))
+#define svalue(o)       getstr(rawtsvalue(o))
 
 
 

Modified: trunk/lib-src/lua/lopcodes.c
===================================================================
--- trunk/lib-src/lua/lopcodes.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lopcodes.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lopcodes.c,v 1.37 2005/11/08 19:45:36 roberto Exp $
+** $Id: lopcodes.c,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
 ** See Copyright Notice in lua.h
 */
 

Modified: trunk/lib-src/lua/lopcodes.h
===================================================================
--- trunk/lib-src/lua/lopcodes.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lopcodes.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lopcodes.h,v 1.125 2006/03/14 19:04:44 roberto Exp $
+** $Id: lopcodes.h,v 1.125.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Opcodes for Lua virtual machine
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/loslib.c
===================================================================
--- trunk/lib-src/lua/loslib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/loslib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: loslib.c,v 1.19 2006/04/26 18:19:49 roberto Exp $
+** $Id: loslib.c,v 1.19.1.3 2008/01/18 16:38:18 roberto Exp $
 ** Standard Operating System library
 ** See Copyright Notice in lua.h
 */
@@ -146,11 +146,22 @@
     setboolfield(L, &quot;isdst&quot;, stm-&gt;tm_isdst);
   }
   else {
-    char b[256];
-    if (strftime(b, sizeof(b), s, stm))
-      lua_pushstring(L, b);
-    else
-      return luaL_error(L, LUA_QL(&quot;date&quot;) &quot; format too long&quot;);
+    char cc[3];
+    luaL_Buffer b;
+    cc[0] = '%'; cc[2] = '\0';
+    luaL_buffinit(L, &amp;b);
+    for (; *s; s++) {
+      if (*s != '%' || *(s + 1) == '\0')  /* no conversion specifier? */
+        luaL_addchar(&amp;b, *s);
+      else {
+        size_t reslen;
+        char buff[200];  /* should be big enough for any conversion result */
+        cc[1] = *(++s);
+        reslen = strftime(buff, sizeof(buff), cc, stm);
+        luaL_addlstring(&amp;b, buff, reslen);
+      }
+    }
+    luaL_pushresult(&amp;b);
   }
   return 1;
 }
@@ -204,7 +215,6 @@
 
 static int os_exit (lua_State *L) {
   exit(luaL_optint(L, 1, EXIT_SUCCESS));
-  return 0;  /* to avoid warnings */
 }
 
 static const luaL_Reg syslib[] = {

Modified: trunk/lib-src/lua/lparser.c
===================================================================
--- trunk/lib-src/lua/lparser.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lparser.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lparser.c,v 2.42 2006/06/05 15:57:59 roberto Exp $
+** $Id: lparser.c,v 2.42.1.3 2007/12/28 15:32:23 roberto Exp $
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */
@@ -489,7 +489,7 @@
 
 static void listfield (LexState *ls, struct ConsControl *cc) {
   expr(ls, &amp;cc-&gt;v);
-  luaY_checklimit(ls-&gt;fs, cc-&gt;na, MAXARG_Bx, &quot;items in a constructor&quot;);
+  luaY_checklimit(ls-&gt;fs, cc-&gt;na, MAX_INT, &quot;items in a constructor&quot;);
   cc-&gt;na++;
   cc-&gt;tostore++;
 }
@@ -938,6 +938,8 @@
     primaryexp(ls, &amp;nv.v);
     if (nv.v.k == VLOCAL)
       check_conflict(ls, lh, &amp;nv.v);
+    luaY_checklimit(ls-&gt;fs, nvars, LUAI_MAXCCALLS - ls-&gt;L-&gt;nCcalls,
+                    &quot;variables in assignment&quot;);
     assignment(ls, &amp;nv, nvars+1);
   }
   else {  /* assignment -&gt; `=' explist1 */

Modified: trunk/lib-src/lua/lparser.h
===================================================================
--- trunk/lib-src/lua/lparser.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lparser.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lparser.h,v 1.57 2006/03/09 18:14:31 roberto Exp $
+** $Id: lparser.h,v 1.57.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lstate.c
===================================================================
--- trunk/lib-src/lua/lstate.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lstate.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lstate.c,v 2.36 2006/05/24 14:15:50 roberto Exp $
+** $Id: lstate.c,v 2.36.1.2 2008/01/03 15:20:39 roberto Exp $
 ** Global State
 ** See Copyright Notice in lua.h
 */
@@ -93,7 +93,7 @@
   resethookcount(L);
   L-&gt;openupval = NULL;
   L-&gt;size_ci = 0;
-  L-&gt;nCcalls = 0;
+  L-&gt;nCcalls = L-&gt;baseCcalls = 0;
   L-&gt;status = 0;
   L-&gt;base_ci = L-&gt;ci = NULL;
   L-&gt;savedpc = NULL;
@@ -205,7 +205,7 @@
   do {  /* repeat until no more errors */
     L-&gt;ci = L-&gt;base_ci;
     L-&gt;base = L-&gt;top = L-&gt;ci-&gt;base;
-    L-&gt;nCcalls = 0;
+    L-&gt;nCcalls = L-&gt;baseCcalls = 0;
   } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
   lua_assert(G(L)-&gt;tmudata == NULL);
   luai_userstateclose(L);

Modified: trunk/lib-src/lua/lstate.h
===================================================================
--- trunk/lib-src/lua/lstate.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lstate.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lstate.h,v 2.24 2006/02/06 18:27:59 roberto Exp $
+** $Id: lstate.h,v 2.24.1.2 2008/01/03 15:20:39 roberto Exp $
 ** Global State
 ** See Copyright Notice in lua.h
 */
@@ -112,6 +112,7 @@
   int stacksize;
   int size_ci;  /* size of array `base_ci' */
   unsigned short nCcalls;  /* number of nested C calls */
+  unsigned short baseCcalls;  /* nested C calls when resuming coroutine */
   lu_byte hookmask;
   lu_byte allowhook;
   int basehookcount;

Modified: trunk/lib-src/lua/lstring.c
===================================================================
--- trunk/lib-src/lua/lstring.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lstring.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lstring.c,v 2.8 2005/12/22 16:19:56 roberto Exp $
+** $Id: lstring.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
 ** String table (keeps all strings handled by Lua)
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lstring.h
===================================================================
--- trunk/lib-src/lua/lstring.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lstring.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lstring.h,v 1.43 2005/04/25 19:24:10 roberto Exp $
+** $Id: lstring.h,v 1.43.1.1 2007/12/27 13:02:25 roberto Exp $
 ** String table (keep all strings handled by Lua)
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lstrlib.c
===================================================================
--- trunk/lib-src/lua/lstrlib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lstrlib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lstrlib.c,v 1.132 2006/04/26 20:41:19 roberto Exp $
+** $Id: lstrlib.c,v 1.132.1.4 2008/07/11 17:27:21 roberto Exp $
 ** Standard library for string operations and pattern-matching
 ** See Copyright Notice in lua.h
 */
@@ -35,7 +35,8 @@
 
 static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
   /* relative string position: negative means back from end */
-  return (pos&gt;=0) ? pos : (ptrdiff_t)len+pos+1;
+  if (pos &lt; 0) pos += (ptrdiff_t)len + 1;
+  return (pos &gt;= 0) ? pos : 0;
 }
 
 
@@ -629,10 +630,6 @@
       lua_gettable(L, 3);
       break;
     }
-    default: {
-      luaL_argerror(L, 3, &quot;string/function/table expected&quot;); 
-      return;
-    }
   }
   if (!lua_toboolean(L, -1)) {  /* nil or false? */
     lua_pop(L, 1);
@@ -648,11 +645,15 @@
   size_t srcl;
   const char *src = luaL_checklstring(L, 1, &amp;srcl);
   const char *p = luaL_checkstring(L, 2);
+  int  tr = lua_type(L, 3);
   int max_s = luaL_optint(L, 4, srcl+1);
   int anchor = (*p == '^') ? (p++, 1) : 0;
   int n = 0;
   MatchState ms;
   luaL_Buffer b;
+  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
+                      &quot;string/function/table expected&quot;);
   luaL_buffinit(L, &amp;b);
   ms.L = L;
   ms.src_init = src;
@@ -723,7 +724,7 @@
 
 static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
   const char *p = strfrmt;
-  while (strchr(FLAGS, *p)) p++;  /* skip flags */
+  while (*p != '\0' &amp;&amp; strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
   if ((size_t)(p - strfrmt) &gt;= sizeof(FLAGS))
     luaL_error(L, &quot;invalid format (repeated flags)&quot;);
   if (isdigit(uchar(*p))) p++;  /* skip width */

Modified: trunk/lib-src/lua/ltable.c
===================================================================
--- trunk/lib-src/lua/ltable.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ltable.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ltable.c,v 2.32 2006/01/18 11:49:02 roberto Exp $
+** $Id: ltable.c,v 2.32.1.2 2007/12/28 15:32:23 roberto Exp $
 ** Lua tables (hash)
 ** See Copyright Notice in lua.h
 */
@@ -84,8 +84,8 @@
 static Node *hashnum (const Table *t, lua_Number n) {
   unsigned int a[numints];
   int i;
-  n += 1;  /* normalize number (avoid -0) */
-  lua_assert(sizeof(a) &lt;= sizeof(n));
+  if (luai_numeq(n, 0))  /* avoid problems with -0 */
+    return gnode(t, 0);
   memcpy(a, &amp;n, sizeof(a));
   for (i = 1; i &lt; numints; i++) a[0] += a[i];
   return hashmod(t, a[0]);

Modified: trunk/lib-src/lua/ltable.h
===================================================================
--- trunk/lib-src/lua/ltable.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ltable.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ltable.h,v 2.10 2006/01/10 13:13:06 roberto Exp $
+** $Id: ltable.h,v 2.10.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Lua tables (hash)
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/ltablib.c
===================================================================
--- trunk/lib-src/lua/ltablib.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ltablib.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ltablib.c,v 1.38 2005/10/23 17:38:15 roberto Exp $
+** $Id: ltablib.c,v 1.38.1.3 2008/02/14 16:46:58 roberto Exp $
 ** Library for Table Manipulation
 ** See Copyright Notice in lua.h
 */
@@ -118,7 +118,8 @@
 static int tremove (lua_State *L) {
   int e = aux_getn(L, 1);
   int pos = luaL_optint(L, 2, e);
-  if (e == 0) return 0;  /* table is `empty' */
+  if (!(1 &lt;= pos &amp;&amp; pos &lt;= e))  /* position is outside bounds? */
+   return 0;  /* nothing to remove */
   luaL_setn(L, 1, e - 1);  /* t.n = n-1 */
   lua_rawgeti(L, 1, pos);  /* result = t[pos] */
   for ( ;pos&lt;e; pos++) {
@@ -131,6 +132,15 @@
 }
 
 
+static void addfield (lua_State *L, luaL_Buffer *b, int i) {
+  lua_rawgeti(L, 1, i);
+  if (!lua_isstring(L, -1))
+    luaL_error(L, &quot;invalid value (%s) at index %d in table for &quot;
+                  LUA_QL(&quot;concat&quot;), luaL_typename(L, -1), i);
+    luaL_addvalue(b);
+}
+
+
 static int tconcat (lua_State *L) {
   luaL_Buffer b;
   size_t lsep;
@@ -140,13 +150,12 @@
   i = luaL_optint(L, 3, 1);
   last = luaL_opt(L, luaL_checkint, 4, luaL_getn(L, 1));
   luaL_buffinit(L, &amp;b);
-  for (; i &lt;= last; i++) {
-    lua_rawgeti(L, 1, i);
-    luaL_argcheck(L, lua_isstring(L, -1), 1, &quot;table contains non-strings&quot;);
-    luaL_addvalue(&amp;b);
-    if (i != last)
-      luaL_addlstring(&amp;b, sep, lsep);
+  for (; i &lt; last; i++) {
+    addfield(L, &amp;b, i);
+    luaL_addlstring(&amp;b, sep, lsep);
   }
+  if (i == last)  /* add last value (if interval was not empty) */
+    addfield(L, &amp;b, i);
   luaL_pushresult(&amp;b);
   return 1;
 }

Modified: trunk/lib-src/lua/ltm.c
===================================================================
--- trunk/lib-src/lua/ltm.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ltm.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ltm.c,v 2.8 2006/01/10 12:50:00 roberto Exp $
+** $Id: ltm.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Tag methods
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/ltm.h
===================================================================
--- trunk/lib-src/lua/ltm.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/ltm.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: ltm.h,v 2.6 2005/06/06 13:30:25 roberto Exp $
+** $Id: ltm.h,v 2.6.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Tag methods
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lua.h
===================================================================
--- trunk/lib-src/lua/lua.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lua.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lua.h,v 1.218 2006/06/02 15:34:00 roberto Exp $
+** $Id: lua.h,v 1.218.1.5 2008/08/06 13:30:12 roberto Exp $
 ** Lua - An Extensible Extension Language
 ** Lua.org, PUC-Rio, Brazil (<A HREF="http://www.lua.org">http://www.lua.org</A>)
 ** See Copyright Notice at the end of this file
@@ -17,9 +17,9 @@
 
 
 #define LUA_VERSION	&quot;Lua 5.1&quot;
-#define LUA_RELEASE	&quot;Lua 5.1.1&quot;
+#define LUA_RELEASE	&quot;Lua 5.1.4&quot;
 #define LUA_VERSION_NUM	501
-#define LUA_COPYRIGHT	&quot;Copyright (C) 1994-2006 Lua.org, PUC-Rio&quot;
+#define LUA_COPYRIGHT	&quot;Copyright (C) 1994-2008 Lua.org, PUC-Rio&quot;
 #define LUA_AUTHORS 	&quot;R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes&quot;
 
 
@@ -294,7 +294,10 @@
 #define lua_Chunkwriter		lua_Writer
 
 
+/* hack */
+LUA_API void lua_setlevel	(lua_State *from, lua_State *to);
 
+
 /*
 ** {======================================================================
 ** Debug API
@@ -359,7 +362,7 @@
 
 
 /******************************************************************************
-* Copyright (C) 1994-2006 Lua.org, PUC-Rio.  All rights reserved.
+* Copyright (C) 1994-2008 Lua.org, PUC-Rio.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the

Modified: trunk/lib-src/lua/luaconf.h
===================================================================
--- trunk/lib-src/lua/luaconf.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/luaconf.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: luaconf.h,v 1.82 2006/04/10 18:27:23 roberto Exp $
+** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
 ** Configuration file for Lua
 ** See Copyright Notice in lua.h
 */
@@ -360,7 +360,7 @@
 /*
 @@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'
 @* behavior.
-** CHANGE it to undefined as soon as you replace to 'luaL_registry'
+** CHANGE it to undefined as soon as you replace to 'luaL_register'
 ** your uses of 'luaL_openlib'
 */
 #define LUA_COMPAT_OPENLIB
@@ -440,9 +440,10 @@
 @* can use.
 ** CHANGE it if you need lots of (Lua) stack space for your C
 ** functions. This limit is arbitrary; its only purpose is to stop C
-** functions to consume unlimited stack space.
+** functions to consume unlimited stack space. (must be smaller than
+** -LUA_REGISTRYINDEX)
 */
-#define LUAI_MAXCSTACK	2048
+#define LUAI_MAXCSTACK	8000
 
 
 
@@ -666,7 +667,7 @@
 */
 #if defined(LUA_USE_POPEN)
 
-#define lua_popen(L,c,m)	((void)L, popen(c,m))
+#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
 #define lua_pclose(L,file)	((void)L, (pclose(file) != -1))
 
 #elif defined(LUA_WIN)

Modified: trunk/lib-src/lua/lualib.h
===================================================================
--- trunk/lib-src/lua/lualib.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lualib.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lualib.h,v 1.36 2005/12/27 17:12:00 roberto Exp $
+** $Id: lualib.h,v 1.36.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Lua standard libraries
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lundump.c
===================================================================
--- trunk/lib-src/lua/lundump.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lundump.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lundump.c,v 1.60 2006/02/16 15:53:49 lhf Exp $
+** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
 ** load precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
@@ -29,6 +29,7 @@
 
 #ifdef LUAC_TRUST_BINARIES
 #define IF(c,s)
+#define error(S,s)
 #else
 #define IF(c,s)		if (c) error(S,s)
 
@@ -113,7 +114,7 @@
    	setnilvalue(o);
 	break;
    case LUA_TBOOLEAN:
-   	setbvalue(o,LoadChar(S));
+   	setbvalue(o,LoadChar(S)!=0);
 	break;
    case LUA_TNUMBER:
 	setnvalue(o,LoadNumber(S));
@@ -122,7 +123,7 @@
 	setsvalue2n(S-&gt;L,o,LoadString(S));
 	break;
    default:
-	IF (1, &quot;bad constant&quot;);
+	error(S,&quot;bad constant&quot;);
 	break;
   }
  }
@@ -159,7 +160,9 @@
 
 static Proto* LoadFunction(LoadState* S, TString* p)
 {
- Proto* f=luaF_newproto(S-&gt;L);
+ Proto* f;
+ if (++S-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS) error(S,&quot;code too deep&quot;);
+ f=luaF_newproto(S-&gt;L);
  setptvalue2s(S-&gt;L,S-&gt;L-&gt;top,f); incr_top(S-&gt;L);
  f-&gt;source=LoadString(S); if (f-&gt;source==NULL) f-&gt;source=p;
  f-&gt;linedefined=LoadInt(S);
@@ -173,6 +176,7 @@
  LoadDebug(S,f);
  IF (!luaG_checkcode(f), &quot;bad code&quot;);
  S-&gt;L-&gt;top--;
+ S-&gt;L-&gt;nCcalls--;
  return f;
 }
 

Modified: trunk/lib-src/lua/lundump.h
===================================================================
--- trunk/lib-src/lua/lundump.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lundump.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lundump.h,v 1.40 2005/11/11 14:03:13 lhf Exp $
+** $Id: lundump.h,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
 ** load precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lvm.c
===================================================================
--- trunk/lib-src/lua/lvm.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lvm.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lvm.c,v 2.63 2006/06/05 15:58:59 roberto Exp $
+** $Id: lvm.c,v 2.63.1.3 2007/12/28 15:32:23 roberto Exp $
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */
@@ -61,11 +61,9 @@
   lu_byte mask = L-&gt;hookmask;
   const Instruction *oldpc = L-&gt;savedpc;
   L-&gt;savedpc = pc;
-  if (mask &gt; LUA_MASKLINE) {  /* instruction-hook set? */
-    if (L-&gt;hookcount == 0) {
-      resethookcount(L);
-      luaD_callhook(L, LUA_HOOKCOUNT, -1);
-    }
+  if ((mask &amp; LUA_MASKCOUNT) &amp;&amp; L-&gt;hookcount == 0) {
+    resethookcount(L);
+    luaD_callhook(L, LUA_HOOKCOUNT, -1);
   }
   if (mask &amp; LUA_MASKLINE) {
     Proto *p = ci_func(L-&gt;ci)-&gt;l.p;
@@ -165,7 +163,7 @@
   const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
   if (ttisnil(tm))
     tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
-  if (!ttisfunction(tm)) return 0;
+  if (ttisnil(tm)) return 0;
   callTMres(L, res, tm, p1, p2);
   return 1;
 }
@@ -281,10 +279,12 @@
   do {
     StkId top = L-&gt;base + last + 1;
     int n = 2;  /* number of elements handled in this pass (at least 2) */
-    if (!tostring(L, top-2) || !tostring(L, top-1)) {
+    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
       if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
         luaG_concaterror(L, top-2, top-1);
-    } else if (tsvalue(top-1)-&gt;len &gt; 0) {  /* if len=0, do nothing */
+    } else if (tsvalue(top-1)-&gt;len == 0)  /* second op is empty? */
+      (void)tostring(L, top - 2);  /* result is first op (as string) */
+    else {
       /* at least two string values; get as many as possible */
       size_t tl = tsvalue(top-1)-&gt;len;
       char *buffer;

Modified: trunk/lib-src/lua/lvm.h
===================================================================
--- trunk/lib-src/lua/lvm.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lvm.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lvm.h,v 2.5 2005/08/22 18:54:49 roberto Exp $
+** $Id: lvm.h,v 2.5.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lzio.c
===================================================================
--- trunk/lib-src/lua/lzio.c	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lzio.c	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lzio.c,v 1.31 2005/06/03 20:15:29 roberto Exp $
+** $Id: lzio.c,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
 ** a generic input stream interface
 ** See Copyright Notice in lua.h
 */

Modified: trunk/lib-src/lua/lzio.h
===================================================================
--- trunk/lib-src/lua/lzio.h	2009-03-31 21:37:25 UTC (rev 1605)
+++ trunk/lib-src/lua/lzio.h	2009-03-31 21:45:14 UTC (rev 1606)
@@ -1,5 +1,5 @@
 /*
-** $Id: lzio.h,v 1.21 2005/05/17 19:49:15 roberto Exp $
+** $Id: lzio.h,v 1.21.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Buffered streams
 ** See Copyright Notice in lua.h
 */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001035.html">[Enigma-game-svn] r1605 - trunk/data/levels/lib
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1036">[ date ]</a>
              <a href="thread.html#1036">[ thread ]</a>
              <a href="subject.html#1036">[ subject ]</a>
              <a href="author.html#1036">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
