<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1605 - trunk/data/levels/lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1605%20-%20trunk/data/levels/lib&In-Reply-To=%3C200903312137.n2VLbRfs026510%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001034.html">
   <LINK REL="Next"  HREF="001036.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1605 - trunk/data/levels/lib</H1>
    <B>andreasl at mail.berlios.de</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1605%20-%20trunk/data/levels/lib&In-Reply-To=%3C200903312137.n2VLbRfs026510%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1605 - trunk/data/levels/lib">andreasl at mail.berlios.de
       </A><BR>
    <I>Tue Mar 31 23:37:27 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001034.html">[Enigma-game-svn] r1604 - in trunk: data data/levels/lib	doc/reference
</A></li>
        <LI>Next message: <A HREF="001036.html">[Enigma-game-svn] r1606 - trunk/lib-src/lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1035">[ date ]</a>
              <a href="thread.html#1035">[ thread ]</a>
              <a href="subject.html#1035">[ subject ]</a>
              <a href="author.html#1035">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: andreasl
Date: 2009-03-31 23:37:25 +0200 (Tue, 31 Mar 2009)
New Revision: 1605

Modified:
   trunk/data/levels/lib/liblua.xml
   trunk/data/levels/lib/libmap.xml
   trunk/data/levels/lib/libmath.xml
   trunk/data/levels/lib/libsoko.xml
Log:
Trunk:
 - Re-indented libmath, libmap, liblua to 4 spaces instead of 2 spaces.
 - Activated freeze checks in libsoko.


Modified: trunk/data/levels/lib/liblua.xml
===================================================================
--- trunk/data/levels/lib/liblua.xml	2009-03-31 15:39:49 UTC (rev 1604)
+++ trunk/data/levels/lib/liblua.xml	2009-03-31 21:37:25 UTC (rev 1605)
@@ -43,19 +43,19 @@
 -- not copied as memory references, but complete (&quot;deep copy&quot;).
 -- Metatables are transfered, but not deep-copied.
 function lib.lua.deep_copy(source)
-  if type(source) ~= &quot;table&quot; then
-    return source
-  end
-  local dest = {}
-  for k, v in pairs(source) do
-    if type(v) == &quot;table&quot; then
-      rawset(dest, k, lib.lua.deep_copy(v))
-    else
-      rawset(dest, k, v)
+    if type(source) ~= &quot;table&quot; then
+        return source
     end
-  end
-  setmetatable(dest, getmetatable(source))
-  return dest
+    local dest = {}
+    for k, v in pairs(source) do
+        if type(v) == &quot;table&quot; then
+            rawset(dest, k, lib.lua.deep_copy(v))
+        else
+            rawset(dest, k, v)
+        end
+    end
+    setmetatable(dest, getmetatable(source))
+    return dest
 end 
 
 -- combine_tables returns a table consisting of all entries of the
@@ -64,23 +64,23 @@
 -- table with all entries of T1, T2, T3 etc., with the first table
 -- having highest priority etc.
 function lib.lua.combine_tables(arg1, ...)
-  local args = {arg1, ...}
-  if table.getn(args) == 1 then
-    args = arg1
-  end
-  if type(args) ~= &quot;table&quot; then
-    error(&quot;combine_tables: None or only one argument, and it's not a table!&quot;, 2)
-  end
-  local result = {}
-  for j,t in pairs(args) do
-    if type(t) ~= &quot;table&quot; then
-      error(&quot;combine_tables: Main table does not consist of tables alone!&quot;, 2)
+    local args = {arg1, ...}
+    if table.getn(args) == 1 then
+        args = arg1
     end
-    for k,v in pairs(t) do
-      result[k] = result[k] or lib.lua.deep_copy(v)
+    if type(args) ~= &quot;table&quot; then
+        error(&quot;combine_tables: None or only one argument, and it's not a table!&quot;, 2)
     end
-  end
-  return result
+    local result = {}
+    for j,t in pairs(args) do
+        if type(t) ~= &quot;table&quot; then
+            error(&quot;combine_tables: Main table does not consist of tables alone!&quot;, 2)
+        end
+        for k,v in pairs(t) do
+            result[k] = result[k] or lib.lua.deep_copy(v)
+        end
+    end
+    return result
 end
 
 -- shuffle resorts the table T randomly and returns a shallow copy of the
@@ -90,22 +90,22 @@
 -- that of the argument. Metamethods will be used during the copy
 -- (i.e. no rawget or rawset).
 function lib.lua.shuffle(t)
-  if type(t) ~= &quot;table&quot; then
-    error(&quot;lib.lua.shuffle: Argument is not a table.&quot;, 2)
-  end
-  local result = {}
-  setmetatable(result, getmetatable(t))
-  for key, value in pairs(t) do
-    result[key] = value
-  end
-  if table.getn(result) &lt; 2 then
+    if type(t) ~= &quot;table&quot; then
+        error(&quot;lib.lua.shuffle: Argument is not a table.&quot;, 2)
+    end
+    local result = {}
+    setmetatable(result, getmetatable(t))
+    for key, value in pairs(t) do
+        result[key] = value
+    end
+    if table.getn(result) &lt; 2 then
+        return result
+    end
+    for n = table.getn(result), 2, -1 do
+        local m = math.random(n)
+        result[n], result[m] = result[m], result[n]
+    end
     return result
-  end
-  for n = table.getn(result), 2, -1 do
-    local m = math.random(n)
-    result[n], result[m] = result[m], result[n]
-  end
-  return result
 end
 
 -- print_table uses the print command to print all
@@ -120,107 +120,107 @@
 -- Don't use it in levels. If you want to suppress
 -- the recursive function, use DEPTH = -1.
 function lib.lua.print_table(t, prefix, depth)
-  if type(t) ~= &quot;table&quot; then
-    print(&quot;print_table: Argument is of type &quot;..type(t)..&quot;, not table.&quot;)
-    return
-  end
-  for key, value in pairs(t) do
-    local key_s
-    if type(key) == &quot;string&quot; then
-      key_s = &quot;\&quot;&quot; .. key .. &quot;\&quot;&quot;
-    elseif type(key) == &quot;number&quot; then
-      key_s = key
-    elseif usertype(key) == &quot;position&quot; then
-      key_s = &quot;&lt;&quot; .. key.x .. &quot;/&quot; .. key.y .. &quot;&gt;&quot;
-    elseif type(key) == &quot;userdata&quot; then
-      key_s = &quot;&lt;&quot; .. usertype(key) .. &quot;&gt;&quot;
-    else
-      key_s = &quot;&lt;&quot; .. type(key) .. &quot;&gt;&quot;
+    if type(t) ~= &quot;table&quot; then
+        print(&quot;print_table: Argument is of type &quot;..type(t)..&quot;, not table.&quot;)
+        return
     end
-    if type(value) == &quot;number&quot; then
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. value)
-    elseif type(value) == &quot;string&quot; then
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = \&quot;&quot; .. value .. &quot;\&quot;&quot;)
-    elseif type(value) == &quot;boolean&quot; then
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. cond(value, &quot;true&quot;, &quot;false&quot;))
-    elseif type(value) == &quot;table&quot; then
-      if (depth or 0) &lt; 5 then
-        print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = |&quot;)
-        lib.lua.print_table(value,
-            (prefix or &quot;&quot;) .. &quot;|&quot; .. string.rep(&quot; &quot;, string.len(key_s) + 3),
-            (depth or 0) + 1)
-        print((prefix or &quot;&quot;) .. &quot;|&quot;)
-      else
-        print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = | ...&quot;)
-      end
-    elseif usertype(value) == &quot;position&quot; then
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = position &quot; .. value.x
-            .. &quot;/&quot; .. value.y)
-    elseif usertype(value) == &quot;polist&quot; then
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = polist of &quot; .. #value
-            .. &quot; position(s)&quot;)
-    elseif usertype(value) == &quot;object&quot; then
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = object of name '&quot;
-            .. (value.name or &quot;&quot;) .. &quot;'&quot;)
-    else
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; of type &quot; .. type(value)
-            .. &quot; (usertype '&quot; .. usertype(value) .. &quot;')&quot;)
+    for key, value in pairs(t) do
+        local key_s
+        if type(key) == &quot;string&quot; then
+            key_s = &quot;\&quot;&quot; .. key .. &quot;\&quot;&quot;
+        elseif type(key) == &quot;number&quot; then
+            key_s = key
+        elseif usertype(key) == &quot;position&quot; then
+            key_s = &quot;&lt;&quot; .. key.x .. &quot;/&quot; .. key.y .. &quot;&gt;&quot;
+        elseif type(key) == &quot;userdata&quot; then
+            key_s = &quot;&lt;&quot; .. usertype(key) .. &quot;&gt;&quot;
+        else
+            key_s = &quot;&lt;&quot; .. type(key) .. &quot;&gt;&quot;
+        end
+        if type(value) == &quot;number&quot; then
+            print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. value)
+        elseif type(value) == &quot;string&quot; then
+            print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = \&quot;&quot; .. value .. &quot;\&quot;&quot;)
+        elseif type(value) == &quot;boolean&quot; then
+            print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. cond(value, &quot;true&quot;, &quot;false&quot;))
+        elseif type(value) == &quot;table&quot; then
+            if (depth or 0) &lt; 5 then
+                print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = |&quot;)
+                lib.lua.print_table(value,
+                    (prefix or &quot;&quot;) .. &quot;|&quot; .. string.rep(&quot; &quot;, string.len(key_s) + 3),
+                    (depth or 0) + 1)
+                print((prefix or &quot;&quot;) .. &quot;|&quot;)
+            else
+                print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = | ...&quot;)
+            end
+        elseif usertype(value) == &quot;position&quot; then
+            print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = position &quot; .. value.x
+                  .. &quot;/&quot; .. value.y)
+        elseif usertype(value) == &quot;polist&quot; then
+            print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = polist of &quot; .. #value
+                  .. &quot; position(s)&quot;)
+        elseif usertype(value) == &quot;object&quot; then
+            print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = object of name '&quot;
+                  .. (value.name or &quot;&quot;) .. &quot;'&quot;)
+        else
+            print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; of type &quot; .. type(value)
+                  .. &quot; (usertype '&quot; .. usertype(value) .. &quot;')&quot;)
+        end
     end
-  end
 end
 
 function lib.lua.to_string(thing)
-  local t = etype(thing)
-  local result = t
-  if (t == &quot;nil&quot;) then
-    result = &quot;nil&quot;
-  elseif (t == &quot;string&quot;) then
-    if string.find(thing, &quot;\n&quot;, 1, true) then
-      result = &quot;string of several lines: \n&quot; .. thing
+    local t = etype(thing)
+    local result = t
+    if (t == &quot;nil&quot;) then
+        result = &quot;nil&quot;
+    elseif (t == &quot;string&quot;) then
+        if string.find(thing, &quot;\n&quot;, 1, true) then
+            result = &quot;string of several lines: \n&quot; .. thing
+        end
+        result = &quot;string: \&quot;&quot; .. thing .. &quot;\&quot;&quot;
+    elseif (t == &quot;number&quot;) then
+        result = &quot;number: &quot; .. thing
+    elseif (t == &quot;boolean&quot;) then
+        result = &quot;boolean: &quot; .. cond(thing, &quot;true&quot;, &quot;false&quot;)
+    elseif (t == &quot;table&quot;) then
+        result = &quot;table:\n&quot;
+        local found = false
+        for key, value in pairs(thing) do
+            found = true
+            result = result .. &quot;  &quot; .. lib.lua.to_string(key) .. &quot; -&gt; &quot; .. lib.lua.to_string(value) .. &quot;\n&quot;
+        end
+        if not found then
+            result = &quot;empty table&quot;
+        end
+    elseif (t == &quot;position&quot;) then
+        result = &quot;position: &quot; .. thing.x .. &quot;/&quot; .. thing.y
+    elseif (t == &quot;object&quot;) then
+        result = &quot;object with name '&quot; .. thing.name .. &quot;' at &quot; .. lib.lua.to_string(po(thing))
+    elseif (t == &quot;tile&quot;) then
+        result = &quot;tile&quot;
+    elseif (t == &quot;tiles&quot;) then
+        result = &quot;tiles&quot;
+    elseif (t == &quot;group&quot;) then
+        result = &quot;object group with &quot; .. #thing .. &quot; objects:\n&quot;
+        for obj in thing do
+            result = result .. &quot;  &quot; .. lib.lua.to_string(obj) .. &quot;\n&quot;
+        end
+    elseif (t == &quot;polist&quot;) then
+        result = &quot;position list with &quot; .. #thing .. &quot; positions:\n&quot;
+        for j = 1, #thing do
+            result = result .. &quot;  &quot; .. j .. &quot;: &quot; .. thing[j].x .. &quot;/&quot; .. thing[j].y .. &quot;\n&quot;
+        end
+    elseif (t == &quot;map&quot;) then
+        result = &quot;map of size &quot; .. thing.width .. &quot; x &quot; .. thing.height .. &quot; with default key '&quot;
+                   .. thing.defaultkey .. &quot;':\n&quot;
+        for j = 1, thing.width do
+            result = result .. &quot;  \&quot;&quot; .. thing[j] .. &quot;\&quot;\n&quot;
+        end
+    elseif (t == &quot;unknown&quot;) then
+        result = &quot;unknown userdata&quot;
     end
-    result = &quot;string: \&quot;&quot; .. thing .. &quot;\&quot;&quot;
-  elseif (t == &quot;number&quot;) then
-    result = &quot;number: &quot; .. thing
-  elseif (t == &quot;boolean&quot;) then
-    result = &quot;boolean: &quot; .. cond(thing, &quot;true&quot;, &quot;false&quot;)
-  elseif (t == &quot;table&quot;) then
-    result = &quot;table:\n&quot;
-    local found = false
-    for key, value in pairs(thing) do
-      found = true
-      result = result .. &quot;  &quot; .. lib.lua.to_string(key) .. &quot; -&gt; &quot; .. lib.lua.to_string(value) .. &quot;\n&quot;
-    end
-    if not found then
-      result = &quot;empty table&quot;
-    end
-  elseif (t == &quot;position&quot;) then
-    result = &quot;position: &quot; .. thing.x .. &quot;/&quot; .. thing.y
-  elseif (t == &quot;object&quot;) then
-    result = &quot;object with name '&quot; .. thing.name .. &quot;' at &quot; .. lib.lua.to_string(po(thing))
-  elseif (t == &quot;tile&quot;) then
-    result = &quot;tile&quot;
-  elseif (t == &quot;tiles&quot;) then
-    result = &quot;tiles&quot;
-  elseif (t == &quot;group&quot;) then
-    result = &quot;object group with &quot; .. #thing .. &quot; objects:\n&quot;
-    for obj in thing do
-      result = result .. &quot;  &quot; .. lib.lua.to_string(obj) .. &quot;\n&quot;
-    end
-  elseif (t == &quot;polist&quot;) then
-    result = &quot;position list with &quot; .. #thing .. &quot; positions:\n&quot;
-    for j = 1, #thing do
-      result = result .. &quot;  &quot; .. j .. &quot;: &quot; .. thing[j].x .. &quot;/&quot; .. thing[j].y .. &quot;\n&quot;
-    end
-  elseif (t == &quot;map&quot;) then
-    result = &quot;map of size &quot; .. thing.width .. &quot; x &quot; .. thing.height .. &quot; with default key '&quot;
-             .. thing.defaultkey .. &quot;':\n&quot;
-    for j = 1, thing.width do
-      result = result .. &quot;  \&quot;&quot; .. thing[j] .. &quot;\&quot;\n&quot;
-    end
-  elseif (t == &quot;unknown&quot;) then
-    result = &quot;unknown userdata&quot;
-  end
-  return result
+    return result
 end
 
 ---------------------------------------------------------------------
@@ -233,16 +233,16 @@
 -- values as it should. The following function returns (given
 -- an integer) another integer between 0 and MODUL-1.
 function lib.lua.mod(value, modul)
-  assert_type(value, &quot;lib.lua.mod first argument&quot;, 2, &quot;number&quot;)
-  assert_type(modul, &quot;lib.lua.mod second argument&quot;, 2, &quot;positive&quot;)
-  if value &lt; 0 then
-    -- No, the following call to lib.lua.mod is not a real recursion, it's
-    -- only for the case where VALUE is a negative multiple of MODUL
-    -- (otherwise we would get MODUL as result, not zero).
-    return lib.lua.mod(modul + (math.fmod or math.mod)(value, modul), modul)
-  else
-    return (math.fmod or math.mod)(value, modul)
-  end
+    assert_type(value, &quot;lib.lua.mod first argument&quot;, 2, &quot;number&quot;)
+    assert_type(modul, &quot;lib.lua.mod second argument&quot;, 2, &quot;positive&quot;)
+    if value &lt; 0 then
+        -- No, the following call to lib.lua.mod is not a real recursion, it's
+        -- only for the case where VALUE is a negative multiple of MODUL
+        -- (otherwise we would get MODUL as result, not zero).
+        return lib.lua.mod(modul + (math.fmod or math.mod)(value, modul), modul)
+    else
+        return (math.fmod or math.mod)(value, modul)
+    end
 end
 
     ]]&gt;&lt;/el:luamain&gt;

Modified: trunk/data/levels/lib/libmap.xml
===================================================================
--- trunk/data/levels/lib/libmap.xml	2009-03-31 15:39:49 UTC (rev 1604)
+++ trunk/data/levels/lib/libmap.xml	2009-03-31 21:37:25 UTC (rev 1605)
@@ -53,583 +53,583 @@
 setmetatable(lib.map, getmetatable(lib))
 
 function lib.map.concat_horizontally(map1, map2)
-  assert_type(map1, &quot;lib.map.concat_horizontally first argument&quot;, 2, &quot;map&quot;)
-  assert_type(map2, &quot;lib.map.concat_horizontally second argument&quot;, 2, &quot;map&quot;)
-  if string.len(map1.defaultkey) ~= string.len(map2.defaultkey) then
-    error(&quot;lib.map.concat_horizontally: Default keys differ in length.&quot;, 2)
-  end
-  local result = {}
-  for y = 1, math.max(map1.height, map2.height) do
-    result[y] = (rawget(map1, y) or string.rep(map1.defaultkey, map1.width))
-             .. (rawget(map2, y) or string.rep(map2.defaultkey, map2.width))
-  end
-  return wo:newMap(map1.defaultkey, result)  
+    assert_type(map1, &quot;lib.map.concat_horizontally first argument&quot;, 2, &quot;map&quot;)
+    assert_type(map2, &quot;lib.map.concat_horizontally second argument&quot;, 2, &quot;map&quot;)
+    if string.len(map1.defaultkey) ~= string.len(map2.defaultkey) then
+        error(&quot;lib.map.concat_horizontally: Default keys differ in length.&quot;, 2)
+    end
+    local result = {}
+    for y = 1, math.max(map1.height, map2.height) do
+        result[y] = (rawget(map1, y) or string.rep(map1.defaultkey, map1.width))
+                 .. (rawget(map2, y) or string.rep(map2.defaultkey, map2.width))
+    end
+    return wo:newMap(map1.defaultkey, result)  
 end
 
 function lib.map.concat_vertically(map1, map2)
-  assert_type(map1, &quot;lib.map.concat_vertically first argument&quot;, 2, &quot;map&quot;)
-  assert_type(map2, &quot;lib.map.concat_vertically second argument&quot;, 2, &quot;map&quot;)
-  if string.len(map1.defaultkey) ~= string.len(map2.defaultkey) then
-    error(&quot;lib.map.concat_vertically: Default keys differ in length.&quot;, 2)
-  end
-  local result = {}
-  for y = 1, map1.height do
-    result[y] = rawget(map1, y)  -- rest of line will be filled by wo:newMap
-  end
-  -- As the default key for result will be set to the first
-  -- default key, we have to attach the missing lines of the
-  -- second map here now.
-  local rest = string.rep(map2.defaultkey, math.max(0, map1.width - map2.width))
-  for y = 1, map2.height do
-    result[y + map1.height] = rawget(map2, y) .. rest
-  end
-  return wo:newMap(map1.defaultkey, result)
+    assert_type(map1, &quot;lib.map.concat_vertically first argument&quot;, 2, &quot;map&quot;)
+    assert_type(map2, &quot;lib.map.concat_vertically second argument&quot;, 2, &quot;map&quot;)
+    if string.len(map1.defaultkey) ~= string.len(map2.defaultkey) then
+        error(&quot;lib.map.concat_vertically: Default keys differ in length.&quot;, 2)
+    end
+    local result = {}
+    for y = 1, map1.height do
+        result[y] = rawget(map1, y)  -- rest of line will be filled by wo:newMap
+    end
+    -- As the default key for result will be set to the first
+    -- default key, we have to attach the missing lines of the
+    -- second map here now.
+    local rest = string.rep(map2.defaultkey, math.max(0, map1.width - map2.width))
+    for y = 1, map2.height do
+        result[y + map1.height] = rawget(map2, y) .. rest
+    end
+    return wo:newMap(map1.defaultkey, result)
 end
 
 function lib.map.fuse(arg1, arg2)
-  local map1, map2 = arg1, arg2
-  if type(arg1) == &quot;string&quot; then
-    map1 = wo:newMap(arg1)
-  end
-  if type(arg2) == &quot;string&quot; then
-    map2 = wo:newMap(arg2)
-  end
-  assert_type(map1, &quot;lib.map.fuse first argument&quot;, 2, &quot;map&quot;)
-  assert_type(map2, &quot;lib.map.fuse second argument&quot;, 2, &quot;map&quot;)
-  local result = {}
-  for y = 1, math.max(map1.height, map2.height) do
-    result[y] = &quot;&quot;
-    for x = 1, math.max(map1.width, map2.width) do
-      result[y] = result[y] .. map1[{x - 1, y - 1}] .. map2[{x - 1, y - 1}]
+    local map1, map2 = arg1, arg2
+    if type(arg1) == &quot;string&quot; then
+        map1 = wo:newMap(arg1)
     end
-  end
-  return wo:newMap(map1.defaultkey .. map2.defaultkey, result)  
+    if type(arg2) == &quot;string&quot; then
+        map2 = wo:newMap(arg2)
+    end
+    assert_type(map1, &quot;lib.map.fuse first argument&quot;, 2, &quot;map&quot;)
+    assert_type(map2, &quot;lib.map.fuse second argument&quot;, 2, &quot;map&quot;)
+    local result = {}
+    for y = 1, math.max(map1.height, map2.height) do
+        result[y] = &quot;&quot;
+        for x = 1, math.max(map1.width, map2.width) do
+            result[y] = result[y] .. map1[{x - 1, y - 1}] .. map2[{x - 1, y - 1}]
+        end
+    end
+    return wo:newMap(map1.defaultkey .. map2.defaultkey, result)  
 end
 
 function lib.map.defuse(map)
-  assert_type(map, &quot;lib.map.defuse first argument&quot;, 2, &quot;map&quot;)
-  local kl = rawget(map, &quot;__keylength&quot;)
-  local dk = rawget(map, &quot;__defaultkey&quot;)
-  local result = {}
-  for j = 1, kl do
-    result[j] = wo:newMap(string.sub(dk, j, j), map.width, map.height)
-  end
-  for y = 0, map.height - 1 do
-    for x = 0, map.width - 1 do
-      local key = map[{x,y}]
-      for j = 1, kl do
-        result[j][{x,y}] = string.sub(key, j, j)
-      end
+    assert_type(map, &quot;lib.map.defuse first argument&quot;, 2, &quot;map&quot;)
+    local kl = rawget(map, &quot;__keylength&quot;)
+    local dk = rawget(map, &quot;__defaultkey&quot;)
+    local result = {}
+    for j = 1, kl do
+        result[j] = wo:newMap(string.sub(dk, j, j), map.width, map.height)
     end
-  end
-  return result
+    for y = 0, map.height - 1 do
+        for x = 0, map.width - 1 do
+            local key = map[{x,y}]
+            for j = 1, kl do
+                result[j][{x,y}] = string.sub(key, j, j)
+            end
+        end
+    end
+    return result
 end
 
 function lib.map.transform(map, op)
-  assert_type(map, &quot;lib.map.transform first argument&quot;, 2, &quot;map&quot;)
-  assert_type(op, &quot;lib.map.transform second argument&quot;, 2, &quot;natural&quot;)
-  if op &gt; 7 then
-    error(&quot;lib.map.transform: Unknown transformation request.&quot;, 2)
-  end
-  local w, h = map.width, map.height
-  local function rot(x, y)
-    return ({[MAP_IDENT]             = {x,         y},
-             [MAP_ROT_CW]            = {y,         h - 1 - x},
-             [MAP_ROT_180]           = {w - 1 - x, h - 1 - y},
-             [MAP_ROT_CCW]           = {w - 1 - y, x},
-             [MAP_MIRROR_HORIZONTAL] = {w - 1 - x, y},
-             [MAP_MIRROR_VERTICAL]   = {x,         h - 1 - y},
-             [MAP_MIRROR_SLASH]      = {y,         x},
-             [MAP_MIRROR_BACKSLASH]  = {w - 1 - y, h - 1 - x}     })[op]
-  end
-  local new_w, new_h = w, h
-  if    (op == MAP_ROT_CW) or (op == MAP_ROT_CCW)
-     or (op == MAP_MIRROR_SLASH) or (op == MAP_MIRROR_BACKSLASH) then
-    new_w, new_h = h, w
-  end
-  local result = {}
-  for y = 1, new_h do
-    result[y] = &quot;&quot;
-    for x = 1, new_w do
-      result[y] = result[y] .. map[rot(x - 1, y - 1)]
+    assert_type(map, &quot;lib.map.transform first argument&quot;, 2, &quot;map&quot;)
+    assert_type(op, &quot;lib.map.transform second argument&quot;, 2, &quot;natural&quot;)
+    if op &gt; 7 then
+        error(&quot;lib.map.transform: Unknown transformation request.&quot;, 2)
     end
-  end
-  return wo:newMap(map.defaultkey, result)  
+    local w, h = map.width, map.height
+    local function rot(x, y)
+        return ({[MAP_IDENT]             = {x,         y},
+                 [MAP_ROT_CW]            = {y,         h - 1 - x},
+                 [MAP_ROT_180]           = {w - 1 - x, h - 1 - y},
+                 [MAP_ROT_CCW]           = {w - 1 - y, x},
+                 [MAP_MIRROR_HORIZONTAL] = {w - 1 - x, y},
+                 [MAP_MIRROR_VERTICAL]   = {x,         h - 1 - y},
+                 [MAP_MIRROR_SLASH]      = {y,         x},
+                 [MAP_MIRROR_BACKSLASH]  = {w - 1 - y, h - 1 - x}     })[op]
+    end
+    local new_w, new_h = w, h
+    if    (op == MAP_ROT_CW) or (op == MAP_ROT_CCW)
+         or (op == MAP_MIRROR_SLASH) or (op == MAP_MIRROR_BACKSLASH) then
+        new_w, new_h = h, w
+    end
+    local result = {}
+    for y = 1, new_h do
+        result[y] = &quot;&quot;
+        for x = 1, new_w do
+            result[y] = result[y] .. map[rot(x - 1, y - 1)]
+        end
+    end
+    return wo:newMap(map.defaultkey, result)  
 end
 
 function lib.map.sub(map, origin, arg2, arg3)
-  -- syntax: map, pos1, pos2
-  --         map, pos1, width, height
-  assert_type(map, &quot;lib.map.sub first argument&quot;, 2, &quot;map&quot;)
-  assert_type(origin, &quot;lib.map.sub second argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;table&quot;)
-  assert_type(arg2, &quot;lib.map.sub third argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;table&quot;, &quot;number&quot;)
-  local pos1, pos2 = origin, arg2
-  if etype(pos1) ~= &quot;position&quot; then
-    pos1 = po(pos1)
-  end
-  if type(arg2) == &quot;number&quot; then
-    -- arg2 and arg3 are width and height
-    assert_type(arg3, &quot;lib.map.sub fourth argument&quot;, 2, &quot;number&quot;)
-    pos2 = po(pos1.x + arg2 - 1, pos1.y + arg3 - 1)
-  elseif etype(arg2) ~= &quot;position&quot; then
-    pos2 = po(arg2)
-  end
-  pos1 = pos1:grid()
-  pos2 = pos2:grid()
-  if (pos2.x &lt; pos1.x) or (pos2.y &lt; pos1.y) then
-    error(&quot;lib.map.sub: Rectangular area not cleanly defined (first argument &quot;
-        .. &quot;is not top left-hand corner).&quot;, 2)
-  end
-  local result = {}
-  local kl = map.keylength
-  for y = pos1.y + 1, pos2.y + 1 do
-    if y &lt;= map.height then
-      result[y-pos1.y] = string.sub(rawget(map, y) or &quot;&quot;,
-                             pos1.x * kl + 1, (pos2.x + 1) * kl) or &quot;&quot;
+    -- syntax: map, pos1, pos2
+    --         map, pos1, width, height
+    assert_type(map, &quot;lib.map.sub first argument&quot;, 2, &quot;map&quot;)
+    assert_type(origin, &quot;lib.map.sub second argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;table&quot;)
+    assert_type(arg2, &quot;lib.map.sub third argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;table&quot;, &quot;number&quot;)
+    local pos1, pos2 = origin, arg2
+    if etype(pos1) ~= &quot;position&quot; then
+        pos1 = po(pos1)
     end
-  end
-  return wo:newMap(rawget(map, &quot;__defaultkey&quot;), result)  
+    if type(arg2) == &quot;number&quot; then
+        -- arg2 and arg3 are width and height
+        assert_type(arg3, &quot;lib.map.sub fourth argument&quot;, 2, &quot;number&quot;)
+        pos2 = po(pos1.x + arg2 - 1, pos1.y + arg3 - 1)
+    elseif etype(arg2) ~= &quot;position&quot; then
+        pos2 = po(arg2)
+    end
+    pos1 = pos1:grid()
+    pos2 = pos2:grid()
+    if (pos2.x &lt; pos1.x) or (pos2.y &lt; pos1.y) then
+        error(&quot;lib.map.sub: Rectangular area not cleanly defined (first argument &quot;
+            .. &quot;is not top left-hand corner).&quot;, 2)
+    end
+    local result = {}
+    local kl = map.keylength
+    for y = pos1.y + 1, pos2.y + 1 do
+        if y &lt;= map.height then
+            result[y-pos1.y] = string.sub(rawget(map, y) or &quot;&quot;,
+                                   pos1.x * kl + 1, (pos2.x + 1) * kl) or &quot;&quot;
+        end
+    end
+    return wo:newMap(rawget(map, &quot;__defaultkey&quot;), result)  
 end
 
 -- TODO: Speed up.
 function lib.map.paste(map1, map2, posarg)
-  assert_type(map1, &quot;lib.map.paste first argument&quot;, 2, &quot;map&quot;)
-  assert_type(map2, &quot;lib.map.paste second argument&quot;, 2, &quot;map&quot;)
-  assert_type(posarg, &quot;lib.map.paste third argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;group&quot;, &quot;polist&quot;, &quot;table&quot;)  
-  assert_bool(map1.keylength == map2.keylength, &quot;lib.map.paste: Can't work on maps with different keylengths.&quot;, 2)
-  local postype = etype(posarg)
-  if postype == &quot;position&quot; then
-    local kl = rawget(map2, &quot;__keylength&quot;)
-    local dk = rawget(map2, &quot;__defaultkey&quot;)
-    for y = 1, map2.height do
-      local line = rawget(map2, y)
-      for x = 1, map2.width do
-        tile = string.sub(line, kl * (x - 1) + 1, x * kl)
-        if tile ~= dk then
-          map1[{posarg.x + x - 1, posarg.y + y - 1}] = tile
+    assert_type(map1, &quot;lib.map.paste first argument&quot;, 2, &quot;map&quot;)
+    assert_type(map2, &quot;lib.map.paste second argument&quot;, 2, &quot;map&quot;)
+    assert_type(posarg, &quot;lib.map.paste third argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;group&quot;, &quot;polist&quot;, &quot;table&quot;)  
+    assert_bool(map1.keylength == map2.keylength, &quot;lib.map.paste: Can't work on maps with different keylengths.&quot;, 2)
+    local postype = etype(posarg)
+    if postype == &quot;position&quot; then
+        local kl = rawget(map2, &quot;__keylength&quot;)
+        local dk = rawget(map2, &quot;__defaultkey&quot;)
+        for y = 1, map2.height do
+            local line = rawget(map2, y)
+            for x = 1, map2.width do
+                tile = string.sub(line, kl * (x - 1) + 1, x * kl)
+                if tile ~= dk then
+                    map1[{posarg.x + x - 1, posarg.y + y - 1}] = tile
+                end
+            end
         end
-      end
+    elseif postype == &quot;group&quot; then
+        for obj in posarg do
+            lib.map.paste(map1, map2, po(obj))
+        end
+    elseif postype == &quot;polist&quot; then
+        for j = 1, #posarg do
+            lib.map.paste(map1, map2, posarg[j])
+        end
+    else
+        lib.map.paste(map1, map2, po(posarg))
     end
-  elseif postype == &quot;group&quot; then
-    for obj in posarg do
-      lib.map.paste(map1, map2, po(obj))
-    end
-  elseif postype == &quot;polist&quot; then
-    for j = 1, #posarg do
-      lib.map.paste(map1, map2, posarg[j])
-    end
-  else
-    lib.map.paste(map1, map2, po(posarg))
-  end
 end
 
 function lib.map.replace(map, tile1, tile2arg)
-  assert_type(map, &quot;lib.map.replace first argument&quot;, 2, &quot;map&quot;)
-  assert_type(tile1, &quot;lib.map.replace second argument&quot;, 2, &quot;string&quot;)
-  assert_type(tile2arg, &quot;lib.map.replace third argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
-  local kl = rawget(map, &quot;__keylength&quot;)
-  local tile2 = tile2arg or rawget(map, &quot;__defaultkey&quot;)
-  if (string.len(tile1) ~= kl) or (string.len(tile2) ~= kl) then
-    error(&quot;lib.map.replace: Tiles do not have the same length as default key.&quot;, 2)
-  end
-  for y = 1, map.height do
-    local line = rawget(map, y)
-    for x = 1, map.width do
-      tile = string.sub(line, kl * (x - 1) + 1, x * kl)
-      if tile == tile1 then
-        map[{x-1, y-1}] = tile2
-      end
+    assert_type(map, &quot;lib.map.replace first argument&quot;, 2, &quot;map&quot;)
+    assert_type(tile1, &quot;lib.map.replace second argument&quot;, 2, &quot;string&quot;)
+    assert_type(tile2arg, &quot;lib.map.replace third argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
+    local kl = rawget(map, &quot;__keylength&quot;)
+    local tile2 = tile2arg or rawget(map, &quot;__defaultkey&quot;)
+    if (string.len(tile1) ~= kl) or (string.len(tile2) ~= kl) then
+        error(&quot;lib.map.replace: Tiles do not have the same length as default key.&quot;, 2)
     end
-  end
+    for y = 1, map.height do
+        local line = rawget(map, y)
+        for x = 1, map.width do
+            tile = string.sub(line, kl * (x - 1) + 1, x * kl)
+            if tile == tile1 then
+                map[{x-1, y-1}] = tile2
+            end
+        end
+    end
 end
 
 function lib.map.replace_outside(map, tile1, tile2arg)
-  assert_type(map, &quot;lib.map.replace_outside first argument&quot;, 2, &quot;map&quot;)
-  assert_type(tile1, &quot;lib.map.replace_outside second argument&quot;, 2, &quot;string&quot;)
-  assert_type(tile2arg, &quot;lib.map.replace_outside third argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
-  local kl = rawget(map, &quot;__keylength&quot;)
-  local tile2 = tile2arg or rawget(map, &quot;__defaultkey&quot;)
-  if (string.len(tile1) ~= kl) or (string.len(tile2) ~= kl) then
-    error(&quot;lib.map.replace_outside: Tiles do not have the same length as default key.&quot;, 2)
-  end
-  if tile1 == tile2 then
-    error(&quot;lib.map.replace_outside: Old and new tile must be different.&quot;, 2)
-  end
-  -- mark outside floor fields from the border
-  local function check_for_outside(x, y)
-    if string.sub(rawget(map, y), kl * (x - 1) + 1, x * kl) == tile1 then
-      map[{x-1, y-1}] = tile2
-      if y &gt; 1          then  check_for_outside(x, y - 1)  end
-      if y &lt; map.height then  check_for_outside(x, y + 1)  end
-      if x &gt; 1          then  check_for_outside(x - 1, y)  end
-      if x &lt; map.width  then  check_for_outside(x + 1, y)  end
+    assert_type(map, &quot;lib.map.replace_outside first argument&quot;, 2, &quot;map&quot;)
+    assert_type(tile1, &quot;lib.map.replace_outside second argument&quot;, 2, &quot;string&quot;)
+    assert_type(tile2arg, &quot;lib.map.replace_outside third argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
+    local kl = rawget(map, &quot;__keylength&quot;)
+    local tile2 = tile2arg or rawget(map, &quot;__defaultkey&quot;)
+    if (string.len(tile1) ~= kl) or (string.len(tile2) ~= kl) then
+        error(&quot;lib.map.replace_outside: Tiles do not have the same length as default key.&quot;, 2)
     end
-  end
-  for y = 1, map.height do
-    check_for_outside(1, y)
-    check_for_outside(map.width, y)
-  end
-  for x = 1, map.width do
-    check_for_outside(x, 1)
-    check_for_outside(x, map.height)
-  end
+    if tile1 == tile2 then
+        error(&quot;lib.map.replace_outside: Old and new tile must be different.&quot;, 2)
+    end
+    -- mark outside floor fields from the border
+    local function check_for_outside(x, y)
+        if string.sub(rawget(map, y), kl * (x - 1) + 1, x * kl) == tile1 then
+            map[{x-1, y-1}] = tile2
+            if y &gt; 1          then  check_for_outside(x, y - 1)  end
+            if y &lt; map.height then  check_for_outside(x, y + 1)  end
+            if x &gt; 1          then  check_for_outside(x - 1, y)  end
+            if x &lt; map.width  then  check_for_outside(x + 1, y)  end
+        end
+    end
+    for y = 1, map.height do
+        check_for_outside(1, y)
+        check_for_outside(map.width, y)
+    end
+    for x = 1, map.width do
+        check_for_outside(x, 1)
+        check_for_outside(x, map.height)
+    end
 end
 
 -- TODO: Maybe use assert_type.
 function lib.map.match(map, conditionsarg, ...)
-  assert_type(map, &quot;lib.map.match first argument&quot;, 2, &quot;map&quot;)
-  local kl = rawget(map, &quot;__keylength&quot;)
-  local conditions 
-  if #{...} == 0 then
-    if      (type(conditionsarg) == &quot;table&quot;)
-       and ((usertype(conditionsarg[1]) == &quot;position&quot;) or (usertype(conditionsarg[1]) == &quot;polist&quot;)) then
-      conditions = lib.lua.deep_copy({conditionsarg})
+    assert_type(map, &quot;lib.map.match first argument&quot;, 2, &quot;map&quot;)
+    local kl = rawget(map, &quot;__keylength&quot;)
+    local conditions 
+    if #{...} == 0 then
+        if      (type(conditionsarg) == &quot;table&quot;)
+             and ((usertype(conditionsarg[1]) == &quot;position&quot;) or (usertype(conditionsarg[1]) == &quot;polist&quot;)) then
+            conditions = lib.lua.deep_copy({conditionsarg})
+        else
+            conditions = lib.lua.deep_copy(conditionsarg)
+        end
     else
-      conditions = lib.lua.deep_copy(conditionsarg)
+        conditions = lib.lua.deep_copy({conditionsarg, ...})
     end
-  else
-    conditions = lib.lua.deep_copy({conditionsarg, ...})
-  end
-  if type(conditions) == &quot;nil&quot; then
-    conditions = {}
-  end
-  if type(conditions) == &quot;string&quot; then
-    conditions = {{po(0,0), conditions}}
-  end
-  if type(conditions) ~= &quot;table&quot; then
-    error(&quot;lib.map.match: Conditions of wrong type &quot; .. type(conditions)
-        .. &quot;, expected table, string, or nil.&quot;, 2)
-  end
-  for _, condition in pairs(conditions) do
-    if (type(condition) ~= &quot;table&quot;) or (#condition &lt; 2) then
-      error(&quot;lib.map.match: Wrong type in condition list, expected a table with &quot;
-          .. &quot;at least two entries.&quot;, 2)
+    if type(conditions) == &quot;nil&quot; then
+        conditions = {}
     end
-    if (usertype(condition[1]) == &quot;position&quot;) then
-      condition[1] = po(grp()) .. condition[1]
+    if type(conditions) == &quot;string&quot; then
+        conditions = {{po(0,0), conditions}}
     end
-    if (usertype(condition[1]) ~= &quot;polist&quot;) then
-      error(&quot;lib.map.match: Wrong type in condition, expected position or &quot;
-          .. &quot;position list as first entry.&quot;, 2)
+    if type(conditions) ~= &quot;table&quot; then
+        error(&quot;lib.map.match: Conditions of wrong type &quot; .. type(conditions)
+            .. &quot;, expected table, string, or nil.&quot;, 2)
     end
-    for j = 2, #condition do
-      if (type(condition[j]) ~= &quot;string&quot;) or (string.len(condition[j]) ~= kl) then
-        error(&quot;lib.map.match: Tile key in condition has wrong type or key length.&quot;, 2)
-      end
-    end       
-  end
-  local result = po(grp())
-  for y = 0, map.height - 1 do
-    for x = 0, map.width - 1 do
-      local conditions_fulfilled = true
-      for _, condition in pairs(conditions) do
-        for j = 1, #condition[1] do
-          if conditions_fulfilled then
-            local ch = map[{x + condition[1][j].x, y + condition[1][j].y}]
-            local found = false
-            for j = 2, #condition do
-              found = found or (condition[j] == ch)
+    for _, condition in pairs(conditions) do
+        if (type(condition) ~= &quot;table&quot;) or (#condition &lt; 2) then
+            error(&quot;lib.map.match: Wrong type in condition list, expected a table with &quot;
+                .. &quot;at least two entries.&quot;, 2)
+        end
+        if (usertype(condition[1]) == &quot;position&quot;) then
+            condition[1] = po(grp()) .. condition[1]
+        end
+        if (usertype(condition[1]) ~= &quot;polist&quot;) then
+            error(&quot;lib.map.match: Wrong type in condition, expected position or &quot;
+                .. &quot;position list as first entry.&quot;, 2)
+        end
+        for j = 2, #condition do
+            if (type(condition[j]) ~= &quot;string&quot;) or (string.len(condition[j]) ~= kl) then
+                error(&quot;lib.map.match: Tile key in condition has wrong type or key length.&quot;, 2)
             end
-            conditions_fulfilled = found  -- at this point, cf was always true
-          end
+        end       
+    end
+    local result = po(grp())
+    for y = 0, map.height - 1 do
+        for x = 0, map.width - 1 do
+            local conditions_fulfilled = true
+            for _, condition in pairs(conditions) do
+                for j = 1, #condition[1] do
+                    if conditions_fulfilled then
+                        local ch = map[{x + condition[1][j].x, y + condition[1][j].y}]
+                        local found = false
+                        for j = 2, #condition do
+                            found = found or (condition[j] == ch)
+                        end
+                        conditions_fulfilled = found  -- at this point, cf was always true
+                    end
+                end
+            end
+            if conditions_fulfilled then
+                result = result .. po(x,y)
+            end
         end
-      end
-      if conditions_fulfilled then
-        result = result .. po(x,y)
-      end
     end
-  end
-  return result
+    return result
 end
 
 function lib.map.covers(map, pos)
-  if type(pos) == &quot;table&quot; then
-    return (pos[1] &gt;= 0) and (pos[2] &gt;= 0)
-        and (pos[1] &lt; map.width) and (pos[2] &lt; map.height)
-  else
-    return (pos.x &gt;= 0) and (pos.y &gt;= 0)
-        and (pos.x &lt; map.width) and (pos.y &lt; map.height)
-  end
+    if type(pos) == &quot;table&quot; then
+        return (pos[1] &gt;= 0) and (pos[2] &gt;= 0)
+            and (pos[1] &lt; map.width) and (pos[2] &lt; map.height)
+    else
+        return (pos.x &gt;= 0) and (pos.y &gt;= 0)
+            and (pos.x &lt; map.width) and (pos.y &lt; map.height)
+    end
 end
 
 -- TODO: Add string as posarg, maybe speed up.
 function lib.map.get(map, posarg)
-  if type(posarg) == &quot;number&quot; then
-    return rawget(map, posarg)
-  elseif (usertype(posarg) == &quot;position&quot;) or (usertype(posarg) == &quot;object&quot;) then
-    local pos = posarg:grid()
-    if map:covers(pos) then
-      local kl = rawget(map, &quot;__keylength&quot;)
-      return string.sub(rawget(map, pos.y + 1), kl * pos.x + 1, (pos.x + 1) * kl)
+    if type(posarg) == &quot;number&quot; then
+        return rawget(map, posarg)
+    elseif (usertype(posarg) == &quot;position&quot;) or (usertype(posarg) == &quot;object&quot;) then
+        local pos = posarg:grid()
+        if map:covers(pos) then
+            local kl = rawget(map, &quot;__keylength&quot;)
+            return string.sub(rawget(map, pos.y + 1), kl * pos.x + 1, (pos.x + 1) * kl)
+        else
+            return rawget(map, &quot;__defaultkey&quot;)
+        end
+    elseif usertype(posarg) == &quot;group&quot; then
+        local result = {}
+        for obj in posarg do
+            table.insert(result, lib.map.get(map, obj))
+        end
+        return result
+    elseif usertype(posarg) == &quot;polist&quot; then
+        local result = {}
+        for j = 1, #posarg do
+            result[j] = lib.map.get(map, posarg[j])
+        end
+        return result
+    elseif type(posarg) == &quot;table&quot; then
+        if map:covers(posarg) then
+            local kl = rawget(map, &quot;__keylength&quot;)
+            return string.sub(rawget(map, posarg[2] + 1), kl * posarg[1] + 1, (posarg[1] + 1) * kl)
+        else
+            return rawget(map, &quot;__defaultkey&quot;)
+        end
+    elseif type(posarg) == &quot;string&quot; then
+        if (posarg == &quot;type&quot;) then
+            return getmetatable(map)._type
+        elseif (posarg == &quot;width&quot;) or (posarg == &quot;height&quot;)
+             or (posarg == &quot;defaultkey&quot;) or (posarg == &quot;keylength&quot;) then
+            return rawget(map, &quot;__&quot;..posarg)
+        else  
+            return (rawget(map, &quot;user_attributes&quot;))[posarg]
+        end
     else
-      return rawget(map, &quot;__defaultkey&quot;)
+        error(&quot;lib.map.get: Can't understand position argument.&quot;)
     end
-  elseif usertype(posarg) == &quot;group&quot; then
-    local result = {}
-    for obj in posarg do
-      table.insert(result, lib.map.get(map, obj))
-    end
-    return result
-  elseif usertype(posarg) == &quot;polist&quot; then
-    local result = {}
-    for j = 1, #posarg do
-      result[j] = lib.map.get(map, posarg[j])
-    end
-    return result
-  elseif type(posarg) == &quot;table&quot; then
-    if map:covers(posarg) then
-      local kl = rawget(map, &quot;__keylength&quot;)
-      return string.sub(rawget(map, posarg[2] + 1), kl * posarg[1] + 1, (posarg[1] + 1) * kl)
-    else
-      return rawget(map, &quot;__defaultkey&quot;)
-    end
-  elseif type(posarg) == &quot;string&quot; then
-    if (posarg == &quot;type&quot;) then
-      return getmetatable(map)._type
-    elseif (posarg == &quot;width&quot;) or (posarg == &quot;height&quot;)
-       or (posarg == &quot;defaultkey&quot;) or (posarg == &quot;keylength&quot;) then
-      return rawget(map, &quot;__&quot;..posarg)
-    else  
-      return (rawget(map, &quot;user_attributes&quot;))[posarg]
-    end
-  else
-    error(&quot;lib.map.get: Can't understand position argument.&quot;)
-  end
 end
 
 -- TODO: Add string as posarg, maybe speed up.
 function lib.map.set(map, posarg, value)
-  if type(posarg) == &quot;string&quot; then
-    if (posarg == &quot;type&quot;) then
-      if tostring(value) ~= &quot;map&quot; then
-        error(&quot;lib.map.set: A map is a map is a map is a map, and not a &quot;
-            .. tostring(value) .. &quot;!&quot;, 2)
-      else
-        return
-      end
-    elseif (posarg == &quot;width&quot;) or (posarg == &quot;height&quot;) then
-      error(&quot;lib.map.set: Use extend or sub to change the size of a map.&quot;, 2)
-    elseif (posarg == &quot;keylength&quot;) then
-      error(&quot;lib.map.set: Can't change keylength without default key.&quot;, 2)
-    elseif (posarg == &quot;defaultkey&quot;) then
-      map:set_default_key(value)
-      return
+    if type(posarg) == &quot;string&quot; then
+        if (posarg == &quot;type&quot;) then
+            if tostring(value) ~= &quot;map&quot; then
+                error(&quot;lib.map.set: A map is a map is a map is a map, and not a &quot;
+                    .. tostring(value) .. &quot;!&quot;, 2)
+            else
+                return
+            end
+        elseif (posarg == &quot;width&quot;) or (posarg == &quot;height&quot;) then
+            error(&quot;lib.map.set: Use extend or sub to change the size of a map.&quot;, 2)
+        elseif (posarg == &quot;keylength&quot;) then
+            error(&quot;lib.map.set: Can't change keylength without default key.&quot;, 2)
+        elseif (posarg == &quot;defaultkey&quot;) then
+            map:set_default_key(value)
+            return
+        end
+        map.user_attributes[posarg] = value
+    else
+        if type(value) ~= &quot;string&quot; then
+            error(&quot;lib.map.set: Key must be of type string, is &quot;..type(value)..&quot;.&quot;, 2)
+        end
+        local kl = rawget(map, &quot;__keylength&quot;)
+        if string.len(value) ~= kl then
+            error(&quot;lib.map.set: Key must be of the same length as default key &quot;
+                ..&quot;(should be &quot;..kl.. &quot;, is &quot;..string.len(value)..&quot;).&quot;, 2)
+        end
+        if (usertype(posarg) == &quot;position&quot;) or (usertype(posarg) == &quot;object&quot;) then
+            local pos = posarg:grid()
+            if (pos.x &lt; 0) or (pos.y &lt; 0) then
+                error(&quot;lib.map.set: Negative positions are not supported.&quot;, 2)
+            end
+            map:extend(pos)
+            rawset(map, pos.y + 1,
+                   string.sub(rawget(map, pos.y + 1), 1, pos.x * kl)
+                .. value
+                .. string.sub(rawget(map, pos.y + 1), (pos.x + 1) * kl + 1, -1))
+        elseif usertype(posarg) == &quot;group&quot; then
+            for obj in posarg do
+                map:extend(obj)
+                rawset(map, obj.y + 1,
+                     string.sub(rawget(map, obj.y + 1), 1, obj.x * kl)
+                  .. value
+                  .. string.sub(rawget(map, obj.y + 1), (obj.x + 1) * kl + 1, -1))
+            end
+        elseif usertype(posarg) == &quot;polist&quot; then
+            for j = 1, #posarg do
+                map:extend(posarg[j])
+                rawset(map, posarg[j].y + 1,
+                     string.sub(rawget(map, posarg[j].y + 1), 1, posarg[j].x * kl)
+                  .. value
+                  .. string.sub(rawget(map, posarg[j].y + 1), (posarg[j].x + 1) * kl + 1, -1))
+            end
+        elseif type(posarg) == &quot;table&quot; then
+            lib.map.set(map, po(posarg), value)
+        end
     end
-    map.user_attributes[posarg] = value
-  else
-    if type(value) ~= &quot;string&quot; then
-      error(&quot;lib.map.set: Key must be of type string, is &quot;..type(value)..&quot;.&quot;, 2)
-    end
-    local kl = rawget(map, &quot;__keylength&quot;)
-    if string.len(value) ~= kl then
-      error(&quot;lib.map.set: Key must be of the same length as default key &quot;
-          ..&quot;(should be &quot;..kl.. &quot;, is &quot;..string.len(value)..&quot;).&quot;, 2)
-    end
-    if (usertype(posarg) == &quot;position&quot;) or (usertype(posarg) == &quot;object&quot;) then
-      local pos = posarg:grid()
-      if (pos.x &lt; 0) or (pos.y &lt; 0) then
-        error(&quot;lib.map.set: Negative positions are not supported.&quot;, 2)
-      end
-      map:extend(pos)
-      rawset(map, pos.y + 1,
-             string.sub(rawget(map, pos.y + 1), 1, pos.x * kl)
-          .. value
-          .. string.sub(rawget(map, pos.y + 1), (pos.x + 1) * kl + 1, -1))
-    elseif usertype(posarg) == &quot;group&quot; then
-      for obj in posarg do
-        map:extend(obj)
-        rawset(map, obj.y + 1,
-             string.sub(rawget(map, obj.y + 1), 1, obj.x * kl)
-          .. value
-          .. string.sub(rawget(map, obj.y + 1), (obj.x + 1) * kl + 1, -1))
-      end
-    elseif usertype(posarg) == &quot;polist&quot; then
-      for j = 1, #posarg do
-        map:extend(posarg[j])
-        rawset(map, posarg[j].y + 1,
-             string.sub(rawget(map, posarg[j].y + 1), 1, posarg[j].x * kl)
-          .. value
-          .. string.sub(rawget(map, posarg[j].y + 1), (posarg[j].x + 1) * kl + 1, -1))
-      end
-    elseif type(posarg) == &quot;table&quot; then
-      lib.map.set(map, po(posarg), value)
-    end
-  end
 end
 
 function lib.map.extend(map, posarg)
-  assert_type(map, &quot;lib.map.extend first argument&quot;, 2, &quot;map&quot;)
-  assert_type(posarg, &quot;lib.map.extend second argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;table&quot;)
-  local pos = posarg
-  if etype(pos) ~= &quot;position&quot; then
-    pos = po(pos)
-  end
-  local w, h = rawget(map, &quot;__width&quot;), rawget(map, &quot;__height&quot;)
-  if pos.x &gt;= w then
-    pos = pos:grid()  
-    local dk = rawget(map, &quot;__defaultkey&quot;)
-    local attach = string.rep(dk, pos.x - w + 1)
-    for y = 1, h do
-      rawset(map, y, rawget(map, y) .. attach)
+    assert_type(map, &quot;lib.map.extend first argument&quot;, 2, &quot;map&quot;)
+    assert_type(posarg, &quot;lib.map.extend second argument&quot;, 2, &quot;position&quot;, &quot;valid object&quot;, &quot;string&quot;, &quot;table&quot;)
+    local pos = posarg
+    if etype(pos) ~= &quot;position&quot; then
+        pos = po(pos)
     end
-    w = pos.x + 1
-    rawset(map, &quot;__width&quot;, w)
-  end
-  if pos.y &gt;= h then
-    pos = pos:grid()
-    local dk = rawget(map, &quot;__defaultkey&quot;)
-    local line = string.rep(dk, w)
-    for y = h + 1, pos.y + 1 do
-      rawset(map, y, line)
+    local w, h = rawget(map, &quot;__width&quot;), rawget(map, &quot;__height&quot;)
+    if pos.x &gt;= w then
+        pos = pos:grid()  
+        local dk = rawget(map, &quot;__defaultkey&quot;)
+        local attach = string.rep(dk, pos.x - w + 1)
+        for y = 1, h do
+            rawset(map, y, rawget(map, y) .. attach)
+        end
+        w = pos.x + 1
+        rawset(map, &quot;__width&quot;, w)
     end
-    h = pos.y + 1
-    rawset(map, &quot;__height&quot;, h)
-  end
+    if pos.y &gt;= h then
+        pos = pos:grid()
+        local dk = rawget(map, &quot;__defaultkey&quot;)
+        local line = string.rep(dk, w)
+        for y = h + 1, pos.y + 1 do
+            rawset(map, y, line)
+        end
+        h = pos.y + 1
+        rawset(map, &quot;__height&quot;, h)
+    end
 end
 
 function lib.map.trim(map, trimkeyarg)
-  assert_type(map, &quot;lib.map.trim first argument&quot;, 2, &quot;map&quot;)
-  assert_type(trimkeyarg, &quot;lib.map.trim second argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
-  local border_n = map.height - 1
-  local border_s = 0
-  local border_w = map.width - 1
-  local border_e = 0
-  local trimkey = trimkeyarg or rawget(map, &quot;__defaultkey&quot;)
-  if string.len(trimkey) ~= rawget(map, &quot;__keylength&quot;) then
-    error(&quot;lib.map.trim: Trim key has wrong key length.&quot;, 2)
-  end
-  for x = 0, map.width - 1 do
-    for y = 0, map.height - 1 do
-      if map[{x,y}] ~= trimkey then
-        border_n = math.min(border_n, y)
-        border_s = math.max(border_s, y)
-        border_w = math.min(border_w, x)
-        border_e = math.max(border_e, x)        
-      end
+    assert_type(map, &quot;lib.map.trim first argument&quot;, 2, &quot;map&quot;)
+    assert_type(trimkeyarg, &quot;lib.map.trim second argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
+    local border_n = map.height - 1
+    local border_s = 0
+    local border_w = map.width - 1
+    local border_e = 0
+    local trimkey = trimkeyarg or rawget(map, &quot;__defaultkey&quot;)
+    if string.len(trimkey) ~= rawget(map, &quot;__keylength&quot;) then
+        error(&quot;lib.map.trim: Trim key has wrong key length.&quot;, 2)
     end
-  end
-  if (border_n &gt;= border_s) or (border_w &gt;= border_e) then
-    return wo:newMap(trimkey)
-  end
-  return map:sub(po(border_w, border_n), po(border_e, border_s))
+    for x = 0, map.width - 1 do
+        for y = 0, map.height - 1 do
+            if map[{x,y}] ~= trimkey then
+                border_n = math.min(border_n, y)
+                border_s = math.max(border_s, y)
+                border_w = math.min(border_w, x)
+                border_e = math.max(border_e, x)        
+            end
+        end
+    end
+    if (border_n &gt;= border_s) or (border_w &gt;= border_e) then
+        return wo:newMap(trimkey)
+    end
+    return map:sub(po(border_w, border_n), po(border_e, border_s))
 end  
 
 function lib.map.print(map, withXYCounts, left_separator, right_separator)
-  assert_type(map, &quot;lib.map.print first argument&quot;, 2, &quot;map&quot;)
-  assert_type(left_separator, &quot;lib.map.print second argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
-  assert_type(right_separator, &quot;lib.map.print third argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)  
-  local w, h = map.width, map.height
-  local kl = rawget(map, &quot;__keylength&quot;)
-  if withXYCounts then
-    local line = string.rep(&quot; &quot;, kl) .. (left_separator or &quot;&quot;)
-    for x = 0, w - 1 do
-      line = line .. string.rep(&quot; &quot;, math.max(0, kl - string.len(x)))
-                  .. string.sub(x, math.max(0, string.len(x) - kl) + 1, string.len(x))
-    end
-    line = line .. (right_separator or &quot;&quot;)
-    print(line)
-  end
-  for y = 0, h - 1 do
-    local line = &quot;&quot;
+    assert_type(map, &quot;lib.map.print first argument&quot;, 2, &quot;map&quot;)
+    assert_type(left_separator, &quot;lib.map.print second argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)
+    assert_type(right_separator, &quot;lib.map.print third argument&quot;, 2, &quot;nil&quot;, &quot;string&quot;)  
+    local w, h = map.width, map.height
+    local kl = rawget(map, &quot;__keylength&quot;)
     if withXYCounts then
-      line =    string.rep(&quot; &quot;, math.max(0, kl - string.len(y)))
-             .. string.sub(y, math.max(0, string.len(y) - kl) + 1, string.len(y))      
+        local line = string.rep(&quot; &quot;, kl) .. (left_separator or &quot;&quot;)
+        for x = 0, w - 1 do
+            line = line .. string.rep(&quot; &quot;, math.max(0, kl - string.len(x)))
+                      .. string.sub(x, math.max(0, string.len(x) - kl) + 1, string.len(x))
+        end
+        line = line .. (right_separator or &quot;&quot;)
+        print(line)
     end
-    line = line .. (left_separator or &quot;&quot;) .. map[y + 1] .. (right_separator or &quot;&quot;)
-    print(line)
-  end
+    for y = 0, h - 1 do
+        local line = &quot;&quot;
+        if withXYCounts then
+            line =    string.rep(&quot; &quot;, math.max(0, kl - string.len(y)))
+                   .. string.sub(y, math.max(0, string.len(y) - kl) + 1, string.len(y))      
+        end
+        line = line .. (left_separator or &quot;&quot;) .. map[y + 1] .. (right_separator or &quot;&quot;)
+        print(line)
+    end
 end
 
 function lib.map.set_default_key(map, newkey)
-  assert_type(map, &quot;lib.map.set_default_key first argument&quot;, 2, &quot;map&quot;)
-  assert_type(newkey, &quot;lib.map.set_default_key second argument&quot;, 2, &quot;non-empty string&quot;)
-  local new_width = map.width * map.keylength / string.len(newkey)
-  if new_width ~= math.ceil(new_width) then
-    error(&quot;lib.map.set_default_key: Map width doesn't fit to new default key.&quot;, 2)
-  end
-  rawset(map, &quot;__defaultkey&quot;, newkey)
-  rawset(map, &quot;__keylength&quot;, string.len(newkey))
-  rawset(map, &quot;__width&quot;, new_width)
+    assert_type(map, &quot;lib.map.set_default_key first argument&quot;, 2, &quot;map&quot;)
+    assert_type(newkey, &quot;lib.map.set_default_key second argument&quot;, 2, &quot;non-empty string&quot;)
+    local new_width = map.width * map.keylength / string.len(newkey)
+    if new_width ~= math.ceil(new_width) then
+        error(&quot;lib.map.set_default_key: Map width doesn't fit to new default key.&quot;, 2)
+    end
+    rawset(map, &quot;__defaultkey&quot;, newkey)
+    rawset(map, &quot;__keylength&quot;, string.len(newkey))
+    rawset(map, &quot;__width&quot;, new_width)
 end
 
 lib.map.metatable = {
-  __concat = lib.map.concat_horizontally,
-  __add = lib.map.concat_vertically,
-  __mul = lib.map.fuse,
-  __pow = lib.map.transform,
-  __index = lib.map.get,
-  __newindex = lib.map.set,
-  _type = &quot;map&quot;
+    __concat = lib.map.concat_horizontally,
+    __add = lib.map.concat_vertically,
+    __mul = lib.map.fuse,
+    __pow = lib.map.transform,
+    __index = lib.map.get,
+    __newindex = lib.map.set,
+    _type = &quot;map&quot;
 }
 
 wo:_register(&quot;newMap&quot;,
-  function(world, defaultKey, arg1, arg2)
-    local newmap = {user_attributes = {}}
-    -- Check arguments, create map if necessary.
-    assert_type(defaultKey, &quot;wo:newMap first argument (default key)&quot;, 2, &quot;non-empty string&quot;)
-    local width = 0
-    local height = 0
-    local kl = string.len(defaultKey)
-    if (type(arg1) == &quot;table&quot;) and (type(arg2) == &quot;nil&quot;) then
-      -- Interpret table as map.
-      for key, entry in pairs(arg1) do
-        if type(key) == &quot;number&quot; then
-          -- This line is going to be a real map entry.
-          height = math.max(height, key)
-          assert_type(entry, &quot;wo:newMap line &quot; .. key, 2, &quot;string&quot;)
-          local line_width = string.len(entry) / kl
-          if line_width ~= math.floor(line_width) then
-            error(&quot;newMap: Line &quot; .. key .. &quot; doesn't fit to key length (&quot; .. kl .. &quot;).&quot;, 2)
-          end
-          width = math.max(width, line_width)
-          newmap[key] = entry
-        elseif type(key) == &quot;string&quot; then
-          newmap.user_attributes[key] = entry
+    function(world, defaultKey, arg1, arg2)
+        local newmap = {user_attributes = {}}
+        -- Check arguments, create map if necessary.
+        assert_type(defaultKey, &quot;wo:newMap first argument (default key)&quot;, 2, &quot;non-empty string&quot;)
+        local width = 0
+        local height = 0
+        local kl = string.len(defaultKey)
+        if (type(arg1) == &quot;table&quot;) and (type(arg2) == &quot;nil&quot;) then
+            -- Interpret table as map.
+            for key, entry in pairs(arg1) do
+                if type(key) == &quot;number&quot; then
+                    -- This line is going to be a real map entry.
+                    height = math.max(height, key)
+                    assert_type(entry, &quot;wo:newMap line &quot; .. key, 2, &quot;string&quot;)
+                    local line_width = string.len(entry) / kl
+                    if line_width ~= math.floor(line_width) then
+                        error(&quot;newMap: Line &quot; .. key .. &quot; doesn't fit to key length (&quot; .. kl .. &quot;).&quot;, 2)
+                    end
+                    width = math.max(width, line_width)
+                    newmap[key] = entry
+                elseif type(key) == &quot;string&quot; then
+                    newmap.user_attributes[key] = entry
+                else
+                    error(&quot;newMap: Strange type for a map table key: &quot; .. etype(key) .. &quot;.&quot;, 2)
+                end
+            end
+            -- Now complete the map, make it rectangular.
+            for y = 1, height do
+                newmap[y] = newmap[y] or &quot;&quot;
+                newmap[y] = newmap[y] .. string.rep(defaultKey, width - string.len(newmap[y]) / kl)
+            end
+        elseif type(arg1) == &quot;number&quot; and type(arg2) == &quot;number&quot; then
+            -- Create map from scratch.
+            assert_type(arg1, &quot;wo:newMap third argument (width)&quot;, 2, &quot;positive integer&quot;)
+            assert_type(arg2, &quot;wo:newMap fourth argument (height)&quot;, 2, &quot;positive integer&quot;)
+            local line = string.rep(defaultKey, arg1)
+            for y = 1, arg2 do
+                newmap[y] = line
+            end
+            width = arg1
+            height = arg2
+        elseif type(arg1) == &quot;nil&quot; and type(arg2) == &quot;nil&quot; then
+            -- Create 1x1-map from scratch.
+            return wo:newMap(defaultKey, 1, 1)
         else
-          error(&quot;newMap: Strange type for a map table key: &quot; .. etype(key) .. &quot;.&quot;, 2)
+            error(&quot;wo:newMap: Syntax error. Can't understand arguments.&quot;, 2)
         end
-      end
-      -- Now complete the map, make it rectangular.
-      for y = 1, height do
-        newmap[y] = newmap[y] or &quot;&quot;
-        newmap[y] = newmap[y] .. string.rep(defaultKey, width - string.len(newmap[y]) / kl)
-      end
-    elseif type(arg1) == &quot;number&quot; and type(arg2) == &quot;number&quot; then
-      -- Create map from scratch.
-      assert_type(arg1, &quot;wo:newMap third argument (width)&quot;, 2, &quot;positive integer&quot;)
-      assert_type(arg2, &quot;wo:newMap fourth argument (height)&quot;, 2, &quot;positive integer&quot;)
-      local line = string.rep(defaultKey, arg1)
-      for y = 1, arg2 do
-        newmap[y] = line
-      end
-      width = arg1
-      height = arg2
-    elseif type(arg1) == &quot;nil&quot; and type(arg2) == &quot;nil&quot; then
-      -- Create 1x1-map from scratch.
-      return wo:newMap(defaultKey, 1, 1)
-    else
-      error(&quot;wo:newMap: Syntax error. Can't understand arguments.&quot;, 2)
+        -- Set additional values.
+        newmap.__width = width
+        newmap.__height = height
+        newmap.__defaultkey = defaultKey
+        newmap.__keylength = string.len(defaultKey)
+        -- Set methods and finally metatable.
+        newmap.covers = lib.map.covers
+        newmap.defuse = lib.map.defuse
+        newmap.extend = lib.map.extend
+        newmap.match = lib.map.match
+        newmap.paste = lib.map.paste
+        newmap.print = lib.map.print
+        newmap.replace = lib.map.replace
+        newmap.replace_outside = lib.map.replace_outside
+        newmap.set_default_key = lib.map.set_default_key
+        newmap.sub = lib.map.sub
+        newmap.trim = lib.map.trim
+        setmetatable(newmap, lib.map.metatable)
+        return newmap
     end
-    -- Set additional values.
-    newmap.__width = width
-    newmap.__height = height
-    newmap.__defaultkey = defaultKey
-    newmap.__keylength = string.len(defaultKey)
-    -- Set methods and finally metatable.
-    newmap.covers = lib.map.covers
-    newmap.defuse = lib.map.defuse
-    newmap.extend = lib.map.extend
-    newmap.match = lib.map.match
-    newmap.paste = lib.map.paste
-    newmap.print = lib.map.print
-    newmap.replace = lib.map.replace
-    newmap.replace_outside = lib.map.replace_outside
-    newmap.set_default_key = lib.map.set_default_key
-    newmap.sub = lib.map.sub
-    newmap.trim = lib.map.trim
-    setmetatable(newmap, lib.map.metatable)
-    return newmap
-  end
 )
 
     ]]&gt;&lt;/el:luamain&gt;

Modified: trunk/data/levels/lib/libmath.xml
===================================================================
--- trunk/data/levels/lib/libmath.xml	2009-03-31 15:39:49 UTC (rev 1604)
+++ trunk/data/levels/lib/libmath.xml	2009-03-31 21:37:25 UTC (rev 1605)
@@ -50,23 +50,23 @@
 -- If X2 and Y2 are nil, X1 and Y1 are assumed to be positions
 -- instead of coordinates.
 function lib.math.manhattan_distance(x1, y1, x2, y2)
-  if x1 and y1 and x2 and y2 then
-    -- x1, y1, x2, y2 are coordinates
-    return math.abs(x1 - x2) + math.abs(y1 - y2)
-  end
-  if x1 and y1 then
-    -- x1 and y1 are positions, possibly tables.
-    local p1 = x1
-    local p2 = y1
-    if type(p1) == &quot;table&quot; then
-      p1 = po(p1)
+    if x1 and y1 and x2 and y2 then
+        -- x1, y1, x2, y2 are coordinates
+        return math.abs(x1 - x2) + math.abs(y1 - y2)
     end
-    if type(p2) == &quot;table&quot; then
-      p2 = po(p2)
+    if x1 and y1 then
+        -- x1 and y1 are positions, possibly tables.
+        local p1 = x1
+        local p2 = y1
+        if type(p1) == &quot;table&quot; then
+            p1 = po(p1)
+        end
+        if type(p2) == &quot;table&quot; then
+            p2 = po(p2)
+        end
+        return math.abs(p1.x - p2.x) + math.abs(p1.y - p2.y)
     end
-    return math.abs(p1.x - p2.x) + math.abs(p1.y - p2.y)
-  end
-  error(&quot;manhattan_distance: Too less arguments.&quot;, 2)
+    error(&quot;manhattan_distance: Too less arguments.&quot;, 2)
 end
 
 ---------------------------------------------------------------------
@@ -86,37 +86,37 @@
 --   lib.math.digits(x, {0,1,2,3,4,5,6,7,8,9,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;})
 -- NUMBER is supposed to be a non-negative integer.
 function lib.math.digits(number, base)
-  -- Check arguments and calculate fullbase and exponent
-  assert_type(number, &quot;lib.math.digits first argument&quot;, 2, &quot;natural&quot;)
-  assert_type(base, &quot;lib.math.digits second argument&quot;, 2, &quot;integer&quot;, &quot;table&quot;)
-  local fullbase = {}
-  local exponent = 0
-  if type(base) == &quot;number&quot; then
-    if base &lt; 2 then
-      error(&quot;lib.math.digits: Second argument out of range, is &quot;..base..&quot;, must be at least 2.&quot;, 2)
+    -- Check arguments and calculate fullbase and exponent
+    assert_type(number, &quot;lib.math.digits first argument&quot;, 2, &quot;natural&quot;)
+    assert_type(base, &quot;lib.math.digits second argument&quot;, 2, &quot;integer&quot;, &quot;table&quot;)
+    local fullbase = {}
+    local exponent = 0
+    if type(base) == &quot;number&quot; then
+        if base &lt; 2 then
+            error(&quot;lib.math.digits: Second argument out of range, is &quot;..base..&quot;, must be at least 2.&quot;, 2)
+        end
+        for j = 1, base do
+            table.insert(fullbase, j - 1)
+        end
+    else -- type(base) == &quot;table&quot;
+        if table.getn(base) &lt; 2 then
+            error(&quot;lib.math.digits: Second argument has not enough elements, must be at least 2.&quot;, 2)
+        end
+        fullbase = base
     end
-    for j = 1, base do
-      table.insert(fullbase, j - 1)
+    exponent = table.getn(fullbase)
+    -- Decompose NUMBER
+    local remains = number
+    local result = {}
+    while remains &gt; 0 do
+        local d = remains % exponent
+        table.insert(result, fullbase[d + 1])
+        remains = (remains - d) / exponent
+        if remains ~= math.ceil(remains) then
+            error(&quot;lib.math.digits: Internal error during calculation (remains = &quot;..remains..&quot;).&quot;)
+        end
     end
-  else -- type(base) == &quot;table&quot;
-    if table.getn(base) &lt; 2 then
-      error(&quot;lib.math.digits: Second argument has not enough elements, must be at least 2.&quot;, 2)
-    end
-    fullbase = base
-  end
-  exponent = table.getn(fullbase)
-  -- Decompose NUMBER
-  local remains = number
-  local result = {}
-  while remains &gt; 0 do
-    local d = remains % exponent
-    table.insert(result, fullbase[d + 1])
-    remains = (remains - d) / exponent
-    if remains ~= math.ceil(remains) then
-      error(&quot;lib.math.digits: Internal error during calculation (remains = &quot;..remains..&quot;).&quot;)
-    end
-  end
-  return result
+    return result
 end
 
 -- Return a table of all combinations of DEPTH entries,
@@ -128,28 +128,28 @@
 -- of depth DEPTH. Note that liblua has to be loaded to use
 -- lib.math.combinations.
 function lib.math.combinations(depth, digits)
-  local all_combinations = {{}}
-  local digs = digits
-  assert_type(depth, &quot;lib.math.combinations first argument (depth)&quot;, 2, &quot;positive integer&quot;)
-  assert_type(digits, &quot;lib.math.combinations second argument (digits)&quot;, 2, &quot;positive integer&quot;, &quot;table&quot;)
-  if type(digits) == &quot;number&quot; then
-    digs = {}
-    for j = 1, digits do
-      digs[j] = j
+    local all_combinations = {{}}
+    local digs = digits
+    assert_type(depth, &quot;lib.math.combinations first argument (depth)&quot;, 2, &quot;positive integer&quot;)
+    assert_type(digits, &quot;lib.math.combinations second argument (digits)&quot;, 2, &quot;positive integer&quot;, &quot;table&quot;)
+    if type(digits) == &quot;number&quot; then
+        digs = {}
+        for j = 1, digits do
+            digs[j] = j
+        end
     end
-  end
-  for _ = 1, depth do
-    local next_step = {}
-    for _, old_combination in pairs(all_combinations) do
-      for _, new_digit in pairs(digs) do
-        local new_combination = lib.lua.deep_copy(old_combination)
-        table.insert(new_combination, new_digit)
-        table.insert(next_step, new_combination)
-      end
+    for _ = 1, depth do
+        local next_step = {}
+        for _, old_combination in pairs(all_combinations) do
+            for _, new_digit in pairs(digs) do
+                local new_combination = lib.lua.deep_copy(old_combination)
+                table.insert(new_combination, new_digit)
+                table.insert(next_step, new_combination)
+            end
+        end
+        all_combinations = next_step
     end
-    all_combinations = next_step
-  end
-  return all_combinations
+    return all_combinations
 end
 
 -- cubic_polynomial returns the result of the
@@ -162,12 +162,12 @@
 -- to your own liking. Entries in A which are not
 -- numbers are considered zero.
 function lib.math.cubic_polynomial(a, x, y)
-  assert_type(a, &quot;lib.math.cubic_polynomial first argument&quot;, 2, &quot;table&quot;)
-  assert_type(x, &quot;lib.math.cubic_polynomial second argument&quot;, 2, &quot;number&quot;)
-  assert_type(y, &quot;lib.math.cubic_polynomial third argument&quot;, 2, &quot;number&quot;)
-  return   (a[10] or 0)*y*y*y + (a[9] or 0)*x*y*y + (a[8] or 0)*x*x*y
-         + (a[7] or 0)*x*x*x + (a[6] or 0)*y*y + (a[5] or 0)*x*y
-         + (a[4] or 0)*x*x + (a[3] or 0)*y + (a[2] or 0)*x + (a[1] or 0)
+    assert_type(a, &quot;lib.math.cubic_polynomial first argument&quot;, 2, &quot;table&quot;)
+    assert_type(x, &quot;lib.math.cubic_polynomial second argument&quot;, 2, &quot;number&quot;)
+    assert_type(y, &quot;lib.math.cubic_polynomial third argument&quot;, 2, &quot;number&quot;)
+    return   (a[10] or 0)*y*y*y + (a[9] or 0)*x*y*y + (a[8] or 0)*x*x*y
+           + (a[7] or 0)*x*x*x + (a[6] or 0)*y*y + (a[5] or 0)*x*y
+           + (a[4] or 0)*x*x + (a[3] or 0)*y + (a[2] or 0)*x + (a[1] or 0)
 end
 
 -- steps takes DISCRIMINATOR and returns a value dependend on where
@@ -179,18 +179,18 @@
 --     3: If  13 &lt;= x
 -- Negative and non-integer values are allowed.
 function lib.math.steps(discriminator, steps)
-  assert_type(discriminator, &quot;lib.math.steps first argument&quot;, 2, &quot;number&quot;)
-  assert_type(steps, &quot;lib.math.steps second argument&quot;, 2, &quot;table&quot;)
-  local result = 0
-  for _, height in ipairs(steps) do
-    assert_type(height, &quot;lib.math.steps entry in second argument (height)&quot;, 2, &quot;number&quot;)
-    if discriminator &lt; height then
-      return result
-    else
-      result = result + 1
+    assert_type(discriminator, &quot;lib.math.steps first argument&quot;, 2, &quot;number&quot;)
+    assert_type(steps, &quot;lib.math.steps second argument&quot;, 2, &quot;table&quot;)
+    local result = 0
+    for _, height in ipairs(steps) do
+        assert_type(height, &quot;lib.math.steps entry in second argument (height)&quot;, 2, &quot;number&quot;)
+        if discriminator &lt; height then
+            return result
+        else
+            result = result + 1
+        end
     end
-  end
-  return result
+    return result
 end
 
 ---------------------------------------------------------------------
@@ -201,42 +201,42 @@
 -- This function outputs a table with integer entries between
 -- 1 and n at positions 1 to n.
 function lib.math.permutation(n)
-  assert_type(n, &quot;lib.math.permutation first argument&quot;, 2, &quot;positive integer&quot;)
-  if n == 1 then
-    return {1}
-  end
-  local sequence = {}
-  for j = 1, n do
-    table.insert(sequence, j)
-  end
-  for n = table.getn(sequence), 2, -1 do
-    local m = math.random(n)
-    sequence[n], sequence[m] = sequence[m], sequence[n]
-  end
-  return sequence
+    assert_type(n, &quot;lib.math.permutation first argument&quot;, 2, &quot;positive integer&quot;)
+    if n == 1 then
+        return {1}
+    end
+    local sequence = {}
+    for j = 1, n do
+        table.insert(sequence, j)
+    end
+    for n = table.getn(sequence), 2, -1 do
+        local m = math.random(n)
+        sequence[n], sequence[m] = sequence[m], sequence[n]
+    end
+    return sequence
 end
 
 -- Return a random cyclic permutation (i.e. with only one cycle) of n elements.
 function lib.math.cyclic_permutation(n)
-  assert_type(n, &quot;lib.math.cyclic_permutation first argument&quot;, 2, &quot;positive integer&quot;)
-  local sequence1 = lib.math.permutation(n)
-  local sequence2 = {}
-  for j = 1, n - 1 do
-    sequence2[sequence1[j]] = sequence1[j+1]
-  end
-  sequence2[sequence1[n]] = sequence1[1]
-  return sequence2
+    assert_type(n, &quot;lib.math.cyclic_permutation first argument&quot;, 2, &quot;positive integer&quot;)
+    local sequence1 = lib.math.permutation(n)
+    local sequence2 = {}
+    for j = 1, n - 1 do
+        sequence2[sequence1[j]] = sequence1[j+1]
+    end
+    sequence2[sequence1[n]] = sequence1[1]
+    return sequence2
 end
 
 -- Return a table with NUMBER random entries.
 -- Additional arguments like with math.random.
 function lib.math.random_vector(number, ...)
-  assert_type(number, &quot;lib.math.random_vector first argument&quot;, 2, &quot;natural&quot;)
-  local result = {}
-  for j = 1, number do
-    result[j] = math.random(...)
-  end
-  return result
+    assert_type(number, &quot;lib.math.random_vector first argument&quot;, 2, &quot;natural&quot;)
+    local result = {}
+    for j = 1, number do
+        result[j] = math.random(...)
+    end
+    return result
 end
 
     ]]&gt;&lt;/el:luamain&gt;

Modified: trunk/data/levels/lib/libsoko.xml
===================================================================
--- trunk/data/levels/lib/libsoko.xml	2009-03-31 15:39:49 UTC (rev 1604)
+++ trunk/data/levels/lib/libsoko.xml	2009-03-31 21:37:25 UTC (rev 1605)
@@ -392,6 +392,10 @@
     end
     
     lib.soko.polist.inf = lib.soko.polist.way .. lib.soko.polist.wall
+    
+    local nogoals = fl(lib.soko.polist.way) - fl(lib.soko.polist.goal)
+    nogoals.freeze_check = true
+    no[&quot;box#*&quot;].freeze_check = true
 
     -- polist.wall_one
     -- There are three conditions for an element of polist.wall_one:


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001034.html">[Enigma-game-svn] r1604 - in trunk: data data/levels/lib	doc/reference
</A></li>
	<LI>Next message: <A HREF="001036.html">[Enigma-game-svn] r1606 - trunk/lib-src/lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1035">[ date ]</a>
              <a href="thread.html#1035">[ thread ]</a>
              <a href="subject.html#1035">[ subject ]</a>
              <a href="author.html#1035">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
