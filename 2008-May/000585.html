<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1152 - trunk/doc/reference
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1152%20-%20trunk/doc/reference&In-Reply-To=%3C200805181322.m4IDMwM1004364%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000584.html">
   <LINK REL="Next"  HREF="000586.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1152 - trunk/doc/reference</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1152%20-%20trunk/doc/reference&In-Reply-To=%3C200805181322.m4IDMwM1004364%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1152 - trunk/doc/reference">ral at mail.berlios.de
       </A><BR>
    <I>Sun May 18 15:22:58 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000584.html">[Enigma-game-svn] r1151 - team_levelpacks/team_test_new_api
</A></li>
        <LI>Next message: <A HREF="000586.html">[Enigma-game-svn] r1153 - in trunk: data src src/stones
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#585">[ date ]</a>
              <a href="thread.html#585">[ thread ]</a>
              <a href="subject.html#585">[ subject ]</a>
              <a href="author.html#585">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2008-05-18 15:22:55 +0200 (Sun, 18 May 2008)
New Revision: 1152

Modified:
   trunk/doc/reference/enigma-ref.texi
Log:
Trunk 1.1: new API
- refman docu for resolvers: application, lib, development
- refman some typo fixes

Modified: trunk/doc/reference/enigma-ref.texi
===================================================================
--- trunk/doc/reference/enigma-ref.texi	2008-05-17 21:25:09 UTC (rev 1151)
+++ trunk/doc/reference/enigma-ref.texi	2008-05-18 13:22:55 UTC (rev 1152)
@@ -39,6 +39,7 @@
 * Actor Objects::
 * Other Objects::               Rubberbands, etc.
 * Advanced Features::           Fire, ...
+* Extension Development::       Resolver, Library Development
 * Old API - Objects::           Description of all objects in Enigma
 * Old API - Variables::         Lua variables that influence the game
 * Old API - Functions::               Predefined functions
@@ -2878,15 +2879,15 @@
 @samp{A..Z}, numbers @samp{0..9} and the underscore @samp{_}. Other special
 charcters are only allowed as far as they are explained in the following text.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> auto naming
 It is up to you to ensure unique names. Reusage of an already assigned name
 will unname the prior object and assign the name to the new object. To simplify
 the naming of larger groups of similar objects you can add the hash sign 
 @samp{#} as the last character to a name, e.g. @samp{mydoor#}. This causes Enigma
-to add a unique number to the given string. The number will start with 1, the
-first unused number will be taken. Thus the first door will be named
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{mydoor#1} the second one @samp{mydoor#2} and so on. If you delete the
-object named @samp{mydoor#2} lateron and if you name another object 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{mydoor#} it will be assigned the unused name @samp{mydoor#2}.
+to add a unique random number to the given string. Thus an auto named object
+will never unname another prior auto named object. But if you delete an 
+auto named object that has been named e.g. @samp{mydoor#132} the number and
+the same name may be assigned to another that is created lateron.
 
 All named objects are registered by the @dfn{named object} repository. The API
 provides a variable @samp{no} that allows you to retrieve any named object, e.g.
@@ -2906,6 +2907,31 @@
 references, a table of object names or a object name with wildcards. Thus
 the string @samp{&quot;mydoor#*&quot;} is a valid target.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at cindex</A> nearest object
+Often switches are located near by their target object. As a major shortcut
+you can reference the nearest object out of a group by prefixing its name
+with an @samp{@@} character.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;F&quot;] = @{&quot;st_floppy&quot;, target=&quot;@@door#*&quot;@}
+ti[&quot;D&quot;] = @{&quot;st_blocker&quot;, name=&quot;door#&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+With this tile declaration you can describe arbitrary number of floppy switches
+and nearby blocker doors in a world map all by the same two tile key characters.
+Every floppy switch will target the nearest blocker door. If two target are
+given within the same distance the one located in the south will win. If the
+targets are additionally horizontally aligned the one located in east will win.
+In the rare case of objects located on the same position stones will preceed
+items, floors and actors. The chosen target or destination depends just on the
+location of these objects and their type, but nothing else. Thus you can rely
+on a stable selection mechanism.
+
+By usage of this nearest object feature you can drastically reduce the number
+of needed tile declarations. @ref{Nearest Object Clustering} may help you in
+case of wrong selected equidistant targets. @ref{Auto Tiling} is another 
+feature for reducing the need of tile declarations.
+
 Another unique feature of object names is their late on access evaluation. This
 allows you to reference an object prior to its existence. E.g. if you want to
 set two vortices each declaring the other one as its destination, object names
@@ -3100,7 +3126,7 @@
 
 Objects like the switch can be triggered on and off. Each time they will
 perform the action. If you would like the door to open and close in turn to
-the switch you another action than @samp{open}. The universal message for
+the switch you need another action than @samp{open}. The universal message for
 changing targets in their alternate states is @samp{toggle}.
 
 @example
@@ -3120,7 +3146,7 @@
 switch states and the door.
 
 As you remember messages can take a value. Action messages are no exception.
-Every objects sends its actions with a value, usually a bool value. A switch
+Every object sends its actions with a value, usually a bool value. A switch
 sends a value @samp{true} if it just switched on, and a value @samp{false} if
 it just switched off. The appropriate message for the door would be the 
 universal message @samp{signal}:
@@ -3132,11 +3158,11 @@
 Now the door will open when the switch is turned on and close if the switch is
 turned off.
 
-If you look at @ref{signal} you will notice that this messages takes an integer
-value of @samp{0} or @samp{1}. Indeed the action value does not match. But in
-this as in many other cases the messages and values are designed in a way that
-they are autoconverted to the appropriated type. This compatibility is the basis
-for a seamless plugging of objects.
+The message @ref{signal} takes an integer value of @samp{0} or @samp{1}. 
+Indeed the action value does not match. But in this as in many other cases 
+the messages and values are designed in a way that they are autoconverted to
+the appropriated type. This compatibility is the basis for a seamless plugging
+of objects.
 
 In many cases authors face the task of triggering two or more objects by a
 single object. @samp{target} and @samp{action} are both able to take 
@@ -3180,10 +3206,12 @@
 standard action @ref{signal}. But sometimes you may want to perform very state
 specific actions. Let us look how this can be done.
 
-E.g. a @ref{st_fourswitch} that switches two @ref{st_laser} beaming in 3 states
-but one of them being switched off while in @samp{EAST} state and the other being
-switched off while in @samp{WEST} state. This can be done by usage of state
-dependent target and actions:
+E.g. let us take an @ref{st_fourswitch}, that has four states, and two 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{st_laser} which should be switched on and off. Both lasers should emit
+their beams while the fourswitch is in 3 of its states. But one of them should
+be off just while the fourswitch is in the @samp{EAST} state and the other
+should be off just while the fourswitch is in the @samp{WEST} state. 
+This can be done by usage of state dependent target and actions:
 
 @example
 @{st_fourswitch, target_3=&quot;laser#2&quot;, action_3=&quot;on&quot;,
@@ -3312,7 +3340,7 @@
 
 Some objects do process internal state transformations that cannot be configured
 by attributes. But some of these states may be of interest on describing a
-snapshot of a level. Where possible special object subkinds exists with a suffix
+snapshot of a level. Where possible a special object subkind exists with a suffix
 of @samp{_new}. These objects can be used in the initial level description to
 set objects in special initial states. E.g. @ref{it_blocker} provides such a
 special subkind. Note that these objects will never report their initial
@@ -3346,6 +3374,9 @@
 * Enigma Lua Types::   
 * Object Definitions and Tiles::
 * Lua Positions::
+* World Creation and Resolver Chaining::
+* Custom Resolver::
+
 @end menu
 
 @c ----------------- Lua Example -------------------- 
@@ -3369,8 +3400,176 @@
 
 @node Lua Positions
 @section Lua Positions
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- World Creation and Resolver Chaining -------------------- 
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> World Creation and Resolver Chaining
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> World Creation and Resolver Chaining
 
+Once all parameters have been set and all tiles have been declared it is time
+to create the level world with all its objects. This is done by the following
+constructor that appears in two variations.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+width, height = @b{wo}(@i{topresolver}, @i{defaultkey}, @i{map})
+
+width, height = @b{wo}(@i{topresolver}, @i{defaultkey}, @i{width}, @i{height})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{topresolver} = @code{ti} | @i{resolver} | @i{localresolver}
+Every tile in the world is given by a key that needs to be resolved to its
+declaration. This can be done either by the tiles repository @samp{ti}, or
+by given library @ref{Resolvers} or by local @ref{Custom Resolver} function.
+This argument takes the top resolver that is requested first.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{defaultkey}
+A string that defines the key that should be taken as default. It is taken
+if no other key is given and it is added to a tile if a floor object is
+missing. The character length of this key defines the key size within the map
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{map}
+A table of strings. Each string describes a row of tiles by its tile keys.
+If a map is given, the worlds size is determined from the longest string and
+the number of rows.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{width}
+As an argument that is given instead of a map it describes the width of the
+desired world.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{height}
+As an argument that is given instead of a map it describes the height of the
+desired world.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+w, h = wo(ti, &quot;  &quot;, 20, 13)
+w, h = wo(resolver, &quot; &quot;, {
+       &quot;                    &quot;,
+       ...
+       &quot;                    &quot;})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+This world constructor may just be called once. Every subsequent call causes
+an error. This call sets the size of the world to fixed values that are reported
+by its two return values. The world size can lateron be retrieved by the world
+attributes @ref{Width} and @ref{Height}, too.
+
+A mapless world is filled with default tiles. Rows in a given map that are
+shorter than others are filled with default tiles, too. Any tile that does
+not define a floor object will add the floor object of the default tile.
+
+Every key is resolved to its tile declaration via the given resolver chain.
+The top resolver is given to this call as a parameter. If it is @samp{ti} the
+chain consists just of one element and the tile delaration stored in the tiles
+repository at the given key is taken. But there exist several useful 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{Resolvers} that may simplify the task of level writing or provide dynamic
+features like randomness, mazes, etc. If you like to use one or several of them
+you provide the instance of the resolver to be requested first in this 
+constructor. The instance that should be requested next is set in the top
+resolver as first argument, and so on. The last library resolver takes usually
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{ti} as its subresolver. For even more flexibility you can provide an
+own @ref{Custom Resolver} function within the level to take influence on the key
+interpretation. This function has to be the last resolver in the chain.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;~&quot;] = @{&quot;fl_water&quot;@}
+ti[&quot;s&quot;] = @{&quot;fl_sahara&quot;@}
+ti[&quot;t&quot;] = @{&quot;fl_tigris&quot;@}
+ti[&quot;1&quot;] = @{&quot;ac-blackball&quot;, 0, 0.5@}
+
+ti[&quot;template_trigger&quot;] = @{&quot;it_trigger&quot;, target=&quot;myoxyd%%&quot;, action=&quot;open&quot;@}
+ti[&quot;template_oxyd&quot;]    = ti[&quot;~&quot;] .. @{&quot;st_oxyd&quot;, &quot;myoxyd%%&quot;@}
+
+myrandom = res.random(ti, &quot; &quot;, @{&quot;s&quot;, &quot;t&quot;@})
+
+myautotile = res.autotile(myrandom, @{&quot;a&quot;, &quot;h&quot;, &quot;template_trigger&quot;@}, 
+                              @{&quot;A&quot;, &quot;H&quot;, &quot;template_oxyd&quot;@})
+                                    
+w, h = wo(myautotile, &quot; &quot;, @{
+&quot;A~                ~E&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~   h        b   ~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;B~     c    d     ~F&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~        1       ~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;C~     f    e     ~G&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~   g        a   ~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;D~                ~H&quot;
+@})
+
+wo:shuffleOxyd()
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Custom Resolver -------------------- 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Custom Resolver
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Custom Resolver
+
+A customer resolver is a function in the level that allows a dynamic remapping
+of tiles. When this function is registered in the resolver chain it is called
+once for every tile to be set. The tile that this function return will be set.
+
+Typical use cases are design patterns that are easy to calculate, but tedious
+to draw in the map and dynamic generated levels that differ slightly on every
+restart.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+tile = @b{myresolver}(@i{key}, @i{x}, @i{y})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{key}
+String that contains the tile key to be resolved.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{x}
+The world x coordinate of the tile.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{x}
+The world y coordinate of the tile.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;r&quot;] = @{&quot;fl_rough_red&quot;@}
+ti[&quot;b&quot;] = @{&quot;fl_rough_blue&quot;@}
+ti[&quot;1&quot;] = @{&quot;#ac-blackball&quot;@}
+
+ti[&quot;x&quot;] = @{&quot;it_cross&quot;@}
+
+function myresolver(key, x, y)
+    if key == &quot; &quot; then
+        local center = ((x%3) * (y%3))%2 
+        local checker = ((math.modf(x/3) %2) + (math.modf(y/3) %2))%2
+        if center + checker == 1 then
+            return ti[&quot;r&quot;]
+        else
+            return ti[&quot;b&quot;]
+        end
+    else
+        return ti[key]
+    end
+end
+
+w, h = wo(myresolver, &quot; &quot;, @{
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;      x x           &quot;,
+&quot;       x            &quot;,
+&quot;      x x           &quot;,
+&quot;                    &quot;,
+&quot;          1         &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;
+@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
 @c ===================  Commons  =======================
 @node Common Attributes and Messages
 @chapter Common Attributes and Messages
@@ -3545,13 +3744,30 @@
 @section Global Attributes
 
 @menu
+* Height::
 * IsDifficult:: 
 * MagnetRange:: 
-* MagnetStrength:: 
+* MagnetStrength::
+* Width::
 * WormholeRange:: 
 * WormholeStrength:: 
 @end menu
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Height
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Height
+
+A global read only variable reports the height of the the world in grid units.
+This is set by the initial world constructor call 
+(@pxref{World Creation and Resolver Chaining}).
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Type:} @ @ number
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Values:} @ @ positiv integer number
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Default:} @ @ @code{?}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Access:} @ @ read only
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Support:} @ @ object independent
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
 @node IsDifficult
 @subsection IsDifficult
 
@@ -3598,6 +3814,21 @@
 @item @b{Support:} @ @ @ref{it_magnet}
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Width
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Width
+
+A global read only variable reports the width of the the world in grid units.
+This is set by the initial world constructor call 
+(@pxref{World Creation and Resolver Chaining}).
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Type:} @ @ number
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Values:} @ @ positiv integer number
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Default:} @ @ @code{?}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Access:} @ @ read only
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Support:} @ @ object independent
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
 @node WormholeRange
 @subsection WormholeRange
 
@@ -5140,10 +5371,10 @@
 
 Even though most levels make use of just a single pair of each color, there
 is no limit on a single color. If you like you can define 3 blue pairs of oxyds
-together with 2 yellow pairs. You do this by setting explicit @samp{color}
+together with 2 yellow pairs. You do this by setting explicit @samp{oxydcolor}
 attributes to the oxyds.
 
-For standard levels the @samp{color} can be set to its default @samp{OXYD_AUTO}.
+For standard levels the @samp{oxydcolor} can be set to its default @samp{OXYD_AUTO}.
 This causes an automatic coloring by pairs of colors in the standard color
 sequence.
 
@@ -5206,7 +5437,7 @@
 @item @code{&quot;c&quot;} blue, flat stone that opens by a concentric animation
 @item @code{&quot;d&quot;} dark blue, pyramid like stone that opens like a flower
 @end table
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{color}, @ @ @i{values}: @code{OXYD_AUTO}, @code{OXYD_FAKE}, @code{OXYD_FART}, @code{OXYD_BOLD}, @code{OXYD_BLUE}, @code{OXYD_RED}, @code{OXYD_GREEN}, @code{OXYD_YELLOW}, @code{OXYD_CYAN}, @code{OXYD_PURPLE}, @code{OXYD_WHITE}, @code{OXYD_BLACK}, ; @ @ @i{default}: @code{OXYD_AUTO}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{oxydcolor}, @ @ @i{values}: @code{OXYD_AUTO}, @code{OXYD_FAKE}, @code{OXYD_FART}, @code{OXYD_BOLD}, @code{OXYD_BLUE}, @code{OXYD_RED}, @code{OXYD_GREEN}, @code{OXYD_YELLOW}, @code{OXYD_CYAN}, @code{OXYD_PURPLE}, @code{OXYD_WHITE}, @code{OXYD_BLACK}, ; @ @ @i{default}: @code{OXYD_AUTO}
 @item @b{noshuffle} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
 @item @b{static} @ @ @i{values}: @code{true}, @code{false}; @ @ @i{default}: @code{false}
 Static oxyds are neither swappable nor pullable.
@@ -5539,14 +5770,579 @@
 @chapter Advanced Features
 
 @menu 
-* Oxyd Shuffling Rules::       
+* World Advanced Methods::  Additional features provided by the world
+* Resolvers::               Standard tools for interpretation of tile maps
+* Tips and Tricks::         Simple patterns that are valuable like a feature
 @end menu
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> Oxyd Shuffling Rules
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> Oxyd Shuffling Rules
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> World Advanced Methods
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> World Advanced Methods
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A> 
+* wo:shuffleOxyd::  Oxyd Shuffling Rules
+* wo:drawMap::      
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- shuffleOxyd -------------------- 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> wo:shuffleOxyd
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> wo:shuffleOxyd
+
 Read API Concept Draft
 
+Work in progress!
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:shuffleOxyd}(@i{rules})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{rules} = @i{rule}, @i{rule},...
+No rule or as many as you like, all seperated by a comma.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{rule} = @{@i{group1}, @i{group2}, @i{maxrule}, @i{minrule}, @i{circularrule}, @i{linearrule}, @i{logrule}@}
+Each rule is a table with a subset of the listed entries. The @i{group1} entry
+is mandatory. All other entries are optional and can be added in any combination.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{group1} = @i{group} | @i{objectreference} | @i{objectspecifier}
+A description of oxyd objects that are part of the first rule group. Either
+a group or a single object reference or a string specifier that resolves to a
+single or via wildcard to several oxyd objects are legal descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{group2} = @i{group} | @i{objectreference} | @i{objectspecifier}
+A description of oxyd objects that are part of the second rule group. Either
+a group or a single object reference or a string specifier that resolves to a 
+single or via wildcard to several oxyd objects are legal descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{maxrule} = @code{max = }@i{number}
+The maximum number of oxyd pairs.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{minrule} = @code{min = }@i{number}
+The minimum number of oxyd pairs.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{circularrule} = @code{circular = true}
+Avoid any pair of neighboring oxyds in group1. Avoid an oxyd pair of first and
+last oxyd in group1, too.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{linearrule} = @code{linear = true}
+Avoid any pair of neighboring oxyds in group1.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{logrule} = @code{log = } @ @  @code{&quot;solution&quot;} |@code{&quot;count&quot;} |@code{&quot;all&quot;} 
+Log additional information to the log stream for debugging purposes and 
+security checks by the level author.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo:shuffleOxyd()
+wo:shuffleOxyd(@{&quot;borderoxyds#*&quot;, circular=true@})
+wo:shuffleOxyd(@{&quot;leftoxyds#*&quot;,&quot;rightoxyds#*&quot;, min=3@}, @{&quot;islandoxyds#*&quot;, max=0@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- drawMap -------------------- 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> wo:drawMap
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> wo:drawMap
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Resolvers
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Resolvers
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A> 
+* res.autotile::  Generate tiles from given template declarations
+* res.composer::  Compose tiles from given base tiles
+* res.maze::      Generate arbitrary chaped mazes
+* res.random::    Choosing random tiles in a given distribution
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Autotile Resolver -------------------- 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> res.autotile
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> res.autotile
+
+Autotiling reduces the number of required tile declarations by generating them
+according to given simple rules. The most common application are a bunch of
+identical switch like objects that target all target the same type of object
+like a door or a laser. As each of them has its individual target object it
+would require to write a separate tile declaration with a unique tile key, e.g.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;A&quot;] = @{&quot;st_floppy&quot;, target=&quot;laserA&quot;@} 
+ti[&quot;B&quot;] = @{&quot;st_floppy&quot;, target=&quot;laserB&quot;@} 
+ti[&quot;C&quot;] = @{&quot;st_floppy&quot;, target=&quot;laserC&quot;@} 
+ti[&quot;a&quot;] = @{&quot;st_laser&quot;, name=&quot;laserA&quot;@} 
+ti[&quot;b&quot;] = @{&quot;st_laser&quot;, name=&quot;laserB&quot;@} 
+ti[&quot;c&quot;] = @{&quot;st_laser&quot;, name=&quot;laserC&quot;@} 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+Autotiling requires just one template tile of each type and substitutes any
+pattern @samp{%%} by a unique substitution.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;template_switch&quot;] = @{&quot;st_floppy&quot;, target=&quot;laser%%&quot;@} 
+ti[&quot;template_laser&quot;]  = @{&quot;st_laser&quot;, name=&quot;laser%%&quot;@} 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+Independent on the number of required unique objects you have just one template.
+You just declare the used ranged of tile keys by a rule and are free to use
+them within your level map.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{res.autotile}(@i{subresolver}, @i{rules})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{subresolver}
+Resolver to which unresolved requests should be forwarded. May be @samp{ti}
+as the final resolver of the resolver chain.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{rules} = @i{rule}, @i{rule},...
+One rule or as many as you like, all seperated by a comma.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{rule} = @i{prefixrule} | @i{rangerule}
+Each rule can be either a prefixrule or a rangerule in any mixture
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{prefixrule} = @{@i{prefix}, @i{template}@}
+A table with two entries. First a prefix string that is common to all tile
+keys that should be handeled followed by key string of the template tile.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{rangerule} = @{@i{first}, @i{last}, @i{template}@}
+A table with three entries. A string with the first key to be handled, followed
+by a string with the last key to be handled. The third value is the key string
+of the template tile.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+res.autotile(ti, @{&quot;A&quot;, &quot;template_switch&quot;@}, @{&quot;L&quot;, &quot;template_laser@})
+res.autotile(ti, @{&quot;a&quot;, &quot;e&quot;, &quot;template_trigger@}, @{&quot;A&quot;, &quot;E&quot;, &quot;template_door&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Prefix rules need a key length of at least 2. You can not use it with maps
+of just one character per tile. The resolver will create a tile declaration for
+any tile key in the map that matches the given prefix. A copy of the template
+will be taken and all occurences of the two characters @samp{%%} will be
+substituted by a single percent sign followed by the suffix of the used tile
+key. Thus a key of @samp{AD} will target the laser @samp{laser%D}. You need to
+use the key @samp{LD} in the map for the matching laser.
+
+Rangerules match any tile key in the given range. It can well be used in one
+character key maps. But it can be used in multicharacter maps, too. In this case
+the given first and last keys may just differ in the last character. Again a
+copy of the template rule will be generated and the @samp{%%} patterns will be
+substituted. But in this case the substitution is composed of a single percent
+sign followed by an interger number that counts the key position within the
+given range. Thus a key of @samp{c} will target the door @samp{door%3}. 
+You need to use the key @samp{C} in the map for the matching door.
+
+The template tile definitions can well be composed of several concatenated 
+tiles even with references of base tiles. The pattern substitution takes place
+on any attribute value containing string descriptions. A valid template would
+be:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;template&quot;] = ti[&quot;~&quot;] .. ti(@{&quot;it_trigger&quot;, target=@{&quot;door%%#*&quot;,&quot;laser%%&quot;@}@}) .. @{&quot;st_grate1&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot; &quot;] = @{&quot;fl-sahara&quot;@}
+
+ti[&quot;template_a&quot;] = @{&quot;st_floppy&quot;, target=@{&quot;door%%#*&quot;,&quot;laser%%&quot;@}@}
+ti[&quot;template_A&quot;] = @{&quot;st_blocker&quot;, &quot;door%%#&quot;@}
+ti[&quot;template_1&quot;] = @{&quot;st_laser_s&quot;, &quot;laser%%&quot;@}
+
+ti[&quot;x&quot;] = @{&quot;#ac-blackball&quot;@} .. ti(@{&quot;it_floppy&quot;@})
+
+local resolver = res.autotile(ti, @{&quot;a&quot;, &quot;e&quot;, &quot;template_a&quot;@}, 
+    @{&quot;A&quot;, &quot;E&quot;, &quot;template_A&quot;@},  @{&quot;1&quot;, &quot;5&quot;, &quot;template_1&quot;@})
+
+w, h = wo(resolver, &quot; &quot;, @{
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;   a   DB  e    BC  &quot;,
+&quot;                    &quot;,
+&quot;   CD  b   AE   c   &quot;,
+&quot;                    &quot;,
+&quot;   d   EA           &quot;,
+&quot;                    &quot;,
+&quot;           x        &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;   4  2  5  1  3    &quot;,
+&quot;                    &quot;
+@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Composer Resolver -------------------- 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> res.composer
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> res.composer
+
+The composer resolver reduces the number of required tile declarations by
+geneating them by composition of base tiles. Small motley levels and nearly
+every large level will use many different objects in numerous tile compositions.
+As the usable one character tile key candidates will not suffice you will need
+to use two or three character tile keys. But you will need numerous tile
+declarations, one for every used object combination.
+
+The composer frees you from declaring every used combination. You just declare
+the base objects, e.g. the floors and all stones, items, actors and use 
+combinations of these base tiles keys. The composer constructs the required
+tile declarations on the fly. E.g. with the following base tile declarations:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot; .&quot;] = @{&quot;fl_space&quot;@}
+ti[&quot; ~&quot;] = @{&quot;fl_water&quot;@}
+ti[&quot;X &quot;] = @{&quot;st_grate&quot;@}
+ti[&quot;h &quot;] = @{&quot;it_hammer&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+You can freely use any of the additional combination like @code{&quot;X.&quot;} - a grate
+on space, @code{&quot;X~&quot;} - a grate on water, @code{&quot;h.&quot;} - a hammer on space, 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;h~&quot;} - a hammer on water.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{res.composer}(@i{subresolver})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{subresolver}
+Resolver to which unresolved requests should be forwarded. May be @samp{ti}
+as the final resolver of the resolver chain.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+res.composer(ti)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+For every key in the map the subresolver will be first requested for a tile
+declaration. Thus any given declaration will preceede the auto composition.
+
+Just in case that no declaration exists the search starts for existing subkey
+tiles. Subkeys are keys with some characters replaced by a whitespace @samp{ }.
+For all key lengths the basic subkeys with just one character different from a
+whitespace will be examined. Additional just for three character key length
+the three keys with just one whitespace replacement and two remaining 
+original characters will be examined and these compositions will preceed the
+composition of three one character tiles.
+
+Thus for the key @code{&quot;h~&quot;} the composer will look for @code{&quot;h &quot;} and 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot; ~&quot;}. For the three character key @code{&quot;#h~&quot;} The compser will look for
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;#h &quot;} plus @code{&quot;  ~&quot;}, @code{&quot;# ~&quot;} plus @code{&quot; h &quot;}, @code{&quot; h~&quot;}
+plus @code{&quot;#  &quot;} and finally @code{&quot;#  &quot;} plus @code{&quot; h &quot;} plus @code{&quot;  ~&quot;}.
+For the 4 character key @code{&quot;A#h~&quot;} the compser will just look for 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;A   &quot;} plus @code{&quot; #  &quot;} plus @code{&quot;  h &quot;} plus @code{&quot;   ~&quot;}. The
+same holds for any larger key length.
+
+It is recommended to add the composer resolver behind most other library
+resolvers in the resolver chain.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;  &quot;] = @{&quot;fl_sahara&quot;@}
+ti[&quot; =&quot;] = @{&quot;fl_tigris&quot;@}
+ti[&quot; .&quot;] = @{&quot;fl_abyss&quot;@}
+ti[&quot; ~&quot;] = @{&quot;fl_water&quot;@}
+ti[&quot; ;&quot;] = @{&quot;fl_leaves&quot;@}
+
+ti[&quot;# &quot;] = @{&quot;st_rock1&quot;@}
+ti[&quot;W &quot;] = @{&quot;st_wood&quot;@}
+ti[&quot;X &quot;] = @{&quot;st_oxyd&quot;@}
+ti[&quot;G &quot;] = @{&quot;st_grate1&quot;@}
+
+ti[&quot;2 &quot;] = @{&quot;it_coin_s&quot;@}
+ti[&quot;s &quot;] = @{&quot;it_seed&quot;@}
+ti[&quot;c &quot;] = @{&quot;it_cherry&quot;@}
+ti[&quot;h &quot;] = @{&quot;it_hammer&quot;@}
+
+ti[&quot;k &quot;] = @{&quot;it_key&quot;@} .. ti(@{&quot;st_glass1&quot;@})
+
+ti[&quot;xx&quot;] = @{&quot;#ac-blackball&quot;@} 
+
+local resolver = res.composer(ti)
+
+w, h = wo(resolver, &quot;  &quot;, @{
+&quot;                                        &quot;,
+&quot;  h= ;W;2;c G~ ~# #.2.X X~k=k;          &quot;,
+&quot;                                        &quot;,
+&quot;  2;s;    2.s.    2=s=                  &quot;,
+&quot;  c;h;    c.h.    c=h=    xx            &quot;,
+&quot;                                        &quot;
+@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> res.maze
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> res.maze
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> res.random
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> res.random
+
+
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tips and Tricks
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Tips and Tricks
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A> 
+* Nearest Object Clustering::    When nearest object address wrong target
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Nearest Object Clustering
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Nearest Object Clustering
+
+The nearest object as described in @ref{Object Naming} provides a major feature
+for reducing the number of needed tile declarations. As the selection needs
+to be unique a rule had to be defined in case of equal distances. South wins, 
+then East, Stone are favored to Items, Floors and Actors.
+
+In most cases level authors can arrange their objects to fit these rules. But
+sometimes the level design does not allow the straight forward usage of a
+simple nearest object selection. E.g.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;F&quot;] = @{&quot;st_floppy&quot;, target=&quot;@@door#*&quot;@}
+ti[&quot;D&quot;] = @{&quot;st_blocker&quot;, name=&quot;door#&quot;@}
+wo{ti, &quot; &quot;, {
+&quot;       B            &quot;,
+&quot;       FB#####FB####&quot;,
+&quot;       # F    B     &quot;,
+&quot;       # #    F#####&quot;,
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+In both cases the floppy switch that is located at the crossing of to blocker
+doors will open the false one.
+
+But you can use a cluster concept like the one we introduced for
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{Cluster Stones}. Just add one or in rare cases two or three additional
+groups. Assign all standard cases to group A and the out of line cases in 
+group B:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;F&quot;] = @{&quot;st_floppy&quot;, target=&quot;@@doorA#*&quot;@}
+ti[&quot;D&quot;] = @{&quot;st_blocker&quot;, name=&quot;doorA#&quot;@}
+ti[&quot;f&quot;] = @{&quot;st_floppy&quot;, target=&quot;@@doorB#*&quot;@}
+ti[&quot;d&quot;] = @{&quot;st_blocker&quot;, name=&quot;doorB#&quot;@}
+wo{ti, &quot; &quot;, {
+&quot;       b            &quot;,
+&quot;       fB#####fb####&quot;,
+&quot;       # F    B     &quot;,
+&quot;       # #    F#####&quot;,
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+By clustering the doors in two groups you just need two additional tile
+declarations. But you will likely be able to handle a dozen of additional
+switch/door combinations.
+
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ==================  Extension Development  =======================
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Extension Development
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at chapter</A> Extension Development
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A> 
+* Resolver Development::    
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Resolver Development
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Resolver Development
+
+Resolvers are designed to provide easy pluggable extensions for usage by level 
+authors. Furtheron resolvers should be as flexible as possible. To reach these
+goals each resolver consists of three parts: the configurator, the implemention
+and the finalizer.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A> 
+* Resolver Configurator::      
+* Resolver Implementation::      
+* Resolver Finalizer::      
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Resolver Configurator
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Resolver Configurator
+
+The configurator is the function that is being called, when the author
+supplies the resolver specific parameters.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+context = @b{res.resolvername}(@i{subresolver},...)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{subresolver}
+Resolver to which unresolved requests should be forwarded. May be @samp{ti}
+as the final resolver of the resolver chain.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+This function has just one mandatory paramenter, the subresolver. You are free
+to specify arbitrary further parameters due to the needs of the resolvers task.
+
+All official resolvers will be registered in the registry table @samp{res} under
+their official name:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+function res.composer(subresolver)
+    ...
+end
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+This configurator function will be called just once per level start. It is 
+called after the tile declarations and before the first tile is set and the
+implementation part may be called.
+
+It is the task of the configurator function to check the user supplied
+parameters thoroughly and to provide appropriate error messages on bad
+parameters. Do this with an lua error message call at level 2:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+error(&quot;Resolver autotile rule &quot; .. i..&quot; is not a table&quot;, 2)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+The configuration function has to return a table that contains the context
+for subsequent calls of the implementation. This table has three predefined
+entries:
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{[1]} = @i{implementation function}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{[2]} = @i{finalizer function}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{[3]} = @i{subresolver}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{...} = resolver specific additional entries
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+All the checked and preprocessed parameters have to be stored in this context
+table for later usage. The resolver implementation function is usually 
+registered as @samp{res.resolvername_implementation}. The finalizer can be
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{nil} if no finalization is necessary. The subresolver given as the
+first parameter of the configurator call needs to be the third context
+table entry.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+function res.composer(subresolver)
+    local context = @{res.composer_implementation, nil, subresolver@}
+    return context
+end
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Resolver Implementation
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Resolver Implementation
+
+When the map gets evaluated on the world creation the top resolver is asked
+for every key to return the valid tile declaration. This is done with the
+following call.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+tile = @b{resolver_implementation}(@i{context}, @i{evaluator}, @i{key}, @i{x}, @i{y})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{context}
+The context as provided as return value by the @ref{Resolver Configurator}.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{evaluator}
+A system function that needs to be called whenever this resolver needs to
+look up the key by its subresolver.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{key}
+The key string that should be resolved
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{x}, @i{y}
+The position of the tile.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Based on the given parameters, the key, the position, the resolver parameters
+stored in the context and the existing tiles that can be requested via the
+evaluator function the implementation needs to decide if it takes influence on
+the key. Note that it is not possible to access any world object via its
+coordinate at this time. On every call you have to assume that it may be the
+first tile that is set.
+
+If the key is not resolved to a final tile by this resolver, the subresolver
+must be called via the evaluator function:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+local tile = evaluator(context[3], key, x, y)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+Remember that the subresolver is stored at position 3 of the context. As no
+influence should be taken this tile is the one that should be returned.
+
+But if you want to return another tile you are free to do it. You can decide
+on another key and ask the subresolver for the appropriate tile. You can
+even concatenate two tiles returned by subsequent subresolver calls. You are
+allowed to return a new tile with a table declaration of an object. Some valid
+return statements:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+return evaluator(context[3], &quot;a&quot;, x, y)
+return evaluator(context[3], &quot;a&quot;, x, y) .. evaluator(context[3], &quot;b&quot;, x, y)
+return evaluator(context[3], &quot;a&quot;, x, y) .. ti({&quot;st_laser_n&quot;, state=ON})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+You are even allowed to add new tile declartions to the tiles repository to
+speed up subsequent calls:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+ti[&quot;newkey&quot;] = evaluator(context[3], &quot;a&quot;, x, y) .. ti({&quot;st_laser_n&quot;, state=ON})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+A resolver implementation can store and modifiy any of its private parameters
+in the context table for subsequent calls. Especially it can enlist all 
+coordinates for postprocessing operations in the finalizer.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
+The implementatio of the composer (without the special 3 character key treatment)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+function res.composer_implementation(context, evaluator, key, x, y)
+    local tile = evaluator(context[3], key, x, y)
+    if tile ~= nil then
+        return tile
+    end
+    -- try to compose tile
+    for i = 1, #key do
+        local subkey = string.rep(&quot; &quot;, i-1) .. string.sub(key, i, i) .. string.rep(&quot; &quot;, #key - i)
+        local subtile = evaluator(context[3], subkey, x, y)
+        if subtile == nil then
+            return nil
+        end
+        if tile == nil then
+            tile = subtile
+        else
+            tile = tile .. subtile
+        end
+    end
+    return tile
+end
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A>
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Resolver Finalizer
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Resolver Finalizer
+
+If the @ref{Resolver Configurator} provides a finalizer function in its context
+this function will be called once when all tiles from the map have been set.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{resolver_finalization}(@i{context})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{context}
+The context as provided as return value by the @ref{Resolver Configurator}.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+The finalization functions of chained resolvers are called from top to bottom.
+
+Many resolvers have no need of a finalization. But some like a maze constructor
+need to know all participating tiles until they can do their final work.
+
+As all tiles from the map have been processed the objects can now be accessed.
+Further information may be stored in the resolvers context.
+
+The finalizer does neither call its subresolver nor does it return a value.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ===================  Old API - Objects  =======================
+
 @node Old API - Objects
 @chapter Old API - Objects
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000584.html">[Enigma-game-svn] r1151 - team_levelpacks/team_test_new_api
</A></li>
	<LI>Next message: <A HREF="000586.html">[Enigma-game-svn] r1153 - in trunk: data src src/stones
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#585">[ date ]</a>
              <a href="thread.html#585">[ thread ]</a>
              <a href="subject.html#585">[ subject ]</a>
              <a href="author.html#585">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
