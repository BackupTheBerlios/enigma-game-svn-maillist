<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1674 - trunk/doc/reference
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1674%20-%20trunk/doc/reference&In-Reply-To=%3C200905132145.n4DLjU9m014450%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001103.html">
   <LINK REL="Next"  HREF="001105.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1674 - trunk/doc/reference</H1>
    <B>ral at mail.berlios.de</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1674%20-%20trunk/doc/reference&In-Reply-To=%3C200905132145.n4DLjU9m014450%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1674 - trunk/doc/reference">ral at mail.berlios.de
       </A><BR>
    <I>Wed May 13 23:45:30 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001103.html">[Enigma-game-svn] r1673 - trunk/doc/reference
</A></li>
        <LI>Next message: <A HREF="001105.html">[Enigma-game-svn] r1675 - trunk/doc/reference
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1104">[ date ]</a>
              <a href="thread.html#1104">[ thread ]</a>
              <a href="subject.html#1104">[ subject ]</a>
              <a href="author.html#1104">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2009-05-13 23:45:16 +0200 (Wed, 13 May 2009)
New Revision: 1674

Modified:
   trunk/doc/reference/enigma-ref.texi
Log:
Trunk 1.1: refman
- Chapter 5 Lua API additions for datatypes Tile, Tiles, World and global functions.html
- Chapter 13 started for Guidlines and Hints

Modified: trunk/doc/reference/enigma-ref.texi
===================================================================
--- trunk/doc/reference/enigma-ref.texi	2009-05-10 14:14:05 UTC (rev 1673)
+++ trunk/doc/reference/enigma-ref.texi	2009-05-13 21:45:16 UTC (rev 1674)
@@ -12,6 +12,7 @@
 @author Ralf Westram
 @author Ronald Lamprecht
 @author Andreas Lochmann
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at author</A> Andreas Abraham
 @end titlepage
 
 @defindex ob
@@ -44,6 +45,7 @@
 * Libraries::                   Advanced tools
 * Advanced Features::           Fire, ...
 * Extension Development::       Resolver, Library Development
+* Guidelines and Hints::        Tips and Recommendations for Levels to be included in Enigma
 * Old API - Objects::           Description of all objects in Enigma
 * Old API - Variables::         Lua variables that influence the game
 * Old API - Functions::         Predefined functions
@@ -52,7 +54,7 @@
 * Message Index::
 * Function Index::
 * Concept Index::
-* Renaming Index::
+* Renaming Index::              Old API to new API translation hints
 @end menu
 
 @node  Running Enigma
@@ -3653,8 +3655,6 @@
 specific API part as you can expect it for a reference manual. Please note
 that additional @ref{Advanced Features} are described in a separate chapter.
 
-Until this chapter is finished please read the API Concept Draft, too!
-
 @menu
 * Basic Lua Examples::
 * API 2 Overview::
@@ -3665,13 +3665,11 @@
 * Group::
 * NamedObjects::
 * PositionList::
-* Positions::
+* Positions Repository::
+* Tile and Object Declaration::
+* Tiles Repository::
+* World::
 * Functions::
-* Tile::
-* Tiles::
-* World::
-* World Creation and Resolver Chaining::
-* Custom Resolver::
 
 @end menu
 
@@ -4503,6 +4501,9 @@
 @node Tiles and World Tasks
 @subsection Tiles and World Tasks
 
+For reference details @pxref{Tile and Object Declaration}, @ref{Tiles Repository}
+and @ref{World}.
+
 @table @asis
 
 @item @b{Tiles:}
@@ -4538,7 +4539,7 @@
   @})
 @end example
 The world is initialized by the @samp{wo()} call that is explained in details
-at @ref{World Creation and Resolver Chaining}. In the simple form you supply
+at @ref{World Creation}. In the simple form you supply
 the @samp{ti} handle as the first argument. The second argument is the key of
 the default tile definition that defines the default floor to be set if a tile
 does not contain another floor object. At the same time this key defines by its
@@ -5003,7 +5004,7 @@
 @end example
 Up to now we did look up the keys used in the map from our tiles repository
 @samp{ti} that was the first argument of the world initialization call. But
-now we use a @ref{Custom Resolver} (@pxref{World Creation and Resolver Chaining}).
+now we use a @ref{Custom Resolver}.
 The function starting in line 22 is called on every tile to be resolved. It has
 the task of delivering the appropriate tile.
 
@@ -5261,10 +5262,10 @@
 can take every positive or negative number and zero, too. Thus you can calculate
 with positions and use them to express offsets between two other positions.
 
-Positions are are created by the @ref{Positions} singleton handle, that allows
-you to convert coordinates, objects, position constants into positions. The
-handle allows you to retrieve existing named positions, too. Furtheron positions
-are implicitly created as return values of many operations.
+Positions are are created by the @ref{Positions Repository} singleton handle, 
+that allows you to convert coordinates, objects, position constants into 
+positions. The handle allows you to retrieve existing named positions, too. 
+Furtheron positions are implicitly created as return values of many operations.
 
 For task driven samples @pxref{Position Tasks}.
 
@@ -5475,7 +5476,7 @@
 attributes on any object. Customer attributes are any indices starting with an
 underscore @samp{_} as prefix to their name.
 
-The real world objects are created by assigning a @ref{Tile} declaration to
+The real world objects are created by assigning a tile declaration to
 a @ref{World} position. You retrieve a corresponding object reference either
 by the @ref{NamedObjects} repository, by @ref{Functions} or other methods that
 return single object references.
@@ -5569,7 +5570,7 @@
 
 @item @b{Details:}
 Checks whether an object reference is still valid. Returns true if the object
-still exists, otherwise false is returned.
+still exists, otherwise false is returned for @samp{NULL} object references.
 
 @item @b{Syntax Samples:}
 @example
@@ -6172,7 +6173,7 @@
 created will never change or get invalid. They are true values themselves. Thus
 they are the containers of choice for longterm storage.
 
-You can easily transform a group into a position list by the @ref{Positions} 
+You can easily transform a group into a position list by the @ref{Positions Repository} 
 singleton by the simple expression @samp{po(group)}. And you can retrieve all
 @ref{Position}s of a basic object kind located along a position list path by
 @ref{Functions} like @samp{st(polist)}, @samp{it(polist)} and @samp{fl(polist)}.
@@ -6292,10 +6293,10 @@
 @end table
 
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- Positions --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Positions Repository --------------------
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> Positions
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> Positions
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Positions Repository
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Positions Repository
 
 The Positions datatyp is just used by a single instance, the singleton 
 repository of named positions. Besides the management of named positions it
@@ -6396,54 +6397,228 @@
 
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- Functions --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Tile and Object Declaration --------------------
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> Functions
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> Functions
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tile and Object Declaration
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Tile and Object Declaration
 
-fl
-it
-st
-grp
-usertype
-random
-cond
+A tile is the description of one or several objects that should be positioned
+on the same grid position. A single object can be set up by a straight
+object declaration, an anonymous Lua table with entries for the object kind
+and all attributes. The object declaration comes in three minor variations:
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- Tile --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+@{&quot;@b{st_chess}&quot;, @b{name}=&quot;@var{jumper}&quot;, @b{color}=@var{WHITE}@}
+@{&quot;@b{st_chess_white}&quot;, &quot;@var{jumper}&quot;, @var{_myattr}=@var{5}@}
+@{&quot;@b{ac_marble}&quot;, 0.2, 0.6, @b{name}=&quot;@var{blacky}&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> Tile
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> Tile
+The first entry, the one stored at table position @samp{1}, has always to be
+the kind name of an supported Enigma object. In the first example all other
+table entries are key value pairs with the key being the attribute name. The
+second example uses the shortcut of specifying the name attribute value as
+second table entry, that will be stored at table position @samp{2}. It has to
+be a string value. The third variation, that is useful for actor declarations,
+stores the grid offsets in x and y direction in the table postions @samp{2} and
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{3}. Of course you can not use the name attribute shortcut in the same
+declaration.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- Tiles --------------------
+These table driven object declarations are always suffcient if you just want to
+set a single object at once. But tiles do often take an item or a stone besides
+a floor. So we need an Enigma data type being able to handle these multiple
+declarations. This is the @samp{tile} data type. It can take just one object
+declaration or an arbitrary list of declarations. You convert a table object
+declaration into a tile by the @ref{Tiles Repository} handle. Once you have a
+tile you can concat other tiles or table object declarations to set up new
+tiles.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> Tiles
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> Tiles
+Enigma guarantees that the objects will be set to the world in the sequence
+of declarations in the tile.
 
+For task driven samples @pxref{Tiles and World Tasks}. 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* Tile concat::     Compose a new tile as concatenation of two other
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Tile concat --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tile concat
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Tile concat
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @i{tile} .. &lt;@i{tile} | @i{odecl}&gt;
+
+result = &lt;@i{tile} | @i{odecl}&gt; .. @i{tile}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Compose a new tile by concatenation of a tile with another tile or a table
+object declaration. In a concatenated chain of tiles and object declarations
+one of the first two evaluated arguments needs to be a tile as two Lua tables
+do not know how to concat. 
+
+Note that Lua does evaluate the @samp{..} operatorfrom right to left! Thus you
+need either use proper braces or you need to guarantee that at least one of the
+two rightmost tokens is a tile.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newtile} = @i{ti}@{@b{st_chess}&quot;@} .. @{&quot;@b{fl_sahara}&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newtile} = @i{ti}@{@b{st_chess}&quot;@} .. @{&quot;@b{fl_sahara}&quot;@} .. @{&quot;@b{it_cherry}&quot;@}   -- Lua error due to right to left evaluation
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newtile} = (@i{ti}@{@b{st_chess}&quot;@} .. @{&quot;@b{fl_sahara}&quot;@}) .. @{&quot;@b{it_cherry}&quot;@} -- evaluation order fixed
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newtile} = @i{ti}@{@b{st_chess}&quot;@} .. @{&quot;@b{fl_sahara}&quot;@} .. @i{ti}@{&quot;@b{it_cherry}&quot;@} -- converted one of the two critical declarations
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Tiles Repository --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tiles Repository
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Tiles Repository
+
+The Tiles datatyp is just used by a single instance, the singleton repository of
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{Tile and Object Declaration}s. Besides the management of tiles it provides
+useful conversions of table based object declarations to tiles.
+
+Being a singleton you can not create a new Tiles repository. The singleton is
+stored at the global variable @samp{ti} on level load.
+
+The repositories stores tiles for given string keys. The key strings can be
+of any length. Due to Lua limitations they need to be composed of printable
+7-bit ASCII characters. 
+
+You can assign a tile to every key just once. A reassign causes an error. On
+one hand this allow internal implementation optimization, but on the other hand
+an unforerseen key reassignement is the most common level coding error that 
+needs to be reported.
+
+For task driven samples @pxref{Tiles and World Tasks}. 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* Tiles Storage::     Store a tile for a key
+* Tiles Request::     Retrieve a tile for a key
+* Tile Convertion::   Convert an object declartion into a tile
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Tiles Storage --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tiles Storage
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Tiles Storage
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+ti[&quot;@i{key}&quot;] = &lt;@i{tile}|@i{odecl}&gt;
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Index write accesses to the singleton allows you to assign a tile or an table
+based object declaration, that is autoconverted to a tile, to a given key. The
+key must be a unique string. Unique in the sense that you can not reassign a
+new tile to key to which previously another tile has been assigned.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at i</A>{ti}[&quot;@var{#}&quot;] = @var{tile}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at i</A>{ti}[&quot;@var{$}&quot;] = @{@b{st_chess}&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at i</A>{ti}[&quot;@var{$}&quot;] = @{@b{st_switch}&quot;@}   -- error of key reassignment
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at i</A>{ti}[&quot;@var{anykey}&quot;] = @{@b{st_chess}&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Tiles Request --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tiles Request
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Tiles Request
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = ti[&quot;@i{key}&quot;]
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Request of the tile that has been assigned to the given key. If no tile has yet
+been stored for the key a Lua @samp{nil} value is returned. Note that this
+tiles repository does not use wildcard characters as the named objects and
+postions repositories do. The asterix @samp{*} and question mark @samp{?} are
+just keys as any other characters.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{tile} = @i{ti}[&quot;@var{#}&quot;]
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Tile Convertion --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tile Convertion
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Tile Convertion
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = ti(@i{odecl})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Converts an table based object declaration to a new tile value.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{tile} = @i{ti}(@{@b{st_chess}&quot;@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{tile} = @i{ti}@{@b{st_chess}&quot;@}   -- Lua syntax equivalence
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
 @c ----------------- World --------------------
 
 @node World
 @section World
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- World Creation and Resolver Chaining --------------------
+The World datatype is just used by a single instance, another singleton object.
+A reference to this singleton is stored at the Lua global variable @samp{wo} on
+level load. Being a singleton you can not instanciate another World object.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> World Creation and Resolver Chaining
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> World Creation and Resolver Chaining
+But even though the singleton @samp{wo} already exists on load of a level the
+world is still undefined in all aspects. From the first line of Lua code you
+can access the @ref{Global Attributes}. But the world gets really set up with
+the @ref{World Creation}. After this call the world has a well defined size
+and is filled with an inital set of objects that you can access and modify
+from this moment on.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* World Creation::   Set up world with objects
+* add::              Add single objects to the world or an inventory
+* drawBorder::       Draw a rectangular border with a tile
+* drawMap::          Draw objects given by a map of tile keys
+* drawRect::         Fill a complete rectangle with a tile
+* world floor::      Retrieval of floor objects
+* world item::       Retrieval of item objects
+* shuffleOxyd::      Oxyd Shuffling Rules
+* world stone::      Retrieval of stone objects
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- World Creation --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> World Creation
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> World Creation
+
 Once all parameters have been set and all tiles have been declared it is time
 to create the level world with all its objects. This is done by the following
-constructor that appears in two variations.
+constructor that appears in three variations.
 
 @table @asis
 @item @b{Syntax:}
 width, height = @b{wo}(@i{topresolver}, @i{defaultkey}, @i{map})
 
+width, height = @b{wo}(@i{topresolver}, @i{libmap})
+
 width, height = @b{wo}(@i{topresolver}, @i{defaultkey}, @i{width}, @i{height})
 
 @table @asis
 @item @i{topresolver} = @code{ti} | @i{resolver} | @i{localresolver}
 Every tile in the world is given by a key that needs to be resolved to its
-declaration. This can be done either by the tiles repository @samp{ti}, or
-by given library @ref{Resolvers} or by local @ref{Custom Resolver} function.
+declaration. This can be done either by the @ref{Tiles Repository} @samp{ti}, or
+by given library @ref{Resolvers} or by a local @ref{Custom Resolver} function.
 This argument takes the top resolver that is requested first.
 @item @i{defaultkey}
 A string that defines the key that should be taken as default. It is taken
@@ -6453,6 +6628,8 @@
 A table of strings. Each string describes a row of tiles by its tile keys.
 If a map is given, the world size is determined from the longest string and
 the number of rows.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{libmap}
+A map of the library @ref{libmap}
 @item @i{width}
 As an argument that is given instead of a map it describes the width of the
 desired world.
@@ -6468,6 +6645,7 @@
        &quot;                    &quot;,
        ...
        &quot;                    &quot;@})
+w, h = wo(ti, mylibmap)
 @end example
 
 @item @b{Details:}
@@ -6483,108 +6661,170 @@
 Every key is resolved to its tile declaration via the given resolver chain.
 The top resolver is given to this call as a parameter. If it is @samp{ti} the
 chain consists just of one element and the tile declaration stored in the tiles
-repository at the given key is taken. But there exist several useful
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at ref</A>{Resolvers} that may simplify the task of level writing or provide dynamic
-features like randomness, mazes, etc. If you like to use one or several of them
-you provide the instance of the resolver to be requested first in this
-constructor. The instance that should be requested next is set in the top
-resolver as first argument, and so on. The last library resolver takes usually
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{ti} as its subresolver. For even more flexibility you can provide an
-own @ref{Custom Resolver} function within the level to take influence on the key
-interpretation. This function has to be the last resolver in the chain.
+repository at the given key is taken. Otherwise the resolvers will be evaluated
+as explained in @ref{Resolver Chaining}.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-ti[&quot;~&quot;] = @{&quot;fl_water&quot;@}
-ti[&quot;s&quot;] = @{&quot;fl_sahara&quot;@}
-ti[&quot;t&quot;] = @{&quot;fl_tigris&quot;@}
-ti[&quot;1&quot;] = @{&quot;ac-blackball&quot;, 0, 0.5@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
 
-ti[&quot;template_trigger&quot;] = @{&quot;it_trigger&quot;, target=&quot;myoxyd%%&quot;, action=&quot;open&quot;@}
-ti[&quot;template_oxyd&quot;]    = ti[&quot;~&quot;] .. @{&quot;st_oxyd&quot;, &quot;myoxyd%%&quot;@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- add --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> add
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> add
 
-myrandom = res.random(ti, &quot; &quot;, @{&quot;s&quot;, &quot;t&quot;@})
+Add @ref{Other Objects} to the world or a portable item to an inventory or
+other container object.
 
-myautotile = res.autotile(myrandom, @{&quot;a&quot;, &quot;h&quot;, &quot;template_trigger&quot;@},
-                              @{&quot;A&quot;, &quot;H&quot;, &quot;template_oxyd&quot;@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:add}(@i{tile_declarations})
 
-w, h = wo(myautotile, &quot; &quot;, @{
-&quot;A~                ~E&quot;,
-&quot;~~                ~~&quot;,
-&quot;~~   h        b   ~~&quot;,
-&quot;~~                ~~&quot;,
-&quot;B~     c    d     ~F&quot;,
-&quot;~~                ~~&quot;,
-&quot;~~        1       ~~&quot;,
-&quot;~~                ~~&quot;,
-&quot;C~     f    e     ~G&quot;,
-&quot;~~                ~~&quot;,
-&quot;~~   g        a   ~~&quot;,
-&quot;~~                ~~&quot;,
-&quot;D~                ~H&quot;
-@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:add}(@i{target}, @i{tile_declarations})
 
-wo:shuffleOxyd()
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{tile_declarations}
+One or many other object declarations given as tiles or anonymous tables.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{target}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{YIN}, @samp{YANG} or valid @ref{Object Reference}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo:add(@{&quot;ot_rubberband&quot;, anchor1=&quot;a1&quot;, anchor2=&quot;w&quot;, length=2, strength=80, threshold=0@})
+wo:add(ti[&quot;r&quot;] .. @{&quot;ot_wire&quot;, anchor1=&quot;w1&quot;, anchor2=&quot;w2&quot;@})
+wo:add(YIN, @{&quot;it_magicwand@})
+wo:add(no[&quot;mybag&quot;], @{&quot;it_magicwand@} .. ti[&quot;h&quot;] .. ti[&quot;c&quot;])
 @end example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Just @ref{Other Objects} can be directly added to the world. Just portable
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{Items} can be added to the player's inventories @samp{YIN} and @samp{YANG}
+and to @ref{it_bag}s. No other targets do currently add objects by this method.
+
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- Custom Resolver --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- drawBorder --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> drawBorder
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> drawBorder
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> Custom Resolver
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> Custom Resolver
+Draw a border around a rectangle out of given tiles.
 
-A customer resolver is a function in the level that allows a dynamic remapping
-of tiles. When this function is registered in the resolver chain it is called
-once for every tile to be set. The tile that this function return will be set.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:drawBorder}(@i{upperleft_edge}, @i{lowerright_edge}, @i{tile})
 
-Typical use cases are design patterns that are easy to calculate, but tedious
-to draw in the map and dynamic generated levels that differ slightly on every
-restart.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:drawBorder}(@i{upperleft_edge}, @i{width}, @i{height}, @i{tile})
 
 @table @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{upperleft_edge}
+Upper left anchor position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{lowerright_edge}
+Lower right end position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{width}
+Width of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{height}
+Height of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo:drawBorder(po(0, 0), wo[&quot;Width&quot;], wo[&quot;Height&quot;], ti[&quot;#&quot;])
+wo:drawBorder(no[&quot;myRectUL&quot;], no[&quot;myRectLR&quot;], @{&quot;st_grate1&quot;@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+The rectangle as four one grid thick lines is drawn with the given tile. That
+means on every position of the rectangle itself an instance of every object of
+the tile declaration is set. The rectangle may degenerate to a single line.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- drawMap --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> drawMap
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> drawMap
+
+Even if the world is initialized by a map on creation of the world
+(@pxref{World Creation}), it is sometime useful to
+be able to draw smaller submaps either as part of the initialization or as
+dynamic level changes within @ref{Callback Function}. Of course the main purpose
+of @samp{drawMap} is the drawing of repeating patterns.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
 @item @b{Syntax:}
-tile = @b{myresolver}(@i{key}, @i{x}, @i{y})
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:drawMap}(@i{resolver}, @i{anchor}, @i{ignore}, @i{map}, [@i{readdir}])
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:drawMap}(@i{resolver}, @i{anchor}, @i{libmap-map}, [@i{readdir}])
+
 @table @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{key}
-String that contains the tile key to be resolved.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{x}
-The world x coordinate of the tile.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{y}
-The world y coordinate of the tile.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{subresolver}
+Resolver to which unresolved requests should be forwarded. May be @samp{ti}
+as the final resolver of the resolver chain.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{anchor}
+The anchor position where the upper left tile of the map should be drawn.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{ignore}
+A tile key string that should be ignored. This key string is mandatory, even
+if it not used within the map.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{map}
+A table of strings. Each string describes a row of tiles by its tile keys.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{libmap-map}
+If the map used is created via @ref{libmap}, the @samp{ignore}-string can
+be omitted. The map's default key will then be ignored instead.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{readdir}
+An optional argument to modify the direction of the map relative to the world.
+This argument can be any of the constants described in @ref{Rotating and
+Mirroring Maps}.
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo:drawMap(ti, po(5, 7), &quot;-&quot;, @{&quot;abcabc&quot;@})
+wo:drawMap(ti, anchor_object, &quot;--&quot;, @{&quot;--##--##&quot;,&quot;##--##&quot;@})
+wo:drawMap(ti, @{12, 5@}, &quot; &quot;, @{&quot;122  221&quot;@}, MAP_ROT_CW)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
 @item @b{Details:}
-A custom resolver function is the last resolver that is called in the chain.
-It has to return the final tile that should be drawn at the given position.
-This can be done by statement @samp{return ti[&quot;k&quot;]}, which references the tile
-already declared in the tiles map.
+The syntax is similar to the world creation call. But there are two essential
+differences you need to be aware of. First the map is drawn in the already
+existing world. Thus we need to define the position. This is done via the
+anchor position, which can be an already existing object, too.
 
-If no suited tile is already declared you can alternatively return a new tile
-like @samp{return ti(@{&quot;st_switch&quot;, state=ON@})}.
+The second difference is in the definition of a tile key string for tiles in
+the map that should be ignored. Remember that the world initialization requested
+a default tile key string. This default is still valid. But with the given
+ignore key string we can draw arbitrary shaped patterns by filling unused
+grids in the map with this key.
 
-If you decide not to draw any tile at all, you must return an empty tile
-declaration: @samp{return ti(@{@})}.
+The length of the ignore key defines the map key length. It is strongly
+recommended to use the same key length as in the world map.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{return nil} indicates an error of usage of an unknown tile key.
+The rows of the supplied map are drawn from the anchor position. The rows may
+be of different length and may start with ignore tile keys. The anchor must be
+the position composed of the smallest x and smallest y coordinate within the
+pattern.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Example:}
+You can use drawMap anywhere after the world creation. You are even allowed to
+use it within the world creation in a resolver.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
 @example
-ti[&quot;r&quot;] = @{&quot;fl_rough_red&quot;@}
-ti[&quot;b&quot;] = @{&quot;fl_rough_blue&quot;@}
-ti[&quot;1&quot;] = @{&quot;#ac-blackball&quot;@}
+ti[&quot; &quot;] = @{&quot;fl_plank&quot;@}
+ti[&quot;X&quot;] = @{&quot;st_oxyd&quot;@}
+ti[&quot;B&quot;] = @{&quot;st_passage_black&quot;, flavor=&quot;frame&quot;@}
+ti[&quot;W&quot;] = @{&quot;st_passage_white&quot;, flavor=&quot;frame&quot;@}
+ti[&quot;y&quot;] = @{&quot;it_yinyang&quot;@}
+ti[&quot;1&quot;] = ti[&quot;y&quot;] .. @{&quot;#ac_marble_black&quot;@}
+ti[&quot;2&quot;] = ti[&quot;y&quot;] .. @{&quot;#ac_marble_white&quot;@}
 
-ti[&quot;x&quot;] = @{&quot;it_cross&quot;@}
-
 function myresolver(key, x, y)
-    if key == &quot; &quot; then
-        local center = ((x%3) * (y%3))%2
-        local checker = ((math.modf(x/3) %2) + (math.modf(y/3) %2))%2
-        if center + checker == 1 then
-            return ti[&quot;r&quot;]
-        else
-            return ti[&quot;b&quot;]
-        end
+    if key == &quot;w&quot; then
+        wo:drawMap(ti, po(x-1, y-1), &quot;-&quot;, @{&quot;-W-&quot;,
+                                           &quot;WXW&quot;,
+                                           &quot;-W-&quot;@})
+        return ti(@{@})
+    elseif key == &quot;b&quot; then
+        wo:drawMap(ti, po(x-1, y-1), &quot;-&quot;, @{&quot;-B&quot;,
+                                           &quot;BXB&quot;,
+                                           &quot;-B&quot;@})
+        return ti(@{@})
     else
         return ti[key]
     end
@@ -6592,22 +6832,767 @@
 
 w, h = wo(myresolver, &quot; &quot;, @{
 &quot;                    &quot;,
+&quot;  b         b       &quot;,
+&quot;       w       w    &quot;,
 &quot;                    &quot;,
 &quot;                    &quot;,
-&quot;      x x           &quot;,
-&quot;       x            &quot;,
-&quot;      x x           &quot;,
-&quot;                    &quot;,
-&quot;          1         &quot;,
-&quot;                    &quot;,
-&quot;                    &quot;,
-&quot;                    &quot;,
-&quot;                    &quot;,
+&quot;   w                &quot;,
+&quot;         12      b  &quot;,
+&quot;              w     &quot;,
+&quot;         w          &quot;,
+&quot;      b             &quot;,
+&quot;   w           b    &quot;,
+&quot;         b          &quot;,
 &quot;                    &quot;
 @})
+wo:shuffleOxyd()
 @end example
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- drawRect --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> drawRect
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> drawRect
+
+Fill a rectangle with a given tile.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:drawRect}(@i{upperleft_edge}, @i{lowerright_edge}, @i{tile})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:drawRect}(@i{upperleft_edge}, @i{width}, @i{height}, @i{tile})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{upperleft_edge}
+Upper left anchor position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{lowerright_edge}
+Lower right end position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{width}
+Width of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{height}
+Height of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo:drawRect(po(0, 0), wo[&quot;Width&quot;], wo[&quot;Height&quot;], ti[&quot; &quot;])
+wo:drawRect(no[&quot;myRectUL&quot;], no[&quot;myRectLR&quot;], @{&quot;fl_water&quot;@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+The complete rectangle is filled with the given tile. That means on every
+position of the rectangle and its interior an instance of every object of
+the tile declaration is set. The rectangle may degenerate to a single line.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- world floor --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> world floor
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> world floor
+
+Retrieves the floor objects for the given position or positions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @b{wo}:@b{fl}(&lt;@i{pos}| @{@i{x}, @i{y}@}|@i{x}, @i{y}| @i{obj} | @i{group}| @i{polist}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+This world method is identical to the global function @ref{fl}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- world item --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> world item
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> world item
+
+Retrieves the item objects for the given position or positions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @b{wo}:@b{it}(&lt;@i{pos}| @{@i{x}, @i{y}@}|@i{x}, @i{y}| @i{obj} | @i{group}| @i{polist}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+This world method is identical to the global function @ref{it}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- shuffleOxyd --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> shuffleOxyd
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> shuffleOxyd
+
+Shuffling the color distribution of the @ref{st_oxyd} makes every level, that
+is no meditation, a bit generic. On every level start the level looks a little
+bit different and the user has to solve a modified level. This provides long
+term amusement. Thus the call of this method is part of most levels.
+
+Many levels just call this method without any arguments. This results in a
+shuffling of all @ref{st_oxyd} that are not excluded by a @samp{noshuffle}
+attribute.
+
+But sometimes levels need to influence the shuffling, either for ensuring that
+the level remains solvable, or simply to ensure fairness. Imagine a level that
+has two @ref{st_oxyd}s in every corner. If by chance a user gets a distribution
+where he has in each corner a pair of same colored oxyds, the level might be
+trivial. Another level may have a passage that the marble can pass just a few
+times. With 5 or more oxyds on each side of the passage you need to ensure that
+the marble never needs to pass the passage more often than possible. Both
+situations can be handled by providing proper rules as arguments to this method.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{wo:shuffleOxyd}(@i{rules})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{rules} = @i{rule}, @i{rule},...
+No rule or as many as you like, all separated by a comma.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{rule} = @{@i{group1}, @i{group2}, @i{maxrule}, @i{minrule}, @i{circularrule}, @i{linearrule}, @i{log}@}
+Each rule is a table with a subset of the listed entries. The @i{group1} entry
+is mandatory. All other entries are optional and can be added in any combination.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{group1} = @i{group} | @i{objectreference} | @i{objectspecifier}
+A description of oxyd objects that are part of the first rule group. Either
+a group or a single object reference or a string specifier that resolves to a
+single or via wildcard to several oxyd objects are legal descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{group2} = @i{group} | @i{objectreference} | @i{objectspecifier}
+A description of oxyd objects that are part of the second rule group. Either
+a group or a single object reference or a string specifier that resolves to a
+single or via wildcard to several oxyd objects are legal descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{maxrule} = @code{max = }@i{number}
+The maximum number of oxyd pairs.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{minrule} = @code{min = }@i{number}
+The minimum number of oxyd pairs.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{circularrule} = @code{circular = true}
+Avoid any pair of neighboring oxyds in group1. Avoid an oxyd pair of first and
+last oxyd in group1, too.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{linearrule} = @code{linear = true}
+Avoid any pair of neighboring oxyds in group1.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{log} = @code{log = } @ @  @code{&quot;solution&quot;} |@code{&quot;count&quot;} |@code{&quot;all&quot;}
+Log additional information to the log stream for debugging purposes and
+security checks by the level author.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo:shuffleOxyd()
+wo:shuffleOxyd(@{no[&quot;borderoxyds#*&quot;]:sort(&quot;circular&quot;), circular=true@})
+wo:shuffleOxyd(@{&quot;leftoxyds#*&quot;,&quot;rightoxyds#*&quot;, min=3@}, @{&quot;islandoxyds#*&quot;, max=0@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+
+Any call of @samp{wo:shuffleOxyd()} must occur after all @ref{st_oxyd} have been
+set. That means that it must follow the standard world initialization
+(@pxref{World Creation}). As a side effect shuffleOxyd
+will assign colors to all @samp{OXYD_AUTO} colored @ref{st_oxyd}.
+
+Once called the given shuffling rules remain valid. Any further reshuffling
+must be done by messages @samp{closeall} and @samp{shuffle} to one arbitrary
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{st_oxyd} instance. No addition of an @ref{st_oxyd} or subsequent
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{wo:shuffleOxyd()} calls are possible without disturbing and deleting the
+given rules.
+
+Rule based shuffling is limited to a maximum of one pair of each standard oxyd
+color plus any combination of additional special fake, quake or bold oxyds
+summing up to a maximum of 32 oxyds. If more than 32 oxyds or 2 or more pairs
+of a single standard color are set, all oxyds will be shuffled by random
+ignoring any provided rules.
+
+There are basically two different types of rules. Those with one group and those
+with two groups of oxyds (Note that group is the general API expression for
+a set of oxyds and not a mathematical group). For a single group the rules apply
+to the oxyd instances within this group. For two groups the rules apply to oxyd
+pairs with one oxyd in the first group and the other in the second group.
+
+E.g. @samp{@{&quot;islandoxyds#*&quot;, max=0@}} requests that there is no pair within
+this group of oxyds. Whereas @samp{@{&quot;leftoxyds#*&quot;,&quot;rightoxyds#*&quot;, min=3@}}
+requests that there are 3 different oxyd pairs, each with one oxyd out of the
+leftoxyd group and the second out of the rightoxyd group.
+
+Linear and circular rules can only be applied to a single group. They are
+shortcuts for the most common rules that are applied to oxyds arranged on a
+line or a circle. In both cases they avoid pairs of neighboring oxyds. They
+are equivalent to @samp{n-1} res. @samp{n} rules with all possible neighboring
+oxyd pairs as two groups and a rule of @samp{max=0}.
+
+Note that you can apply several rules at once to given groups. E.g. you can
+apply a minrule and a maxrule within one rule!
+
+The shuffling process consists always of two stages. The most important first
+stage generates a valid oxyd pair distribution. That means that we settle which
+pairs will have the same color. But the color itself is assigned in an
+independent second stage. As for the examination of given rules just the pair
+distribution is relevant, we do just count and log these different distributions
+ignoring the colors.
+
+With 16 oxyds of 8 different colors and no restricting rules you have 2027025
+(15 * 13 * 11 * 9 * 7 * 5 * 3) different valid distributions. Keep in mind
+that useful rules should always keep hundreds or thousands of different valid
+distributions for a level.
+
+For debugging purposes you can add a log parameter to one of the rules (it does
+not matter to which one). If you request the log of @samp{solution} the
+pair distribution will be printed to the log stream.
+
+In case of @samp{count} the number of different oxyd distributions will be
+counted and logged. It is recommended to check the count on complex rules to
+ensure that enough distributions remain for a varying game. But be careful
+applying count on trivial rules. With 16 oxyds there may be as many as
+2027025 distributions and it may take a standard PC up to 30 seconds to count
+them - add a factor of 17*19 for 20 oxyds!
+
+Be very, very cautious in usage of logging @samp{all}. This call tries to print
+all solutions. It takes ages if there are too many solutions. First check the
+count before trying to log the solutions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+wo[&quot;ConserveLevel&quot;] = false
+
+ti[&quot;~&quot;] = @{&quot;fl_water&quot;@}
+ti[&quot; &quot;] = @{&quot;fl_plank&quot;@}
+ti[&quot;c&quot;] = @{&quot;it_crack_l&quot;, brittleness=0@}
+ti[&quot;^&quot;] = @{&quot;st_oneway_n&quot;@}
+ti[&quot;1&quot;] = @{&quot;ac_marble_black&quot;, 0, 0.5@}
+
+ti[&quot;x&quot;] = @{&quot;st_oxyd&quot;, &quot;island#&quot;@}
+ti[&quot;y&quot;] = @{&quot;st_oxyd&quot;, &quot;left#&quot;@}
+ti[&quot;z&quot;] = @{&quot;st_oxyd&quot;, &quot;right#&quot;@}
+
+w, h = wo(ti, &quot; &quot;, @{
+&quot;~~x  x  x  x  x  x~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~~~^~~~~~~~~~~^~~~~&quot;,
+&quot;y       ~~~~       z&quot;,
+&quot;~       cccc       ~&quot;,
+&quot;y       ~~~~       z&quot;,
+&quot;~       cccc       ~&quot;,
+&quot;y       ~~~~       z&quot;,
+&quot;~       cccc       ~&quot;,
+&quot;y       ~~~~       z&quot;,
+&quot;~~~~c~~~~~~~~~~c~~~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~        1       ~~&quot;
+@})
+
+wo:shuffleOxyd(@{&quot;island#*&quot;, min=3, linear=true@}, @{&quot;left#*&quot;,&quot;right#*&quot;, max=2, min=2@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
+This level uses 14 oxyds. The 6 oxyds in the upper row are on an island that
+can not be left once the marble entered it through one of the oneways. Thus
+we need 3 pairs of oxyds on this island, which are enforced by the min rule.
+To avoid trivial neighboring pairs on the island, we do add a linear rule, too.
+The marble can pass just three times between the left and right islands. This
+allows a first look on the color oxyds with one pass and opening one pair on
+each of the two following passes. Thus we limit the number of pairs by a max
+rule to 2. To avoid trivial oxyd pair distributions, like two pairs on the left
+and two pairs on the right side, we do add a min rule that enforces that two
+shared pairs of oxyds do exist.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- world stone --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> world stone
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> world stone
+
+Retrieves the stone objects for the given position or positions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @b{wo}:@b{st}(&lt;@i{pos}| @{@i{x}, @i{y}@}|@i{x}, @i{y}| @i{obj} | @i{group}| @i{polist}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+This world method is identical to the global function @ref{st}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Functions --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Functions
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Functions
+
+Besides all the features strongly related to a value as context and thus
+implemented as operators or methods of these datatypes, a few other tasks 
+remain. These are either context free or take at least in one variation just a 
+standard Lua datatype, that does not supply a context. Thus these tasks are
+implemented as simple functions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* assert_bool::     Throws an error if a condition doesn't hold.
+* assert_type::     Throws an error if a variable is not of a given type.
+* cond::            A ternary operator, wrapper for if-then-else.
+* etype::           An advanced function to return normal and user data types.
+* fl::              Floor retrieval
+* grp::             Create a group out of the argument objects
+* it::              Item retrieval
+* random::          Random number generator
+* st::              Stone retrieval
+* usertype::        Type info for Enigma userdata types 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- assert_bool --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> assert_bool
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> assert_bool
+
+The function @samp{assert_bool} throws an error if a given condition doesn't hold.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{assert_bool}(@i{condition}, @i{message}, @i{level})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{condition}
+A boolean expression or anything else. If it is @code{false} or @code{nil}, an
+error will be thrown.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{message}
+A string, holding the error message. If @code{message} is nil or empty, an
+&quot;anonymous assertion&quot; will be thrown, but it's always better to provide a
+meaningful error message.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{level}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{level} specifies the error position in the same way as does Lua's
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{error}-function. Default is 1.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at i</A>{assert_bool}(@i{no}[&quot;@var{mystone}&quot;]:@b{exists}(), &quot;@var{Stone 'mystone' has disappeared.}&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Assertions help you to detect coding errors. They are heavily used on argument
+checks of library functions and resolver implementations. As the assertions
+should not lead to performance penalties during runtime they are just evaluated
+when the level's @samp{status} is declared in the XML header element @ref{&lt;version&gt;}
+with a value of either @code{&quot;test&quot;} or @code{&quot;experimental&quot;}. For @code{&quot;stable&quot;} 
+and @code{&quot;released&quot;} levels assert statements are simply skipped on compilation
+like Lua comments.
+
+Similar to @ref{cond}, all side effects within the evaluation of @samp{message}
+and @samp{level} will appear.
+
+See Lua's manual for more detailed information about the @samp{error}-function.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- assert_type --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> assert_type
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> assert_type
+
+The function @samp{assert_type} throws an error if the first argument is not of one of the
+specified types.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{assert_type}(@i{var}, @i{vardescription}, @i{level}, @i{type1}, @i{type2}, ...)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{var}
+Any kind of variable.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{vardescription}
+If @samp{var} is not of one of the types @samp{type1}, @samp{type2} ...,
+then an error message will be thrown which includes the actual type of
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{var} and the desired types. @samp{vardescription} is a string which
+holds additional information for the error message. It should be a lower-case
+not-too-short description of @samp{var} (a name, as it is), additional
+details should be added in brackets.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{level}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{level} specifies the error position in the same way as does Lua's
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{error}-function. Can't be omitted, use @samp{1} if in doubt.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{type1}, @i{type2}, ...
+A sequence of strings. If @samp{var} is none of these types, the error will
+be thrown. See details below for type descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at i</A>{assert_type}(@var{arg1}, &quot;@var{mygreatfunction first argument (level width)}&quot;, @var{1}, &quot;@b{nil}&quot;, &quot;@b{positive integer}&quot;, &quot;@b{position}&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Assertions help you to detect coding errors. They are heavily used on argument
+checks of library functions and resolver implementations. As the assertions
+should not lead to performance penalties during runtime they are just evaluated
+when the level's @samp{status} is declared in the XML header element @ref{&lt;version&gt;}
+with a value of either @code{&quot;test&quot;} or @code{&quot;experimental&quot;}. For @code{&quot;stable&quot;} 
+and @code{&quot;released&quot;} levels assert statements are simply skipped on compilation
+like Lua comments.
+
+Possible types are all Lua types (like @code{&quot;nil&quot;}, @code{&quot;number&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;boolean&quot;}, @code{&quot;string&quot;}, @code{&quot;table&quot;}, @code{&quot;function&quot;}) except
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;userdata&quot;}, all Enigma-own user types (@code{&quot;object&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;position&quot;}, @code{&quot;tile&quot;}, @code{&quot;tiles&quot;}, @code{&quot;group&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;world&quot;}, @code{&quot;polist&quot;}, @code{&quot;unknown&quot;}), and
+types defined inside metatables (@code{&quot;map&quot;} from @ref{libmap}), see
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{etype}. In addition, the following type descriptors are recognized:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;integer&quot;}
+Any integer number (..., -2, -1, 0, 1, 2, ...)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;positive&quot;}
+Any number which is positive and not zero.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;non-negative&quot;}
+Any number which is not negative, i.e. which is positive or zero.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;natural&quot;}
+Any non-negative integer number (0, 1, 2, ...).
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;positive integer&quot;}
+Any positive integer number (1, 2, 3, ...).
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;non-empty string&quot;}
+Any string other than the empty string @code{&quot;&quot;}.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;any table&quot;}
+If @samp{var} is a table, the @samp{_type}-attribute of its metatable will
+be used as its @ref{etype}. In particular, it won't be accepted as a
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;table&quot;} anymore, if this @samp{_type}-attribute exists. For example,
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+assert_type(mytable, &quot;large table&quot;, 1, &quot;table&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+will throw an assertion when @samp{mytable} is a @code{&quot;map&quot;}, although,
+technically, a @code{&quot;map&quot;} always is a @code{&quot;table&quot;}. You can use
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;any table&quot;} as type to allow for any table, regardless of its metatable.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @code{&quot;valid object&quot;}
+Any valid object.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+Similar to @ref{cond}, all side effects within the evaluation of
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{vardescription}, @samp{level} and any type descriptor will apply.
+
+See Lua's manual for more detailed information about the @samp{error}-function.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+function paint_lawn(pos)
+    assert_type(pos, &quot;paint_lawn first argument&quot;, 2, &quot;position&quot;, &quot;object&quot;, &quot;polist&quot;, &quot;group&quot;, &quot;table&quot;)
+    if etype(pos) == &quot;object&quot; then
+        assert_bool(-pos, &quot;paint_lawn: Object not existing.&quot;, 2)
+    end
+    wo[pos] = ti[&quot;lawn&quot;]
+end
+paint_lawn(no[&quot;mystone&quot;])
+paint_lawn(&quot;myotherstone&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+If @samp{mystone} doesn't exist, @code{no[&quot;mystone&quot;]} will still be of etype
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;object&quot;}, an invalid object. Hence @code{assert_type} will not trigger,
+but @code{assert_bool} will.
+
+If @samp{mystone} exists, the second @samp{paint_lawn} will throw an error via
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{assert_type}, as @code{pos} now is a @code{&quot;string&quot;}. The error message
+will be:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
+Wrong type for paint_lawn first argument, is string, must be one of position,
+object, polist, group, table.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- cond --------------------
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> cond
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> cond
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{cond} is a conditional assignment, a substitution for the ternary
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{?:} operator of C-like languages. Note however, that it is not a 
+equivalent substitution but just a workaround with some subtle side effects. 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{cond}(@i{condition}, @i{iftrue}, @i{iffalse})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{condition}
+A boolean expression.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{iftrue}
+The expression to be returned if @samp{condition} is true.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{iffalse}
+The expression to be returned if @samp{condition} is false.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at i</A>{ti}[&quot;@var{x}&quot;] = @i{cond}(@i{wo}[&quot;@b{IsDifficult}&quot;], @{&quot;@b{st_death}&quot;@}, @i{ti}[&quot;@var{#}&quot;])
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{cond} always evaluates both expressions @samp{iftrue} and
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{iffalse}, regardless of @samp{condition}. Hence,
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{mytable} = @{@var{1}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{2}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{3}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{4}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{5}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{6}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{7}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{8}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{9}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{0}@}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{removed_element} = @i{cond}(@var{i} &lt; @var{5}, @i{table}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">. at i</A>{remove}(@var{mytable}, @var{i}), @i{table}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">. at i</A>{remove}(@var{mytable}, @var{5}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+will always remove two elements. With @samp{i=2} the @samp{2} will be returned
+but @samp{mytable} will result in @samp{@{1,3,4,5,7,8,9,0@}}, and with @samp{i=6}
+you get the @samp{5} but mytable will be @samp{@{1,2,3,4,7,8,9,0@}}.
+
+Another Enigma example that will cause errors is:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{w}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{h} = @i{cond}(@i{wo}[&quot;@b{IsDifficult}&quot;], @i{wo}(@i{ti}, &quot; &quot;, @var{map1}), @i{wo}(@i{ti}, &quot; &quot;, @var{map2}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+Both, the second and the third argument will be evaluate. Thus two contradicting
+attempts to create a new world will be made causing the second one to fail. Use
+the following statement instead:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{w}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{h} = @i{wo}(@i{ti}, &quot; &quot;, @i{cond}(@i{wo}[&quot;@b{IsDifficult}&quot;], @var{map1}, @var{map2}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+However, in most cases @samp{cond} is used anyway with static expressions for
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{iftrue} and @samp{iffalse} (e.g. strings or variables) and no side effects
+will occur.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- etype --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> etype
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> etype
+
+The function @samp{etype()} returns the advanced type of its argument.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{etype}(@i{var})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{var}
+Any kind of variable.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{argtype} = @i{etype}(@var{value})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Lua types are @code{&quot;nil&quot;}, @code{&quot;number&quot;}, @code{&quot;boolean&quot;}, @code{&quot;string&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;table&quot;}, @code{&quot;function&quot;}, @code{&quot;userdata&quot;}, and @code{&quot;thread&quot;}. You
+can use Lua's @samp{type}-function to query the type of any variable. However,
+Enigma defines more types through various means, and these types can be queried
+via @samp{etype}. @samp{etype} will return its argument's Lua type as usual,
+with the following two exceptions:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{&quot;userdata&quot;}
+Instead of @code{&quot;userdata&quot;}, Enigma's special types will be returned. These
+special types are @code{&quot;object&quot;}, @code{&quot;position&quot;}, @code{&quot;tile&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;tiles&quot;}, @code{&quot;group&quot;}, @code{&quot;world&quot;}, @code{&quot;polist&quot;} and 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;default&quot;}. If an unknown userdata is encountered, @code{&quot;unknown&quot;} will
+be returned.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{&quot;table&quot;}
+If @code{var} is a table, it's metatable will be queried. If there is an entry
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{_type}, this entry will be used as @code{etype}. Most important examples
+of this kind are @ref{libmap}-maps and @ref{res.maze} with its mazes and cells.
+So @samp{etype} will return @code{&quot;map&quot;}, @code{&quot;maze&quot;} and @code{&quot;cell&quot;}, too.
+You may access the @code{etype}-system through @samp{_type} whenever you use
+metatables on your own.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- fl --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> fl
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> fl
+
+The function @samp{fl()} retrieves the floor objects for the given position or
+positions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @b{fl}(&lt;@i{pos}| @{@i{x}, @i{y}@}|@i{x}, @i{y}| @i{obj} | @i{group}| @i{polist}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+If the argument describes a single position, the floor object at this position 
+is returned. When this single position is outside of the world an invalid
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{NULL} @ref{Object} reference is returned.
+
+If the argument is either a @ref{Group} or @ref{PositionList} all floor objects
+of the related positions are retrieved and added in the same sequence to a new
+result group. Invalid positions will be skipped without adding an object to the
+group.
+
+In any case you can send messages to the result value.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{floor} = @i{fl}(@i{po}(@var{3}, @var{5}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{floor} = @i{fl}(@{@var{3}, @var{5}@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{floor} = @i{fl}(@var{3}, @var{5})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{floor} = @i{fl}@{@var{3}, @var{5}@}     -- by Lua syntax equivalence
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{floor} = @i{fl}(@var{mystone})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{group} = @i{fl}(@i{no}[&quot;door#*&quot;])
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{group} = @i{fl}(@i{po}(@var{3}, @var{5})<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">.. at i</A>{po}(@var{4}, @var{2}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- grp --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> grp
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> grp
+
+The function @samp{grp()} builds a @ref{Group} out of its argument @ref{Object}s.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{grp}(&lt;@{@i{obj1}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at i</A>{obj2},...@}| @i{obj1}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at i</A>{obj2},... |@i{group}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Returns a new @ref{Group} that is build up by the objects listed by the 
+arguements. The contents objects must be either listed in a Lua table, given
+as multiple single object arguments or an existing group. In all cases the
+sequence of objects is maintained in the returned new group, but all invalid
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{NULL} objects are omitted. In case one object is listed multiple times
+just the first instance will occur in the group and subsequent instances will
+be omitted.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newgroup} = @i{grp}(@var{obj1}, @var{obj2}, @var{obj3})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newgroup} = @i{grp}(@{@var{obj1}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{obj2}@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newgroup} = @i{grp}@{@var{obj1}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{obj2}@}   -- Lua syntax equivalence
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newgroup} = @i{grp}@{@}            -- empty group
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{newgroup} = @i{grp}(@var{group})       -- a copy of group cleaned of invalid @samp{NULL} objects
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- it --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> it
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> it
+
+The function @samp{it()} retrieves the item objects for the given position or
+positions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @b{it}(&lt;@i{pos}| @{@i{x}, @i{y}@}|@i{x}, @i{y}| @i{obj} | @i{group}| @i{polist}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+If the argument describes a single position, the item object at this position 
+is returned. When no item is located at the given single position or this 
+position is outside of the world an invalid @samp{NULL} @ref{Object} reference
+is returned.
+
+If the argument is either a @ref{Group} or @ref{PositionList} all item objects
+of the related positions are retrieved and added in the same sequence to a new
+result group. Invalid positions or positions without items will be skipped 
+without adding an object to the group.
+
+In any case you can send messages to the result value.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{item} = @i{it}(@i{po}(@var{3}, @var{5}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{item} = @i{it}(@{@var{3}, @var{5}@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{item} = @i{it}(@var{3}, @var{5})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{item} = @i{it}@{@var{3}, @var{5}@}     -- by Lua syntax equivalence
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{item} = @i{it}(@var{mystone})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{group} = @i{it}(@i{no}[&quot;door#*&quot;])
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{group} = @i{it}(@i{po}(@var{3}, @var{5})<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">.. at i</A>{po}(@var{4}, @var{2}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- random --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> random
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> random
+
+The function @samp{random()} is a syntax compatible replacement for the standard
+Lua function @samp{math.random()}. Both names refer to the same Enigma random
+implementation.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @b{random}(&lt;|@var{n}|@var{l}<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">, at var</A>{u}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+When called without arguments, math.random returns a pseudo-random real number
+in the range [0,1). When called with a number n, math.random returns a 
+pseudo-random integer in the range [1,n]. When called with two arguments, l and
+u, math.random returns a pseudo-random integer in the range [l,u].
+
+The only difference from the Lua implementation is the random generator itself.
+Enigma uses an own implementation that guarantees the same pseudo-random
+number sequence on any operating system and any processor for a given seed.
+This feature will be important for future Enigma versions and thus the 
+randomseed can not be modified by the level itself.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{float} = @i{random}()          -- e.g. 0.402834
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{integer} = @i{random}(20)      -- e.g. 13
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{integer} = @i{random}(5, 10)   -- e.g. 5
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- st --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> st
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> st
+
+The function @samp{st()} retrieves the stone objects for the given position or
+positions.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
+result = @b{st}(&lt;@i{pos}| @{@i{x}, @i{y}@}|@i{x}, @i{y}| @i{obj} | @i{group}| @i{polist}&gt;)
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+If the argument describes a single position, the stone object at this position 
+is returned. When no stone is located at the given single position or this 
+position is outside of the world an invalid @samp{NULL} @ref{Object} reference
+is returned.
+
+If the argument is either a @ref{Group} or @ref{PositionList} all stone objects
+of the related positions are retrieved and added in the same sequence to a new
+result group. Invalid positions or positions without stone will be skipped 
+without adding an object to the group.
+
+In any case you can send messages to the result value.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{stone} = @i{st}(@i{po}(@var{3}, @var{5}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{stone} = @i{st}(@{@var{3}, @var{5}@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{stone} = @i{st}(@var{3}, @var{5})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{stone} = @i{st}@{@var{3}, @var{5}@}     -- by Lua syntax equivalence
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{stone} = @i{st}(@var{myfloor})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{group} = @i{st}(@i{no}[&quot;cherry#*&quot;])
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{group} = @i{st}(@i{po}(@var{3}, @var{5})<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">.. at i</A>{po}(@var{4}, @var{2}))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example 
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- usertype --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> usertype
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> usertype
+
+The function @samp{usertype()} returns type info for Enigma data types.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at b</A>{usertype}(@i{var})
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{var}
+Any kind of variable.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at var</A>{argtype} = @i{usertype}(@var{value})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Details:}
+Just for Lua type @code{&quot;userdata&quot;} Enigma's special type info will be returned.
+These special types are @code{&quot;object&quot;}, @code{&quot;position&quot;}, @code{&quot;tile&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;tiles&quot;}, @code{&quot;group&quot;}, @code{&quot;world&quot;}, @code{&quot;polist&quot;} and 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at code</A>{&quot;default&quot;}. If another data type is encountered, @code{&quot;unknown&quot;} will
+be returned.
+
+The function @ref{etype} provides a more general type evaluation for arbitrary
+data types and is partially based on this function.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
+
 @c ===================  Commons  =======================
 @node Common Attributes and Messages
 @chapter Common Attributes and Messages
@@ -7668,7 +8653,7 @@
 
 A global read only variable reports the height of the world in grid units.
 This is set by the initial world constructor call
-(@pxref{World Creation and Resolver Chaining}).
+(@pxref{World Creation}).
 
 @table @asis
 @item @b{Type:} @ @ number
@@ -7760,7 +8745,7 @@
 A global variable that causes two @ref{it_extralife}s to be added to both player
 inventories on start of a new level. Set it to @samp{false} if a gamer could
 misuse these items. It is important to set this attribute before the world is
-created (@pxref{World Creation and Resolver Chaining}).
+created (@pxref{World Creation}).
 
 @table @asis
 @item @b{Type:} @ @ bool
@@ -7867,7 +8852,7 @@
 
 A global read only variable reports the width of the world in grid units.
 This is set by the initial world constructor call
-(@pxref{World Creation and Resolver Chaining}).
+(@pxref{World Creation}).
 
 @table @asis
 @item @b{Type:} @ @ number
@@ -12953,6 +13938,7 @@
 * st_ghost::           Invisible Transforming Stone
 * st_grate::           Hovering metal Grate
 * st_greenbrown::      Mainly brown seedable stone
+* st_ice::             Item and Floor freezing Ice block
 * st_jamb::            Colored Door Jamb
 * st_key::             Key Driven Switch
 * st_knight::          Sword Bearing Knight Stone
@@ -14289,6 +15275,33 @@
 @end table
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Ice Stone --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> st_ice
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> st_ice
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at obindex</A> st_ice
+
+A block of ice is a movable stone that freezes some items when being pushed
+over them. Of course a floor of @ref{fl_water} will freeze, too, when ice is
+being pushed over it. But a block of ice can be destroyed by explosions and by
+heating fire leaving either @ref{fl_ice} or @ref{fl_water}.
+
+Note some minor details of st_ice are not yet stable - especially the fire
+interactions may still change.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Messages:}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{ignite} @ @ @xref{ignite}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{heat} @ @ @xref{heat}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Variants:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{st_ice}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> table
+
 @c ----------------- Jamb Stone --------------------
 @node st_jamb
 @subsection st_jamb
@@ -15536,8 +16549,8 @@
 very nature transparent to laser light. Like other @ref{Transparent Stones} it
 is passable for invisible actors.
 
-This stone looks identical to @ref{st_ice}, but differs of course in its
-features.
+This stone comes in a second texture variant that looks like being composed
+of 4 small rawglasses. This @samp{quad} variant is not movable.
 
 @table @asis
 @item @b{Attributes:}
@@ -15552,6 +16565,7 @@
 
 @table @asis
 @item @b{st_rawglass}: movable = @code{false}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{st_rawglass_quad}: movable = @code{false}
 @item @b{st_rawglass_movable}: movable = @code{true}
 @end table
 
@@ -15773,6 +16787,9 @@
 @obindex st_spitter
 
 A stone that spits @ref{ot_cannonball}s on actor hits and on proper messages.
+The standard spitter is @samp{ACTIVE} showing a slow rotating animation. In
+this @samp{state} the spitter reacts on actor hits, while being @samp{IDLE}
+it is steady and will spit just on messages.
 
 On an actor hit the spitter checks the owner's inventory for an existing
 @ref{it_extralife}. If one exists that is not stuffed in a @ref{it_bag}, it
@@ -15831,6 +16848,9 @@
 @item @b{Attributes:}
 
 @table @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{state}, @ @ @i{values}: @code{IDLE}, @code{ACTIVE}; @ @ @i{default}: @code{ACTIVE} @ @ @xref{state}
+An @samp{ACTIVE} spitter is animated and reacts on actor hits while an @samp{IDLE}
+looks steady and does not spit on actor hits.
 @item @b{hit_strength} @ @ @i{values}: floating point numbers; @ @ @i{default}: @code{1.0}; @ @ @xref{hit_*}
 @item @b{hit_distortion_xx} @ @ @i{values}: floating point numbers; @ @ @i{default}: @code{1.0}; @ @ @xref{hit_*}
 @item @b{hit_distortion_xy} @ @ @i{values}: floating point numbers; @ @ @i{default}: @code{0.0}; @ @ @xref{hit_*}
@@ -15850,7 +16870,7 @@
 
 @item @b{Variants:}
 @table @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{st_spitter}: secure = @code{false}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{st_spitter}: secure = @code{false}, state = @code{ACTIVE}
 @end table
 
 @end table
@@ -17498,264 +18518,7 @@
 @uref{<A HREF="http://www.lua.org/manual/5.0/,">http://www.lua.org/manual/5.0/,</A> Lua 5.0} and 
 @uref{<A HREF="http://www.lua.org/manual/5.1/,">http://www.lua.org/manual/5.1/,</A> Lua 5.1} for more detailed information.
 
-In addition to the usual Lua functions, Enigma provides the @ref{cond}-function,
-which can be used to abbreviate simple if-then-else-constructions, and two
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{assert}-kind functions.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at menu</A>
-* assert_bool::     Throws an error if a condition doesn't hold.
-* assert_type::     Throws an error if a variable is not of a given type.
-* cond::            A ternary operator, wrapper for if-then-else.
-* etype::           An advanced function to return normal and user data types.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> menu
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- assert_bool --------------------
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> assert_bool
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> assert_bool
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{assert_bool} throws an error if a given condition doesn't hold.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{assert_bool}(@i{condition}, @i{message}, @i{level})
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{condition}
-A boolean expression or anything else. If it is @code{false} or @code{nil}, an
-error will be thrown.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{message}
-A string, holding the error message. If @code{message} is nil or empty, an
-&quot;anonymous assertion&quot; will be thrown, but it's always better to provide a
-meaningful error message.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{level}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{level} specifies the error position in the same way as does Lua's
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{error}-function. Default is 1.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-assert_bool(no[&quot;mystone&quot;], &quot;Stone 'mystone' has disappeared.&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Details:}
-Similar to @ref{cond}, all side effects within the evaluation of @samp{message}
-and @samp{level} will appear.
-
-See Lua's manual for more detailed information about the @samp{error}-function.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- assert_type --------------------
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> assert_type
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> assert_type
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{assert_type} throws an error if the first argument is not of one of the
-specified types.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{assert_type}(@i{var}, @i{vardescription}, @i{level}, @i{type1}, @i{type2}, ...)
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{var}
-Any kind of variable.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{vardescription}
-If @samp{var} is not of one of the types @samp{type1}, @samp{type2} ...,
-then an error message will be thrown which includes the actual type of
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{var} and the desired types. @samp{vardescription} is a string which
-holds additional information for the error message. It should be a lower-case
-not-too-short description of @samp{var} (a name, as it is), additional
-details should be added in brackets.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{level}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{level} specifies the error position in the same way as does Lua's
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{error}-function. Can't be omitted, use @samp{1} if in doubt.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{type1}, @i{type2}, ...
-A sequence of strings. If @samp{var} is none of these types, the error will
-be thrown. See details below for type descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-assert_type(arg1, &quot;mygreatfunction first argument (level width)&quot;, 1, &quot;nil&quot;, &quot;positive integer&quot;, &quot;position&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Details:}
-Possible types are all Lua types (like @code{&quot;nil&quot;}, @code{&quot;number&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;boolean&quot;}, @code{&quot;string&quot;}, @code{&quot;table&quot;}, @code{&quot;function&quot;}) except
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;userdata&quot;}, all Enigma-own user types (@code{&quot;object&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;position&quot;}, @code{&quot;tile&quot;}, @code{&quot;tiles&quot;}, @code{&quot;group&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;world&quot;}, @code{&quot;polist&quot;}, @code{&quot;unknown&quot;}), and
-types defined inside metatables (@code{&quot;map&quot;} from @ref{libmap}), see
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at ref</A>{etype}. In addition, the following type descriptors are recognized:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;integer&quot;}
-Any integer number (..., -2, -1, 0, 1, 2, ...)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;positive&quot;}
-Any number which is positive and not zero.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;non-negative&quot;}
-Any number which is not negative, i.e. which is positive or zero.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;natural&quot;}
-Any non-negative integer number (0, 1, 2, ...).
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;positive integer&quot;}
-Any positive integer number (1, 2, 3, ...).
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;non-empty string&quot;}
-Any string other than the empty string @code{&quot;&quot;}.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;any table&quot;}
-If @samp{var} is a table, the @samp{_type}-attribute of its metatable will
-be used as its @ref{etype}. In particular, it won't be accepted as a
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;table&quot;} anymore, if this @samp{_type}-attribute exists. For example,
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-assert_type(mytable, &quot;large table&quot;, 1, &quot;table&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-will throw an assertion when @samp{mytable} is a @code{&quot;map&quot;}, although,
-technically, a @code{&quot;map&quot;} always is a @code{&quot;table&quot;}. You can use
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;any table&quot;} as type to allow for any table, regardless of its metatable.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @code{&quot;valid object&quot;}
-Any valid object.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
-Similar to @ref{cond}, all side effects within the evaluation of
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{vardescription}, @samp{level} and any type descriptor will apply.
-
-See Lua's manual for more detailed information about the @samp{error}-function.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-function paint_lawn(pos)
-    assert_type(pos, &quot;paint_lawn first argument&quot;, 2, &quot;position&quot;, &quot;object&quot;, &quot;polist&quot;, &quot;group&quot;, &quot;table&quot;)
-    if etype(pos) == &quot;object&quot; then
-        assert_bool(-pos, &quot;paint_lawn: Object not existing.&quot;, 2)
-    end
-    wo[pos] = ti[&quot;lawn&quot;]
-end
-paint_lawn(no[&quot;mystone&quot;])
-paint_lawn(&quot;myotherstone&quot;)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-If @samp{mystone} doesn't exist, @code{no[&quot;mystone&quot;]} will still be of etype
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;object&quot;}, an invalid object. Hence @code{assert_type} will not trigger,
-but @code{assert_bool} will.
-
-If @samp{mystone} exists, the second @samp{paint_lawn} will throw an error via
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{assert_type}, as @code{pos} now is a @code{&quot;string&quot;}. The error message
-will be:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-Wrong type for paint_lawn first argument, is string, must be one of position,
-object, polist, group, table.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- cond --------------------
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> cond
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> cond
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{cond} is a conditional assignment, a ternary operator very
-similar (but not equal to) the @samp{?:}-expression in C-like languages. Note
-however, that there are caveats, see details.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{cond}(@i{condition}, @i{iftrue}, @i{iffalse})
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{condition}
-A boolean expression.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{iftrue}
-The expression to be returned if @samp{condition} is true.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{iffalse}
-The expression to be returned if @samp{condition} is false.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-cond(wo[&quot;IsDifficult&quot;], @{&quot;st_death&quot;@}, ti[&quot;#&quot;])
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Details:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{cond} evaluates both expressions @samp{iftrue} and
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{iffalse}, regardless of @samp{condition}. Hence,
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-cond(t == 0, 1/t, error(&quot;Division by zero&quot;))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-will always raise an error: All side effects will happen.
-Another example which will not work:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-w,h = cond(wo[&quot;IsDifficult&quot;], wo(ti, &quot; &quot;, map1), wo(ti, &quot; &quot;, map2))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-Use this instead:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-w,h = wo(ti, &quot; &quot;, cond(wo[&quot;IsDifficult&quot;], map1, map2))
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-However, in most cases @samp{cond} is used with static expressions for
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{iftrue} and @samp{iffalse} (e.g. strings or variables), when no
-side effects are possible.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- etype --------------------
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> etype
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> etype
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{etype} returns an advanced type of its argument.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{etype}(@i{var})
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{var}
-Any kind of variable.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-local argtype = etype(firstargument)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Details:}
-Lua types are @code{&quot;nil&quot;}, @code{&quot;number&quot;}, @code{&quot;boolean&quot;}, @code{&quot;string&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;table&quot;}, @code{&quot;function&quot;}, @code{&quot;userdata&quot;}, and @code{&quot;thread&quot;}. You
-can use Lua's @samp{type}-function to query the type of any variable. However,
-Enigma defines more types through various means, and these types can be queried
-via @samp{etype}. @samp{etype} will return its argument's Lua type as usual,
-with the following two exceptions:
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{&quot;userdata&quot;}
-Instead of @code{&quot;userdata&quot;}, Enigma's special types will be returned. These
-special types are @code{&quot;object&quot;}, @code{&quot;position&quot;}, @code{&quot;tile&quot;},
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at code</A>{&quot;tiles&quot;}, @code{&quot;group&quot;}, @code{&quot;world&quot;}, and @code{&quot;polist&quot;}. If an unknown
-userdata is encountered, @code{&quot;unknown&quot;} will be returned.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{&quot;table&quot;}
-If @code{var} is a table, it's metatable will be queried. If there is an entry
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{_type}, this entry will be used as @code{etype}. Most important examples
-of this kind are @ref{libmap}-maps, so @samp{etype} will return @code{&quot;map&quot;}.
-You may access the @code{etype}-system through @samp{_type} whenever you use
-metatables on your own.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
-
 @node liblua
 @section liblua
 
@@ -18454,8 +19217,8 @@
 @section libmap
 
 The @samp{libmap} gives the author more possibilities to work with API 2-maps. 
-Up to now, a map just is a table of strings, as described in @ref{World Creation
-and Resolver Chaining}. With @samp{libmap}, you can utilize maps in a more
+Up to now, a map just is a table of strings, as described in 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{World Creation}. With @samp{libmap}, you can utilize maps in a more
 advanced way.
 
 This library is described as of release 1. 
@@ -19184,185 +19947,157 @@
 @chapter Advanced Features
 
 @menu
-* World Advanced Methods::  Additional features provided by the world
 * Resolvers::               Standard tools for interpretation of tile maps
 * General Features::        Special features like scrolling, flood, fire,...
 * Tips and Tricks::         Simple patterns that are valuable like a feature
 @end menu
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> World Advanced Methods
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> World Advanced Methods
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Resolvers
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Resolvers
 
 @menu
-* add::          Add @ref{Other Objects} to the world
-* drawBorder::
-* drawMap::
-* drawRect::
-* shuffleOxyd::  Oxyd Shuffling Rules
+* Resolver Chaining::  
+* Custom Resolver::    
+* res.autotile::       Generate tiles from given template declarations
+* res.composer::       Compose tiles from given base tiles
+* res.maze::           Generate arbitrarily shaped mazes
+* res.puzzle::         Generate puzzle tiles and shuffle resulting puzzle clusters
+* res.random::         Choosing random tiles in a given distribution
 @end menu
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- add --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> add
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> add
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Resolver Chaining --------------------
 
-Add @ref{Other Objects} to the world.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Resolver Chaining
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Resolver Chaining
 
+Once all parameters have been set and all tiles have been declared it is time
+to create the level world with all its objects. This is done by the following
+constructor that appears in two variations.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{World Creation}
+
 @table @asis
 @item @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:add}(@i{tile_declarations})
+width, height = @b{wo}(@i{topresolver}, ...)
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:add}(@i{target}, @i{tile_declarations})
 
 @table @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{tile_declarations}
-One or many other object declarations given as tiles or anonymous tables.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{target}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{YIN}, @samp{YANG} or valid @ref{Object Reference}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{topresolver} = @code{ti} | @i{resolver} | @i{localresolver}
+Every tile in the world is given by a key that needs to be resolved to its
+declaration. This can be done either by the @ref{Tiles Repository} @samp{ti}, or
+by given library @ref{Resolvers} or by local @ref{Custom Resolver} function.
+This argument takes the top resolver that is requested first.
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-wo:add(@{&quot;ot_rubberband&quot;, anchor1=&quot;a1&quot;, anchor2=&quot;w&quot;, length=2, strength=80, threshold=0@})
-wo:add(ti[&quot;r&quot;] .. @{&quot;ot_wire&quot;, anchor1=&quot;w1&quot;, anchor2=&quot;w2&quot;@})
-wo:add(YIN, @{&quot;it_magicwand@})
-wo:add(no[&quot;mybag&quot;], @{&quot;it_magicwand@} .. ti[&quot;h&quot;] .. ti[&quot;c&quot;])
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
 @item @b{Details:}
-Just @ref{Other Objects} can be directly added to the world. Just non static
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at ref</A>{Items} can be added to the player's inventories @samp{YIN} and @samp{YANG}
-and to @ref{it_bag}s. No other targets do currently add objects by this method.
+Every key is resolved to its tile declaration via the given resolver chain.
+The top resolver is given to this call as a parameter. If it is @samp{ti} the
+chain consists just of one element and the tile declaration stored in the tiles
+repository at the given key is taken. Otherwise the resolvers will be evaluated
+as explained in @ref{Resolver Chaining}.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
+But there exist several useful
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at ref</A>{Resolvers} that may simplify the task of level writing or provide dynamic
+features like randomness, mazes, etc. If you like to use one or several of them
+you provide the instance of the resolver to be requested first in this
+constructor. The instance that should be requested next is set in the top
+resolver as first argument, and so on. The last library resolver takes usually
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{ti} as its subresolver. For even more flexibility you can provide an
+own @ref{Custom Resolver} function within the level to take influence on the key
+interpretation. This function has to be the last resolver in the chain.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Example:}
 @example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
+ti[&quot;~&quot;] = @{&quot;fl_water&quot;@}
+ti[&quot;s&quot;] = @{&quot;fl_sahara&quot;@}
+ti[&quot;t&quot;] = @{&quot;fl_tigris&quot;@}
+ti[&quot;1&quot;] = @{&quot;ac-blackball&quot;, 0, 0.5@}
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- drawBorder --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> drawBorder
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> drawBorder
+ti[&quot;template_trigger&quot;] = @{&quot;it_trigger&quot;, target=&quot;myoxyd%%&quot;, action=&quot;open&quot;@}
+ti[&quot;template_oxyd&quot;]    = ti[&quot;~&quot;] .. @{&quot;st_oxyd&quot;, &quot;myoxyd%%&quot;@}
 
-Draw a border around a rectangle out of given tiles.
+myrandom = res.random(ti, &quot; &quot;, @{&quot;s&quot;, &quot;t&quot;@})
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:drawBorder}(@i{upperleft_edge}, @i{lowerright_edge}, @i{tile})
+myautotile = res.autotile(myrandom, @{&quot;a&quot;, &quot;h&quot;, &quot;template_trigger&quot;@},
+                              @{&quot;A&quot;, &quot;H&quot;, &quot;template_oxyd&quot;@})
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:drawBorder}(@i{upperleft_edge}, @i{width}, @i{height}, @i{tile})
+w, h = wo(myautotile, &quot; &quot;, @{
+&quot;A~                ~E&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~   h        b   ~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;B~     c    d     ~F&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~        1       ~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;C~     f    e     ~G&quot;,
+&quot;~~                ~~&quot;,
+&quot;~~   g        a   ~~&quot;,
+&quot;~~                ~~&quot;,
+&quot;D~                ~H&quot;
+@})
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{upperleft_edge}
-Upper left anchor position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{lowerright_edge}
-Lower right end position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{width}
-Width of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{height}
-Height of the rectangle.
+wo:shuffleOxyd()
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> example
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-wo:drawBorder(po(0, 0), wo[&quot;Width&quot;], wo[&quot;Height&quot;], ti[&quot;#&quot;])
-wo:drawBorder(no[&quot;myRectUL&quot;], no[&quot;myRectLR&quot;], @{&quot;st_grate1&quot;@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ----------------- Custom Resolver --------------------
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Details:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Custom Resolver
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at subsection</A> Custom Resolver
 
+A customer resolver is a function in the level that allows a dynamic remapping
+of tiles. When this function is registered in the resolver chain it is called
+once for every tile to be set. The tile that this function return will be set.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
+Typical use cases are design patterns that are easy to calculate, but tedious
+to draw in the map and dynamic generated levels that differ slightly on every
+restart.
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- drawMap --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> drawMap
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> drawMap
-
-Even if the world is initialized by a map on creation of the world
-(@pxref{World Creation and Resolver Chaining}), it is sometime useful to
-be able to draw smaller submaps either as part of the initialization or as
-dynamic level changes within @ref{Callback Function}. Of course the main purpose
-of @samp{drawMap} is the drawing of repeating patterns.
-
 @table @asis
 @item @b{Syntax:}
+tile = @b{myresolver}(@i{key}, @i{x}, @i{y})
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:drawMap}(@i{resolver}, @i{anchor}, @i{ignore}, @i{map}, [@i{readdir}])
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:drawMap}(@i{resolver}, @i{anchor}, @i{libmap-map}, [@i{readdir}])
-
 @table @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{subresolver}
-Resolver to which unresolved requests should be forwarded. May be @samp{ti}
-as the final resolver of the resolver chain.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{anchor}
-The anchor position where the upper left tile of the map should be drawn.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{ignore}
-A tile key string that should be ignored. This key string is mandatory, even
-if it not used within the map.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{map}
-A table of strings. Each string describes a row of tiles by its tile keys.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{libmap-map}
-If the map used is created via @ref{libmap}, the @samp{ignore}-string can
-be omitted. The map's default key will then be ignored instead.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{readdir}
-An optional argument to modify the direction of the map relative to the world.
-This argument can be any of the constants described in @ref{Rotating and
-Mirroring Maps}.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{key}
+String that contains the tile key to be resolved.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{x}
+The world x coordinate of the tile.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @i{y}
+The world y coordinate of the tile.
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-wo:drawMap(ti, po(5, 7), &quot;-&quot;, @{&quot;abcabc&quot;@})
-wo:drawMap(ti, anchor_object, &quot;--&quot;, @{&quot;--##--##&quot;,&quot;##--##&quot;@})
-wo:drawMap(ti, @{12, 5@}, &quot; &quot;, @{&quot;122  221&quot;@}, MAP_ROT_CW)
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
 @item @b{Details:}
-The syntax is similar to the world creation call. But there are two essential
-differences you need to be aware of. First the map is drawn in the already
-existing world. Thus we need to define the position. This is done via the
-anchor position, which can be an already existing object, too.
+A custom resolver function is the last resolver that is called in the chain.
+It has to return the final tile that should be drawn at the given position.
+This can be done by statement @samp{return ti[&quot;k&quot;]}, which references the tile
+already declared in the tiles map.
 
-The second difference is in the definition of a tile key string for tiles in
-the map that should be ignored. Remember that the world initialization requested
-a default tile key string. This default is still valid. But with the given
-ignore key string we can draw arbitrary shaped patterns by filling unused
-grids in the map with this key.
+If no suited tile is already declared you can alternatively return a new tile
+like @samp{return ti(@{&quot;st_switch&quot;, state=ON@})}.
 
-The length of the ignore key defines the map key length. It is strongly
-recommended to use the same key length as in the world map.
+If you decide not to draw any tile at all, you must return an empty tile
+declaration: @samp{return ti(@{@})}.
 
-The rows of the supplied map are drawn from the anchor position. The rows may
-be of different length and may start with ignore tile keys. The anchor must be
-the position composed of the smallest x and smallest y coordinate within the
-pattern.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at samp</A>{return nil} indicates an error of usage of an unknown tile key.
 
-You can use drawMap anywhere after the world creation. You are even allowed to
-use it within the world creation in a resolver.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at item</A> @b{Example:}
 @example
-ti[&quot; &quot;] = @{&quot;fl_plank&quot;@}
-ti[&quot;X&quot;] = @{&quot;st_oxyd&quot;@}
-ti[&quot;B&quot;] = @{&quot;st_passage_black&quot;, flavor=&quot;frame&quot;@}
-ti[&quot;W&quot;] = @{&quot;st_passage_white&quot;, flavor=&quot;frame&quot;@}
-ti[&quot;y&quot;] = @{&quot;it_yinyang&quot;@}
-ti[&quot;1&quot;] = ti[&quot;y&quot;] .. @{&quot;#ac_marble_black&quot;@}
-ti[&quot;2&quot;] = ti[&quot;y&quot;] .. @{&quot;#ac_marble_white&quot;@}
+ti[&quot;r&quot;] = @{&quot;fl_rough_red&quot;@}
+ti[&quot;b&quot;] = @{&quot;fl_rough_blue&quot;@}
+ti[&quot;1&quot;] = @{&quot;#ac-blackball&quot;@}
 
+ti[&quot;x&quot;] = @{&quot;it_cross&quot;@}
+
 function myresolver(key, x, y)
-    if key == &quot;w&quot; then
-        wo:drawMap(ti, po(x-1, y-1), &quot;-&quot;, @{&quot;-W-&quot;,
-                                           &quot;WXW&quot;,
-                                           &quot;-W-&quot;@})
-        return ti(@{@})
-    elseif key == &quot;b&quot; then
-        wo:drawMap(ti, po(x-1, y-1), &quot;-&quot;, @{&quot;-B&quot;,
-                                           &quot;BXB&quot;,
-                                           &quot;-B&quot;@})
-        return ti(@{@})
+    if key == &quot; &quot; then
+        local center = ((x%3) * (y%3))%2
+        local checker = ((math.modf(x/3) %2) + (math.modf(y/3) %2))%2
+        if center + checker == 1 then
+            return ti[&quot;r&quot;]
+        else
+            return ti[&quot;b&quot;]
+        end
     else
         return ti[key]
     end
@@ -19370,241 +20105,22 @@
 
 w, h = wo(myresolver, &quot; &quot;, @{
 &quot;                    &quot;,
-&quot;  b         b       &quot;,
-&quot;       w       w    &quot;,
 &quot;                    &quot;,
 &quot;                    &quot;,
-&quot;   w                &quot;,
-&quot;         12      b  &quot;,
-&quot;              w     &quot;,
-&quot;         w          &quot;,
-&quot;      b             &quot;,
-&quot;   w           b    &quot;,
-&quot;         b          &quot;,
+&quot;      x x           &quot;,
+&quot;       x            &quot;,
+&quot;      x x           &quot;,
+&quot;                    &quot;,
+&quot;          1         &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
+&quot;                    &quot;,
 &quot;                    &quot;
 @})
-wo:shuffleOxyd()
 @end example
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- drawRect --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> drawRect
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> drawRect
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:drawRect}(@i{upperleft_edge}, @i{lowerright_edge}, @i{tile})
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:drawRect}(@i{upperleft_edge}, @i{width}, @i{height}, @i{tile})
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{upperleft_edge}
-Upper left anchor position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{lowerright_edge}
-Lower right end position of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{width}
-Width of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{height}
-Height of the rectangle.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-wo:drawRect(po(0, 0), wo[&quot;Width&quot;], wo[&quot;Height&quot;], ti[&quot; &quot;])
-wo:drawRect(no[&quot;myRectUL&quot;], no[&quot;myRectLR&quot;], @{&quot;fl_water&quot;@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Details:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at c</A> ----------------- shuffleOxyd --------------------
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> shuffleOxyd
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at subsection</A> shuffleOxyd
-
-Shuffling the color distribution of the @ref{st_oxyd} makes every level, that
-is no meditation, a bit generic. On every level start the level looks a little
-bit different and the user has to solve a modified level. This provides long
-term amusement. Thus the call of this method is part of most levels.
-
-Many levels just call this method without any arguments. This results in a
-shuffling of all @ref{st_oxyd} that are not excluded by a @samp{noshuffle}
-attribute.
-
-But sometimes levels need to influence the shuffling, either for ensuring that
-the level remains solvable, or simply to ensure fairness. Imagine a level that
-has two @ref{st_oxyd}s in every corner. If by chance a user gets a distribution
-where he has in each corner a pair of same colored oxyds, the level might be
-trivial. Another level may have a passage that the marble can pass just a few
-times. With 5 or more oxyds on each side of the passage you need to ensure that
-the marble never needs to pass the passage more often than possible. Both
-situations can be handled by providing proper rules as arguments to this method.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax:}
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at b</A>{wo:shuffleOxyd}(@i{rules})
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at table</A> @asis
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{rules} = @i{rule}, @i{rule},...
-No rule or as many as you like, all separated by a comma.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{rule} = @{@i{group1}, @i{group2}, @i{maxrule}, @i{minrule}, @i{circularrule}, @i{linearrule}, @i{log}@}
-Each rule is a table with a subset of the listed entries. The @i{group1} entry
-is mandatory. All other entries are optional and can be added in any combination.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{group1} = @i{group} | @i{objectreference} | @i{objectspecifier}
-A description of oxyd objects that are part of the first rule group. Either
-a group or a single object reference or a string specifier that resolves to a
-single or via wildcard to several oxyd objects are legal descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{group2} = @i{group} | @i{objectreference} | @i{objectspecifier}
-A description of oxyd objects that are part of the second rule group. Either
-a group or a single object reference or a string specifier that resolves to a
-single or via wildcard to several oxyd objects are legal descriptors.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{maxrule} = @code{max = }@i{number}
-The maximum number of oxyd pairs.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{minrule} = @code{min = }@i{number}
-The minimum number of oxyd pairs.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{circularrule} = @code{circular = true}
-Avoid any pair of neighboring oxyds in group1. Avoid an oxyd pair of first and
-last oxyd in group1, too.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{linearrule} = @code{linear = true}
-Avoid any pair of neighboring oxyds in group1.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @i{log} = @code{log = } @ @  @code{&quot;solution&quot;} |@code{&quot;count&quot;} |@code{&quot;all&quot;}
-Log additional information to the log stream for debugging purposes and
-security checks by the level author.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Syntax Samples:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-wo:shuffleOxyd()
-wo:shuffleOxyd(@{no[&quot;borderoxyds#*&quot;]:sort(&quot;circular&quot;), circular=true@})
-wo:shuffleOxyd(@{&quot;leftoxyds#*&quot;,&quot;rightoxyds#*&quot;, min=3@}, @{&quot;islandoxyds#*&quot;, max=0@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Details:}
-
-Any call of @samp{wo:shuffleOxyd()} must occur after all @ref{st_oxyd} have been
-set. That means that it must follow the standard world initialization
-(@pxref{World Creation and Resolver Chaining}). As a side effect shuffleOxyd
-will assign colors to all @samp{OXYD_AUTO} colored @ref{st_oxyd}.
-
-Once called the given shuffling rules remain valid. Any further reshuffling
-must be done by messages @samp{closeall} and @samp{shuffle} to one arbitrary
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at ref</A>{st_oxyd} instance. No addition of an @ref{st_oxyd} or subsequent
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at samp</A>{wo:shuffleOxyd()} calls are possible without disturbing and deleting the
-given rules.
-
-Rule based shuffling is limited to a maximum of one pair of each standard oxyd
-color plus any combination of additional special fake, quake or bold oxyds
-summing up to a maximum of 32 oxyds. If more than 32 oxyds or 2 or more pairs
-of a single standard color are set, all oxyds will be shuffled by random
-ignoring any provided rules.
-
-There are basically two different types of rules. Those with one group and those
-with two groups of oxyds (Note that group is the general API expression for
-a set of oxyds and not a mathematical group). For a single group the rules apply
-to the oxyd instances within this group. For two groups the rules apply to oxyd
-pairs with one oxyd in the first group and the other in the second group.
-
-E.g. @samp{@{&quot;islandoxyds#*&quot;, max=0@}} requests that there is no pair within
-this group of oxyds. Whereas @samp{@{&quot;leftoxyds#*&quot;,&quot;rightoxyds#*&quot;, min=3@}}
-requests that there are 3 different oxyd pairs, each with one oxyd out of the
-leftoxyd group and the second out of the rightoxyd group.
-
-Linear and circular rules can only be applied to a single group. They are
-shortcuts for the most common rules that are applied to oxyds arranged on a
-line or a circle. In both cases they avoid pairs of neighboring oxyds. They
-are equivalent to @samp{n-1} res. @samp{n} rules with all possible neighboring
-oxyd pairs as two groups and a rule of @samp{max=0}.
-
-Note that you can apply several rules at once to given groups. E.g. you can
-apply a minrule and a maxrule within one rule!
-
-The shuffling process consists always of two stages. The most important first
-stage generates a valid oxyd pair distribution. That means that we settle which
-pairs will have the same color. But the color itself is assigned in an
-independent second stage. As for the examination of given rules just the pair
-distribution is relevant, we do just count and log these different distributions
-ignoring the colors.
-
-With 16 oxyds of 8 different colors and no restricting rules you have 2027025
-(15 * 13 * 11 * 9 * 7 * 5 * 3) different valid distributions. Keep in mind
-that useful rules should always keep hundreds or thousands of different valid
-distributions for a level.
-
-For debugging purposes you can add a log parameter to one of the rules (it does
-not matter to which one). If you request the log of @samp{solution} the
-pair distribution will be printed to the log stream.
-
-In case of @samp{count} the number of different oxyd distributions will be
-counted and logged. It is recommended to check the count on complex rules to
-ensure that enough distributions remain for a varying game. But be careful
-applying count on trivial rules. With 16 oxyds there may be as many as
-2027025 distributions and it may take a standard PC up to 30 seconds to count
-them - add a factor of 17*19 for 20 oxyds!
-
-Be very, very cautious in usage of logging @samp{all}. This call tries to print
-all solutions. It takes ages if there are too many solutions. First check the
-count before trying to log the solutions.
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at item</A> @b{Full Example:}
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at example</A>
-wo[&quot;ConserveLevel&quot;] = false
-
-ti[&quot;~&quot;] = @{&quot;fl_water&quot;@}
-ti[&quot; &quot;] = @{&quot;fl_plank&quot;@}
-ti[&quot;c&quot;] = @{&quot;it_crack_l&quot;, brittleness=0@}
-ti[&quot;^&quot;] = @{&quot;st_oneway_n&quot;@}
-ti[&quot;1&quot;] = @{&quot;ac_marble_black&quot;, 0, 0.5@}
-
-ti[&quot;x&quot;] = @{&quot;st_oxyd&quot;, &quot;island#&quot;@}
-ti[&quot;y&quot;] = @{&quot;st_oxyd&quot;, &quot;left#&quot;@}
-ti[&quot;z&quot;] = @{&quot;st_oxyd&quot;, &quot;right#&quot;@}
-
-w, h = wo(ti, &quot; &quot;, @{
-&quot;~~x  x  x  x  x  x~~&quot;,
-&quot;~~                ~~&quot;,
-&quot;~~~~^~~~~~~~~~~^~~~~&quot;,
-&quot;y       ~~~~       z&quot;,
-&quot;~       cccc       ~&quot;,
-&quot;y       ~~~~       z&quot;,
-&quot;~       cccc       ~&quot;,
-&quot;y       ~~~~       z&quot;,
-&quot;~       cccc       ~&quot;,
-&quot;y       ~~~~       z&quot;,
-&quot;~~~~c~~~~~~~~~~c~~~~&quot;,
-&quot;~~                ~~&quot;,
-&quot;~~        1       ~~&quot;
-@})
-
-wo:shuffleOxyd(@{&quot;island#*&quot;, min=3, linear=true@}, @{&quot;left#*&quot;,&quot;right#*&quot;, max=2, min=2@})
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> example
-
-This level uses 14 oxyds. The 6 oxyds in the upper row are on an island that
-can not be left once the marble entered it through one of the oneways. Thus
-we need 3 pairs of oxyds on this island, which are enforced by the min rule.
-To avoid trivial neighboring pairs on the island, we do add a linear rule, too.
-The marble can pass just three times between the left and right islands. This
-allows a first look on the color oxyds with one pass and opening one pair on
-each of the two following passes. Thus we limit the number of pairs by a max
-rule to 2. To avoid trivial oxyd pair distributions, like two pairs on the left
-and two pairs on the right side, we do add a min rule that enforces that two
-shared pairs of oxyds do exist.
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> table
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at node</A> Resolvers
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at section</A> Resolvers
-
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at menu</A>
-* res.autotile::  Generate tiles from given template declarations
-* res.composer::  Compose tiles from given base tiles
-* res.maze::      Generate arbitrarily shaped mazes
-* res.puzzle::    Generate puzzle tiles and shuffle resulting puzzle clusters
-* res.random::    Choosing random tiles in a given distribution
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">- at end</A> menu
-
 @c ----------------- Autotile Resolver --------------------
 
 @node res.autotile
@@ -20684,6 +21200,47 @@
 The finalizer does neither call its subresolver nor does it return a value.
 @end table
 
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at c</A> ==================  Guidelines and Hints  =======================
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Guidelines and Hints
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at chapter</A> Guidelines and Hints
+
+Up to now we described all features in their full extend. Of course you are
+free to use them all without any restrictions for your private levels. We are
+committed to maintain all features in future versions of Enigma.
+
+But for inclusion of your levels into the Enigma project we would like to
+recommend conformance to some common standards. These few points gurantee that
+your levels can easily be processed by our administration tools, the players
+can talk about your level and your level remains editable by the project
+maintainers in case of urgent need.
+
+Additionally we like to give you some hints how to write good levels by means
+of proper strategy.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at menu</A>
+* Filename Recommendation::
+* Title Recommendation::
+* Tile Key Recommendation::
+* Easy Mode Hints::
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at end</A> menu
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Filename Recommendation
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Filename Recommendation
+No space for spaces
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Title Recommendation
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Title Recommendation
+English - no translation - use subtitle, too
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Tile Key Recommendation
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Tile Key Recommendation
+space for default
+
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at node</A> Easy Mode Hints
<A HREF="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">+ at section</A> Easy Mode Hints
+write easy first, floor friction,...
+
 @c ===================  Old API - Objects  =======================
 
 @node Old API - Objects


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001103.html">[Enigma-game-svn] r1673 - trunk/doc/reference
</A></li>
	<LI>Next message: <A HREF="001105.html">[Enigma-game-svn] r1675 - trunk/doc/reference
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1104">[ date ]</a>
              <a href="thread.html#1104">[ thread ]</a>
              <a href="subject.html#1104">[ subject ]</a>
              <a href="author.html#1104">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
