<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r838 - in trunk: data/gfx48 src src/gui
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r838%20-%20in%20trunk%3A%20data/gfx48%20src%20src/gui&In-Reply-To=%3C200708162129.l7GLTtCs013460%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000271.html">
   <LINK REL="Next"  HREF="000273.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r838 - in trunk: data/gfx48 src src/gui</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r838%20-%20in%20trunk%3A%20data/gfx48%20src%20src/gui&In-Reply-To=%3C200708162129.l7GLTtCs013460%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r838 - in trunk: data/gfx48 src src/gui">ral at mail.berlios.de
       </A><BR>
    <I>Thu Aug 16 23:29:55 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000271.html">[Enigma-game-svn] r837 - trunk/data/levels/lib
</A></li>
        <LI>Next message: <A HREF="000273.html">[Enigma-game-svn] r839 - in branches/eval/java: .	src/org/enigma_game/lev src/org/enigma_game/util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#272">[ date ]</a>
              <a href="thread.html#272">[ thread ]</a>
              <a href="subject.html#272">[ subject ]</a>
              <a href="author.html#272">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2007-08-16 23:29:50 +0200 (Thu, 16 Aug 2007)
New Revision: 838

Modified:
   trunk/data/gfx48/menu_bg.jpg
   trunk/src/client.cc
   trunk/src/gui/InfoMenu.cc
   trunk/src/gui/LPGroupConfig.cc
   trunk/src/gui/LevelInspector.cc
   trunk/src/gui/LevelMenu.cc
   trunk/src/gui/LevelPackComposer.cc
   trunk/src/gui/LevelPackConfig.cc
   trunk/src/gui/LevelPackMenu.cc
   trunk/src/gui/LevelPackMenu.hh
   trunk/src/gui/LevelPreviewCache.cc
   trunk/src/gui/LevelWidget.cc
   trunk/src/gui/MainMenu.cc
   trunk/src/gui/OptionsMenu.cc
   trunk/src/gui/ScreenshotViewer.cc
   trunk/src/main.cc
   trunk/src/main.hh
   trunk/src/video.cc
   trunk/src/video.hh
Log:
Trunk 1.1: 
- new video modes:
    960x720 = 48 bit tiles without black framing
    960x768 = 1280x1024 in fullscreen
    1152x720 = 1680x1050 in fullscreen
    1280x960 = 64 bit tiles basic window
Note:
- 1280x960 runs, but is deactivated due to missing images
ToDo:
- fine tuning of some menus
- scaling of screenshots
- 64 bit images


Modified: trunk/data/gfx48/menu_bg.jpg
===================================================================
(Binary files differ)

Modified: trunk/src/client.cc
===================================================================
--- trunk/src/client.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/client.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -92,7 +92,7 @@
     }
 }
 
-
+
 /* -------------------- Variables -------------------- */
 
 namespace
@@ -103,7 +103,6 @@
 
 #define CLIENT client_instance
 
-
 /* -------------------- Client class -------------------- */
 
 Client::Client() 
@@ -259,7 +258,6 @@
     player::RotateInventory(direction);
 }
 
-
 /* -------------------- Console related -------------------- */
 
 class HistoryProxy {

Modified: trunk/src/gui/InfoMenu.cc
===================================================================
--- trunk/src/gui/InfoMenu.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/InfoMenu.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -40,10 +40,12 @@
     
     void InfoMenu::draw_background(ecl::GC &amp;gc) {
         const video::VMInfo &amp;vminfo = *video::GetInfo();
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo.mbg_offsetx, vminfo.mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
         
         Font *f = enigma::GetFont(&quot;menufont&quot;);
         int row = 0;
+        int yoff[] = {0, -20, -40, -40};
+        int ygap[] = {0, 4, 6, 6};
         for (int p=0; p&lt;curPage; p++) {
             while (info[row])
                 row++;
@@ -53,7 +55,7 @@
         for (int i = 0; info[row]; row++, i++) {
             const char *t = _(info[row]);
             f-&gt;render (gc, 40 + (vminfo.width-640)/2, 
-                    20 + (vminfo.height-480)/2 + i*f-&gt;get_height(), t);
+                    20 + yoff[vminfo.tt] + (vminfo.height-480)/2 + i*(f-&gt;get_height() + ygap[vminfo.tt]), t);
         }
     }
     

Modified: trunk/src/gui/LPGroupConfig.cc
===================================================================
--- trunk/src/gui/LPGroupConfig.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LPGroupConfig.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -223,8 +223,10 @@
     }
     
     void LPGroupConfig::draw_background(ecl::GC &amp;gc) {
+        const video::VMInfo *vminfo = video::GetInfo();
+
         video::SetCaption((&quot;Enigma - Level Pack Group Configuration&quot;));
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
     }
     
 

Modified: trunk/src/gui/LevelInspector.cc
===================================================================
--- trunk/src/gui/LevelInspector.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelInspector.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -573,7 +573,7 @@
         const video::VMInfo *vminfo = video::GetInfo();
         video::SetCaption((std::string(&quot;Enigma - Level &quot;) + 
             (isDeveloperMode ? &quot;Developer &quot; : &quot;&quot;) + &quot;Inspector&quot;).c_str());
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
         blit(gc, vminfo-&gt;width-vminfo-&gt;thumbw-10-hmargin, vmargin, previewImage);
         Surface *img_hard = enigma::GetImage(&quot;completed&quot;);
         if (withEasy) {

Modified: trunk/src/gui/LevelMenu.cc
===================================================================
--- trunk/src/gui/LevelMenu.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelMenu.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -40,22 +40,6 @@
 namespace enigma { namespace gui {
 /* -------------------- Level Menu -------------------- */
     
-    struct LevelMenuConfig {
-        int buttonw, ibuttonw, buttonh;
-        int lbuttonw, lbuttonh;
-        ecl::Rect previewarea;
-        int thumbsy;                // y coordinate of thumbnail window
-        int leftborder;
-    
-        LevelMenuConfig (const ecl::Rect &amp;screen)
-        : buttonw (140), ibuttonw (90), buttonh (35),
-          lbuttonw (140), lbuttonh (100),
-          previewarea (10, 60, screen.w-50, screen.h-130),
-          thumbsy (60),
-          leftborder (10)
-        {}
-    };
-    
     LevelMenu::LevelMenu()
     : but_advancemode (new AdvanceModeButton),
       but_next       (new ImageButton(&quot;ic-next&quot;, &quot;ic-next1&quot;, this)),
@@ -68,42 +52,75 @@
       lbl_levelinfo  (new Label(&quot;&quot;, HALIGN_LEFT)),
       shown_text_ttl(-1.0), main_quit (false)
     {
+        static struct SpacingConfig {
+            int hmargin_info, vmargin, vgap_info, vsize_info;
+            int hmargin_prev, hgap_prev_nav, vgap_info_prev, vgap_prev_but;
+            int hsize_nav, hmargin_nav, vsize_nav, vgap_info_nav, vgap_nav_nav, vgap_nav1_nav2;
+            int hsize_button_small, hsize_button_large, hgap_button, vsize_button, vmargin_bottom;
+        } param[] = {
+            {  // VTS_32 (640x480)
+                5, 10, 20, 28,
+                10, 10, 10, 10,
+                20, 10, 50, 20, 10, 90,
+                90, 140, 10, 35, 15
+            },
+            {  // VTS_40 (800x600)
+                5, 10, 20, 28,
+                10, 10, 10, 10,                
+                20, 10, 50, 20, 10, 120,
+                90, 140, 10, 35, 15
+            },
+            {  // VTS_48 (960x720)  VM_1024x768
+                5, 10, 20, 28,
+                10, 10, 10, 10,                
+                20, 10, 50, 20, 10, 120,
+                90, 140, 10, 35, 15
+            },
+            {  // VTS_64 (1280x960)
+                15, 15, 25, 28,
+                15, 25, 15, 15,
+                20, 15, 50, 40, 10, 120,                
+                90, 140, 10, 35, 15
+            }
+        };
+
+        const video::VMInfo &amp;vminfo = *video::GetInfo();
+        video::VideoModes vm = vminfo.videomode;
+        video::VideoTileType vtt = vminfo.tt;
+        
+        int preview_y = param[vtt].vmargin + 2*param[vtt].vgap_info + param[vtt].vgap_info_prev;
+        ecl::Rect previewarea(param[vtt].hmargin_prev, preview_y,
+                vminfo.width - param[vtt].hmargin_nav - param[vtt].hsize_nav - param[vtt].hgap_prev_nav, 
+                vminfo.height - preview_y - param[vtt].vgap_prev_but - param[vtt].vsize_button - param[vtt].vmargin_bottom);
+        
         HList *hl, *hll, *hlr ;
     
-        const video::VMInfo &amp;vminfo = *video::GetInfo();
-    
-    
-        // Levelmenu configuration
-        const int Y2 = 10;          // y position for information area
-        const int Y3 = vminfo.height-50; // y position for bottom button row
-        LevelMenuConfig c (Rect (0, 0, vminfo.width, vminfo.height));
-    
         but_difficulty-&gt;set_listener (this);
     
-    
         // Create buttons
         hll = new HList;
-        hll-&gt;set_spacing (10);
+        hll-&gt;set_spacing (param[vtt].hgap_button);
         hll-&gt;set_alignment (HALIGN_CENTER, VALIGN_TOP);
-        hll-&gt;set_default_size (c.ibuttonw, c.buttonh);
+        hll-&gt;set_default_size (param[vtt].hsize_button_small, param[vtt].vsize_button);
         hll-&gt;add_back (but_advancemode);
         hll-&gt;add_back (but_next);
         hll-&gt;add_back (but_difficulty);
         
         hlr = new HList;
-        hlr-&gt;set_spacing (10);
+        hlr-&gt;set_spacing (param[vtt].hgap_button);
         hlr-&gt;set_alignment (HALIGN_CENTER, VALIGN_TOP);
-        hlr-&gt;set_default_size (c.buttonw, c.buttonh);
+        hlr-&gt;set_default_size (param[vtt].hsize_button_large, param[vtt].vsize_button);
         hlr-&gt;add_back (but_levelpack);
         hlr-&gt;add_back (but_back);
         
         hl = new HList;
         hl-&gt;set_spacing (10);
         hl-&gt;set_alignment (HALIGN_CENTER, VALIGN_TOP);
-        hl-&gt;set_default_size (2*c.buttonw + 10, c.buttonh);
+        hl-&gt;set_default_size (2*param[vtt].hsize_button_large + param[vtt].hgap_button, param[vtt].vsize_button);
         hl-&gt;add_back (hll);
         hl-&gt;add_back (hlr);
-        this-&gt;add (hl, Rect(c.leftborder, Y3, vminfo.width-20, c.buttonh));
+        this-&gt;add (hl, Rect(0, vminfo.height - param[vtt].vsize_button - param[vtt].vmargin_bottom,
+                vminfo.width, param[vtt].vsize_button));
             
         // Add navigation buttons
         pgup     = new ImageButton(&quot;ic-up&quot;, &quot;ic-up1&quot;, this);
@@ -111,32 +128,35 @@
         start    = new ImageButton(&quot;ic-top&quot;, &quot;ic-top1&quot;, this);
         end      = new ImageButton(&quot;ic-bottom&quot;, &quot;ic-bottom1&quot;, this);
     
-        Rect r(vminfo.width-30, c.thumbsy, 20, 50);
-        r.y = c.thumbsy;
+        Rect r(vminfo.width - param[vtt].hmargin_nav - param[vtt].hsize_nav,
+                param[vtt].vmargin + 2*param[vtt].vgap_info + param[vtt].vgap_info_nav,
+                param[vtt].hsize_nav, param[vtt].vsize_nav);
         add (pgup, r);
-        r.y += 60;
+        r.y += param[vtt].vsize_nav + param[vtt].vgap_nav_nav;
         add (pgdown, r);
-        r.y = c.thumbsy + 240;
+        r.y += param[vtt].vsize_nav + param[vtt].vgap_nav1_nav2;
         add (start, r);
-        r.y += 60;
+        r.y += param[vtt].vsize_nav + param[vtt].vgap_nav_nav;
         add (end, r);
     
         // Information area
         hl = new HList;
         hl-&gt;add_back (lbl_levelname, List::EXPAND);
         hl-&gt;add_back (lbl_lpinfo, List::TIGHT);
-        this-&gt;add (hl, Rect (5, Y2, vminfo.width - 10, 28));
+        this-&gt;add (hl, Rect (param[vtt].hmargin_info, param[vtt].vmargin, 
+                vminfo.width - 2*param[vtt].hmargin_info, param[vtt].vsize_info));
     
         hl_info_stat = new HList;
         hl_info_stat-&gt;add_back (lbl_levelinfo, List::EXPAND); //Rect (c.leftborder, Y2+20,305, 28));
         hl_info_stat-&gt;add_back (lbl_statistics, List::TIGHT);
-        this-&gt;add (hl_info_stat, Rect (5, Y2+20, vminfo.width - 10, 28));
+        this-&gt;add (hl_info_stat, Rect (param[vtt].hmargin_info, param[vtt].vmargin + param[vtt].vgap_info, 
+                vminfo.width - 2*param[vtt].hmargin_info, param[vtt].vsize_info));
     
         // Prepare level selection widget
         levelwidget = new LevelWidget();
         levelwidget-&gt;set_listener(this);
-        levelwidget-&gt;realize (c.previewarea);
-        levelwidget-&gt;set_area (c.previewarea);
+        levelwidget-&gt;realize (previewarea);
+        levelwidget-&gt;set_area (previewarea);
     
         this-&gt;add (levelwidget);
         
@@ -392,10 +412,12 @@
     
     void LevelMenu::draw_background(ecl::GC &amp;gc) 
     {
+        const video::VMInfo *vminfo = video::GetInfo();
+        
         video::SetCaption((&quot;Enigma - Level Menu&quot;));
         sound::PlayMusic (options::GetString(&quot;MenuMusicFile&quot;));
     
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
     }
 
     void LevelMenu::next_unsolved() 

Modified: trunk/src/gui/LevelPackComposer.cc
===================================================================
--- trunk/src/gui/LevelPackComposer.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelPackComposer.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -378,10 +378,11 @@
     }
     
     void LevelPackComposer::draw_background(ecl::GC &amp;gc) {
+        const video::VMInfo *vminfo = video::GetInfo();
+        
         video::SetCaption((&quot;Enigma - Level Pack Composer&quot;));
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
         if (isModified)
-    
             blit(gc, 0,0, enigma::GetImage(&quot;changed&quot;));
     }
     

Modified: trunk/src/gui/LevelPackConfig.cc
===================================================================
--- trunk/src/gui/LevelPackConfig.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelPackConfig.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -532,8 +532,10 @@
     }
     
     void LevelPackConfig::draw_background(ecl::GC &amp;gc) {
+        const video::VMInfo *vminfo = video::GetInfo();
+
         video::SetCaption((&quot;Enigma - Level Pack Configuration&quot;));
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
     }
     
 

Modified: trunk/src/gui/LevelPackMenu.cc
===================================================================
--- trunk/src/gui/LevelPackMenu.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelPackMenu.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -55,6 +55,9 @@
             scrollDown (NULL), isLevelMenuSubmenu (false) {
         const video::VMInfo &amp;vminfo = *video::GetInfo();
         vm = vminfo.videomode;
+        vtt = vminfo.tt;
+        vh = vminfo.area.x;
+        vv = (vminfo.height - vminfo.area.h)/2;
        
         // Create buttons - positioning identical to Levelmenu
         but_new = new StaticTextButton(N_(&quot;New Group&quot;), this);
@@ -79,26 +82,26 @@
             int packcolumns, rows;
             int vmargin, vrow_row;
             int hmargin, hgroup_pack, hscrollbutton, hscroll_pack, hpack_pack;
-        } param[video::VM_COUNT] = {
-            {  // VM_640x480
+        } param[] = {
+            {  // VTS_32 (640x480)
                 2, 9,
                 15, 10,
                 20, 36, 22, 10, 20
             },
-            {  // VM_640x512
-                2, 9,
-                15, 10,
-                20, 36, 22, 10, 20
-            },
-            {  // VM_800x600
+            {  // VTS_40 (800x600)
                 3, 11,
                 15, 13,
                 15, 36, 22, 10, 15
             },
-            {  // VM_1024x768
-                4, 15,
+            {  // VTS_48 (960x720)  VM_1024x768
+                3, 14,
                 15, 10,
-                30, 36, 22, 12, 20
+                70, 56, 22, 20, 20
+            },
+            {  // VTS_64 (1280x960)
+                5, 17,
+                25, 14,
+                60, 40, 22, 18, 20
             }
         };
         
@@ -137,7 +140,7 @@
         std::string curGroupName = lev::Index::getCurrentGroup();
         bool needUpScroll = false;
         bool needDownScroll = false;
-        int numDisplayGroups = param[vm].rows;
+        int numDisplayGroups = param[vtt].rows;
         int usedGroupRows = (groupCount &gt; numDisplayGroups) ? numDisplayGroups : groupCount;
         
         // correct scroll attempts and screen resolution changes
@@ -175,7 +178,7 @@
         
         
         groupsVList = new VList; 
-        groupsVList-&gt;set_spacing(param[vm].vrow_row);
+        groupsVList-&gt;set_spacing(param[vtt].vrow_row);
         groupsVList-&gt;set_alignment(HALIGN_LEFT, VALIGN_CENTER);
         groupsVList-&gt;set_default_size(160, 35);
         
@@ -194,9 +197,9 @@
             }
         }
 
-        this-&gt;add(groupsVList, Rect(param[vm].hmargin, param[vm].vmargin, 
-                160, param[vm].rows * 35 + 
-                (param[vm].rows - 1) * param[vm].vrow_row));
+        this-&gt;add(groupsVList, Rect(param[vtt].hmargin + vh, param[vtt].vmargin + vv, 
+                160, param[vtt].rows * 35 + 
+                (param[vtt].rows - 1) * param[vtt].vrow_row));
         
         lastGroupName = curGroupName;
         std::vector&lt;lev::Index *&gt; * group = lev::Index::getGroup(curGroupName);
@@ -210,35 +213,35 @@
         
         if (selectedColumn != INDEX_GROUP_COLUMN_UNKNOWN || 
                 groupLastSelectedIndex.find(curGroupName) == groupLastSelectedIndex.end()) {
-            colCurrentIndex = checkColumn(param[vm].rows, param[vm].packcolumns,
+            colCurrentIndex = checkColumn(param[vtt].rows, param[vtt].packcolumns,
                     packCount, posCurrentIndex, selectedColumn);
-            nextPack = (posCurrentIndex / param[vm].rows - colCurrentIndex) * param[vm].rows;
+            nextPack = (posCurrentIndex / param[vtt].rows - colCurrentIndex) * param[vtt].rows;
         } else {
             // the user selected a new level pack and the column was not yet
             // calculated: we try to keep the display unchanged in respect of
             // of the last selected pack and if necessary scroll minimum amount
             // of columns 
             int posLastIndex = getIndexPosition(group,groupLastSelectedIndex[curGroupName]);
-            int colLastIndex = checkColumn(param[vm].rows, param[vm].packcolumns,
+            int colLastIndex = checkColumn(param[vtt].rows, param[vtt].packcolumns,
                     packCount, posLastIndex, groupLastSelectedColumn[curGroupName]);
-            nextPack = (posLastIndex / param[vm].rows - colLastIndex) * param[vm].rows;
+            nextPack = (posLastIndex / param[vtt].rows - colLastIndex) * param[vtt].rows;
             if (posCurrentIndex &lt; nextPack) {
                 // current index would be left of display - we need to scroll left
-                nextPack -= (((nextPack - posCurrentIndex - 1)/param[vm].rows) + 1) *
-                        param[vm].rows;
+                nextPack -= (((nextPack - posCurrentIndex - 1)/param[vtt].rows) + 1) *
+                        param[vtt].rows;
                 colCurrentIndex = 0;
-            } else if (posCurrentIndex &lt; nextPack + param[vm].rows * param[vm].packcolumns) {
+            } else if (posCurrentIndex &lt; nextPack + param[vtt].rows * param[vtt].packcolumns) {
                 // current index is still visible - keep nextPack
-                colCurrentIndex = (posCurrentIndex - nextPack) / param[vm].rows;
+                colCurrentIndex = (posCurrentIndex - nextPack) / param[vtt].rows;
             } else {
                 // current index would be right of display - we need to scroll right
-                nextPack += (((posCurrentIndex - nextPack)/param[vm].rows) - 
-                        (param[vm].packcolumns - 1)) * param[vm].rows;
-                colCurrentIndex = param[vm].packcolumns - 1;                
+                nextPack += (((posCurrentIndex - nextPack)/param[vtt].rows) - 
+                        (param[vtt].packcolumns - 1)) * param[vtt].rows;
+                colCurrentIndex = param[vtt].packcolumns - 1;                
             }
         }
         
-        bool needRightScroll = packCount &gt; nextPack + param[vm].rows * param[vm].packcolumns;
+        bool needRightScroll = packCount &gt; nextPack + param[vtt].rows * param[vtt].packcolumns;
         bool needLeftScroll = nextPack &gt; 0;
 
         lev::Index::setGroupSelectedColumn(curGroupName, colCurrentIndex);
@@ -246,19 +249,19 @@
         groupLastSelectedColumn[curGroupName] = colCurrentIndex;
         
         packsHList = new HList; 
-        packsHList-&gt;set_spacing(param[vm].hpack_pack);
+        packsHList-&gt;set_spacing(param[vtt].hpack_pack);
         packsHList-&gt;set_alignment(HALIGN_CENTER, VALIGN_TOP);
-        packsHList-&gt;set_default_size(160, param[vm].rows*35 + 
-                (param[vm].rows - 1) * param[vm].vrow_row);
+        packsHList-&gt;set_default_size(160, param[vtt].rows*35 + 
+                (param[vtt].rows - 1) * param[vtt].vrow_row);
         
-        for (int col = 0; col &lt; param[vm].packcolumns; col++) {
+        for (int col = 0; col &lt; param[vtt].packcolumns; col++) {
             if (packCount - nextPack &gt; 0) {
                 VList * pl = new VList;
-                pl-&gt;set_spacing (param[vm].vrow_row);
+                pl-&gt;set_spacing (param[vtt].vrow_row);
                 // first column is centered - if it is full it is like top alignment:
                 pl-&gt;set_alignment (HALIGN_LEFT, col == 0 ? VALIGN_CENTER : VALIGN_TOP);
                 pl-&gt;set_default_size (160, 35);
-                for (int row = 0; row &lt; param[vm].rows; row++) {
+                for (int row = 0; row &lt; param[vtt].rows; row++) {
                     if (nextPack &lt; packCount) {
                         lev::Index *ind = (*group)[nextPack];
                         TextButton * button = new UntranslatedStaticTextButton(ind-&gt;getName(), this);
@@ -273,29 +276,29 @@
                 break;
         }
 
-        this-&gt;add(packsHList, Rect(param[vm].hmargin + 160 + param[vm].hgroup_pack +
-                param[vm].hscrollbutton + param[vm].hscroll_pack, 
-                param[vm].vmargin, 
-                param[vm].packcolumns * 160 + (param[vm].packcolumns - 1) * 
-                param[vm].hpack_pack, 
-                param[vm].rows * 35 + 
-                (param[vm].rows - 1) * param[vm].vrow_row));
+        this-&gt;add(packsHList, Rect(param[vtt].hmargin + vh + 160 + param[vtt].hgroup_pack +
+                param[vtt].hscrollbutton + param[vtt].hscroll_pack, 
+                param[vtt].vmargin + vv, 
+                param[vtt].packcolumns * 160 + (param[vtt].packcolumns - 1) * 
+                param[vtt].hpack_pack, 
+                param[vtt].rows * 35 + 
+                (param[vtt].rows - 1) * param[vtt].vrow_row));
         
         if (needLeftScroll) {
             scrollLeft = new ImageButton(&quot;ic-left&quot;, &quot;ic-left1&quot;, this);
-            this-&gt;add(scrollLeft, Rect(param[vm].hmargin + 160 + param[vm].hgroup_pack,
-                    param[vm].vmargin + param[vm].rows / 2 * (35 + param[vm].vrow_row),
-                    param[vm].hscrollbutton, 35));
+            this-&gt;add(scrollLeft, Rect(param[vtt].hmargin + vh + 160 + param[vtt].hgroup_pack,
+                    param[vtt].vmargin + vv + param[vtt].rows / 2 * (35 + param[vtt].vrow_row),
+                    param[vtt].hscrollbutton, 35));
         }
                 
         if (needRightScroll) {
             scrollRight = new ImageButton(&quot;ic-right&quot;, &quot;ic-right1&quot;, this);
-            this-&gt;add(scrollRight, Rect(param[vm].hmargin + 160 + param[vm].hgroup_pack +
-                    param[vm].hscrollbutton + 2 * param[vm].hscroll_pack +
-                    param[vm].packcolumns * 160 + (param[vm].packcolumns - 1) * 
-                    param[vm].hpack_pack,
-                    param[vm].vmargin + param[vm].rows / 2 * (35 + param[vm].vrow_row),
-                    param[vm].hscrollbutton, 35));
+            this-&gt;add(scrollRight, Rect(param[vtt].hmargin + vh + 160 + param[vtt].hgroup_pack +
+                    param[vtt].hscrollbutton + 2 * param[vtt].hscroll_pack +
+                    param[vtt].packcolumns * 160 + (param[vtt].packcolumns - 1) * 
+                    param[vtt].hpack_pack,
+                    param[vtt].vmargin + vv+ param[vtt].rows / 2 * (35 + param[vtt].vrow_row),
+                    param[vtt].hscrollbutton, 35));
         }
     }
     
@@ -464,8 +467,9 @@
     }
     
     void LevelPackMenu::draw_background(ecl::GC &amp;gc) {
+        const video::VMInfo *vminfo = video::GetInfo();
         video::SetCaption((&quot;Enigma - Level Pack Menu&quot;));
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
     }
     
     int LevelPackMenu::getGroupPosition(std::vector&lt;std::string&gt; * groups, std::string groupName) {

Modified: trunk/src/gui/LevelPackMenu.hh
===================================================================
--- trunk/src/gui/LevelPackMenu.hh	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelPackMenu.hh	2007-08-16 21:29:50 UTC (rev 838)
@@ -60,6 +60,8 @@
         static int firstDisplayedGroup;
         
         video::VideoModes vm;
+        video::VideoTileType vtt;
+        int  vh, vv;   // h and v margins due to fullscreen margins
         std::vector&lt;TextButton *&gt; packButtons;
         std::vector&lt;TextButton *&gt; groupButtons;
 

Modified: trunk/src/gui/LevelPreviewCache.cc
===================================================================
--- trunk/src/gui/LevelPreviewCache.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelPreviewCache.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -72,6 +72,7 @@
             cachedIndex = lev::Index::getCurrentIndex();
         }
             
+        const video::VMInfo &amp;vminfo = *video::GetInfo();
         std::string previewSubPath = makePreviewPath(levelProxy);
         Surface *surface = 0;
         
@@ -80,8 +81,8 @@
         std::auto_ptr&lt;std::istream&gt; isptr;
         ByteVec imageData;
         if(levelProxy-&gt;getNormPathType() == lev::Proxy::pt_resource &amp;&amp; 
-                app.resourceFS-&gt;findFile (&quot;levels/&quot; + levelProxy-&gt;getNormLevelPath() + &quot;.png&quot;, 
-                        absLevelPath, isptr)) {
+                app.resourceFS-&gt;findFile (&quot;levels/&quot; + levelProxy-&gt;getNormLevelPath() 
+                        + vminfo.thumbsext + &quot;.png&quot;, absLevelPath, isptr)) {
             // load plain image file or zipped image
             if (isptr.get() != NULL) {
                 // zipped file
@@ -145,7 +146,8 @@
     }
     
     std::string LevelPreviewCache::makePreviewPath(lev::Proxy *levelProxy) {
-        return &quot;thumbs/&quot; +
+        const video::VMInfo &amp;vminfo = *video::GetInfo();
+        return &quot;thumbs&quot; + vminfo.thumbsext + &quot;/&quot; +
                 levelProxy-&gt;getLocalSubstitutionLevelPath() +
                 ecl::strf(&quot;#%d&quot;, levelProxy-&gt;getReleaseVersion()) + &quot;.png&quot;;
     }
@@ -162,7 +164,9 @@
     }
     
     void LevelPreviewCache::makeSystemPreview(lev::Proxy *levelProxy, std::string systemDataPath) {
-        std::string savePath = systemDataPath + &quot;/levels/&quot; + levelProxy-&gt;getNormLevelPath() + &quot;.png&quot;;
+        const video::VMInfo &amp;vminfo = *video::GetInfo();
+        std::string savePath = systemDataPath + &quot;/levels/&quot; + levelProxy-&gt;getNormLevelPath() 
+                + vminfo.thumbsext + &quot;.png&quot;;
         // auto-create the directory if necessary -- on an installed Enigma
         // distribution this is of course unnecessary, but you start Enigma
         // without prior installation. This is useful to get a directory with
@@ -174,5 +178,5 @@
         ecl::Surface * s = newPreview(levelProxy);
         if (s != NULL)
             ecl::SavePNG(s, savePath);
-    }
+    }
 }} // namespace enigma::gui

Modified: trunk/src/gui/LevelWidget.cc
===================================================================
--- trunk/src/gui/LevelWidget.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/LevelWidget.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -37,7 +37,7 @@
 using namespace std;
 
 
-namespace enigma { namespace gui {    
+namespace enigma { namespace gui {
     /* -------------------- LevelWidget -------------------- */
     
     LevelWidget::LevelWidget(bool withScoreIcons, bool withEditBorder) : 
@@ -47,7 +47,7 @@
     {
         const video::VMInfo &amp;vminfo = *video::GetInfo();
     
-        buttonw = vminfo.thumbw + 20;
+        buttonw = vminfo.thumbw + 27;  // min should be +30 for all modes but 640x480
         buttonh = vminfo.thumbh + 28;
         curIndex = lev::Index::getCurrentIndex();
         iselected = curIndex-&gt;getCurrentPosition();

Modified: trunk/src/gui/MainMenu.cc
===================================================================
--- trunk/src/gui/MainMenu.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/MainMenu.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -43,8 +43,6 @@
 namespace enigma { namespace gui {
 /* -------------------- Helper routines -------------------- */
     
-//    namespace
-//    {
     /*! Change the video mode.  Because this opens a new screen with a
       new resolution, the display engine must be re-initialized to
       load the appropriate models. */
@@ -57,9 +55,8 @@
         display::Shutdown();
         display::Init();
     }
-//    }
     
-    
+
     /* -------------------- NetworkMenu -------------------- */
     
     NetworkMenu::NetworkMenu ()
@@ -103,8 +100,7 @@
     {
     }
     
-    
-    
+
     /* -------------------- Main menu -------------------- */
     static const char *credit_text[] = {
         N_(&quot;Main developers of the 1.0 release:&quot;),
@@ -215,13 +211,14 @@
     {
         const video::VMInfo *vminfo = video::GetInfo();
     
-        BuildVList b(this, Rect((vminfo-&gt;width - 150)/2,150,150,40), 5);
+        int y[] = {150, 170, 200, 200};
+        BuildVList b(this, Rect((vminfo-&gt;width - 150)/2, y[vminfo-&gt;tt], 150, 40), 5);
         m_startgame = b.add(new StaticTextButton(N_(&quot;Start Game&quot;), this));
         m_levelpack = b.add(new StaticTextButton(N_(&quot;Level Pack&quot;), this));
-    #ifdef ENABLE_EXPERIMENTAL
+#ifdef ENABLE_EXPERIMENTAL
         m_netgame   = b.add (new StaticTextButton (N_(&quot;Network Game&quot;), this));
         leveled     = b.add(new StaticTextButton(N_(&quot;Editor&quot;), this));
-    #endif
+#endif
         options     = b.add(new StaticTextButton(N_(&quot;Options&quot;), this));
         credits     = b.add(new StaticTextButton(N_(&quot;Credits&quot;), this));
         quit        = b.add(new StaticTextButton(N_(&quot;Quit&quot;), this));
@@ -234,13 +231,13 @@
         video::SetCaption ((&quot;Enigma - Main Menu&quot;));
         sound::PlayMusic (options::GetString(&quot;MenuMusicFile&quot;));
     
-        blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
     
         Font *f = enigma::GetFont(&quot;levelmenu&quot;);
         Surface * logo(enigma::GetImage(&quot;enigma_logo3&quot;));
         int x0=(vminfo-&gt;width - logo-&gt;width())/2;
-        int y0=30;
-        blit(gc, x0, y0, logo);
+        int y0[] = {30, 40, 50, 60};
+        blit(gc, x0, y0[vminfo-&gt;tt], logo);
         f-&gt;render (gc, 5, vminfo-&gt;height - 20, app.getVersionInfo().c_str());
     }
     
@@ -292,9 +289,8 @@
     
     void MainMenu::tick(double /* dtime */) 
     {
-        bool option_fullscreen = options::GetInt (&quot;FullScreen&quot;) != 0;
-        if (options::GetInt (&quot;VideoMode&quot;) != video::GetVideoMode()
-            || option_fullscreen != video::IsFullScreen())
+        if (app.prefs-&gt;getInt(&quot;VideoMode1.1&quot;) != video::GetVideoMode()
+                || app.prefs-&gt;getBool(&quot;FullScreen1.1&quot;) != video::IsFullScreen())
         {
             ChangeVideoMode();
             clear();

Modified: trunk/src/gui/OptionsMenu.cc
===================================================================
--- trunk/src/gui/OptionsMenu.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/OptionsMenu.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -126,11 +126,11 @@
     class VideoModeButton : public TextButton {
 
         video::VideoModes get_mode() const {
-            int mode = Clamp(options::GetInt(&quot;VideoMode&quot;), 0, int(video::VM_COUNT));
+            int mode = Clamp(app.prefs-&gt;getInt(&quot;VideoMode1.1&quot;), 0, int(video::VM_COUNT));
             return static_cast&lt;video::VideoModes&gt;(mode);
         }
         string get_text() const {
-            return GetInfo(get_mode())-&gt;name;
+            return video::GetInfo(get_mode())-&gt;name;
         }
         void on_action(Widget *) {
             int mode = get_mode();
@@ -141,9 +141,9 @@
                 if (mode &gt;= video::VM_COUNT) 
                     mode = 0;
 
-                const video::VMInfo *vminfo = GetInfo (static_cast&lt;video::VideoModes&gt;(mode));
+                const video::VMInfo *vminfo = video::GetInfo (static_cast&lt;video::VideoModes&gt;(mode));
                 if (vminfo-&gt;available) {
-                    options::SetOption(&quot;VideoMode&quot;, mode);
+                    app.prefs-&gt;setProperty(&quot;VideoMode1.1&quot;, mode);
                     invalidate();
                     break;
                 }
@@ -153,7 +153,7 @@
         VideoModeButton() : TextButton(this) { }
     };
 
-
+
     /* -------------------- SoundSetButton -------------------- */
     
     SoundSetButton::SoundSetButton() : ValueButton(0, 1) {
@@ -174,7 +174,7 @@
         return _(sound::GetOptionSoundSetText(value).c_str());
     }
 
-    
+
     /* -------------------- StereoButton -------------------- */
     
     StereoButton::StereoButton() : ValueButton(-1, 1)
@@ -211,11 +211,11 @@
         return string();
     }
     
-    
+
     /* -------------------- FullscreenButton -------------------- */
     
     FullscreenButton::FullscreenButton()
-        : BoolOptionButton(&quot;FullScreen&quot;, N_(&quot;Yes&quot;), N_(&quot;No&quot;), this)
+        : BoolOptionButton(&quot;FullScreen1.1&quot;, N_(&quot;Yes&quot;), N_(&quot;No&quot;), this)
     {
     }
     
@@ -309,8 +309,7 @@
         return ecl::strf (&quot;%d&quot;, value-5);
     }
     
-    
-    
+
     /* -------------------- Options Menu -------------------- */
     
     OptionsMenu::OptionsMenu(ecl::Surface *background_)
@@ -458,9 +457,10 @@
     
     void OptionsMenu::draw_background(ecl::GC &amp;gc)
     {
+        const video::VMInfo *vminfo = video::GetInfo();
         video::SetCaption((&quot;Enigma - Options Menu&quot;));
     //     blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;));
-        blit(gc, 0,0, background);
+        blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, background);
     }
     
 /* -------------------- Functions -------------------- */

Modified: trunk/src/gui/ScreenshotViewer.cc
===================================================================
--- trunk/src/gui/ScreenshotViewer.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/gui/ScreenshotViewer.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -84,12 +84,12 @@
     }
     
     void ScreenshotViewer::draw_background (ecl::GC &amp;gc) {
+        const video::VMInfo *vminfo = video::GetInfo();
         std::string filename = &quot;screenshots/&quot; + 
                 levelProxy-&gt;getLocalSubstitutionLevelPath() + 
                 (shotNumber &gt; 0 ? ecl::strf(&quot;#%d&quot;, shotNumber) : &quot;&quot;) + &quot;.png&quot;;
         std::string fullPath;
         if (app.resourceFS-&gt;findFile(filename, fullPath)) {
-            const video::VMInfo *vminfo = video::GetInfo();
             ecl::Surface * image = ecl::LoadImage(fullPath.c_str());
             if (image-&gt;width() == vminfo-&gt;width &amp;&amp; image-&gt;height() == vminfo-&gt;height) {
                 blit(gc, 0,0, image);
@@ -100,7 +100,7 @@
             }
             delete image;
         } else {
-            blit(gc, 0,0, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
+            blit(gc, vminfo-&gt;mbg_offsetx, vminfo-&gt;mbg_offsety, enigma::GetImage(&quot;menu_bg&quot;, &quot;.jpg&quot;));
             Font *f = enigma::GetFont(&quot;menufont&quot;);
             f-&gt;render (gc, 30, 60, _(&quot;No screenshot available:&quot;));
             f-&gt;render (gc, 30, 100, filename.c_str());

Modified: trunk/src/main.cc
===================================================================
--- trunk/src/main.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/main.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -285,10 +285,10 @@
     prefs = PreferenceManager::instance();
     
     if (ap.force_window) {
-        options::SetOption(&quot;FullScreen&quot;, false);
+        app.prefs-&gt;setProperty(&quot;FullScreen1.1&quot;, false);
     }
     if (isMakePreviews) {
-        options::SetOption(&quot;VideoMode&quot;, 0);
+        app.prefs-&gt;setProperty(&quot;VideoMode1.1&quot;, 0);  // we will not save the prefs!
     }
 
     // initialize user data paths -- needs preferences, system datapaths
@@ -400,11 +400,14 @@
         scr-&gt;flush_updates();
         
         int i = 0;
-        for (it = proxies.begin(); it != proxies.end(); it++, i++) {
-            gui::LevelPreviewCache::makeSystemPreview(*it, systemAppDataPath);
-            vline(gc, 170 + i*300 / size, 280, 20);
-            scr-&gt;update_all ();
-            scr-&gt;flush_updates();
+        for (int m=0; m&lt;2; m++) {
+            for (it = proxies.begin(); it != proxies.end(); it++, i++) {
+                gui::LevelPreviewCache::makeSystemPreview(*it, systemAppDataPath);
+                vline(gc, 170 + i*150 / size, 280, 20);
+                scr-&gt;update_all ();
+                scr-&gt;flush_updates();
+            }
+            video::SetThumbInfo(160, 104, &quot;-160x104&quot;);
         }
         return;
     }

Modified: trunk/src/main.hh
===================================================================
--- trunk/src/main.hh	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/main.hh	2007-08-16 21:29:50 UTC (rev 838)
@@ -68,7 +68,7 @@
         void init(int argc, char **argv);
         void shutdown();
         std::string getVersionInfo();
-	double getEnigmaVersion();
+        double getEnigmaVersion();
         void setLanguage(std::string newLanguage);
         /**
          * Define a new user path. Files stored to user path use the new path

Modified: trunk/src/video.cc
===================================================================
--- trunk/src/video.cc	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/video.cc	2007-08-16 21:29:50 UTC (rev 838)
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2002,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -104,7 +105,6 @@
     };
 }
 
-
 /* -------------------- Video Engine -------------------- */
 
 Video_SDL::Video_SDL()
@@ -187,7 +187,6 @@
 }
 
 
-
 /* -------------------- MouseCursor -------------------- */
 
 MouseCursor::MouseCursor ()
@@ -300,7 +299,6 @@
     }
 }
 
-
 /* -------------------- Local Variables -------------------- */
 namespace
 {
@@ -311,62 +309,139 @@
     /*! List of available video modes. */
     video::VMInfo video_modes[] = {
         { 
-            VM_640x480, 640, 480, 32, &quot;640x480&quot;, 
-            &quot;models-32.lua&quot;, &quot;gfx32/&quot;,
-            120, 78, &quot;thumbs32&quot;,     // thumbnail size/directory
-            Rect (0, 0, 640, 416),   // game area
-            Rect (0, 416, 640, 64),  // statusbar area
-            Rect (10, 425, 117, 43), // time area
-            Rect (100, 425, 30, 43), // moves area
-            Rect (152, 433, 490, 52),// inventory area
-            Rect (150, 434, 475, 35),// text area
-            VM_None, true,
+            VM_640x480, 640, 480,            // id, w, h
+            32, VTS_32,                      // tilesize, tiletype
+            &quot;640x480&quot;, &quot;640x480&quot;, false,     // name, fsname, fs only
+            &quot;models-32.lua&quot;, &quot;gfx32/&quot;,       // initscript, dir
+            Rect (0, 0, 640, 480),           // display area
+            0, 0,                            // menu background image offsets 
+            120, 78, &quot;&quot;,                     // thumbnail size/extension
+            Rect (0, 0, 640, 416),           // game area
+            Rect (0, 416, 640, 64),          // statusbar area
+            Rect (10, 425, 117, 43),         // time area
+            Rect (100, 425, 30, 43),         // moves area
+            Rect (152, 433, 490, 52),        // inventory area
+            Rect (150, 434, 475, 35),        // text area
+            VM_None, true,                   // fallback, available
         },
         { 
-            VM_640x512, 640, 512, 32, &quot;640x512&quot;, 
-            &quot;models-32.lua&quot;, &quot;gfx32/&quot;,
-            120, 78, &quot;thumbs32&quot;,     // thumbnail size/directory
-            Rect (0, 0, 640, 416),   // game area
-            Rect (0, 416, 640, 64),  // statusbar area
-            Rect (15, 420, 110, 40), // time area
-            Rect (100, 420, 30, 40), // moves area
-            Rect (152, 433, 490, 52),// inventory area
-            Rect (150, 434, 475, 35), // text area
-            VM_640x480, 
-            false,              // 640x512 is deprecated!
+            VM_640x512, 640, 512,            // id, w, h
+            32, VTS_32,                      // tilesize, tiletype
+            &quot;640x512&quot;, &quot;640x512&quot;, false,     // name, fsname, fs only
+            &quot;models-32.lua&quot;, &quot;gfx32/&quot;,       // initscript, dir
+            Rect (0, 0, 640, 480),           // display area
+            0, 0,                            // menu background image offsets 
+            120, 78, &quot;&quot;,                     // thumbnail size/extension
+            Rect (0, 0, 640, 416),           // game area
+            Rect (0, 416, 640, 64),          // statusbar area
+            Rect (15, 420, 110, 40),         // time area
+            Rect (100, 420, 30, 40),         // moves area
+            Rect (152, 433, 490, 52),        // inventory area
+            Rect (150, 434, 475, 35),        // text area
+            VM_640x480, false,               // 640x512 is deprecated!
         },
         { 
-            VM_800x600, 800, 600, 40, &quot;800x600&quot;, 
-            &quot;models-40.lua&quot;, &quot;gfx40/&quot;,
-//            160, 104, &quot;thumbs40&quot;,    // thumbnail size/directory
-            120, 78, &quot;thumbs32&quot;,
-            Rect (0, 0, 800, 520),   // game area
-            Rect (0, 520, 800, 80),  // statusbar area
-            Rect (15, 540, 140, 40), // time area
-            Rect (125, 540, 30, 40), // moves area
-            Rect (192, 539, 610, 46),// inventory area
-            Rect (185, 545, 600, 39), // text area
-            VM_640x480, true,
+            VM_800x600, 800, 600,            // id, w, h
+            40, VTS_40,                      // tilesize, tiletype
+            &quot;800x600&quot;, &quot;800x600&quot;, false,     // name, fsname, fs only
+            &quot;models-40.lua&quot;, &quot;gfx40/&quot;,       // initscript, dir
+            Rect (0, 0, 800, 600),           // display area
+            0, 0,                            // menu background image offsets 
+            120, 78, &quot;&quot;,                     // thumbnail size/extension
+            Rect (0, 0, 800, 520),           // game area
+            Rect (0, 520, 800, 80),          // statusbar area
+            Rect (15, 540, 140, 40),         // time area
+            Rect (125, 540, 30, 40),         // moves area
+            Rect (192, 539, 610, 46),        // inventory area
+            Rect (185, 545, 600, 39),        // text area
+            VM_640x480, true,                // fallback, available
         },
         { 
-            VM_1024x768, 1024, 768, 48, &quot;1024x768&quot;, 
-            &quot;models-48.lua&quot;, &quot;gfx48/&quot;,
-//            160, 104, &quot;thumbs40&quot;,    // thumbnail size/directory
-            120, 78, &quot;thumbs32&quot;,
-            Rect (32, 0, 960, 624), // game area
-            Rect (32, 624, 960, 96),  // statusbar area
-            Rect (50, 640, 170, 60), // time area
-            Rect (185, 640, 30, 60), // moves area
-            Rect (260, 650, 710, 46),// inventory area
-            Rect (260, 655, 710, 40), // text area
-            VM_640x480, true,
+            VM_1024x768, 1024, 768,          // id, w, h
+            48, VTS_48,                      // tilesize, tiletype
+            &quot;1024x768&quot;, &quot;1024x768&quot;, false,   // name, fsname, fs only
+            &quot;models-48.lua&quot;, &quot;gfx48/&quot;,       // initscript, dir
+            Rect (32, 0, 960, 720),          // display area
+            -128, -96,                       // menu background image offsets 
+            120, 78, &quot;&quot;,                     // thumbnail size/extension
+            Rect (32, 0, 960, 624),          // game area
+            Rect (32, 624, 960, 96),         // statusbar area
+            Rect (50, 640, 170, 60),         // time area
+            Rect (185, 640, 30, 60),         // moves area
+            Rect (260, 650, 710, 46),        // inventory area
+            Rect (260, 655, 710, 40),        // text area
+            VM_640x480, true,                // fallback, available
         },
+        { 
+            VM_960x720, 960, 720,            // id, w, h
+            48, VTS_48,                      // tilesize, tiletype
+            &quot;960x720&quot;, &quot;960x720&quot;, false,     // name, fsname, fs only
+            &quot;models-48.lua&quot;, &quot;gfx48/&quot;,       // initscript, dir
+            Rect (0, 0, 960, 720),           // display area
+            -192, -144,                      // menu background image offsets 
+            120, 78, &quot;&quot;,                     // thumbnail size/extension
+            Rect (0, 0, 960, 624),           // game area
+            Rect (0, 624, 960, 96),          // statusbar area
+            Rect (18, 640, 170, 60),         // time area
+            Rect (153, 640, 30, 60),         // moves area
+            Rect (228, 650, 710, 46),        // inventory area
+            Rect (228, 655, 710, 40),        // text area
+            VM_640x480, true,                // fallback, available
+        },
+        { 
+            VM_960x768, 960, 768,            // id, w, h
+            48, VTS_48,                      // tilesize, tiletype
+            &quot;960x768&quot;, &quot;1280x1024&quot;, true,    // name, fsname, fs only
+            &quot;models-48.lua&quot;, &quot;gfx48/&quot;,       // initscript, dir
+            Rect (0, 0, 960, 720),           // display area
+            -192, -96,                       // menu background image offsets 
+            120, 78, &quot;&quot;,                     // thumbnail size/extension
+            Rect (0, 0, 960, 624),           // game area
+            Rect (0, 624, 960, 96),          // statusbar area
+            Rect (18, 640, 170, 60),         // time area
+            Rect (153, 640, 30, 60),         // moves area
+            Rect (228, 650, 710, 46),        // inventory area
+            Rect (228, 655, 710, 40),        // text area
+            VM_640x480, true,                // fallback, available
+        },
+        { 
+            VM_1152x720, 1152, 720,          // id, w, h
+            48, VTS_48,                      // tilesize, tiletype
+            &quot;1152x720&quot;, &quot;1680x1050&quot;, true,   // name, fsname, fs only
+            &quot;models-48.lua&quot;, &quot;gfx48/&quot;,       // initscript, dir
+            Rect (96, 0, 960, 720),          // display area
+            0, -144,                         // menu background image offsets 
+            120, 78, &quot;&quot;,                     // thumbnail size/extension
+            Rect (96, 0, 960, 624),          // game area
+            Rect (96, 624, 960, 96),         // statusbar area
+            Rect (114, 640, 170, 60),        // time area
+            Rect (249, 640, 30, 60),         // moves area
+            Rect (324, 650, 710, 46),        // inventory area
+            Rect (324, 655, 710, 40),        // text area
+            VM_640x480, true,                // fallback, available
+        },
+        { 
+            VM_1280x960, 1280, 960,          // id, w, h
+            64, VTS_64,                      // tilesize, tiletype
+            &quot;1280x960&quot;, &quot;1280x960&quot;, false,   // name, fsname, fs only
+//            &quot;models-64.lua&quot;, &quot;gfx64/&quot;,       // initscript, dir
+            &quot;models-48.lua&quot;, &quot;gfx48/&quot;,       // initscript, dir
+            Rect (0, 0, 1280, 960),          // display area
+            0, 0,                            // menu background image offsets 
+            160, 104, &quot;-160x104&quot;,            // thumbnail size/extension
+            Rect (0, 0, 1280, 832),          // game area
+            Rect (0, 832, 1280, 128),        // statusbar area
+            Rect (18, 640, 170, 60),         // time area //TODO
+            Rect (153, 640, 30, 60),         // moves area //TODO
+            Rect (228, 650, 710, 46),        // inventory area //TODO
+            Rect (228, 655, 710, 40),        // text area //TODO
+            VM_640x480, false,               // fallback, available
+        },
     };
 
     VideoModes current_video_mode = VM_None;
 }
 
-
 /* -------------------- Auxiliary functions -------------------- */
 
 namespace
@@ -480,6 +555,12 @@
     return GetInfo (current_video_mode);
 }
 
+void video::SetThumbInfo(int width, int height, std::string extension) {
+    video_modes[current_video_mode].thumbw = width;
+    video_modes[current_video_mode].thumbh = height;
+    video_modes[current_video_mode].thumbsext = extension;
+}
+
 bool video::ModeAvailable (VideoModes vm)
 {
     const VMInfo *vminfo = GetInfo (vm);
@@ -492,7 +573,18 @@
 {
     assert (NUMENTRIES(video_modes) == VM_COUNT);
 
-    int vidmode = Clamp (options::GetInt(&quot;VideoMode&quot;), 0, VM_COUNT-1);
+    int vidmode = -1;
+    app.prefs-&gt;getProperty(&quot;VideoMode1.1&quot;, vidmode);
+    if (vidmode == -1) {
+        // initialize from 1.0 mode if never set before
+        vidmode = app.prefs-&gt;getInt(&quot;VideoMode&quot;);
+        app.prefs-&gt;setProperty(&quot;VideoMode1.1&quot;, vidmode);
+        app.prefs-&gt;setProperty(&quot;FullScreen1.1&quot;, app.prefs-&gt;getBool(&quot;FullScreen&quot;));
+    }
+    if (vidmode &gt;= VM_COUNT) {
+        // TODO
+    }
+    vidmode = ecl::Clamp(vidmode, 0, VM_COUNT-1);
     int oldvidmode = vidmode;
 
     video_engine = new Video_SDL();
@@ -504,7 +596,7 @@
         VMInfo *vminfo     = &amp;video_modes[vidmode];
         int     w          = vminfo-&gt;width;
         int     h          = vminfo-&gt;height;
-        bool    fullscreen = options::GetBool(&quot;FullScreen&quot;);
+        bool    fullscreen = app.prefs-&gt;getBool(&quot;FullScreen1.1&quot;);
 
         if (ModeAvailable (static_cast&lt;VideoModes&gt; (vidmode))
             &amp;&amp; vm_available (w, h, bpp, fullscreen)
@@ -524,8 +616,8 @@
     }
 
     current_video_mode = static_cast&lt;VideoModes&gt;(vidmode);
-    if (vidmode != oldvidmode) {
-        options::SetOption (&quot;VideoMode&quot;, vidmode);
+    if (vidmode != app.prefs-&gt;getInt(&quot;VideoMode1.1&quot;)) {
+        app.prefs-&gt;setProperty(&quot;VideoMode1.1&quot;, vidmode);
     }
 
 
@@ -627,7 +719,6 @@
     enigma::Log &lt;&lt; &quot;Wrote screenshot to '&quot; &lt;&lt; fname &lt;&lt; &quot;\n&quot;;
 }
 
-
 /* -------------------- Special Effects -------------------- */
 
 void video::FX_Fade(FadeMode mode) 

Modified: trunk/src/video.hh
===================================================================
--- trunk/src/video.hh	2007-08-16 21:22:30 UTC (rev 837)
+++ trunk/src/video.hh	2007-08-16 21:29:50 UTC (rev 838)
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2002,2003,2004,2005 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -29,31 +30,47 @@
 {
 
     enum VideoModes {
-        VM_None     = -1,
-        VM_640x480  = 0,
-        VM_640x512  = 1,
-        VM_800x600  = 2,
-        VM_1024x768 = 3,
+        VM_None      = -1,
+        VM_640x480   = 0,   // 32 bit basic
+        VM_640x512   = 1,
+        VM_800x600   = 2,   // 40 bit basic
+        VM_1024x768  = 3,
+        VM_960x720   = 4,   // 48 bit basic
+        VM_960x768   = 5,   // 48 bit grid linear strechable to 1280x1024
+        VM_1152x720  = 6,   // 48 bit grid lineas strechable to 1680x1050
+        VM_1280x960  = 7,   // 64 bit basic
         VM_COUNT
     };
+    
+    enum VideoTileType {    // Tile size in pixels
+        VTS_32 = 0,
+        VTS_40 = 1,
+        VTS_48 = 2,
+        VTS_64 = 3
+    };
 
     struct VMInfo {
-        VideoModes  videomode;
-        int width, height;      // Screen width and height in pixels
-        int tile_size;          // Tile size in pixels
-        const char *name;       // Menu text 
-        const char *initscript; // Lua initialization script
-        const char *gfxdir;     // Directory that contains the graphics
-        int thumbw, thumbh;     // Width and height of thumbnails
-        const char *thumbsdir;  // Directory that contains the thumbnails
-        ecl::Rect gamearea;
-        ecl::Rect statusbararea;
-        ecl::Rect sb_timearea;
-        ecl::Rect sb_movesarea;
-        ecl::Rect sb_itemarea;
-        ecl::Rect sb_textarea;
-        VideoModes  fallback_videomode;
-        bool     available;     // Is this video mode available?
+        VideoModes     videomode;
+        int            width, height;    // Screen width and height in pixels
+        int            tile_size;        // Tile size in pixels
+        VideoTileType  tt;               // Tile type
+        const char    *name;             // Menu text 
+        const char    *fullscreen_name;  // Menu text 
+        bool           isFullscreenOnly;
+        const char    *initscript;       // Lua initialization script
+        const char    *gfxdir;           // Directory that contains the graphics
+        ecl::Rect      area;             // Area that is used for display
+        int            mbg_offsetx, mbg_offsety; // offsets for menu background image
+        int            thumbw, thumbh;   // Width and height of thumbnails
+        std::string    thumbsext;        // extension added to thumbnails files and dirs
+        ecl::Rect      gamearea;
+        ecl::Rect      statusbararea;
+        ecl::Rect      sb_timearea;
+        ecl::Rect      sb_movesarea;
+        ecl::Rect      sb_itemarea;
+        ecl::Rect      sb_textarea;
+        VideoModes     fallback_videomode;
+        bool           available;        // Is this video mode available?
     };
 
     void Init();
@@ -74,6 +91,9 @@
     /*! Return information about current video mode. */
     const VMInfo *GetInfo ();
 
+    // just for main batch thumb generation in wrong videomode
+    void SetThumbInfo(int width, int height, std::string extension);
+
     bool ModeAvailable (VideoModes vm);
 
     //! Return the current video mode


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000271.html">[Enigma-game-svn] r837 - trunk/data/levels/lib
</A></li>
	<LI>Next message: <A HREF="000273.html">[Enigma-game-svn] r839 - in branches/eval/java: .	src/org/enigma_game/lev src/org/enigma_game/util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#272">[ date ]</a>
              <a href="thread.html#272">[ thread ]</a>
              <a href="subject.html#272">[ subject ]</a>
              <a href="author.html#272">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
