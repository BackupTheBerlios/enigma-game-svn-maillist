<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1023 - in trunk: data/schemas src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1023%20-%20in%20trunk%3A%20data/schemas%20src&In-Reply-To=%3C200802031904.m13J4Ksd005989%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000454.html">
   <LINK REL="Next"  HREF="000456.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1023 - in trunk: data/schemas src</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1023%20-%20in%20trunk%3A%20data/schemas%20src&In-Reply-To=%3C200802031904.m13J4Ksd005989%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1023 - in trunk: data/schemas src">ral at mail.berlios.de
       </A><BR>
    <I>Sun Feb  3 20:04:20 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000454.html">[Enigma-game-svn] r1022 - homepage/input
</A></li>
        <LI>Next message: <A HREF="000456.html">[Enigma-game-svn] r1024 - in trunk: lib-src/enigma-core src	src/stones
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#455">[ date ]</a>
              <a href="thread.html#455">[ thread ]</a>
              <a href="subject.html#455">[ subject ]</a>
              <a href="author.html#455">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2008-02-03 20:04:18 +0100 (Sun, 03 Feb 2008)
New Revision: 1023

Added:
   trunk/data/schemas/objects.xml
   trunk/data/schemas/objects.xsd
   trunk/src/AttributeDescriptor.cc
   trunk/src/AttributeDescriptor.hh
   trunk/src/KindDescriptor.cc
   trunk/src/KindDescriptor.hh
   trunk/src/MessageDescriptor.cc
   trunk/src/MessageDescriptor.hh
   trunk/src/ObjectValidator.cc
   trunk/src/ObjectValidator.hh
Modified:
   trunk/src/Makefile.am
   trunk/src/Object.cc
   trunk/src/Object.hh
   trunk/src/lua.cc
   trunk/src/main.cc
   trunk/src/world.cc
Log:
Trunk 1.1: Object Validation part I
- add an XML declaration of the objects zoo, attributes, messages
- add descriptor classes for objects, attributes, messages
- cleanup Object
- add a validation class
- validate all level messages including action messages:
  - unknown messages are rejected, e.g. &quot;open&quot; on a switch
Note:
- just a few test objects are XML declared
- further features of the validator will be added in the next parts


Added: trunk/data/schemas/objects.xml
===================================================================
--- trunk/data/schemas/objects.xml	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/data/schemas/objects.xml	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,90 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
+&lt;objects xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:noNamespaceSchemaLocation=&quot;objects.xsd&quot;&gt;
+  &lt;attributes&gt;
+    &lt;attr name=&quot;action&quot; type=&quot;tokens&quot; default=&quot;nil&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;autoclose&quot; type=&quot;bool&quot; default=&quot;false&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;color&quot; type=&quot;int&quot; default=&quot;nil&quot; min=&quot;0&quot; max=&quot;1&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;counterclock&quot; type=&quot;bool&quot; default=&quot;false&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;inverse&quot; type=&quot;bool&quot; default=&quot;false&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;name&quot; type=&quot;string&quot; default=&quot;nil&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;state&quot; type=&quot;int&quot; default=&quot;0&quot; min=&quot;0&quot; max=&quot;1&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;target&quot; type=&quot;tokens&quot; default=&quot;nil&quot; rw=&quot;rw&quot;/&gt;
+  &lt;/attributes&gt;
+  &lt;messages&gt;
+    &lt;msg name=&quot;close&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;closeall&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;inner_pull&quot; type=&quot;dir&quot;/&gt;
+    &lt;msg name=&quot;off&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;on&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;open&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;shuffle&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;signal&quot; type=&quot;int&quot; min=&quot;0&quot; max=&quot;1&quot;/&gt;
+    &lt;msg name=&quot;toggle&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_bombstone&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_explosion&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_init&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_jumping&quot; type=&quot;bool&quot;/&gt;
+    &lt;msg name=&quot;_performaction&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_model_reanimated&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_passed&quot; type=&quot;nil&quot;/&gt;            &lt;!-- check type--&gt;
+    &lt;msg name=&quot;_performaction&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_start&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_trigger&quot; type=&quot;bool&quot;/&gt;
+  &lt;/messages&gt;
+  &lt;zoo&gt;
+    &lt;object name=&quot;&quot; abstract=&quot;true&quot; states=&quot;2&quot;&gt;
+      &lt;attr name=&quot;action&quot;/&gt;
+      &lt;attr name=&quot;inverse&quot;/&gt;
+      &lt;attr name=&quot;name&quot;/&gt;
+      &lt;attr name=&quot;state&quot;/&gt;
+      &lt;attr name=&quot;target&quot;/&gt;
+      &lt;action type=&quot;bool&quot;/&gt;
+      &lt;msg name=&quot;toggle&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;it&quot; abstract=&quot;true&quot;/&gt;
+    &lt;object name=&quot;it_blocker&quot;&gt;
+      &lt;attr name=&quot;autoclose&quot;/&gt;
+      &lt;msg name=&quot;close&quot;/&gt;
+      &lt;msg name=&quot;open&quot;/&gt;
+      &lt;msg name=&quot;signal&quot;/&gt;
+      &lt;msg name=&quot;_init&quot;/&gt;
+      &lt;msg name=&quot;_performaction&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;it_blocker_new&quot; init=&quot;true&quot;&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st&quot; abstract=&quot;true&quot;/&gt;
+    &lt;object name=&quot;st_blocker&quot;&gt;
+      &lt;attr name=&quot;autoclose&quot;/&gt;
+      &lt;msg name=&quot;close&quot;/&gt;
+      &lt;msg name=&quot;open&quot;/&gt;
+      &lt;msg name=&quot;signal&quot;/&gt;
+      &lt;msg name=&quot;_performaction&quot;/&gt;
+      &lt;msg name=&quot;_trigger&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_blocker_new&quot; init=&quot;true&quot;&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_floppy&quot;&gt;
+      &lt;msg name=&quot;on&quot;/&gt;
+      &lt;msg name=&quot;off&quot;/&gt;
+      &lt;msg name=&quot;signal&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_fourswitch&quot; states=&quot;4&quot;&gt;
+      &lt;attr name=&quot;counterclock&quot;/&gt;
+      &lt;action type=&quot;dir&quot; statetype=&quot;bool&quot;/&gt;
+      &lt;msg name=&quot;signal&quot;/&gt;
+      &lt;msg name=&quot;_trigger&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_switch&quot;&gt;
+      &lt;attr name=&quot;color&quot;/&gt;
+      &lt;msg name=&quot;on&quot;/&gt;
+      &lt;msg name=&quot;off&quot;/&gt;
+      &lt;msg name=&quot;signal&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_switch_black&quot;&gt;
+      &lt;attr name=&quot;color&quot; value=&quot;0&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_switch_white&quot;&gt;
+      &lt;attr name=&quot;color&quot; value=&quot;1&quot;/&gt;
+    &lt;/object&gt;
+  &lt;/zoo&gt;
+&lt;/objects&gt;


Property changes on: trunk/data/schemas/objects.xml
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: trunk/data/schemas/objects.xsd
===================================================================
--- trunk/data/schemas/objects.xsd	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/data/schemas/objects.xsd	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,122 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;xs:schema xmlns:xs='<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>' version=&quot;0.1&quot; xml:lang=&quot;en&quot;&gt;
+  &lt;xs:annotation&gt;
+    &lt;xs:documentation&gt;
+      XML schema definitions for Enigma objects
+      Copyright &#169; 2008 Ronald Lamprecht
+      GPL2
+    &lt;/xs:documentation&gt;
+  &lt;/xs:annotation&gt;
+  &lt;xs:element name=&quot;objects&quot;&gt;
+    &lt;xs:complexType&gt;
+      &lt;xs:sequence&gt;
+        &lt;xs:element name=&quot;attributes&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;&gt;
+          &lt;xs:annotation&gt;
+            &lt;xs:documentation&gt;
+              All attributes of all objects with their default behaviour
+            &lt;/xs:documentation&gt;
+          &lt;/xs:annotation&gt;
+          &lt;xs:complexType&gt;
+            &lt;xs:sequence&gt;
+              &lt;xs:element name=&quot;attr&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
+                &lt;xs:complexType&gt;
+                  &lt;xs:attribute name=&quot;name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+                  &lt;xs:attribute name=&quot;type&quot; type=&quot;valueType&quot; use=&quot;required&quot;/&gt;
+                  &lt;xs:attribute name=&quot;default&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+                  &lt;xs:attribute name=&quot;min&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+                  &lt;xs:attribute name=&quot;max&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+                  &lt;xs:attribute name=&quot;rw&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+                  &lt;xs:anyAttribute namespace=&quot;##targetNamespace&quot; processContents=&quot;skip&quot;/&gt;
+                &lt;/xs:complexType&gt;
+              &lt;/xs:element&gt; &lt;!-- attr --&gt;
+            &lt;/xs:sequence&gt;
+          &lt;/xs:complexType&gt;
+        &lt;/xs:element&gt; &lt;!-- attributes --&gt;
+        
+        &lt;xs:element name=&quot;messages&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;&gt;
+          &lt;xs:annotation&gt;
+            &lt;xs:documentation&gt;
+              All messages of all objects with their value types
+            &lt;/xs:documentation&gt;
+          &lt;/xs:annotation&gt;
+          &lt;xs:complexType&gt;
+            &lt;xs:sequence&gt;
+              &lt;xs:element name=&quot;msg&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; &gt;
+                &lt;xs:complexType&gt;
+                  &lt;xs:attribute name=&quot;name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+                  &lt;xs:attribute name=&quot;type&quot; type=&quot;valueType&quot; use=&quot;required&quot;/&gt;
+                  &lt;xs:anyAttribute namespace=&quot;##targetNamespace&quot; processContents=&quot;skip&quot;/&gt;
+                &lt;/xs:complexType&gt;
+              &lt;/xs:element&gt; &lt;!-- msg --&gt;
+            &lt;/xs:sequence&gt;
+          &lt;/xs:complexType&gt;
+        &lt;/xs:element&gt; &lt;!-- messages --&gt;
+
+        &lt;xs:element name=&quot;zoo&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;&gt;
+          &lt;xs:annotation&gt;
+            &lt;xs:documentation&gt;
+              The zoo of all existing objects
+            &lt;/xs:documentation&gt;
+          &lt;/xs:annotation&gt;
+          &lt;xs:complexType&gt;
+            &lt;xs:sequence&gt;
+              &lt;xs:element name=&quot;object&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; &gt;
+                &lt;xs:complexType&gt;
+                  &lt;xs:sequence&gt;
+                    &lt;xs:element name=&quot;attr&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
+                      &lt;xs:complexType&gt;
+                        &lt;xs:attribute name=&quot;name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+                        &lt;xs:attribute name=&quot;type&quot; type=&quot;valueType&quot; use=&quot;optional&quot;/&gt;
+                        &lt;xs:attribute name=&quot;default&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+                        &lt;xs:attribute name=&quot;min&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+                        &lt;xs:attribute name=&quot;max&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+                        &lt;xs:attribute name=&quot;rw&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+                        &lt;xs:attribute name=&quot;value&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+                        &lt;xs:anyAttribute namespace=&quot;##targetNamespace&quot; processContents=&quot;skip&quot;/&gt;
+                      &lt;/xs:complexType&gt;
+                    &lt;/xs:element&gt; &lt;!-- attr --&gt;
+                    &lt;xs:element name=&quot;action&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;&gt;
+                      &lt;xs:complexType&gt;
+                        &lt;xs:attribute name=&quot;type&quot; type=&quot;valueType&quot; use=&quot;required&quot;/&gt;
+                        &lt;xs:anyAttribute namespace=&quot;##targetNamespace&quot; processContents=&quot;skip&quot;/&gt;
+                      &lt;/xs:complexType&gt;
+                    &lt;/xs:element&gt; &lt;!-- action --&gt;
+                    &lt;xs:element name=&quot;msg&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; &gt;
+                      &lt;xs:complexType&gt;
+                        &lt;xs:attribute name=&quot;name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+                        &lt;xs:attribute name=&quot;type&quot; type=&quot;valueType&quot; use=&quot;optional&quot;/&gt;
+                        &lt;xs:anyAttribute namespace=&quot;##targetNamespace&quot; processContents=&quot;skip&quot;/&gt;
+                      &lt;/xs:complexType&gt;
+                    &lt;/xs:element&gt; &lt;!-- msg --&gt;
+                  &lt;/xs:sequence&gt;
+                  &lt;xs:attribute name=&quot;name&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+                  &lt;xs:attribute name=&quot;super&quot; type=&quot;xs:string&quot; use=&quot;optional&quot; default=&quot;-&quot;/&gt;
+                  &lt;xs:attribute name=&quot;abtract&quot; type=&quot;xs:boolean&quot; use=&quot;optional&quot; default=&quot;false&quot;/&gt;
+                  &lt;xs:attribute name=&quot;states&quot; type=&quot;xs:int&quot; use=&quot;optional&quot; default=&quot;-1&quot;/&gt;
+                  &lt;xs:attribute name=&quot;init&quot; type=&quot;xs:boolean&quot; use=&quot;optional&quot; default=&quot;false&quot;/&gt;
+                  &lt;xs:anyAttribute namespace=&quot;##targetNamespace&quot; processContents=&quot;skip&quot;/&gt;
+                &lt;/xs:complexType&gt;
+              &lt;/xs:element&gt; &lt;!-- object --&gt;
+            &lt;/xs:sequence&gt;
+          &lt;/xs:complexType&gt;
+        &lt;/xs:element&gt; &lt;!-- zoo --&gt;
+        
+        &lt;xs:any namespace=&quot;##targetNamespace&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; processContents=&quot;skip&quot;/&gt;
+      &lt;/xs:sequence&gt;
+    &lt;/xs:complexType&gt;
+  &lt;/xs:element&gt; &lt;!-- objects --&gt;
+  
+  &lt;xs:simpleType name=&quot;valueType&quot;&gt;
+    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
+      &lt;xs:enumeration value=&quot;bool&quot;/&gt;
+      &lt;xs:enumeration value=&quot;int&quot;/&gt;
+      &lt;xs:enumeration value=&quot;double&quot;/&gt;
+      &lt;xs:enumeration value=&quot;nil&quot;/&gt;
+      &lt;xs:enumeration value=&quot;dir&quot;/&gt;
+&lt;!--      &lt;xs:enumeration value=&quot;pos&quot;/&gt;  --&gt;
+      &lt;xs:enumeration value=&quot;string&quot;/&gt;
+      &lt;xs:enumeration value=&quot;enum&quot;/&gt;
+      &lt;xs:enumeration value=&quot;tokens&quot;/&gt;
+    &lt;/xs:restriction&gt;
+  &lt;/xs:simpleType&gt;
+&lt;/xs:schema&gt;


Property changes on: trunk/data/schemas/objects.xsd
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: trunk/src/AttributeDescriptor.cc
===================================================================
--- trunk/src/AttributeDescriptor.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/AttributeDescriptor.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include &quot;AttributeDescriptor.hh&quot;
+
+#include &quot;ObjectValidator.hh&quot;
+
+namespace enigma {
+    
+    AttributeDescriptor::AttributeDescriptor(std::string attributeName, validationType valType, 
+            Value aValue, bool allowRead, bool allowWrite, Value minVal, Value maxVal)
+            : name (attributeName), type (valType), defaultValue (aValue), 
+            readable (allowRead), writable(allowWrite), min (minVal), max (maxVal) {
+    }
+    
+    std::string AttributeDescriptor::getName() {
+        return name;
+    }
+    
+    validationType AttributeDescriptor::getType() {
+        return type;
+    }
+    
+    bool AttributeDescriptor::isReadable() {
+        return readable;
+    }
+    
+    bool AttributeDescriptor::isWritable() {
+        return writable;
+    }
+    
+    Value AttributeDescriptor::getValue() {
+        return value;
+    }
+    
+    void AttributeDescriptor::setReadable(bool allowRead) {
+        readable = allowRead;
+    }
+    
+    void AttributeDescriptor::setWritable(bool allowWrite) {
+        writable = allowWrite;
+    }
+    
+    void AttributeDescriptor::setDefaultValue(const Value &amp;newDefault) {
+        defaultValue = newDefault;
+    }
+
+    void AttributeDescriptor::setMinValue(const Value &amp;newMin) {
+        min = newMin;
+    }
+    
+    void AttributeDescriptor::setMaxValue(const Value &amp;newMax) {
+        max = newMax;
+    }
+    
+    void AttributeDescriptor::setValue(const Value &amp;newValue) {
+        value = newValue;
+    }
+    
+} // namespace enigma


Property changes on: trunk/src/AttributeDescriptor.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/AttributeDescriptor.hh
===================================================================
--- trunk/src/AttributeDescriptor.hh	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/AttributeDescriptor.hh	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+ 
+#ifndef ATTRIBUTEDESCRIPTOR_HH_INCLUDED
+#define ATTRIBUTEDESCRIPTOR_HH_INCLUDED
+
+#include &quot;Value.hh&quot;
+#include &lt;string&gt;
+
+namespace enigma
+{
+    enum validationType {
+        VAL_BOOL,
+        VAL_INT,
+        VAL_DOUBLE,
+        VAL_NIL,
+        VAL_DIR,
+//        VAL_POS,
+        VAL_STRING,
+        VAL_ENUM,
+        VAL_TOKENS
+    };    
+
+    class AttributeDescriptor {
+    public:
+        AttributeDescriptor(std::string name, validationType valType, Value defaultValue,
+                bool allowRead, bool allowWrite, Value minVal, Value maxVal);
+        std::string getName();
+        validationType getType();
+        bool isReadable();
+        bool isWritable();
+        Value getValue();
+        void setReadable(bool allowRead);
+        void setWritable(bool allowWrite);
+        void setDefaultValue(const Value &amp;newDefault);
+        void setMinValue(const Value &amp;newMin);
+        void setMaxValue(const Value &amp;newMax);
+        void setValue(const Value &amp;newValue);
+
+    private:
+        std::string name;
+        validationType type;
+        Value defaultValue;
+        bool readable;
+        bool writable;
+        Value  min;
+        Value  max;
+        Value value;
+    };
+} // namespace enigma
+#endif


Property changes on: trunk/src/AttributeDescriptor.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/KindDescriptor.cc
===================================================================
--- trunk/src/KindDescriptor.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/KindDescriptor.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include &quot;KindDescriptor.hh&quot;
+
+#include &quot;errors.hh&quot;
+#include &quot;main.hh&quot;
+#include &quot;ObjectValidator.hh&quot;
+
+namespace enigma {
+    KindDescriptor::KindDescriptor(std::string name, std::string superKind, bool abstract, 
+            int states, bool initOnly) : kind (name), isAbstract (abstract), 
+            isInitOnly (isInitOnly), numStates (states) {
+        // find super kind
+        if (superKind != &quot;-&quot;) {
+            // an explicit super kind is given
+            super = ObjectValidator::instance()-&gt;getKindDesc(superKind);
+        } else {
+            // implicit super kind by suffix cut off
+            std::string::size_type pos = name.rfind('_');
+            if (pos != std::string::npos)
+                super = ObjectValidator::instance()-&gt;getKindDesc( name.substr(0, pos));
+            else
+                super = ObjectValidator::instance()-&gt;getKindDesc(&quot;&quot;);
+        }
+        ASSERT(super != NULL || name == &quot;&quot;, XFrontend, &quot;Object description initialization error - unknown super kind&quot;);
+        // isClass - if all super are abstract
+        isClass = !abstract;
+        for (KindDescriptor *s = super; s != NULL; s = s-&gt;super)
+            if (!s-&gt;isAbstract)
+                isClass = false;
+
+        // inherit messages from super
+        if (super != NULL)
+            messages = super-&gt;messages;
+
+        // inherit attributes from super
+        if (super != NULL)
+            attributes = super-&gt;attributes;
+    }
+    
+    void KindDescriptor::addMessage(std::string msg) {
+        if (messages[msg] == NULL)
+            messages[msg] = ObjectValidator::instance()-&gt;getMessage(msg);
+    }
+    
+    bool KindDescriptor::validateMessage(std::string msg) {
+        std::map&lt;std::string, MessageDescriptor *&gt;::iterator it = messages.find(msg);
+        return it != messages.end();
+    }
+    
+    void KindDescriptor::addAttribute(std::string name) {
+        if (attributes[name] == NULL)
+            attributes[name] = ObjectValidator::instance()-&gt;getDefaultAttribute(name);
+    }
+    
+    AttributeDescriptor * KindDescriptor::addModifiedAttribute(std::string name) {
+        // make a clone and return it for modification
+        AttributeDescriptor *inheritedAttribute = attributes[name];
+        if (inheritedAttribute == NULL)
+            inheritedAttribute = ObjectValidator::instance()-&gt;getDefaultAttribute(name);
+        AttributeDescriptor *cloneAttribute = ObjectValidator::instance()-&gt;cloneAttribute(inheritedAttribute);
+        attributes[name] = cloneAttribute;
+        return cloneAttribute;
+    }
+    
+    bool KindDescriptor::validateAttributeWrite(std::string key, Value val) {
+        std::map&lt;std::string, AttributeDescriptor *&gt;::iterator it = attributes.find(key);
+        if (it == attributes.end())
+            return false;
+        else
+            return it-&gt;second-&gt;isWritable();
+    }
+    
+    void KindDescriptor::log() {
+        if (super != NULL)
+            Log &lt;&lt; &quot;Kind &quot; &lt;&lt; kind &lt;&lt; &quot; of super &quot; &lt;&lt; super-&gt;kind &lt;&lt; &quot; isClass &quot; &lt;&lt; isClass &lt;&lt; &quot;\n&quot;;
+        else
+            Log &lt;&lt; &quot;Kind &quot; &lt;&lt; kind &lt;&lt; &quot; is base - isClass &quot; &lt;&lt; isClass &lt;&lt; &quot;\n&quot;;
+        for (std::map&lt;std::string, MessageDescriptor *&gt;::iterator it = messages.begin(); it != messages.end(); ++it)
+            Log &lt;&lt; &quot;    Message: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;\n&quot;;
+        for (std::map&lt;std::string, AttributeDescriptor *&gt;::iterator it = attributes.begin(); it != attributes.end(); ++it) {
+            Log &lt;&lt; &quot;    Attribute: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; - &quot;;
+            switch (it-&gt;second-&gt;getType()) {
+                case VAL_BOOL :
+                    Log &lt;&lt; &quot;bool - &quot;;
+                    break;
+                case VAL_NIL :
+                    Log &lt;&lt; &quot;nil - &quot;;
+                    break;
+                case VAL_STRING :
+                    Log &lt;&lt; &quot;string - &quot;;
+                    break;
+                case VAL_INT :
+                    Log &lt;&lt; &quot;int - &quot;;
+                    break;
+                case VAL_DIR :
+                    Log &lt;&lt; &quot;dir - &quot;;
+                    break;
+                case VAL_ENUM :
+                    Log &lt;&lt; &quot;enum - &quot;;
+                    break;
+                case VAL_DOUBLE :
+                    Log &lt;&lt; &quot;double - &quot;;
+                    break;
+                case VAL_TOKENS :
+                    Log &lt;&lt; &quot;tokens - &quot;;
+                    break;
+            }
+            if (it-&gt;second-&gt;isReadable()) Log &lt;&lt; &quot;r&quot;;
+            if (it-&gt;second-&gt;isWritable()) Log &lt;&lt; &quot;w&quot;;
+            if (it-&gt;second-&gt;getType() == VAL_INT &amp;&amp; it-&gt;second-&gt;getValue() != Value())
+                Log &lt;&lt; &quot; : &quot; &lt;&lt; (int)(it-&gt;second-&gt;getValue());
+            Log &lt;&lt; &quot;\n&quot;;
+        }
+    }
+} // namespace enigma


Property changes on: trunk/src/KindDescriptor.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/KindDescriptor.hh
===================================================================
--- trunk/src/KindDescriptor.hh	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/KindDescriptor.hh	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+ 
+#ifndef KINDDESCRIPTOR_HH_INCLUDED
+#define KINDDESCRIPTOR_HH_INCLUDED
+
+#include &quot;AttributeDescriptor.hh&quot;
+#include &quot;MessageDescriptor.hh&quot;
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+namespace enigma
+{
+    class KindDescriptor {
+    public:
+        KindDescriptor(std::string name, std::string superKind, bool abstract, int states, bool initOnly);
+        void addMessage(std::string msg);
+        bool validateMessage(std::string msg);
+        void addAttribute(std::string name);
+        AttributeDescriptor * addModifiedAttribute(std::string name);
+        bool validateAttributeWrite(std::string key, Value val);
+        void log();
+    private:
+        std::string kind;
+        KindDescriptor *super;
+        bool isAbstract;  // object instantiation not possible
+        bool isClass;     // 
+        bool isInitOnly;  // isKind is never true 
+        int numStates;
+        std::map&lt;std::string, MessageDescriptor *&gt; messages;
+        std::map&lt;std::string, AttributeDescriptor *&gt; attributes;
+    };
+} // namespace enigma
+#endif


Property changes on: trunk/src/KindDescriptor.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/Makefile.am	2008-02-03 19:04:18 UTC (rev 1023)
@@ -25,6 +25,8 @@
 	actors.hh 		\
 	actors.cc 		\
 	actors_internal.hh	\
+	AttributeDescriptor.cc	\
+	AttributeDescriptor.hh	\
 	client.cc 		\
 	client.hh 		\
 	client_internal.hh	\
@@ -59,6 +61,8 @@
 	ItemHolder.hh		\
 	items.cc 		\
 	items.hh		\
+	KindDescriptor.cc	\
+	KindDescriptor.hh	\
 	laser.cc 		\
 	laser.hh		\
 	LocalToXML.cc		\
@@ -77,6 +81,8 @@
 	lua-ecl.hh		\
 	main.cc 		\
 	main.hh			\
+	MessageDescriptor.cc	\
+	MessageDescriptor.hh	\
 	netgame.cc 		\
 	netgame.hh 		\
 	network.cc		\
@@ -85,6 +91,8 @@
 	nls.hh			\
 	Object.cc 		\
 	Object.hh 		\
+	ObjectValidator.cc	\
+	ObjectValidator.hh	\
 	oxyd.cc			\
 	oxyd.hh 		\
 	oxyd_internal.hh	\

Added: trunk/src/MessageDescriptor.cc
===================================================================
--- trunk/src/MessageDescriptor.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/MessageDescriptor.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include &quot;MessageDescriptor.hh&quot;
+
+#include &quot;ObjectValidator.hh&quot;
+
+namespace enigma {
+    MessageDescriptor::MessageDescriptor(std::string name) : message (name) {
+    }
+    
+    std::string MessageDescriptor::getMessage() {
+        return message;
+    }
+} // namespace enigma


Property changes on: trunk/src/MessageDescriptor.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/MessageDescriptor.hh
===================================================================
--- trunk/src/MessageDescriptor.hh	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/MessageDescriptor.hh	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+ 
+#ifndef MESSAGEDESCRIPTOR_HH_INCLUDED
+#define MESSAGEDESCRIPTOR_HH_INCLUDED
+
+#include &lt;string&gt;
+
+namespace enigma
+{
+    class MessageDescriptor {
+    public:
+        MessageDescriptor(std::string name);
+        std::string getMessage();
+    private:
+        std::string message;
+    };
+} // namespace enigma
+#endif


Property changes on: trunk/src/MessageDescriptor.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/Object.cc
===================================================================
--- trunk/src/Object.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/Object.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -24,6 +24,7 @@
 #include &quot;game.hh&quot;
 #include &quot;main.hh&quot;
 #include &quot;lua.hh&quot;
+#include &quot;ObjectValidator.hh&quot;
 #include &quot;server.hh&quot;
 #include &quot;sound.hh&quot;
 #include &quot;world.hh&quot;
@@ -112,19 +113,11 @@
         return id;
     }
     
-    Value Object::message(const Message &amp;m) {
-        return Value();
-    }
-    
-    void Object::on_levelinit() {
-    }
-    
-    
     const char * Object::get_kind() const {      // To be made pure virtual
-        const Value *v = get_attrib(&quot;kind&quot;);
-        ASSERT(v &amp;&amp; v-&gt;getType() == Value::STRING, XLevelRuntime,
-            &quot;Object: attribute kind is not of type string (found in get_kind)&quot;);
-        return v-&gt;get_string();
+        AttribMap::const_iterator i = attribs.find(&quot;kind&quot;);        
+        ASSERT(i != attribs.end() &amp;&amp; i-&gt;second.getType() == Value::STRING, XLevelRuntime,
+                &quot;Object: attribute kind not found&quot;);
+        return i-&gt;second.get_string();
     }
     
     // check kind of object
@@ -137,20 +130,47 @@
         return ecl::string_match(get_kind(), kind_templ.c_str());
     }
     
+    std::string Object::getClass() const {
+        return get_kind();  // should be abstract, but until end of the reengineering we need compatibility
+    }
+    
+    std::string Object::getKind() const {
+        return getClass();
+    }
+    
+    bool Object::isKind(const std::string &amp;kind) const {
+        return true;
+    }
+
+    bool Object::validateMessage(std::string msg, Value arg) {
+        return ObjectValidator::instance()-&gt;validateMessage(this, msg, arg);
+    }
+    
+    Value Object::message(const Message &amp;m) {
+        return Value();
+    }
+    
+    
+    
     void Object::set_attrib(const string&amp; key, const Value&amp; val) {
         if (val)         // only set non-default values
             attribs[key] = val;  //.insert (key, val);
     }
     
-    const Value* Object::get_attrib(const string&amp; key) const { // To be delete as soon as
-                                                               // get_kind() has no need of it
-        AttribMap::const_iterator i = attribs.find(key);
-        if (i == attribs.end())
-            return 0;
-        else
-            return &amp;i-&gt;second;
+    
+    void Object::setAttrChecked(const std::string&amp; key, const Value &amp;val) {
+        if (key.find('_') == 0 || ObjectValidator::instance()-&gt;validateAttributeWrite(this, key, val))
+            setAttr(key, val);
     }
     
+    void Object::setAttr(const std::string&amp; key, const Value &amp;val) {
+        set_attrib(key, val);
+    }
+    
+    Value Object::getAttrChecked(const std::string &amp;key) const {
+        return getAttr(key);
+    }
+    
     Value Object::getAttr(const string&amp; key) const {
         AttribMap::const_iterator i = attribs.find(key);
         if (i == attribs.end())
@@ -166,14 +186,7 @@
             return defaultValue;
     }
     
-    Value Object::getValue(const string&amp; key) const {
-        return getAttr(key);       // TODO write template method
-    }
     
-    Value Object::getDefaultValue(const string &amp;key) const {
-        return Value(Value::DEFAULT);
-    }
-    
     void Object::transferName(Object *target) {
         if (target == NULL)
             return;
@@ -249,7 +262,9 @@
 //                            if (obj_action != action)
 //                                Log &lt;&lt; &quot;PerformAction renamed '&quot; &lt;&lt; action &lt;&lt; &quot;' to '&quot; &lt;&lt; obj_action &lt;&lt; &quot;' for receiver '&quot; &lt;&lt; (*oit)-&gt;get_kind() &lt;&lt; &quot;'\n&quot;;
                         }
-                        SendMessage(*oit, Message(obj_action, messageValue, this));                    
+                        // check if message is valid, otherwise ignore message
+                        if ((*oit)-&gt;validateMessage(obj_action, messageValue))
+                            SendMessage(*oit, Message(obj_action, messageValue, this));                    
                     }
                 }
             }

Modified: trunk/src/Object.hh
===================================================================
--- trunk/src/Object.hh	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/Object.hh	2008-02-03 19:04:18 UTC (rev 1023)
@@ -75,6 +75,8 @@
             ACTOR
         };
             
+        typedef ecl::AssocList&lt;std::string, Value&gt; AttribMap;
+
         Object();
         Object(const char *kind);
         Object(const Object &amp;src_obj); 
@@ -83,77 +85,112 @@
         static Object * getObject(int id);
         int getId() const;
         
-        /* ---------- Attributes ---------- */
+        /* ---------- depreceated methods ---------- */
 
-        typedef ecl::AssocList&lt;std::string, Value&gt; AttribMap;
-
         bool is_kind(const char *kind) const;
         bool is_kind(const string&amp; kind) const;
+        virtual const char *get_kind() const;
+        const AttribMap &amp;get_attribs() const { return attribs; }  // just used by ObjectRepos::dump_info()        
 
-        const AttribMap &amp;get_attribs() const { return attribs; }
-        
-        /**
-         * Get an attribute or a special given default value. This method
-         * gets attributes like the simple argumented getAttr method but
-         * returns the given default value instead of a DEFAULT value if
-         * no explicit attribute exists.
-         */
-        Value getDefaultedAttr(const string &amp;key, Value defaultValue) const;
-
-
         /* ---------- Helper routines ---------- */
 
         void send_impulse(const GridPos&amp; dest, Direction dir);
         void send_impulse(const GridPos&amp; dest, Direction dir, double delay);
 
         /* ---------- Object interface ---------- */
+        
+        /**
+         * The main object category name of the object that describes its gaming class.
+         * All objects of a gaming class support the same attributes and messages. But
+         * they may still be members of different kind subcategories. E.g. &quot;st_panel&quot;
+         * is a class with &quot;st_panel_n&quot;, &quot;st_panel_s&quot;,... as kinds. A gaming object
+         * class is often implemented as a separate C++ class. But sometimes several 
+         * gaming classes share a single C++ class. E.g. &quot;st_panel&quot;, &quot;st_bluesand&quot; are
+         * both impleneted by the class &quot;ClusterStone&quot;. In this case we talk about a 
+         * common &quot;familiy&quot;. 
+         */
+        virtual std::string getClass() const;
+        
+        /**
+         * The most specific object category name. Many objects change their kind during
+         * their lifecycle. All attributes are evaluated to determine the current kind
+         * of a gaming object. 
+         */
+        std::string getKind() const;
+        
+        /**
+         * Check the current kind of the object versus the given name.
+         */
+        bool isKind(const std::string &amp;kind) const;
+        
+        
+        bool validateMessage(std::string msg, Value arg);
 
-        virtual const char *get_kind() const;
-
         /**
          * 
          */
         virtual Value message(const Message &amp;m);
         
-        virtual void set_attrib(const string&amp; key, const Value &amp;val);
+        virtual void set_attrib(const string &amp;key, const Value &amp;val);
         
         /**
+         * Store the value information for the given key with prior checking of
+         * write allowance. All level code attribute settings should pass this
+         * central call. If a set is granted the virtual unchecked setAttr is 
+         * executed.
+         */
+        void setAttrChecked(const std::string &amp;key, const Value &amp;val);
+        
+        /**
+         * Store the value information for the given key. If it is a XML declared
+         * system attribute or a user attribute it will be stored in the attribute
+         * map. Otherwise an ivar may be set. Nothing happens if the attribute is
+         * declared as read only. If the value is &quot;nil&quot; the attribute will be reset
+         * to its declared default. If the default is &quot;nil&quot;, too, or if it is a user
+         * attribute, it will be deleted in the attribute map. In these cases a read
+         * will return &quot;nil&quot; either way.
+         */
+        virtual void setAttr(const std::string &amp;key, const Value &amp;val);
+        
+        /**
+         * Get an attribute or value for the given key with prior checking of
+         * read allowance. All level code attribute reads should pass this central
+         * call. If a read is granted the virtual unchecked getAttr is executed.
+         */
+        Value getAttrChecked(const std::string &amp;key) const;
+        
+        /**
          * Get an attribute that has been set or that stands as a proxy for a
          * trait or ivar. Object itself will just return attribute values
          * that are stored in its attribute map. For not existing attributes
-         * a value of type DEFAULT is returned.
+         * a XML declared standard default value will be returned. If the default
+         * is &quot;nil&quot; type DEFAULT will be returned. 
          * 
          * Subclasses may override this method to supply values of traits or
          * ivars. This way levels can gain read access to attributes that can
          * not to be stored in the attribute map due to performance reasons.
          */
-        virtual Value getAttr(const string &amp;key) const;
+        virtual Value getAttr(const std::string &amp;key) const;
         
+
         /**
-         * Get the attribute, traits, ivar or default value for a given key.
-         * This is the main access method for object values that returns
-         * the best available value known for a key. It resolves attributes,
-         * uses proxy values for ivars and traits, uses class defaults,
-         * world defaults or system defaults.
-         * 
-         * This is a template method. Subclass have to override the method
-         * &lt;code&gt;getDefaultValue()&lt;/code&gt; to supply proper class defaults.
-         * All other defaults are resolved by this method
+         * Get an attribute or a special given default value. This method
+         * gets attributes like the simple argumented getAttr method but
+         * returns the given default value instead of a DEFAULT value if
+         * no explicit attribute exists.
          */
-        Value getValue(const string &amp;key) const;
-
+        Value getDefaultedAttr(const string &amp;key, Value defaultValue) const;
+        
+        
         virtual Object *clone()=0;
         virtual void dispose()=0;
 
-        virtual void on_levelinit();
-
         virtual void warning(const char *format, ...) const;
         virtual ObjectType getObjectType() const;
         void transferName(Object *target);
         virtual void transferIdentity(Object *target);
 
     protected:
-        virtual Value getDefaultValue(const string &amp;key) const;
         /** This function is used by all triggers, switches etc. that
          * perform some particular action when activated (like opening
          * doors or switching lasers on and off). It interprets the
@@ -184,10 +221,11 @@
         static std::map&lt;int, Object *&gt; objects;
         int id;
         AttribMap attribs;
+        
         static int getNextId(Object *obj, bool bootFinished);
         static void bootFinished();
         static void freeId(int id);
-        const Value* get_attrib(const string&amp; key) const;
+        
     };
 
 

Added: trunk/src/ObjectValidator.cc
===================================================================
--- trunk/src/ObjectValidator.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/ObjectValidator.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include &quot;ObjectValidator.hh&quot;
+
+#include &quot;errors.hh&quot;
+#include &quot;main.hh&quot;
+#include &quot;DOMErrorReporter.hh&quot;
+#include &quot;DOMSchemaResolver.hh&quot;
+#include &quot;utilXML.hh&quot;
+#include &quot;Utf8ToXML.hh&quot;
+#include &quot;XMLtoUtf8.hh&quot;
+#include &quot;gui/ErrorMenu.hh&quot;
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;xercesc/dom/DOM.hpp&gt;
+#include &lt;xercesc/util/XMLDouble.hpp&gt;
+
+XERCES_CPP_NAMESPACE_USE 
+
+namespace enigma {
+    ObjectValidator *ObjectValidator::theSingleton = 0;
+    
+    ObjectValidator* ObjectValidator::instance() {
+        if (theSingleton == NULL) {
+            theSingleton = new ObjectValidator();
+            theSingleton-&gt;init();
+        }
+        return theSingleton;
+    }
+    
+    ObjectValidator::ObjectValidator() {
+        std::string objectsPath;
+        std::string errMessage;
+        
+        if (!app.systemFS-&gt;findFile( &quot;schemas/objects.xml&quot; , objectsPath)) {
+                throw XFrontend(&quot;Cannot load object declarations!&quot;);
+        }
+
+        try {
+            std::ostringstream errStream;
+            app.domParserErrorHandler-&gt;resetErrors();
+            app.domParserErrorHandler-&gt;reportToOstream(&amp;errStream);
+            app.domParserSchemaResolver-&gt;resetResolver();
+            app.domParserSchemaResolver-&gt;addSchemaId(&quot;objects.xsd&quot;,&quot;objects.xsd&quot;);
+
+            doc = app.domParser-&gt;parseURI(objectsPath.c_str());
+            if (doc != NULL &amp;&amp; !app.domParserErrorHandler-&gt;getSawErrors()) {
+                
+            }
+            if(app.domParserErrorHandler-&gt;getSawErrors()) {
+                errMessage = errStream.str();
+            }
+            app.domParserErrorHandler-&gt;reportToNull();  // do not report to errStream any more
+        }
+        catch (...) {
+            errMessage = &quot;Unexpected XML Exception on load of object declarations\n&quot;;
+        }
+        if (!errMessage.empty()) {
+            throw XFrontend(&quot;Cannot load object declarations file: &quot; + objectsPath +
+                    &quot;\nError: &quot; + errMessage);
+        }
+    }
+     
+    ObjectValidator::~ObjectValidator() {
+        if (doc != NULL)
+            shutdown();
+        for (std::map&lt;std::string, KindDescriptor *&gt;::iterator it = kinds.begin(); it != kinds.end(); ++it)
+            delete it-&gt;second;
+        for (std::map&lt;std::string, MessageDescriptor *&gt;::iterator it = messages.begin(); it != messages.end(); ++it)
+            delete it-&gt;second;
+        for (std::map&lt;std::string, AttributeDescriptor *&gt;::iterator it = defaultAttributes.begin(); it != defaultAttributes.end(); ++it)
+            delete it-&gt;second;
+        while (!otherAttributes.empty()) {
+            delete otherAttributes.back();
+            otherAttributes.pop_back();
+        }
+    }
+    
+    void ObjectValidator::init() {
+        ASSERT(doc != NULL, XFrontend, &quot;ObjectValidator try to init without given document&quot;);
+        
+        DOMNodeList *elemList;
+        DOMElement *baseElem;
+        
+        baseElem = dynamic_cast&lt;DOMElement *&gt;(doc-&gt;getElementsByTagName(Utf8ToXML(&quot;attributes&quot;).x_str())-&gt;item(0));
+        elemList = baseElem-&gt;getElementsByTagName(Utf8ToXML(&quot;attr&quot;).x_str());
+        for (int i = 0, l = elemList-&gt;getLength(); i &lt; l; i++) {
+            scanAttributeElement(dynamic_cast&lt;DOMElement *&gt;(elemList-&gt;item(i)));
+        }
+        
+        baseElem = dynamic_cast&lt;DOMElement *&gt;(doc-&gt;getElementsByTagName(Utf8ToXML(&quot;messages&quot;).x_str())-&gt;item(0));
+        elemList = baseElem-&gt;getElementsByTagName(Utf8ToXML(&quot;msg&quot;).x_str());
+        for (int i = 0, l = elemList-&gt;getLength(); i &lt; l; i++) {
+            scanMessageElement(dynamic_cast&lt;DOMElement *&gt;(elemList-&gt;item(i)));
+        }
+        
+        elemList = doc-&gt;getElementsByTagName(Utf8ToXML(&quot;object&quot;).x_str());
+        for (int i = 0, l = elemList-&gt;getLength(); i &lt; l; i++) {
+            scanObjectElement(dynamic_cast&lt;DOMElement *&gt;(elemList-&gt;item(i)));
+        }
+    }
+    
+    void ObjectValidator::shutdown() {
+        if (doc != NULL)
+            doc-&gt;release();
+        doc = NULL;
+    }
+    
+    KindDescriptor *ObjectValidator::getKindDesc(std::string name) {
+        std::map&lt;std::string, KindDescriptor *&gt;::iterator it = kinds.find(name);
+        if (it != kinds.end())
+            return it-&gt;second;
+        else
+            return NULL;
+    }
+    
+    MessageDescriptor *ObjectValidator::getMessage(std::string name) {
+        std::map&lt;std::string, MessageDescriptor *&gt;::iterator it = messages.find(name);
+        if (it != messages.end())
+            return it-&gt;second;
+
+        ASSERT(false, XFrontend, (&quot;ObjectValidator missing message declaration for: &quot; + name).c_str());
+        return NULL;
+    }
+    
+    bool ObjectValidator::validateMessage(Object *obj, std::string msg, Value val) {
+        KindDescriptor *kind = getKindDesc(obj-&gt;getClass());
+        if (kind == NULL) {
+            return true;    // object is not under validator control
+        }
+        return kind-&gt;validateMessage(msg);
+    }
+
+    AttributeDescriptor *ObjectValidator::getDefaultAttribute(std::string name) {
+        std::map&lt;std::string, AttributeDescriptor *&gt;::iterator it = defaultAttributes.find(name);
+        if (it != defaultAttributes.end())
+            return it-&gt;second;
+
+        ASSERT(false, XFrontend, (&quot;ObjectValidator missing default attribute declaration for: &quot; + name).c_str());
+        return NULL;
+    }
+    
+    AttributeDescriptor *ObjectValidator::cloneAttribute(AttributeDescriptor *masterAttr) {
+        AttributeDescriptor *clone = new AttributeDescriptor(*masterAttr);
+        otherAttributes.push_back(clone);
+        return clone;
+    }
+
+    bool ObjectValidator::validateAttributeWrite(Object *obj, std::string key, Value val) {
+        KindDescriptor *kind = getKindDesc(obj-&gt;getClass());
+        if (kind == NULL) {
+            return true;    // object is not under validator control
+        }
+        return kind-&gt;validateAttributeWrite(key, val);
+    }
+    
+    bool ObjectValidator::validateAttributeRead(Object *obj, std::string key) {
+        KindDescriptor *kind = getKindDesc(obj-&gt;getClass());
+        if (kind == NULL) {
+            return true;    // object is not under validator control
+        }
+        return true;
+    }
+
+    void ObjectValidator::scanAttributeElement(DOMElement *attribElement) {
+        std::string name = XMLtoUtf8(attribElement-&gt;getAttribute(Utf8ToXML(&quot;name&quot;).x_str())).c_str();
+        std::string typeName = XMLtoUtf8(attribElement-&gt;getAttribute(Utf8ToXML(&quot;type&quot;).x_str())).c_str();
+        validationType valType;
+        if (typeName == &quot;bool&quot;)
+            valType = VAL_BOOL;
+        else if (typeName == &quot;int&quot;)
+            valType = VAL_INT;
+        else if (typeName == &quot;double&quot;)
+            valType = VAL_DOUBLE;
+        else if (typeName == &quot;nil&quot;)
+            valType = VAL_NIL;
+        else if (typeName == &quot;dir&quot;)
+            valType = VAL_DIR;
+//        else if (typeName == &quot;pos&quot;)
+//            valType = VAL_POS;
+        else if (typeName == &quot;string&quot;)
+            valType = VAL_STRING;
+        else if (typeName == &quot;enum&quot;)
+            valType = VAL_ENUM;
+        else if (typeName == &quot;tokens&quot;)
+            valType = VAL_TOKENS;
+        
+        const XMLCh* defaultAttribute = attribElement-&gt;getAttribute(Utf8ToXML(&quot;default&quot;).x_str());
+        std::string defaultString = XMLtoUtf8(defaultAttribute).c_str();
+        Value defaultValue = parseTypedValue(defaultAttribute, defaultString, valType);
+
+        std::string rwString = XMLtoUtf8(attribElement-&gt;getAttribute(Utf8ToXML(&quot;rw&quot;).x_str())).c_str();
+        bool allowRead = (rwString.find('r') != std::string::npos) ? true : false;
+        bool allowWrite = (rwString.find('w') != std::string::npos) ? true : false;
+        
+        const XMLCh* minAttribute = attribElement-&gt;getAttribute(Utf8ToXML(&quot;min&quot;).x_str());
+        std::string minString = XMLtoUtf8(minAttribute).c_str();
+        Value minVal = parseTypedValue(minAttribute, minString, valType);
+
+        const XMLCh* maxAttribute = attribElement-&gt;getAttribute(Utf8ToXML(&quot;max&quot;).x_str());
+        std::string maxString = XMLtoUtf8(maxAttribute).c_str();
+        Value maxVal = parseTypedValue(maxAttribute, maxString, valType);
+        
+        AttributeDescriptor *attr = new AttributeDescriptor(name, valType, defaultValue, allowRead, allowWrite, minVal, maxVal);
+        defaultAttributes[name] = attr;
+        Log &lt;&lt; &quot;Default Attribute &quot; &lt;&lt; name &lt;&lt; &quot;\n&quot;;
+    }
+    
+    void ObjectValidator::scanMessageElement(DOMElement *msgElement) {
+        std::string name = XMLtoUtf8(msgElement-&gt;getAttribute(Utf8ToXML(&quot;name&quot;).x_str())).c_str();
+        MessageDescriptor *msg = new MessageDescriptor(name);
+        messages[name] = msg;
+//        Log &lt;&lt; &quot;Default Message &quot; &lt;&lt; name &lt;&lt; &quot;\n&quot;;
+    }
+    
+    void ObjectValidator::scanObjectElement(DOMElement *objectElement) {
+        std::string name = XMLtoUtf8(objectElement-&gt;getAttribute(Utf8ToXML(&quot;name&quot;).x_str())).c_str();
+        std::string super = XMLtoUtf8(objectElement-&gt;getAttribute(Utf8ToXML(&quot;super&quot;).x_str())).c_str();
+        int states = XMLString::parseInt(objectElement-&gt;getAttribute(Utf8ToXML(&quot;states&quot;).x_str()));
+        bool isAbstract = boolValue(objectElement-&gt;getAttribute(Utf8ToXML(&quot;abstract&quot;).x_str()));
+        bool isInit = boolValue(objectElement-&gt;getAttribute(Utf8ToXML(&quot;init&quot;).x_str()));
+        
+        KindDescriptor *kd = new KindDescriptor(name, super, isAbstract, states, isInit);
+        kinds[name] = kd;
+        
+        DOMNodeList *elemList;
+        
+        elemList = objectElement-&gt;getElementsByTagName(Utf8ToXML(&quot;msg&quot;).x_str());
+        for (int i = 0, l = elemList-&gt;getLength(); i &lt; l; i++) {
+            DOMElement *msgElem = dynamic_cast&lt;DOMElement *&gt;(elemList-&gt;item(i));
+            kd-&gt;addMessage(XMLtoUtf8(msgElem-&gt;getAttribute(Utf8ToXML(&quot;name&quot;).x_str())).c_str());
+        }
+        
+        elemList = objectElement-&gt;getElementsByTagName(Utf8ToXML(&quot;attr&quot;).x_str());
+        for (int i = 0, l = elemList-&gt;getLength(); i &lt; l; i++) {
+            DOMElement *attrElem = dynamic_cast&lt;DOMElement *&gt;(elemList-&gt;item(i));
+                        
+            std::string name = XMLtoUtf8(attrElem-&gt;getAttribute(Utf8ToXML(&quot;name&quot;).x_str())).c_str();
+            std::string typeName = XMLtoUtf8(attrElem-&gt;getAttribute(Utf8ToXML(&quot;type&quot;).x_str())).c_str();
+            const XMLCh* defaultAttribute = attrElem-&gt;getAttribute(Utf8ToXML(&quot;default&quot;).x_str());
+            std::string defaultString = XMLtoUtf8(defaultAttribute).c_str();
+            std::string rwString = XMLtoUtf8(attrElem-&gt;getAttribute(Utf8ToXML(&quot;rw&quot;).x_str())).c_str();
+            const XMLCh* minAttribute = attrElem-&gt;getAttribute(Utf8ToXML(&quot;min&quot;).x_str());
+            std::string minString = XMLtoUtf8(minAttribute).c_str();
+            const XMLCh* maxAttribute = attrElem-&gt;getAttribute(Utf8ToXML(&quot;max&quot;).x_str());
+            std::string maxString = XMLtoUtf8(maxAttribute).c_str();
+            const XMLCh* valAttribute = attrElem-&gt;getAttribute(Utf8ToXML(&quot;value&quot;).x_str());
+            std::string valString = XMLtoUtf8(valAttribute).c_str();
+
+            if (typeName == &quot;&quot; &amp;&amp; defaultString == &quot;&quot; &amp;&amp; rwString == &quot;&quot; &amp;&amp; minString == &quot;&quot; 
+                    &amp;&amp; maxString == &quot;&quot; &amp;&amp; valString == &quot;&quot;)
+                kd-&gt;addAttribute(name);
+            else {
+                ASSERT(typeName == &quot;&quot;, XFrontend, (&quot;ObjectValidator unsupported retyping of: &quot; + name).c_str());
+                AttributeDescriptor *cloneAttr = kd-&gt;addModifiedAttribute(name);
+                if (rwString != &quot;&quot;) {
+                    cloneAttr-&gt;setReadable((rwString.find('r') != std::string::npos) ? true : false);
+                    cloneAttr-&gt;setWritable((rwString.find('w') != std::string::npos) ? true : false);
+                }
+                validationType valType = cloneAttr-&gt;getType();
+                if (defaultString != &quot;&quot;) {
+                    Value defaultValue = parseTypedValue(defaultAttribute, defaultString, valType);
+                    cloneAttr-&gt;setDefaultValue(defaultValue);
+                }
+                if (minString != &quot;&quot;) {
+                    Value minValue = parseTypedValue(minAttribute, minString, valType);
+                    cloneAttr-&gt;setDefaultValue(minValue);
+                }
+                if (maxString != &quot;&quot;) {
+                    Value maxValue = parseTypedValue(maxAttribute, maxString, valType);
+                    cloneAttr-&gt;setMaxValue(maxValue);
+                }
+                if (maxString != &quot;&quot;) {
+                    Value maxValue = parseTypedValue(maxAttribute, maxString, valType);
+                    cloneAttr-&gt;setMaxValue(maxValue);
+                }
+                if (valString != &quot;&quot;) {
+                    Value value = parseTypedValue(valAttribute, valString, valType);
+                    cloneAttr-&gt;setValue(value);
+                }
+            }
+        }
+        
+        kd-&gt;log();
+    }
+    
+    Value ObjectValidator::parseTypedValue(const XMLCh* xmlSource, const std::string &amp;strSource, validationType type) {
+        if (strSource != &quot;nil&quot;) {
+            switch (type) {
+                case VAL_BOOL :
+                    return Value(boolValue(xmlSource));
+                    break;
+                case VAL_STRING :
+                    return Value(XMLtoUtf8(xmlSource).c_str());
+                case VAL_INT :
+                case VAL_DIR :
+                case VAL_ENUM :
+                    return Value(XMLString::parseInt(xmlSource));
+                    break;
+                case VAL_DOUBLE : {
+                    XMLDouble * result = new XMLDouble(xmlSource);
+                    Value v = result-&gt;getValue();
+                    delete result;
+                    return v;
+                    break;
+                }
+                default :    // nil, tokens default to nil
+                    return Value();
+                    break;
+            }
+        } else
+            return Value();
+    }
+    
+} // namespace enigma
+


Property changes on: trunk/src/ObjectValidator.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/ObjectValidator.hh
===================================================================
--- trunk/src/ObjectValidator.hh	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/ObjectValidator.hh	2008-02-03 19:04:18 UTC (rev 1023)
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+ 
+#ifndef OBJECTVALIDATOR_HH_INCLUDED
+#define OBJECTVALIDATOR_HH_INCLUDED
+
+#include &quot;KindDescriptor.hh&quot;
+#include &quot;AttributeDescriptor.hh&quot;
+#include &quot;MessageDescriptor.hh&quot;
+#include &quot;Object.hh&quot;
+#include &quot;Value.hh&quot;
+#include &lt;list&gt;
+#include &lt;map&gt;
+#include &lt;string&gt;
+#include &lt;xercesc/dom/DOMDocument.hpp&gt;
+#include &lt;xercesc/dom/DOMElement.hpp&gt;
+
+namespace enigma
+{
+    /**
+     * 
+     * - distinguish message vs. attribute names for lua
+     * - ignore unknown messages - free classes from task to block unsupported messages
+     * - rw access check for attributes on behalf of classes
+     * - supply default attribute values if not set
+     * - delete attribute or reset to default on nil setting
+     * - getKind evaluation of special subKind conditions
+     * - isKind checking against arbitrary kind names
+     */
+    class ObjectValidator {
+    public:
+        
+        static ObjectValidator *instance();
+        ~ObjectValidator();
+        void shutdown();
+        
+        KindDescriptor *getKindDesc(std::string name);
+        MessageDescriptor *getMessage(std::string name);
+        bool validateMessage(Object *obj, std::string msg, Value val);
+        AttributeDescriptor *getDefaultAttribute(std::string name);
+        AttributeDescriptor *cloneAttribute(AttributeDescriptor *masterAttr);
+        bool validateAttributeWrite(Object *obj, std::string key, Value val);
+        bool validateAttributeRead(Object *obj, std::string key);
+        
+    protected:
+        ObjectValidator();
+    private:
+        static ObjectValidator *theSingleton;
+        
+        void init();
+        void scanAttributeElement(XERCES_CPP_NAMESPACE_QUALIFIER DOMElement *attribElement);
+        void scanMessageElement(XERCES_CPP_NAMESPACE_QUALIFIER DOMElement *msgElement);
+        void scanObjectElement(XERCES_CPP_NAMESPACE_QUALIFIER DOMElement *objectElement);
+        Value parseTypedValue(const XMLCh* xmlSource, const std::string &amp;strSource, validationType type);
+        
+        std::map&lt;std::string, KindDescriptor *&gt; kinds;
+        std::map&lt;std::string, MessageDescriptor *&gt; messages;
+        std::map&lt;std::string, AttributeDescriptor *&gt; defaultAttributes;
+        std::list&lt;AttributeDescriptor *&gt; otherAttributes;
+        
+        XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument *doc;
+    };
+} // namespace enigma
+#endif
+


Property changes on: trunk/src/ObjectValidator.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/lua.cc
===================================================================
--- trunk/src/lua.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/lua.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -1236,7 +1236,9 @@
     
     if (obj) {   // ignore not existing objects
         try {
-            answer = SendMessage (obj, msg, val);
+            // check if message is valid, otherwise ignore message
+            if (obj-&gt;validateMessage(msg, val))
+                answer = SendMessage (obj, msg, val);
         }
         catch (const XLevelRuntime &amp;e) {
             throwLuaError (L, e.what());
@@ -1455,17 +1457,20 @@
     } else {
         // attribute
         Value val;  // nil
-        if (obj) 
-            val = obj-&gt;getAttr(keyStr);
-        if ((keyStr.find('_') != 0) &amp;&amp; val.isDefault()) {
-            // object exists and no user attribute - no existing system attribute
-            // try to send message
-            messageLIFO.push_back(keyStr);
-            lua_pushcfunction(L, objectDirectMessage);
+        if (obj) {
+            if ((keyStr.find('_') != 0) &amp;&amp;  obj-&gt;validateMessage(keyStr, Value(Value::DEFAULT))) {
+                // it is a valid public message - try to send it
+                messageLIFO.push_back(keyStr);
+                lua_pushcfunction(L, objectDirectMessage);
+            } else {
+                val = obj-&gt;getAttr(keyStr);
+                // user attribute, existing system attribute or nil if no object
+                push_value(L, val);
+            }
         } else {
-            // user attribute, existing system attribute or nil if no object
+            // access of no longer existing object - ignore it and return nil
             push_value(L, val);
-        }
+        } 
         return 1;
     }
     return 0;

Modified: trunk/src/main.cc
===================================================================
--- trunk/src/main.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/main.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -33,6 +33,7 @@
 #include &quot;world.hh&quot;
 #include &quot;nls.hh&quot;
 #include &quot;LocalToXML.hh&quot;
+#include &quot;ObjectValidator.hh&quot;
 #include &quot;PreferenceManager.hh&quot;
 #include &quot;Utf8ToXML.hh&quot;
 #include &quot;XMLtoUtf8.hh&quot;
@@ -368,6 +369,9 @@
     }
 
     lev::Proxy::countLevels();
+    
+    // ----- Object declarations
+    ObjectValidator::instance();    // force early initialization (an optional statement)
 
     // ----- Initialize sound tables -- needs sound, oxyd, video (error messages!)
     sound::InitSoundSets();

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2008-02-02 19:26:52 UTC (rev 1022)
+++ trunk/src/world.cc	2008-02-03 19:04:18 UTC (rev 1023)
@@ -347,10 +347,6 @@
 
 void World::name_object(Object *obj, const std::string &amp;name)
 {
-    Object *old = get_named(name);
-    if (old != NULL)
-        unname(old);
-    
     std::string unique_name = name;
     if (server::EnigmaCompatibility &gt;= 1.10 &amp;&amp; name.size() &gt; 0 &amp;&amp; name[name.size() - 1] == '#') {
         // auto name object with a unique name
@@ -1855,7 +1851,7 @@
     // activate which key hole
     if (src-&gt;getObjectType() == Object::ITEM) {
         ItemID src_id = get_id(dynamic_cast&lt;Item *&gt;(src));
-        if (src_id &gt;= it_key_a &amp;&amp; src_id &lt;= it_key_c &amp;&amp; dst-&gt;is_kind(&quot;st_key&quot;)) {
+        if (src_id &gt;= it_key_a &amp;&amp; src_id &lt;= it_key_c &amp;&amp; dst-&gt;is_kind(&quot;st-key&quot;)) {
             dst-&gt;set_attrib(&quot;keycode&quot;, src-&gt;getAttr(&quot;keycode&quot;));
             return;
         }
@@ -1921,17 +1917,17 @@
     void explosion (GridPos p, ItemID explosion_item)
     {
         if (Stone *stone = GetStone(p))
-            SendMessage(stone, &quot;_explosion&quot;);
+            SendMessage(stone, &quot;expl&quot;);
         if (Item  *item  = GetItem(p)) {
             if (has_flags(item, itf_indestructible))
-                SendMessage(item, &quot;_explosion&quot;);
+                SendMessage(item, &quot;expl&quot;);
             else
                 SetItem(p, explosion_item);
         }
         else
             SetItem(p, explosion_item);
         if (Floor *floor = GetFloor(p))
-            SendMessage(floor, &quot;_explosion&quot;);
+            SendMessage(floor, &quot;expl&quot;);
     }
 }
 
@@ -1972,9 +1968,9 @@
 
         case EXPLOSION_BOMBSTONE:
             if (direct_neighbor) {
-                if (stone) SendMessage(stone, &quot;_bombstone&quot;);
-                if (item) SendMessage(item, &quot;_bombstone&quot;);
-                if (floor) SendMessage(floor, &quot;_bombstone&quot;);
+                if (stone) SendMessage(stone, &quot;bombstone&quot;);
+                if (item) SendMessage(item, &quot;bombstone&quot;);
+                if (floor) SendMessage(floor, &quot;bombstone&quot;);
             }
             break;
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000454.html">[Enigma-game-svn] r1022 - homepage/input
</A></li>
	<LI>Next message: <A HREF="000456.html">[Enigma-game-svn] r1024 - in trunk: lib-src/enigma-core src	src/stones
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#455">[ date ]</a>
              <a href="thread.html#455">[ thread ]</a>
              <a href="subject.html#455">[ subject ]</a>
              <a href="author.html#455">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
