<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1284 - in trunk/data/levels: enigma_iii	enigma_tutorial enigma_vi enigma_vii enigma_viii lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1284%20-%20in%20trunk/data/levels%3A%20enigma_iii%0A%09enigma_tutorial%20enigma_vi%20enigma_vii%20enigma_viii%20lib&In-Reply-To=%3C200808231658.m7NGwuQh022814%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000713.html">
   <LINK REL="Next"  HREF="000715.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1284 - in trunk/data/levels: enigma_iii	enigma_tutorial enigma_vi enigma_vii enigma_viii lib</H1>
    <B>andreasl at mail.berlios.de</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1284%20-%20in%20trunk/data/levels%3A%20enigma_iii%0A%09enigma_tutorial%20enigma_vi%20enigma_vii%20enigma_viii%20lib&In-Reply-To=%3C200808231658.m7NGwuQh022814%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1284 - in trunk/data/levels: enigma_iii	enigma_tutorial enigma_vi enigma_vii enigma_viii lib">andreasl at mail.berlios.de
       </A><BR>
    <I>Sat Aug 23 18:58:56 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000713.html">[Enigma-game-svn] r1283 - in homepage/input: . articles
</A></li>
        <LI>Next message: <A HREF="000715.html">[Enigma-game-svn] r1285 - trunk/doc/reference
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#714">[ date ]</a>
              <a href="thread.html#714">[ thread ]</a>
              <a href="subject.html#714">[ subject ]</a>
              <a href="author.html#714">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: andreasl
Date: 2008-08-23 18:58:35 +0200 (Sat, 23 Aug 2008)
New Revision: 1284

Added:
   trunk/data/levels/enigma_viii/andreas48_2.xml
   trunk/data/levels/lib/liblua.xml
   trunk/data/levels/lib/libmath.xml
Removed:
   trunk/data/levels/enigma_viii/andreas48_1.xml
   trunk/data/levels/lib/libluatools.xml
Modified:
   trunk/data/levels/enigma_iii/andreas04_1.xml
   trunk/data/levels/enigma_iii/index.xml
   trunk/data/levels/enigma_tutorial/a_tut07.xml
   trunk/data/levels/enigma_tutorial/index.xml
   trunk/data/levels/enigma_vi/andreas31_1.xml
   trunk/data/levels/enigma_vi/index.xml
   trunk/data/levels/enigma_vii/andreas46_3.xml
   trunk/data/levels/enigma_vii/index.xml
   trunk/data/levels/enigma_viii/andreas47_1.xml
   trunk/data/levels/enigma_viii/andreas49_1.xml
   trunk/data/levels/enigma_viii/index.xml
   trunk/data/levels/lib/libmap.xml
   trunk/data/levels/lib/libsoko-endphase.xml
   trunk/data/levels/lib/libsoko.xml
Log:
Trunk:
 - Split libluatools into libmath and liblua.
 - Adapt levels to new libraries.
 - New version of &quot;Fashions Pass&quot; (release 2)
Note:
 - libsoko will still not work, due to an API-conflict


Modified: trunk/data/levels/enigma_iii/andreas04_1.xml
===================================================================
--- trunk/data/levels/enigma_iii/andreas04_1.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_iii/andreas04_1.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -3,12 +3,12 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;level&quot;&gt;
       &lt;el:identity el:title=&quot;Laser Castle&quot; el:subtitle=&quot;&quot; el:id=&quot;andreas04&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;released&quot;/&gt;
       &lt;el:author  el:name=&quot;Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2006 Andreas Lochmann&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmap&quot; el:id=&quot;lib/libmap&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;true&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:comments&gt;
@@ -20,8 +20,6 @@
     &lt;el:luamain&gt;&lt;![CDATA[
 -- Originally created with the help of BBE 1.05
 
-isPreview = wo[&quot;CreatingPreview&quot;]
-
 ti[&quot;    &quot;]={&quot;fl-water&quot;}
 ti[&quot;!   &quot;]={&quot;fl-water&quot;}
 ti[&quot;#   &quot;]={&quot;fl-leaves&quot;}
@@ -72,7 +70,7 @@
 ti[&quot; -  &quot;]={&quot;st_laser&quot;, &quot;la_n&quot;, orientation = NORTH, state = OFF}
 ti[&quot; .  &quot;]={&quot;st_laser&quot;, &quot;la_s&quot;, orientation = SOUTH, state = OFF}
 ti[&quot; 0  &quot;]={&quot;st_laser&quot;, &quot;la_e&quot;, orientation = EAST, state = OFF}
-ti[&quot; 5  &quot;]={&quot;st-door-v&quot;, &quot;castle_door&quot;}
+ti[&quot; 5  &quot;]={&quot;st_door&quot;, &quot;castle_door&quot;, faces=&quot;ew&quot;}
 ti[&quot; 6  &quot;]={&quot;st-stoneimpulse-hollow&quot;}
 ti[&quot;  1 &quot;]={&quot;it_trigger&quot;, target = {&quot;fo_a&quot;, &quot;fo_c&quot;}}
 ti[&quot;  2 &quot;]={&quot;it_trigger&quot;, target = {&quot;fo_a&quot;}}
@@ -85,7 +83,11 @@
 ti[&quot;  ' &quot;]={&quot;it-seed&quot;}
 ti[&quot;  ( &quot;]={&quot;it-extralife&quot;}
 ti[&quot;  &amp; &quot;]={&quot;it-document&quot;, text = &quot;text1&quot;}
-ti[&quot;   !&quot;]=luatools.cond(isPreview, {}, {&quot;#ac-blackball&quot;, mouseforce = 1})
+if wo[&quot;CreatingPreview&quot;] then
+  ti[&quot;   !&quot;] = {}
+else
+  ti[&quot;   !&quot;] = {&quot;#ac-blackball&quot;, mouseforce = 1}
+end
 ti[&quot;   #&quot;]={&quot;ac-top&quot;, range = 10, force = 10, gohome = false}
 
 level={&quot;!!!!!!!!!!!!!!!!!!!!&quot;,
@@ -297,7 +299,8 @@
         &quot;             %%)'%  &quot;,
         &quot;              %%%%  &quot;}
 
-map = luatools.fuse_map_layers(level, stmap, itmap, acmap)
+map =   wo:newMap(&quot; &quot;, level) * wo:newMap(&quot; &quot;, stmap)
+      * wo:newMap(&quot; &quot;, itmap) * wo:newMap(&quot; &quot;, acmap)
 w, h = wo(res.composer(ti), &quot;    &quot;, map)
 
 if not wo[&quot;IsDifficult&quot;] then
@@ -306,7 +309,7 @@
 
 wo[&quot;SlopeForce&quot;] = 30
 
-if isPreview then
+if wo[&quot;CreatingPreview&quot;] then
   wo[{4, 11.3}] = {&quot;ac-blackball&quot;}
   wo[&quot;FollowGrid&quot;] = false
   wo[&quot;FollowMethod&quot;] = FOLLOW_SCROLL

Modified: trunk/data/levels/enigma_iii/index.xml
===================================================================
--- trunk/data/levels/enigma_iii/index.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_iii/index.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -69,7 +69,7 @@
     &lt;level _seq=&quot;61&quot; _title=&quot;Fool the Warden&quot; _xpath=&quot;./duffy37_1&quot; author=&quot;Jacob Scott&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;duffy37&quot; rel=&quot;1&quot; rev=&quot;1&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;62&quot; _title=&quot;Don't Touch&quot; _xpath=&quot;./raoul07_2&quot; author=&quot;Raoul Bourquin&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;raoul07&quot; rel=&quot;2&quot; rev=&quot;1&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;63&quot; _title=&quot;Emergency Exit&quot; _xpath=&quot;./ss05_1&quot; author=&quot;Sven Siggelkow&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;ss5&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;64&quot; _title=&quot;Laser Castle&quot; _xpath=&quot;./andreas04_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas04&quot; rel=&quot;1&quot; rev=&quot;3&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;64&quot; _title=&quot;Laser Castle&quot; _xpath=&quot;./andreas04_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas04&quot; rel=&quot;1&quot; rev=&quot;4&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;65&quot; _title=&quot;The Safe&quot; _xpath=&quot;./siegfried77_1&quot; author=&quot;Siegfried Fennig&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;siegfried77&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;66&quot; _title=&quot;Block its way!&quot; _xpath=&quot;./wb05_2&quot; author=&quot;Jon 'WB' Sneyers&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;wb5&quot; rel=&quot;2&quot; rev=&quot;1&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;67&quot; _title=&quot;Bump Ahead&quot; _xpath=&quot;./illmind01_1&quot; author=&quot;illmind&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;illmind01&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;

Modified: trunk/data/levels/enigma_tutorial/a_tut07.xml
===================================================================
--- trunk/data/levels/enigma_tutorial/a_tut07.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_tutorial/a_tut07.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -3,12 +3,12 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;level&quot;&gt;
       &lt;el:identity el:title=&quot;Chess Stones&quot; el:subtitle=&quot;&quot; el:id=&quot;c_tut01&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;2&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;released&quot;/&gt;
       &lt;el:author  el:name=&quot;Raoul Bourquin, ShadowPhrogg32642342, Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2008 Raoul Bourquin, Andreas Lochmann&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:comments&gt;
@@ -74,7 +74,7 @@
   sender:set({target = &quot;&quot;})
 end
 
-trigger_to_doors = luatools.permutation(8)
+trigger_to_doors = lib.math.permutation(8)
 doors = no[&quot;door#*&quot;]
 triggers = no[&quot;trigger#*&quot;]
 

Modified: trunk/data/levels/enigma_tutorial/index.xml
===================================================================
--- trunk/data/levels/enigma_tutorial/index.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_tutorial/index.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -69,7 +69,7 @@
     &lt;level _seq=&quot;61&quot; _title=&quot;Is It Easy?&quot; _xpath=&quot;enigma_i/martin06_1&quot; author=&quot;Martin Hawlisch&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;martin06&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;62&quot; _title=&quot;Beam0r&quot; _xpath=&quot;enigma_ii/peter01_1&quot; author=&quot;Peter Santo&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;peter_001&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;63&quot; _title=&quot;Slalom Skiing&quot; _xpath=&quot;enigma_ii/martin93_1&quot; author=&quot;Martin Hawlisch&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;martin93&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;64&quot; _title=&quot;Chess Stones&quot; _xpath=&quot;./a_tut07&quot; author=&quot;Raoul Bourquin, ShadowPhrogg32642342, Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;c_tut01&quot; rel=&quot;1&quot; rev=&quot;2&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;64&quot; _title=&quot;Chess Stones&quot; _xpath=&quot;./a_tut07&quot; author=&quot;Raoul Bourquin, ShadowPhrogg32642342, Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;c_tut01&quot; rel=&quot;1&quot; rev=&quot;3&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;65&quot; _title=&quot;Bye!&quot; _xpath=&quot;./a_tut06&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;a_tut06&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;66&quot; _title=&quot;Advanced Tutorial&quot; _xpath=&quot;./adv_tutorial&quot; author=&quot;Jacob Scott&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;m_tutor/adv_tutorial&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
   &lt;/levels&gt;

Modified: trunk/data/levels/enigma_vi/andreas31_1.xml
===================================================================
--- trunk/data/levels/enigma_vi/andreas31_1.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_vi/andreas31_1.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -3,12 +3,12 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;level&quot;&gt;
       &lt;el:identity el:title=&quot;Chess, Bugs &amp; Rock'n'Roll&quot; el:subtitle=&quot;&quot; el:id=&quot;andreas31&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;2&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;released&quot;/&gt;
       &lt;el:author  el:name=&quot;Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2006, 2008 Andreas Lochmann&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmap&quot; el:id=&quot;lib/libmap&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:comments&gt;
@@ -142,7 +142,7 @@
         &quot;!                  T                  !&quot;,
         &quot;!!!!#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#!!!!&quot;}
 
-map = luatools.fuse_map_layers(level, stmap, acmap)
+map = wo:newMap(&quot; &quot;, level) * wo:newMap(&quot; &quot;, stmap) * wo:newMap(&quot; &quot;, acmap)
 w, h = wo(res.composer(myresolver), &quot;   &quot;, map)
 
 wo:shuffleOxyd()

Modified: trunk/data/levels/enigma_vi/index.xml
===================================================================
--- trunk/data/levels/enigma_vi/index.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_vi/index.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -52,7 +52,7 @@
     &lt;level _seq=&quot;44&quot; _title=&quot;Dancing on Light Beams&quot; _xpath=&quot;./andreas28_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas28&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;45&quot; _title=&quot;Wormhole Madness!&quot; _xpath=&quot;./edward24_1&quot; author=&quot;Edward&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;edward24&quot; rel=&quot;1&quot; rev=&quot;1&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;46&quot; _title=&quot;Alcatraz&quot; _xpath=&quot;./ralf14_1&quot; author=&quot;Ralf Westram&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;ralf14&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;47&quot; _title=&quot;Chess, Bugs &amp; Rock'n'Roll&quot; _xpath=&quot;./andreas31_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;andreas31&quot; rel=&quot;1&quot; rev=&quot;2&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;47&quot; _title=&quot;Chess, Bugs &amp; Rock'n'Roll&quot; _xpath=&quot;./andreas31_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;andreas31&quot; rel=&quot;1&quot; rev=&quot;3&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;48&quot; _title=&quot;Oiltrace&quot; _xpath=&quot;./raoul25_1&quot; author=&quot;Raoul Bourquin&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;raoul25&quot; rel=&quot;1&quot; rev=&quot;1&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;49&quot; _title=&quot;Simple Space&quot; _xpath=&quot;./ulf02_1&quot; author=&quot;Ulf Stegemann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;20060628ulf002&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;50&quot; _title=&quot;Hot Meditation&quot; _xpath=&quot;./ral08_1&quot; author=&quot;Ronald Lamprecht&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;20060527ral010&quot; rel=&quot;1&quot; rev=&quot;42&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;

Modified: trunk/data/levels/enigma_vii/andreas46_3.xml
===================================================================
--- trunk/data/levels/enigma_vii/andreas46_3.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_vii/andreas46_3.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -3,12 +3,13 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;level&quot;&gt;
       &lt;el:identity el:title=&quot;Tinker, Tailor&quot; el:subtitle=&quot;&quot; el:id=&quot;andreas46&quot;/&gt;
-      &lt;el:version el:score=&quot;2&quot; el:release=&quot;4&quot; el:revision=&quot;4&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:version el:score=&quot;2&quot; el:release=&quot;4&quot; el:revision=&quot;5&quot; el:status=&quot;released&quot;/&gt;
       &lt;el:author el:name=&quot;Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2007 Andreas Lochmann&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/liblua&quot; el:id=&quot;lib/liblua&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;true&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:score el:easy=&quot;2:18&quot; el:difficult=&quot;5:10&quot;/&gt;
@@ -74,7 +75,7 @@
 function connect(obj1, obj2, restrict)
   wo:add({&quot;ot_rubberband&quot;, anchor1 = obj1, anchor2 = obj2,
           strength = strength or maxstrength,
-          max = luatools.cond(restrict and wo[&quot;IsDifficult&quot;], 2.5, nil)})
+          max = lib.lua.cond(restrict and wo[&quot;IsDifficult&quot;], 2.5, nil)})
   -- Save partner of actor: When call_scissors is called, the
   -- rubberband will've already been removed, so [&quot;fellows&quot;]
   -- doesn't work anymore for the marble.
@@ -123,7 +124,7 @@
   pattern_count = pattern_count + 1
   if pattern_count &lt; 8 then
     -- create new permutation with one horse less
-    local p = luatools.cyclic_permutation(8 - pattern_count)
+    local p = lib.math.cyclic_permutation(8 - pattern_count)
     for j = 8 - pattern_count + 1, 8 do
       p[j] = j
     end
@@ -131,7 +132,7 @@
       Goal[fixpoint_permutation[j]] = fixpoint_permutation[p[j]]
     end
     -- create temporary goals for the horses to untangle
-    local TemporaryGoal = luatools.permutation(8)
+    local TemporaryGoal = lib.math.permutation(8)
     for j = 1, 8 do
       no[&quot;parahorse%&quot;..j]:set(
           {destination = {no[&quot;parafloor%&quot;..TemporaryGoal[j]]}})
@@ -162,11 +163,11 @@
   end
 end
 
-Goal = luatools.cyclic_permutation(8)
+Goal = lib.math.cyclic_permutation(8)
 connect(no[&quot;marble&quot;], no[&quot;scissors_central&quot;], true)
 
 if wo[&quot;IsDifficult&quot;] then
-  fixpoint_permutation = luatools.permutation(8)
+  fixpoint_permutation = lib.math.permutation(8)
 else
   fixpoint_permutation = {}
   for j = 1, 8 do

Modified: trunk/data/levels/enigma_vii/index.xml
===================================================================
--- trunk/data/levels/enigma_vii/index.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_vii/index.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -61,7 +61,7 @@
     &lt;level _seq=&quot;53&quot; _title=&quot;Re-entry Circuit&quot; _xpath=&quot;./pulley05_1&quot; author=&quot;Mark Pulley&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;pulley05&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;54&quot; _title=&quot;Not Fast Enough&quot; _xpath=&quot;./jet04_3&quot; author=&quot;James Taylor, Ronald Lamprecht&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;20070413jet001&quot; rel=&quot;3&quot; rev=&quot;3&quot; score=&quot;3&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;55&quot; _title=&quot;Give Way&quot; _xpath=&quot;./just20_1&quot; author=&quot;JuSt&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;just20&quot; rel=&quot;1&quot; rev=&quot;1&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;56&quot; _title=&quot;Give more Way&quot; _xpath=&quot;./just21_2&quot; author=&quot;JuSt&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;just21&quot; rel=&quot;2&quot; rev=&quot;3&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;56&quot; _title=&quot;Give more Way&quot; _xpath=&quot;./just21_2&quot; author=&quot;JuSt&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;just21&quot; rel=&quot;2&quot; rev=&quot;2&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;57&quot; _title=&quot;Give Way 4 two&quot; _xpath=&quot;./just22_2&quot; author=&quot;JuSt&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;just22&quot; rel=&quot;2&quot; rev=&quot;2&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;58&quot; _title=&quot;Lost in Time and Space&quot; _xpath=&quot;./just23_1&quot; author=&quot;JuSt&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;just23&quot; rel=&quot;1&quot; rev=&quot;2&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;59&quot; _title=&quot;Alternatives?&quot; _xpath=&quot;./just24_1&quot; author=&quot;JuSt&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;just24&quot; rel=&quot;1&quot; rev=&quot;1&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
@@ -94,7 +94,7 @@
     &lt;level _seq=&quot;86&quot; _title=&quot;Lady in Red&quot; _xpath=&quot;./just30_1&quot; author=&quot;Just&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;just30&quot; rel=&quot;1&quot; rev=&quot;3&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;87&quot; _title=&quot;Crawling the Abyss&quot; _xpath=&quot;./sph02_1&quot; author=&quot;ShadowPhrogg32642342&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;sph02&quot; rel=&quot;1&quot; rev=&quot;5&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;88&quot; _title=&quot;Bold Boulder&quot; _xpath=&quot;./ral14_1&quot; author=&quot;Ronald Lamprecht&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;20061124ral279&quot; rel=&quot;1&quot; rev=&quot;96&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;89&quot; _title=&quot;Tinker, Tailor&quot; _xpath=&quot;./andreas46_3&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas46&quot; rel=&quot;4&quot; rev=&quot;4&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;89&quot; _title=&quot;Tinker, Tailor&quot; _xpath=&quot;./andreas46_3&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas46&quot; rel=&quot;4&quot; rev=&quot;5&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;90&quot; _title=&quot;Elbow Society&quot; _xpath=&quot;./andreas45_2&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas45&quot; rel=&quot;2&quot; rev=&quot;5&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;91&quot; _title=&quot;Watchmaker&quot; _xpath=&quot;./huesing01_1&quot; author=&quot;Johannes H&#252;sing&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;huesing01&quot; rel=&quot;1&quot; rev=&quot;1&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;92&quot; _title=&quot;Map it out II&quot; _xpath=&quot;./manuel01_1&quot; author=&quot;Manuel Eisentraut&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;manuel01&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;

Modified: trunk/data/levels/enigma_viii/andreas47_1.xml
===================================================================
--- trunk/data/levels/enigma_viii/andreas47_1.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_viii/andreas47_1.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -3,12 +3,12 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;level&quot;&gt;
       &lt;el:identity el:title=&quot;The Show Jumper&quot; el:subtitle=&quot;&quot; el:id=&quot;andreas47&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;released&quot;/&gt;
       &lt;el:author el:name=&quot;Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2008 Andreas Lochmann&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;true&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:score el:easy=&quot;1:06&quot; el:difficult=&quot;3:56&quot;/&gt;
@@ -150,7 +150,7 @@
 for y, line in pairs(floor_plus) do
   for x, ways in pairs(line) do
     if ways &gt;= 0 then
-      local dirs = luatools.digits(ways, 2)
+      local dirs = lib.math.digits(ways, 2)
       local rx, ry = 2*x+y-4, 2*y-x+3
       add_dirs(rx, ry, dirs)
     end
@@ -160,7 +160,7 @@
 for y, line in pairs(floor_percent) do
   for x, ways in pairs(line) do
     if ways &gt;= 0 then
-      local dirs = luatools.digits(ways, 2)
+      local dirs = lib.math.digits(ways, 2)
       local rx, ry = 2*x-y+5, 2*y+x-8
       add_dirs(rx, ry, dirs)
     end

Deleted: trunk/data/levels/enigma_viii/andreas48_1.xml
===================================================================
--- trunk/data/levels/enigma_viii/andreas48_1.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_viii/andreas48_1.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -1,448 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
-&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
-  &lt;el:protected&gt;
-    &lt;el:info el:type=&quot;level&quot;&gt;
-      &lt;el:identity el:title=&quot;Fashions Pass&quot; el:subtitle=&quot;But dynamite is forever&quot; el:id=&quot;andreas48&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;2&quot; el:status=&quot;released&quot;/&gt;
-      &lt;el:author el:name=&quot;Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
-      &lt;el:copyright&gt;Copyright &#169; 2008 Andreas Lochmann&lt;/el:copyright&gt;
-      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
-      &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/natmaze&quot; el:id=&quot;lib/natmaze&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
-      &lt;/el:compatibility&gt;
-      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
-      &lt;el:comments&gt;
-        &lt;el:dedication&gt;Thanks to Nat for his maze-library!&lt;/el:dedication&gt;
-      &lt;/el:comments&gt;
-      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;26:33&quot;/&gt;
-    &lt;/el:info&gt;
-    &lt;el:luamain&gt;&lt;![CDATA[
-
---------------------------------------------
--- CONSTANTS
---------------------------------------------
-
-spot_constants = {SPOT_DEATH,
-                  SPOT_TRAP,
-                  SPOT_SENSOR,
-                  SPOT_ACTORIMPULSE,
-                  SPOT_HOLLOW}
-
-designs =
-  {{&quot;fl-samba&quot;,     &quot;fl-water&quot;, &quot;st-bluegray&quot;,   &quot;st-bluegray_hole&quot;,   OXYD_CYAN},
-   {&quot;fl-rock&quot;,      &quot;fl-abyss&quot;, &quot;st-camouflage&quot;, &quot;st-camouflage_hole&quot;, OXYD_GREEN},
-   {&quot;fl-sahara&quot;,    &quot;fl-abyss&quot;, &quot;st-greenbrown&quot;, &quot;st-greenbrown_hole&quot;, OXYD_YELLOW},
-   {&quot;fl-black&quot;,     &quot;fl-water&quot;, &quot;st-marble&quot;,     &quot;st-marble_hole&quot;,     OXYD_PURPLE},
-   {&quot;fl-bluegreen&quot;, &quot;fl-abyss&quot;, &quot;st-metal&quot;,      &quot;st-metal_hole&quot;,      OXYD_BLUE},
-   {&quot;fl-brick&quot;,     &quot;fl-water&quot;, &quot;st-rock1&quot;,      &quot;st-rock1_hole&quot;,      OXYD_RED},
-   {&quot;fl-gravel&quot;,    &quot;fl-abyss&quot;, &quot;st-rock2&quot;,      &quot;st-rock2_hole&quot;,      OXYD_BLACK},
-   {&quot;fl-metal&quot;,     &quot;fl-water&quot;, &quot;st-rock3&quot;,      &quot;st-rock3_hole&quot;,      OXYD_WHITE}}
-
-vortex_goals = {}
-maze_maps = {}
-mazes = {}
-
---------------------------------------------
--- MOST IMPORTANT RANDOM DECISIONS
---------------------------------------------
-
-design_permutation = luatools.permutation(#designs)
-spot_permutation = luatools.permutation(#spot_constants)
-monoflop_permutation = luatools.permutation(5)
-final_spot_1 = random(2) + 1
-final_spot_2 = random(2) + 3
-wo[&quot;ExtralifeGlasses&quot;] = spot_constants[spot_permutation[1]]
-
---------------------------------------------
--- TILE DEFINITIONS (CENTRAL AND OXYD ROOM)
---------------------------------------------
-
-ti[&quot;  &quot;] = {&quot;fl-water&quot;}
-ti[&quot; 0&quot;] = {&quot;fl-stone&quot;}
-ti[&quot;@0&quot;] = {&quot;#ac-blackball&quot;} .. ti({&quot;fl-stone&quot;, &quot;start_position&quot;})
-ti[&quot;L0&quot;] = {&quot;st_laser&quot;, orientation = EAST, state = ON} .. ti[&quot; 0&quot;]
-ti[&quot;P0&quot;] = {&quot;st_polarswitch&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;v0&quot;] = {&quot;it_vortex&quot;, autoclose = true, state = CLOSED, name = &quot;vortex#&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;M0&quot;] = {&quot;st_monoflop&quot;, target = &quot;monoflop_call&quot;, name = &quot;monoflop#&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;e0&quot;] = {&quot;it_extralife&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;W0&quot;] = {&quot;st_turnstilearm_w&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;S0&quot;] = {&quot;st_turnstilearm_s&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;T0&quot;] = {&quot;st_turnstile&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;B0&quot;] = {&quot;st-stone_break&quot;} .. ti[&quot; 0&quot;]
-ti[&quot;s0&quot;] = {&quot;it-spade&quot;} .. ti[&quot; 0&quot;]
-
-for j = 1, 5 do
-  ti[j..&quot;0&quot;] = {&quot;st_oxyd&quot;, oxydcolor = designs[design_permutation[j]][5]} .. ti[&quot; 0&quot;]
-end
-
-ti[&quot;panel1&quot;] = ti({&quot;st_panel&quot;, cluster = 1}) .. ti[&quot; 0&quot;]
-ti[&quot;panel2&quot;] = ti({&quot;st_panel&quot;, cluster = 2}) .. ti[&quot; 0&quot;]
-ti[&quot;water&quot;] = ti({&quot;fl-water&quot;})
-
---------------------------------------------
--- TILE DEFINITIONS (MAZES)
---------------------------------------------
-
-for j = 1, 5 do
-  local design = designs[design_permutation[j]]
-  local spot = spot_constants[spot_permutation[j]]
-
-  ti[&quot;_&quot;..j] = ti({design[1]})
-
-  if spot == SPOT_SENSOR then
-    ti[&quot; &quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;it_blocker&quot;, name = &quot;sensor_door#&quot;})
-  else
-    ti[&quot; &quot;..j] = ti[&quot;_&quot;..j]
-  end
-  
-  if spot == SPOT_ACTORIMPULSE then
-    ti[&quot;#&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[2]})
-  else
-    ti[&quot;#&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[3]})
-  end
-  
-  if spot == SPOT_HOLLOW then
-    ti[&quot;.&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[4]})
-  else
-    ti[&quot;.&quot;..j] = ti[&quot;_&quot;..j]
-  end
-
-  if spot == SPOT_DEATH then
-    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;st_death&quot;, invisible = true})
-  elseif spot == SPOT_TRAP then
-    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;it_trap&quot;})
-  elseif spot == SPOT_SENSOR then
-    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j]
-      .. ti({&quot;it_sensor&quot;, invisible = true, action = &quot;close&quot;, target = &quot;sensor_door#*&quot;})
-  elseif spot == SPOT_ACTORIMPULSE then
-    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;st_actorimpulse&quot;, invisible = true, strength = 1000})
-  elseif spot == SPOT_HOLLOW then
-    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[4]}) .. ti({&quot;it-booze-broken&quot;})
-  end
-
-  if spot == SPOT_SENSOR then
-    ti[&quot;g&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;it_sensor&quot;, target = &quot;sensor_door#*&quot;,
-                   action = &quot;open&quot;})
-  else
-    ti[&quot;g&quot;..j] = ti[&quot;_&quot;..j]
-  end
-  
-  ti[&quot;M&quot;..j] = {&quot;st_monoflop&quot;, target = &quot;vortex_&quot;..spot,
-                 action_1 = &quot;open&quot;, action_0 = &quot;close&quot;} .. ti[&quot;_&quot;..j]
-  ti[&quot;v&quot;..j] = {&quot;it_vortex&quot;, autoclose = true, state = CLOSED,
-                 name = &quot;vortex_&quot;..spot, destination = &quot;start_position&quot;} .. ti[&quot;_&quot;..j]
-  ti[&quot;O&quot;..j] = {&quot;st_oxyd&quot;, oxydcolor = design[5]} .. ti[&quot;_&quot;..j]
-  ti[&quot;d&quot;..j] = {&quot;it-dynamite&quot;} .. ti[&quot;_&quot;..j]
-  ti[&quot;G&quot;..j] = {&quot;it_glasses&quot;, state = spot_constants[spot_permutation[(j%5) + 1]]}
-               .. ti[&quot;_&quot;..j]
-  ti[&quot;H&quot;..j] = {&quot;it_glasses&quot;, state = spot_constants[spot_permutation[((j+1)%5) + 1]]}
-               .. ti[&quot;_&quot;..j]
-  ti[&quot;E&quot;..j] = {&quot;it_extralife&quot;} .. ti[&quot;_&quot;..j]
-  ti[&quot;A&quot;..j] = {&quot;st_oneway&quot;, orientation = EAST} .. ti[&quot;_&quot;..j]
-  ti[&quot;-&quot;..j] = ti[&quot; 0&quot;]
-
-  if (j == 4) or (j == 5) then
-    ti[&quot;+&quot;..j] = ti[&quot;#&quot;..j]
-    ti[&quot;k&quot;..j] = ti[&quot;_&quot;..j]
-    ti[&quot;D&quot;..j] = ti[&quot;_&quot;..j] .. {&quot;st_blocker&quot;, &quot;keydoor&quot;..j}
-  else
-    ti[&quot;+&quot;..j] = ti[&quot;_&quot;..j]
-    ti[&quot;K&quot;..j] = ti[&quot;_&quot;..j]
-    ti[&quot;D&quot;..j] = ti[&quot;_&quot;..j]
-  end
-end    
-
-ti[&quot;k1&quot;] = ti[&quot;_1&quot;] .. {&quot;it_floppy&quot;}
-ti[&quot;k2&quot;] = ti[&quot;_2&quot;] .. {&quot;it_key&quot;, code = &quot;good_key&quot;}
-ti[&quot;k3&quot;] = ti[&quot;_3&quot;] .. {&quot;it_key&quot;, code = &quot;bad_key&quot;}
-ti[&quot;K4&quot;] = ti[&quot;_4&quot;] .. {&quot;st_floppy&quot;, target = &quot;keydoor4&quot;}
-ti[&quot;K5&quot;] = ti[&quot;_5&quot;] .. {&quot;st_key&quot;, code = &quot;good_key&quot;, target = &quot;keydoor5&quot;}
-
---------------------------------------------
--- RESOLVER (RANDOM ELEMENTS)
---------------------------------------------
-
-panel_randomicity = {[&quot;~&quot;] = 15, [&quot;%&quot;] = 2, [&quot;$&quot;] = 1}
-
-function main_resolver(key, x, y)
-  local mainkey = string.sub(key, 1, 1)
-  local number = tonumber(string.sub(key, 2, 2))
-  if panel_randomicity[mainkey] then
-    if random(panel_randomicity[mainkey]) == 1 then
-      return ti[&quot;panel&quot;..random(2)]
-    else
-      return ti[&quot;water&quot;]
-    end
-  elseif mainkey == &quot;*&quot; and random(3) == 1 then
-    return ti[&quot;#&quot;..number]
-  elseif mainkey == &quot;.&quot; and random(3) == 1 then
-    return ti[&quot;_&quot;..number]
-  elseif mainkey == &quot;g&quot; then
-    table.insert(vortex_goals, po({x + 0.5, y + 0.5}))
-    return ti[&quot;g&quot;..number]
-  end
-  return ti[key]
-end
-
---------------------------------------------
--- MAP AND MAZE TOOLS
---------------------------------------------
-
-function replace_key_in_map(j, oldkey, newkey, pos)
-  if luatools.get_key_in_map(maze_maps[j], oldkey, pos) == oldkey then
-    maze_maps[j] = luatools.insert_key_in_map(maze_maps[j], newkey, pos)
-  end
-end
-
-function glue_maze_into_map(j, maze, height, width, offset)
-  for y = 0, height - 1 do
-    for x = 0, width - 1 do
-      local pos = 2*po({x, y}) + offset
-      local east = luatools.cond(maze:can_go_east(x,y), &quot;.&quot;, &quot;*&quot;)
-      local south = luatools.cond(maze:can_go_south(x,y), &quot;.&quot;, &quot;*&quot;)
-      replace_key_in_map(j, &quot; &quot;, east,  pos + {1,0})
-      replace_key_in_map(j, &quot; &quot;, south, pos + {0,1})
-      replace_key_in_map(j, &quot; &quot;, &quot;#&quot;,   pos + {1,1})
-    end
-  end
-end
-
---------------------------------------------
--- CENTRAL ROOM
---------------------------------------------
-
-central_room = {
--- |        ++        |        ++        |        ++        |
-  &quot;~~~~~~~%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%$&quot;,
-  &quot;~~~~~%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%$$&quot;,
-  &quot;~~~%%%%     %%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%%%%$$&quot;,
-  &quot;~~%%%   M v    %%%%%~~~~%%%%%%%%%%~~~~~~~~~~%%%%%%%%%$$$$&quot;,
-  &quot;~~%%  v     M    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$&quot;,
-  &quot;~~%%               %%%%%%%      %%%%%%%%%%%%%%%%%$WT $$$$&quot;,
-  &quot;~~%% M   @    v             LP                     S     &quot;,
-  &quot;~~%%               %%%%%%%      %%%%%%%%%%%%%%%%%$$$$$$$$&quot;,
-  &quot;~~%%  v     M    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$&quot;,
-  &quot;~~%%%   M v    %%%%%~~~~%%%%%%%%%%~~~~~~~~~~%%%%%%%%%$$$$&quot;,
-  &quot;~~~%%%%     %%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%%%%$$&quot;,
-  &quot;~~~~~%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%$$&quot;,
-  &quot;~~~~~~~%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%$&quot;}
-
---------------------------------------------
--- FIRST FIVE MAZES
---------------------------------------------
-
-maze_map = {
-&quot;###O################################O##&quot;,
-&quot;#_____                             ___#&quot;,
-&quot;#_M___                             _d_O&quot;,
-&quot;O__v__                             ___#&quot;,
-&quot;#___g_                                #&quot;,
-&quot;#_____                                #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                     #&quot;,
-&quot;#                                _____#&quot;,
-&quot;#                                _++D+#&quot;,
-&quot;#___                             _+k__O&quot;,
-&quot;O_d_                             _K___#&quot;,
-&quot;#___                             _+___#&quot;,
-&quot;##O################################O###&quot;}
-
-maze_width = 19
-maze_height = 12
-maze_offset = po({2, 2})
-
-for j = 1, 5 do
-  mazes[j] = new_kruskal_maze(maze_width, maze_height)
-end
-
-for j = 1, 5 do
-  maze_maps[j] = luatools.deep_copy(maze_map)
-  glue_maze_into_map(j, mazes[j], maze_height, maze_width, maze_offset)
-  local glasses1 = po({5 + random(9), 5 + random(3)})
-  local glasses2, extralife
-  repeat
-    glasses2 = po({5 + random(9), 5 + random(3)})
-  until glasses2 ~= glasses1
-  repeat
-    extralife = po({5 + random(9), 5 + random(3)})
-  until (extralife ~= glasses1) and (extralife ~= glasses2)
-  replace_key_in_map(j, &quot; &quot;, &quot;G&quot;, 2*glasses1 + maze_offset)
-  replace_key_in_map(j, &quot; &quot;, &quot;H&quot;, 2*glasses2 + maze_offset)
-  replace_key_in_map(j, &quot; &quot;, &quot;E&quot;, 2*extralife + maze_offset)
-  if random(2) == 1 then
-    maze_maps[j] = luatools.mirror_map_vertically(maze_maps[j])
-  end
-  if random(2) == 1 then
-    maze_maps[j] = luatools.mirror_map_horizontally(maze_maps[j], 1)
-  end
-  local number_field = {}
-  for y = 1, #maze_map do
-    number_field[y] = string.rep(&quot;&quot;..j, string.len(maze_map[y]))
-  end  
-  maze_maps[j] = luatools.fuse_map_layers(maze_maps[j], number_field)
-end
-
---------------------------------------------
--- FINAL MAZE
---------------------------------------------
-
-fmaze_width = 19 * 2 - 1
-fmaze_height = 12 * 2 - 1
-fmaze_offset = po({3, 3})
-
--- frame
-maze_maps[6] = {string.rep(&quot;$&quot;, fmaze_width * 2 + 3)}
-table.insert(maze_maps[6], maze_maps[6][1])
-for j = 1, fmaze_height * 2 - 1 do
-  table.insert(maze_maps[6], &quot;$$&quot; .. string.rep(&quot; &quot;, fmaze_width * 2 - 1) .. &quot;$$&quot;)
-end
-table.insert(maze_maps[6], maze_maps[6][1])
-table.insert(maze_maps[6], maze_maps[6][1])
-
--- oneway entry and exit
-replace_key_in_map(6, &quot;$&quot;, &quot;-&quot;, {1, 7})
-replace_key_in_map(6, &quot;$&quot;, &quot;A&quot;, {2, 7})
-replace_key_in_map(6, &quot;$&quot;, &quot;-&quot;, {fmaze_width * 2 + 2, fmaze_height * 2 - 3})
-replace_key_in_map(6, &quot;$&quot;, &quot;-&quot;, {fmaze_width * 2 + 3, fmaze_height * 2 - 3})
-
--- water/panel holes
-local radius = {}
-local position = {}
-for h = 1, 5 do
-  local tries = 0
-  repeat
-    radius[h] = 5 + random(5)
-    position[h] = po({radius[h] + 2 + random(2*fmaze_width - 1 - 2*(radius[h] + 2)),
-                      radius[h] + 2 + random(2*fmaze_height - 1 - 2*(radius[h] + 2))})
-    local correct = true
-    for j = 1, h - 1 do
-      local delta = position[h] - position[j]
-      local joined_radius = radius[h] + radius[j] + 2
-      correct = correct and
-        (delta.x*delta.x + delta.y*delta.y &gt; joined_radius * joined_radius)
-    end
-    tries = tries + 1
-  until correct or (tries &gt; 100)
-end
-for h = 1, #radius do
-  for y = -radius[h], radius[h] do
-    for x = -radius[h], radius[h] do
-      local distsqr = x*x + y*y
-      if distsqr &lt;= (radius[h] - 3) * (radius[h] - 3) then
-        replace_key_in_map(6, &quot;$&quot;, &quot;%&quot;, position[h] + {x, y})
-        replace_key_in_map(6, &quot;_&quot;, &quot;%&quot;, position[h] + {x, y})
-        replace_key_in_map(6, &quot; &quot;, &quot;%&quot;, position[h] + {x, y})
-      elseif distsqr &lt;= (radius[h] - 1.5) * (radius[h] - 1.5) then
-        replace_key_in_map(6, &quot;_&quot;, &quot;$&quot;, position[h] + {x, y})
-        replace_key_in_map(6, &quot; &quot;, &quot;$&quot;, position[h] + {x, y})
-      elseif distsqr &lt;= radius[h] * radius[h] then
-        replace_key_in_map(6, &quot; &quot;, &quot;-&quot;, position[h] + {x, y})
-      end
-    end
-  end
-end
-
--- maze
-fmaze = new_kruskal_maze(fmaze_width, fmaze_height)
-glue_maze_into_map(6, fmaze, fmaze_height, fmaze_width, fmaze_offset)
-
--- numbers
-local number_field = {}
-for y = 1, #maze_maps[6] do
-  number_field[y] = &quot;&quot;
-  for x = 1, string.len(maze_maps[6][y]) do
-    number_field[y] = number_field[y]
-      .. luatools.cond(math.floor(x/5)%2 == math.floor(y/5)%2, final_spot_1, final_spot_2)
-  end
-end
-maze_maps[6] = luatools.fuse_map_layers(maze_maps[6], number_field)
-
---------------------------------------------
--- OXYD ROOM
---------------------------------------------
-
-oxyd_room = {
--- |        ++        |
-   &quot;$%%%%%%%~~%%%~~~~~~&quot;,
-   &quot;$%%%%%%%%%%3%%%%~~~&quot;,
-   &quot;$$%%%%%%2%%B%%4%%%%&quot;,
-   &quot;$$%%%1%%B%   %B%%5%&quot;,
-   &quot;$$$%%B%         %B%&quot;,
-   &quot;$$$%%    $$$$$    %&quot;,
-   &quot;  s     $$$$$$$   %&quot;,
-   &quot;$$$%%    $$$$$    %&quot;,
-   &quot;$$$%%B%         %B%&quot;,
-   &quot;$$%%%5%%B%   %B%%1%&quot;,
-   &quot;$$%%%%%%4%%B%%2%%%%&quot;,
-   &quot;$%%%%%%%%%%3%%%%~~~&quot;,
-   &quot;$%%%%%%%~~%%%~~~~~~&quot;}
-
---------------------------------------------
--- FUSING, GLUING AND CREATING THE WORLD
---------------------------------------------
-
--- prepare central room
-local central_number_field = {}
-for y = 1, #central_room do
-  central_number_field[y] = string.rep(&quot;0&quot;, string.len(central_room[y]))
-end
-central_room = luatools.fuse_map_layers(central_room, central_number_field)
-
--- prepare oxyd room
-for j = 1, 3*12 do
-  table.insert(oxyd_room, 1, &quot;&quot;)
-end
-local oxyd_number_field = {}
-for y = 1, #oxyd_room do
-  oxyd_number_field[y] = string.rep(&quot;0&quot;, string.len(oxyd_room[y]))
-end
-oxyd_room = luatools.fuse_map_layers(oxyd_room, oxyd_number_field)
-
--- glue together
-local xspacing = {string.rep(&quot; &quot;, 2*18)}
-local yspacing = {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;} -- 11 times
-
-map1 = luatools.concat_maps_vertically(maze_maps[1], yspacing, maze_maps[2])
-map2 = luatools.concat_maps_vertically(maze_maps[3], yspacing, maze_maps[4])
-map3 = luatools.concat_maps_vertically(central_room, yspacing, maze_maps[5])
-whole_map = luatools.concat_maps_horizontally(
-    map1, xspacing, map2, xspacing, map3, maze_maps[6], oxyd_room)
-
-w, h = wo(main_resolver, &quot;  &quot;, whole_map)
-
-print (&quot;Width: &quot;..w..&quot;, Height: &quot;..h..&quot;, Total: &quot;..w*h)
-
---------------------------------------------
--- MONOFLOP-VORTEX CABLING
---------------------------------------------
-
-for j = 1, 5 do
-  no[&quot;monoflop#*&quot;][j][&quot;_mynumber&quot;] = monoflop_permutation[j]
-  no[&quot;vortex#*&quot;][j][&quot;destination&quot;] = vortex_goals[j]
-end
-
-function monoflop_call(onoff, sender)
-  local myvortex = no[&quot;vortex#*&quot;][sender[&quot;_mynumber&quot;]]
-  myvortex:message(luatools.cond(onoff == true, &quot;open&quot;, &quot;close&quot;))
-end
-
-    ]]&gt;&lt;/el:luamain&gt;
-    &lt;el:i18n&gt;
-      &lt;el:string el:key=&quot;title&quot;&gt;
-        &lt;el:english el:translate=&quot;false&quot;/&gt;
-      &lt;/el:string&gt;
-    &lt;/el:i18n&gt;
-  &lt;/el:protected&gt;
-&lt;/el:level&gt;

Copied: trunk/data/levels/enigma_viii/andreas48_2.xml (from rev 1281, trunk/data/levels/enigma_viii/andreas48_1.xml)
===================================================================
--- trunk/data/levels/enigma_viii/andreas48_1.xml	2008-08-22 01:09:49 UTC (rev 1281)
+++ trunk/data/levels/enigma_viii/andreas48_2.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -0,0 +1,450 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
+&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
+  &lt;el:protected&gt;
+    &lt;el:info el:type=&quot;level&quot;&gt;
+      &lt;el:identity el:title=&quot;Fashions Pass&quot; el:subtitle=&quot;But dynamite is forever&quot; el:id=&quot;andreas48&quot;/&gt;
+      &lt;el:version el:score=&quot;2&quot; el:release=&quot;2&quot; el:revision=&quot;3&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:author el:name=&quot;Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
+      &lt;el:copyright&gt;Copyright &#169; 2008 Andreas Lochmann&lt;/el:copyright&gt;
+      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
+      &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
+        &lt;el:dependency el:path=&quot;lib/natmaze&quot; el:id=&quot;lib/natmaze&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/liblua&quot; el:id=&quot;lib/liblua&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmap&quot; el:id=&quot;lib/libmap&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+      &lt;/el:compatibility&gt;
+      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
+      &lt;el:comments&gt;
+        &lt;el:dedication&gt;Thanks to Nat for his maze-library!&lt;/el:dedication&gt;
+      &lt;/el:comments&gt;
+      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;21:06&quot;/&gt;
+    &lt;/el:info&gt;
+    &lt;el:luamain&gt;&lt;![CDATA[
+
+--------------------------------------------
+-- CONSTANTS
+--------------------------------------------
+
+spot_constants = {SPOT_DEATH,
+                  SPOT_TRAP,
+                  SPOT_SENSOR,
+                  SPOT_ACTORIMPULSE,
+                  SPOT_HOLLOW}
+
+designs =
+  {{&quot;fl-samba&quot;,     &quot;fl-water&quot;, &quot;st-bluegray&quot;,   &quot;st-bluegray_hole&quot;,   OXYD_CYAN},
+   {&quot;fl-rock&quot;,      &quot;fl-abyss&quot;, &quot;st-camouflage&quot;, &quot;st-camouflage_hole&quot;, OXYD_GREEN},
+   {&quot;fl-sahara&quot;,    &quot;fl-abyss&quot;, &quot;st-greenbrown&quot;, &quot;st-greenbrown_hole&quot;, OXYD_YELLOW},
+   {&quot;fl-black&quot;,     &quot;fl-water&quot;, &quot;st-marble&quot;,     &quot;st-marble_hole&quot;,     OXYD_PURPLE},
+   {&quot;fl-bluegreen&quot;, &quot;fl-abyss&quot;, &quot;st-metal&quot;,      &quot;st-metal_hole&quot;,      OXYD_BLUE},
+   {&quot;fl-brick&quot;,     &quot;fl-water&quot;, &quot;st-rock1&quot;,      &quot;st-rock1_hole&quot;,      OXYD_RED},
+   {&quot;fl-gravel&quot;,    &quot;fl-abyss&quot;, &quot;st-rock2&quot;,      &quot;st-rock2_hole&quot;,      OXYD_BLACK},
+   {&quot;fl-metal&quot;,     &quot;fl-water&quot;, &quot;st-rock3&quot;,      &quot;st-rock3_hole&quot;,      OXYD_WHITE}}
+
+vortex_goals = {}
+maze_maps = {}
+mazes = {}
+
+--------------------------------------------
+-- MOST IMPORTANT RANDOM DECISIONS
+--------------------------------------------
+
+design_permutation = lib.math.permutation(#designs)
+spot_permutation = lib.math.permutation(#spot_constants)
+monoflop_permutation = lib.math.permutation(5)
+final_spot_1 = random(2) + 1
+final_spot_2 = random(2) + 3
+wo[&quot;ExtralifeGlasses&quot;] = spot_constants[spot_permutation[1]]
+
+--------------------------------------------
+-- TILE DEFINITIONS (CENTRAL AND OXYD ROOM)
+--------------------------------------------
+
+ti[&quot;  &quot;] = {&quot;fl-water&quot;}
+ti[&quot; 0&quot;] = {&quot;fl-stone&quot;, friction = 3.0, adhesion = 3.0}
+ti[&quot;@0&quot;] = {&quot;#ac-blackball&quot;} .. ti({&quot;fl-stone&quot;, &quot;start_position&quot;})
+ti[&quot;L0&quot;] = {&quot;st_laser&quot;, orientation = EAST, state = ON} .. ti[&quot; 0&quot;]
+ti[&quot;P0&quot;] = {&quot;st_polarswitch&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;v0&quot;] = {&quot;it_vortex&quot;, &quot;vortex#&quot;, autoclose = true, state = CLOSED} .. ti[&quot; 0&quot;]
+ti[&quot;M0&quot;] = {&quot;st_monoflop&quot;, &quot;monoflop#&quot;, action = &quot;signal&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;e0&quot;] = {&quot;it_extralife&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;f0&quot;] = {&quot;it-flagblack&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;W0&quot;] = {&quot;st_turnstilearm_w&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;S0&quot;] = {&quot;st_turnstilearm_s&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;T0&quot;] = {&quot;st_turnstile&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;B0&quot;] = {&quot;st-stone_break&quot;} .. ti[&quot; 0&quot;]
+ti[&quot;s0&quot;] = {&quot;it-spade&quot;} .. ti[&quot; 0&quot;]
+
+for j = 1, 5 do
+  ti[j..&quot;0&quot;] = {&quot;st_oxyd&quot;, oxydcolor = designs[design_permutation[j]][5]} .. ti[&quot; 0&quot;]
+end
+
+ti[&quot;panel1&quot;] = ti({&quot;st_panel&quot;, cluster = 1}) .. ti[&quot; 0&quot;]
+ti[&quot;panel2&quot;] = ti({&quot;st_panel&quot;, cluster = 2}) .. ti[&quot; 0&quot;]
+ti[&quot;water&quot;] = ti({&quot;fl-water&quot;})
+
+--------------------------------------------
+-- TILE DEFINITIONS (MAZES)
+--------------------------------------------
+
+for j = 1, 5 do
+  local design = designs[design_permutation[j]]
+  local spot = spot_constants[spot_permutation[j]]
+
+  ti[&quot;_&quot;..j] = ti({design[1]})
+
+  if spot == SPOT_SENSOR then
+    ti[&quot; &quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;it_blocker&quot;, &quot;sensor_door#&quot;})
+  else
+    ti[&quot; &quot;..j] = ti[&quot;_&quot;..j]
+  end
+  
+  if spot == SPOT_ACTORIMPULSE then
+    ti[&quot;#&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[2]})
+  else
+    ti[&quot;#&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[3]})
+  end
+  
+  if spot == SPOT_HOLLOW then
+    ti[&quot;.&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[4]})
+  else
+    ti[&quot;.&quot;..j] = ti[&quot;_&quot;..j]
+  end
+
+  if spot == SPOT_DEATH then
+    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;st_death&quot;, invisible = true})
+  elseif spot == SPOT_TRAP then
+    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;it_trap&quot;})
+  elseif spot == SPOT_SENSOR then
+    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j]
+      .. ti({&quot;it_sensor&quot;, invisible = true, action = &quot;close&quot;, target = &quot;sensor_door#*&quot;})
+  elseif spot == SPOT_ACTORIMPULSE then
+    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;st_actorimpulse&quot;, invisible = true, strength = 1000})
+  elseif spot == SPOT_HOLLOW then
+    ti[&quot;*&quot;..j] = ti[&quot;_&quot;..j] .. ti({design[4]}) .. ti({&quot;it-booze-broken&quot;})
+  end
+
+  if spot == SPOT_SENSOR then
+    ti[&quot;g&quot;..j] = ti[&quot;_&quot;..j] .. ti({&quot;it_sensor&quot;, target = &quot;sensor_door#*&quot;,
+                   action = &quot;open&quot;})
+  else
+    ti[&quot;g&quot;..j] = ti[&quot;_&quot;..j]
+  end
+  
+  ti[&quot;M&quot;..j] = {&quot;st_monoflop&quot;, target = &quot;vortex_&quot;..spot, action = &quot;signal&quot;} .. ti[&quot;_&quot;..j]
+  ti[&quot;v&quot;..j] = {&quot;it_vortex&quot;, &quot;vortex_&quot;..spot, autoclose = true, state = CLOSED,
+                 destination = &quot;start_position&quot;} .. ti[&quot;_&quot;..j]
+  ti[&quot;O&quot;..j] = {&quot;st_oxyd&quot;, oxydcolor = design[5]} .. ti[&quot;_&quot;..j]
+  ti[&quot;d&quot;..j] = {&quot;it-dynamite&quot;} .. ti[&quot;_&quot;..j]
+  ti[&quot;G&quot;..j] = {&quot;it_glasses&quot;, state = spot_constants[spot_permutation[(j%5) + 1]]}
+               .. ti[&quot;_&quot;..j]
+  ti[&quot;H&quot;..j] = {&quot;it_glasses&quot;, state = spot_constants[spot_permutation[((j+1)%5) + 1]]}
+               .. ti[&quot;_&quot;..j]
+  ti[&quot;E&quot;..j] = {&quot;it_extralife&quot;} .. ti[&quot;_&quot;..j]
+  ti[&quot;A&quot;..j] = {&quot;st_oneway&quot;, orientation = EAST} .. ti[&quot;_&quot;..j]
+  ti[&quot;-&quot;..j] = ti[&quot; 0&quot;]
+
+  if (j == 4) then
+    ti[&quot;+&quot;..j] = ti[&quot;#&quot;..j]
+    ti[&quot;k&quot;..j] = ti[&quot;_&quot;..j]
+    ti[&quot;D&quot;..j] = ti[&quot;_&quot;..j] .. {&quot;st_blocker&quot;, &quot;keydoor&quot;..j}
+    ti[&quot;L&quot;..j] = ti[&quot;#&quot;..j]
+    ti[&quot;N&quot;..j] = ti[&quot;#&quot;..j]
+  elseif j == 5 then
+    ti[&quot;+&quot;..j] = ti[&quot;#&quot;..j]
+    ti[&quot;k&quot;..j] = ti[&quot;_&quot;..j]
+    ti[&quot;D&quot;..j] = ti[&quot;_&quot;..j] .. {&quot;st_blocker&quot;, &quot;keydoor&quot;..j}
+    ti[&quot;K&quot;..j] = ti[&quot;#&quot;..j]
+  else
+    ti[&quot;+&quot;..j] = ti[&quot;_&quot;..j]
+    ti[&quot;K&quot;..j] = ti[&quot;_&quot;..j]
+    ti[&quot;D&quot;..j] = ti[&quot;_&quot;..j]
+    ti[&quot;L&quot;..j] = ti[&quot;_&quot;..j]
+    ti[&quot;N&quot;..j] = ti[&quot;_&quot;..j]
+  end
+end    
+
+ti[&quot;k1&quot;] = ti[&quot;_1&quot;] .. {&quot;it_floppy&quot;}
+ti[&quot;k2&quot;] = ti[&quot;_2&quot;] .. {&quot;it_key&quot;, code = &quot;good_key&quot;}
+ti[&quot;k3&quot;] = ti[&quot;_3&quot;] .. {&quot;it_key&quot;, code = &quot;bad_key&quot;}
+ti[&quot;K4&quot;] = ti[&quot;_4&quot;] .. {&quot;st_floppy&quot;, target = &quot;keydoor4&quot;}
+ti[&quot;N5&quot;] = ti[&quot;_5&quot;] .. {&quot;st_key&quot;, code = &quot;good_key&quot;, target = &quot;key_call&quot;}
+ti[&quot;L5&quot;] = ti[&quot;_5&quot;] .. {&quot;st_key&quot;, code = &quot;bad_key&quot;, target = &quot;key_call&quot;}
+
+--------------------------------------------
+-- RESOLVER (RANDOM ELEMENTS)
+--------------------------------------------
+
+panel_randomicity = {[&quot;~&quot;] = 20, [&quot;%&quot;] = 70, [&quot;$&quot;] = 100} -- in percent
+
+function main_resolver(key, x, y)
+  local mainkey = string.sub(key, 1, 1)
+  local number = tonumber(string.sub(key, 2, 2))
+  if panel_randomicity[mainkey] then
+    if random(100) &lt;= panel_randomicity[mainkey] then
+      return ti[&quot;panel&quot;..random(2)]
+    else
+      return ti[&quot;water&quot;]
+    end
+  elseif mainkey == &quot;*&quot; and random(3) == 1 then
+    return ti[&quot;#&quot;..number]
+  elseif mainkey == &quot;.&quot; and random(3) == 1 then
+    return ti[&quot;_&quot;..number]
+  elseif mainkey == &quot;g&quot; then
+    table.insert(vortex_goals, po({x + 0.5, y + 0.5}))
+    return ti[&quot;g&quot;..number]
+  end
+  return ti[key]
+end
+
+--------------------------------------------
+-- MAP AND MAZE TOOLS
+--------------------------------------------
+
+function replace_key_in_map(j, oldkey, newkey, pos)
+  if maze_maps[j][po(pos) - {1,1}] == oldkey then
+    maze_maps[j][po(pos) - {1,1}] = newkey
+  end
+end
+
+function glue_maze_into_map(j, maze, height, width, offset)
+  for y = 0, height - 1 do
+    for x = 0, width - 1 do
+      local pos = 2*po({x, y}) + offset
+      local east = lib.lua.cond(maze:can_go_east(x,y), &quot;.&quot;, &quot;*&quot;)
+      local south = lib.lua.cond(maze:can_go_south(x,y), &quot;.&quot;, &quot;*&quot;)
+      replace_key_in_map(j, &quot; &quot;, east,  pos + {1,0})
+      replace_key_in_map(j, &quot; &quot;, south, pos + {0,1})
+      replace_key_in_map(j, &quot; &quot;, &quot;#&quot;,   pos + {1,1})
+    end
+  end
+end
+
+--------------------------------------------
+-- CENTRAL ROOM
+--------------------------------------------
+
+central_room = wo:newMap(&quot; &quot;, {
+-- |        ++        |        ++        |        ++        |
+  &quot;~~~~~~~%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%$&quot;,
+  &quot;~~~~~%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%$$&quot;,
+  &quot;~~~%%%%     %%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%%%%$$&quot;,
+  &quot;~~%%%   M v    %%%%%~~~~%%%%%%%%%%~~~~~~~~~~%%%%%%%%%$$$$&quot;,
+  &quot;~~%%  v     M    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$&quot;,
+  &quot;~~%%               %%%%%%%      %%%%%%%%%%%%%%%%%$WT $$$$&quot;,
+  &quot;~~%% M   @    v             LP                     S     &quot;,
+  &quot;~~%%               %%%%%%%      %%%%%%%%%%%%%%%%%$$$$$$$$&quot;,
+  &quot;~~%%  v     M    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$&quot;,
+  &quot;~~%%%   M v    %%%%%~~~~%%%%%%%%%%~~~~~~~~~~%%%%%%%%%$$$$&quot;,
+  &quot;~~~%%%%     %%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%%%%$$&quot;,
+  &quot;~~~~~%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%$$&quot;,
+  &quot;~~~~~~~%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%$&quot;})
+
+--------------------------------------------
+-- FIRST FIVE MAZES
+--------------------------------------------
+
+maze_map = wo:newMap(&quot; &quot;, {
+&quot;###O################################O##&quot;,
+&quot;#_____                             ___#&quot;,
+&quot;#_M___                             _d_O&quot;,
+&quot;O__v__                             ___#&quot;,
+&quot;#___g_                                #&quot;,
+&quot;#_____                                #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                     #&quot;,
+&quot;#                                _____#&quot;,
+&quot;#                                _++D+#&quot;,
+&quot;#___                             _Lk__O&quot;,
+&quot;O_d_                             _K___#&quot;,
+&quot;#___                             _N___#&quot;,
+&quot;##O################################O###&quot;})
+
+maze_width = 19
+maze_height = 12
+maze_offset = po({2, 2})
+
+for j = 1, 5 do
+  mazes[j] = new_kruskal_maze(maze_width, maze_height)
+end
+
+for j = 1, 5 do
+  maze_maps[j] = lib.lua.deep_copy(maze_map)
+  glue_maze_into_map(j, mazes[j], maze_height, maze_width, maze_offset)
+  local glasses1 = po({5 + random(9), 5 + random(3)})
+  local glasses2, extralife
+  repeat
+    glasses2 = po({5 + random(9), 5 + random(3)})
+  until glasses2 ~= glasses1
+  repeat
+    extralife = po({5 + random(9), 5 + random(3)})
+  until (extralife ~= glasses1) and (extralife ~= glasses2)
+  replace_key_in_map(j, &quot; &quot;, &quot;G&quot;, 2*glasses1 + maze_offset)
+  replace_key_in_map(j, &quot; &quot;, &quot;H&quot;, 2*glasses2 + maze_offset)
+  replace_key_in_map(j, &quot; &quot;, &quot;E&quot;, 2*extralife + maze_offset)
+  if random(2) == 1 then
+    maze_maps[j] = maze_maps[j] ^ MAP_MIRROR_VERTICAL
+  end
+  if random(2) == 1 then
+    maze_maps[j] = maze_maps[j] ^ MAP_MIRROR_HORIZONTAL
+  end
+  maze_maps[j] = maze_maps[j] * (&quot;&quot;..j)
+end
+
+--------------------------------------------
+-- FINAL MAZE
+--------------------------------------------
+
+fmaze_width = 19 * 2 - 1
+fmaze_height = 12 * 2 - 1
+fmaze_offset = po({3, 3})
+
+-- frame
+maze_maps[6] = {string.rep(&quot;$&quot;, fmaze_width * 2 + 3)}
+table.insert(maze_maps[6], maze_maps[6][1])
+for j = 1, fmaze_height * 2 - 1 do
+  table.insert(maze_maps[6], &quot;$$&quot; .. string.rep(&quot; &quot;, fmaze_width * 2 - 1) .. &quot;$$&quot;)
+end
+table.insert(maze_maps[6], maze_maps[6][1])
+table.insert(maze_maps[6], maze_maps[6][1])
+maze_maps[6] = wo:newMap(&quot; &quot;, maze_maps[6])
+
+-- oneway entry and exit
+replace_key_in_map(6, &quot;$&quot;, &quot;-&quot;, {1, 7})
+replace_key_in_map(6, &quot;$&quot;, &quot;A&quot;, {2, 7})
+replace_key_in_map(6, &quot;$&quot;, &quot;-&quot;, {fmaze_width * 2 + 2, fmaze_height * 2 - 3})
+replace_key_in_map(6, &quot;$&quot;, &quot;-&quot;, {fmaze_width * 2 + 3, fmaze_height * 2 - 3})
+
+-- water/panel holes
+local radius = {}
+local position = {}
+for h = 1, 5 do
+  local tries = 0
+  repeat
+    radius[h] = 11 - h   -- former: 5 + random(5)
+    position[h] = po({radius[h] + 2 + random(2*fmaze_width - 1 - 2*(radius[h] + 2)),
+                      radius[h] + 2 + random(2*fmaze_height - 1 - 2*(radius[h] + 2))})
+    local correct = true
+    for j = 1, h - 1 do
+      local delta = position[h] - position[j]
+      local joined_radius = radius[h] + radius[j] + 2
+      correct = correct and
+        (delta.x*delta.x + delta.y*delta.y &gt; joined_radius * joined_radius)
+    end
+    tries = tries + 1
+  until correct or (tries &gt; 100)
+end
+for h = 1, #radius do
+  for y = -radius[h], radius[h] do
+    for x = -radius[h], radius[h] do
+      local distsqr = x*x + y*y
+      if distsqr &lt;= (radius[h] - 3) * (radius[h] - 3) then
+        replace_key_in_map(6, &quot;$&quot;, &quot;%&quot;, position[h] + {x, y})
+        replace_key_in_map(6, &quot;-&quot;, &quot;%&quot;, position[h] + {x, y})
+        replace_key_in_map(6, &quot; &quot;, &quot;%&quot;, position[h] + {x, y})
+      elseif distsqr &lt;= (radius[h] - 1.5) * (radius[h] - 1.5) then
+        replace_key_in_map(6, &quot;-&quot;, &quot;$&quot;, position[h] + {x, y})
+        replace_key_in_map(6, &quot; &quot;, &quot;$&quot;, position[h] + {x, y})
+      elseif distsqr &lt;= radius[h] * radius[h] then
+        replace_key_in_map(6, &quot; &quot;, &quot;-&quot;, position[h] + {x, y})
+      end
+    end
+  end
+end
+
+-- maze
+fmaze = new_kruskal_maze(fmaze_width, fmaze_height)
+glue_maze_into_map(6, fmaze, fmaze_height, fmaze_width, fmaze_offset)
+
+-- numbers
+local number_field = {}
+for y = 1, #maze_maps[6] do
+  number_field[y] = &quot;&quot;
+  for x = 1, string.len(maze_maps[6][y]) do
+    number_field[y] = number_field[y]
+      .. lib.lua.cond(math.floor(x/5)%2 == math.floor(y/5)%2, final_spot_1, final_spot_2)
+  end
+end
+maze_maps[6] = maze_maps[6] * wo:newMap(&quot; &quot;, number_field)
+
+--------------------------------------------
+-- OXYD ROOM
+--------------------------------------------
+
+oxyd_room = wo:newMap(&quot; &quot;, {
+-- |        ++        |
+   &quot;%%%%%%%~~%%%~~~~~~~&quot;,
+   &quot;%%%%%%%%%%3%%%%~~~~&quot;,
+   &quot;$%%%%%%2%%B%%4%%%%~&quot;,
+   &quot;$%%%1%%B%   %B%%5%%&quot;,
+   &quot;$$%%B%         %B%%&quot;,
+   &quot;$$$%    $$$$$    %%&quot;,
+   &quot;efs    $$~~~$$   %%&quot;,
+   &quot;$$$%    $$$$$    %%&quot;,
+   &quot;$$%%B%         %B%%&quot;,
+   &quot;$%%%5%%B%   %B%%1%%&quot;,
+   &quot;$%%%%%%4%%B%%2%%%%~&quot;,
+   &quot;%%%%%%%%%%3%%%%~~~~&quot;,
+   &quot;%%%%%%%~~%%%~~~~~~~&quot;})
+
+--------------------------------------------
+-- FUSING, GLUING AND CREATING THE WORLD
+--------------------------------------------
+
+-- prepare central and oxyd room
+central_room = central_room * &quot;0&quot;
+oxyd_room = (wo:newMap(&quot; &quot;, 1, 3*12) + oxyd_room) * &quot;0&quot;
+
+-- glue together
+xspacing = wo:newMap(&quot;  &quot;, 18, 1)
+yspacing = wo:newMap(&quot;  &quot;, 1, 11)
+
+map1 = maze_maps[1] + yspacing + maze_maps[2]
+map2 = maze_maps[3] + yspacing + maze_maps[4]
+map3 = central_room + yspacing + (maze_maps[5] .. xspacing)
+whole_map =     map1 .. xspacing .. map2 .. xspacing
+             .. map3 .. maze_maps[6] .. oxyd_room
+
+w, h = wo(main_resolver, &quot;  &quot;, whole_map)
+
+--------------------------------------------
+-- MONOFLOP-VORTEX CABLING
+--------------------------------------------
+
+monoflops = no[&quot;monoflop#*&quot;]
+vortices = no[&quot;vortex#*&quot;]
+
+for j = 1, 5 do
+  monoflops[j][&quot;target&quot;] = vortices[monoflop_permutation[j]]
+  vortices[j][&quot;destination&quot;] = vortex_goals[j]
+end
+
+--------------------------------------------
+-- KEY-STONE CALLBACK FUNCTION
+--------------------------------------------
+
+key_sum = 0
+function key_call(is_on, sender)
+  key_sum = key_sum + lib.lua.cond(is_on == ON, 1, -1)
+  no[&quot;keydoor5&quot;]:message(lib.lua.cond(key_sum == 2, &quot;open&quot;, &quot;close&quot;))
+end
+
+    ]]&gt;&lt;/el:luamain&gt;
+    &lt;el:i18n&gt;
+      &lt;el:string el:key=&quot;title&quot;&gt;
+        &lt;el:english el:translate=&quot;false&quot;/&gt;
+      &lt;/el:string&gt;
+    &lt;/el:i18n&gt;
+  &lt;/el:protected&gt;
+&lt;/el:level&gt;

Modified: trunk/data/levels/enigma_viii/andreas49_1.xml
===================================================================
--- trunk/data/levels/enigma_viii/andreas49_1.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_viii/andreas49_1.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -3,12 +3,12 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;level&quot;&gt;
       &lt;el:identity el:title=&quot;Wired&quot; el:subtitle=&quot;&quot; el:id=&quot;andreas49&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;released&quot;/&gt;
       &lt;el:author el:name=&quot;Andreas Lochmann&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2008 Andreas Lochmann&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;true&quot; el:single=&quot;true&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:score el:easy=&quot;0:37&quot; el:difficult=&quot;8:49&quot;/&gt;
@@ -30,11 +30,11 @@
 ti[&quot;S&quot;] = {&quot;st_switch&quot;, target = &quot;easy_mode_call&quot;}
 
 floors  = {ti[&quot; &quot;], ti[&quot;a&quot;], ti[&quot;b&quot;], ti[&quot;c&quot;]}
-polynom = luatools.random_vector(10, 4)
+polynom = lib.math.random_vector(10, 4)
 
 function myresolver(key, x, y)
   if key == &quot; &quot; then  
-    return floors[luatools.cubic_polynomial(polynom, x, y) % (#floors) + 1]
+    return floors[lib.math.cubic_polynomial(polynom, x, y) % (#floors) + 1]
   elseif    (key == &quot;#&quot;)
          or ((key == &quot;_&quot;) and (random(4) == 1))
          or ((key == &quot;S&quot;) and wo[&quot;IsDifficult&quot;]) then
@@ -61,8 +61,8 @@
    &quot;####################___________________&quot;
 })
 
-door_p = luatools.permutation(12)
-wire_p = luatools.permutation(12)
+door_p = lib.math.permutation(12)
+wire_p = lib.math.permutation(12)
 woods = no[&quot;wood#*&quot;]
 triggers = no[&quot;trigger#*&quot;]
 doors = no[&quot;door#*&quot;]

Modified: trunk/data/levels/enigma_viii/index.xml
===================================================================
--- trunk/data/levels/enigma_viii/index.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/enigma_viii/index.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
 &lt;index xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:noNamespaceSchemaLocation=&quot;index.xsd&quot;&gt;
 
-  &lt;info enigma=&quot;1.00&quot; group=&quot;Enigma&quot; location=&quot;10900&quot; network=&quot;false&quot; owner=&quot;Enigma Team&quot; release=&quot;1&quot; revision=&quot;5&quot; title=&quot;Enigma VIII&quot;/&gt;
+  &lt;info enigma=&quot;1.00&quot; group=&quot;Enigma&quot; location=&quot;10900&quot; network=&quot;false&quot; owner=&quot;Enigma Team&quot; release=&quot;1&quot; revision=&quot;6&quot; title=&quot;Enigma VIII&quot;/&gt;
 
   &lt;attributes/&gt;
 
@@ -10,7 +10,7 @@
     &lt;level _seq=&quot;2&quot; _title=&quot;Jack-Of-All-Trades&quot; _xpath=&quot;./mecke12_1&quot; author=&quot;mecke&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;mecke12&quot; rel=&quot;1&quot; rev=&quot;31&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;3&quot; _title=&quot;Enigmaparcour&quot; _xpath=&quot;./mecke15_1&quot; author=&quot;mecke&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;mecke15&quot; rel=&quot;1&quot; rev=&quot;21&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;4&quot; _title=&quot;Rhythm of Space&quot; _xpath=&quot;./mecke20_1&quot; author=&quot;mecke&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;mecke20&quot; rel=&quot;1&quot; rev=&quot;21&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;5&quot; _title=&quot;The Show Jumper&quot; _xpath=&quot;./andreas47_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas47&quot; rel=&quot;1&quot; rev=&quot;3&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;5&quot; _title=&quot;The Show Jumper&quot; _xpath=&quot;./andreas47_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas47&quot; rel=&quot;1&quot; rev=&quot;4&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;6&quot; _title=&quot;The Red Room&quot; _xpath=&quot;./joe29_1&quot; author=&quot;Joseph Dunne&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;joe29&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;7&quot; _title=&quot;Enigmines&quot; _xpath=&quot;./huffman01_1&quot; author=&quot;Brian Huffman&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;huffman01&quot; rel=&quot;1&quot; rev=&quot;2&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;8&quot; _title=&quot;Red Cave&quot; _xpath=&quot;./mecke21_1&quot; author=&quot;mecke&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;mecke21&quot; rel=&quot;1&quot; rev=&quot;30&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
@@ -27,7 +27,7 @@
     &lt;level _seq=&quot;19&quot; _title=&quot;Color Maze&quot; _xpath=&quot;./pulley16_3&quot; author=&quot;Mark Pulley&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;pulley16&quot; rel=&quot;3&quot; rev=&quot;4&quot; score=&quot;3&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;20&quot; _title=&quot;Earthlink&quot; _xpath=&quot;./pulley15_1&quot; author=&quot;Mark Pulley&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;pulley15&quot; rel=&quot;1&quot; rev=&quot;0&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;21&quot; _title=&quot;Vanity's Constrictions&quot; _xpath=&quot;./andreas53_2&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas53&quot; rel=&quot;2&quot; rev=&quot;5&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;22&quot; _title=&quot;Wired&quot; _xpath=&quot;./andreas49_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas49&quot; rel=&quot;1&quot; rev=&quot;3&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;22&quot; _title=&quot;Wired&quot; _xpath=&quot;./andreas49_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;andreas49&quot; rel=&quot;1&quot; rev=&quot;4&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;23&quot; _title=&quot;Push Wires&quot; _xpath=&quot;./ral24_1&quot; author=&quot;Ronald Lamprecht&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;20080708ral196&quot; rel=&quot;1&quot; rev=&quot;100&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;24&quot; _title=&quot;Wired Five&quot; _xpath=&quot;./ral25_1&quot; author=&quot;Ronald Lamprecht&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;20080721ral073&quot; rel=&quot;1&quot; rev=&quot;109&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;25&quot; _title=&quot;Wireban Premiere&quot; _xpath=&quot;./ral26_1&quot; author=&quot;Ronald Lamprecht&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;20080715ral161&quot; rel=&quot;1&quot; rev=&quot;106&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
@@ -36,7 +36,7 @@
     &lt;level _seq=&quot;28&quot; _title=&quot;Freestyle Microwire&quot; _xpath=&quot;./ral29_1&quot; author=&quot;Ronald Lamprecht&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;20080719ral530&quot; rel=&quot;1&quot; rev=&quot;107&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;29&quot; _title=&quot;Balance Beam&quot; _xpath=&quot;./mecke03_1&quot; author=&quot;mecke&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;mecke03&quot; rel=&quot;1&quot; rev=&quot;29&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;30&quot; _title=&quot;Colored Oxyds&quot; _xpath=&quot;./andreas50_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;andreas50&quot; rel=&quot;1&quot; rev=&quot;2&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
-    &lt;level _seq=&quot;31&quot; _title=&quot;Fashions Pass&quot; _xpath=&quot;./andreas48_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;andreas48&quot; rel=&quot;1&quot; rev=&quot;2&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
+    &lt;level _seq=&quot;31&quot; _title=&quot;Fashions Pass&quot; _xpath=&quot;./andreas48_2&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;andreas48&quot; rel=&quot;2&quot; rev=&quot;3&quot; score=&quot;2&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;32&quot; _title=&quot;Colored Turnstiles&quot; _xpath=&quot;./andreas51_1&quot; author=&quot;Andreas Lochmann&quot; ctrl=&quot;force&quot; easy=&quot;false&quot; id=&quot;andreas51&quot; rel=&quot;1&quot; rev=&quot;1&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
     &lt;level _seq=&quot;33&quot; _title=&quot;Sanssouci&quot; _xpath=&quot;./mecke05_1&quot; author=&quot;mecke&quot; ctrl=&quot;force&quot; easy=&quot;true&quot; id=&quot;mecke05&quot; rel=&quot;1&quot; rev=&quot;22&quot; score=&quot;1&quot; target=&quot;time&quot; unit=&quot;duration&quot;/&gt;
   &lt;/levels&gt;

Copied: trunk/data/levels/lib/liblua.xml (from rev 1281, trunk/data/levels/lib/libluatools.xml)
===================================================================
--- trunk/data/levels/lib/libluatools.xml	2008-08-22 01:09:49 UTC (rev 1281)
+++ trunk/data/levels/lib/liblua.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -0,0 +1,189 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
+&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
+  &lt;el:protected&gt;
+    &lt;el:info el:type=&quot;library&quot;&gt;
+      &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/liblua&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:author  el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
+      &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
+      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
+      &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
+      &lt;/el:compatibility&gt;
+      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
+      &lt;el:comments&gt;
+      &lt;/el:comments&gt;
+      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;-&quot;/&gt;
+    &lt;/el:info&gt;
+    &lt;el:luamain&gt;&lt;![CDATA[
+
+---------------------------------------------------------------------
+-- liblib.lua holds some general utilities for working with Lua.
+-- It includes functions for deep-copying tables, combining tables,
+-- and shuffling tables and a conditional function.
+---------------------------------------------------------------------
+--
+-- liblua provides the following functions:
+--   lib.lua.deep_copy(source)
+--   lib.lua.combine_tables(arg1, ...)
+--   lib.lua.shuffle_table(t)
+--   lib.lua.print_table(t, prefix, depth)
+--   lib.lua.mod(value, modul)
+--   lib.lua.cond(condition, iftrue, iffalse)
+--
+
+lib.lua = {}
+setmetatable(lib.lua, getmetatable(lib))
+
+---------------------------------------------------------------------
+--  TABLE  HANDLING
+---------------------------------------------------------------------
+
+-- deep_copy returns a copy of SOURCE, where table entries are
+-- not copied as memory references, but complete (&quot;deep copy&quot;).
+-- Metatables are transfered, but not deep-copied.
+-- TODO: use rawset/rawget instead.
+function lib.lua.deep_copy(source)
+ if type(source) ~= &quot;table&quot; then
+   return source
+ end
+ local dest = {}
+ for k, v in pairs(source) do
+   if type(source[k]) == &quot;table&quot; then
+     dest[k] = lib.lua.deep_copy(source[k])
+   else
+     dest[k] = source[k]
+   end
+ end
+ setmetatable(dest, getmetatable(source))
+ return dest
+end 
+
+-- combine_tables returns a table consisting of all entries of the
+-- entries of OVER_TABLE: OVER_TABLE is a table of tables, say
+-- {T1, T2, T3, ...}. The result of combine_tables will be a new
+-- table with all entries of T1, T2, T3 etc., with the first table
+-- having highest priority etc.
+function lib.lua.combine_tables(arg1, ...)
+  local args = {arg1, ...}
+  if table.getn(args) == 1 then
+    args = arg1
+  end
+  if type(args) ~= &quot;table&quot; then
+    error(&quot;combine_tables: None or only one argument, and it's not a table!&quot;, 2)
+  end
+  local result = {}
+  for j,t in pairs(args) do
+    if type(t) ~= &quot;table&quot; then
+      error(&quot;combine_tables: Main table does not consist of tables alone!&quot;, 2)
+    end
+    for k,v in pairs(t) do
+      result[k] = result[k] or lib.lua.deep_copy(v)
+    end
+  end
+  return result
+end
+
+-- shuffle_table resorts the table T randomly. Note that only those entries
+-- of T can be sorted, that are indexed with integers from 1 to table.getn(T).
+-- No return value, the table itself is shuffled.
+function lib.lua.shuffle_table(t)
+  if table.getn(t) &lt; 2 then
+    return
+  end
+  for n = table.getn(t), 2, -1 do
+    local m = math.random(n)
+    t[n], t[m] = t[m], t[n]
+  end
+end
+
+-- print_table uses the print command to print all
+-- entries of a table, one table per line.
+-- It should be used for debug reasons only.
+-- PREFIX can be a string to be put in front of each
+-- line of the output, in case you need to distinguish
+-- several outputs from each other.
+-- print_table is recursive, i.e. a table with table
+-- as entries will call print_table again. To avoid
+-- infinite loops, DEPTH is used as additional argument.
+-- Don't use it in levels. If you want to suppress
+-- the recursive function, use DEPTH = -1.
+function lib.lua.print_table(t, prefix, depth)
+  if type(t) ~= &quot;table&quot; then
+    print(&quot;print_table: Argument is of type &quot;..type(t)..&quot;, not table.&quot;)
+    return
+  end
+  for key, value in pairs(t) do
+    local key_s
+    if type(key) == &quot;string&quot; then
+      key_s = &quot;\&quot;&quot; .. key .. &quot;\&quot;&quot;
+    elseif type(key) == &quot;number&quot; then
+      key_s = key
+    else
+      key_s = &quot;&lt;&quot; .. type(key) .. &quot;&gt;&quot;
+    end
+    if type(value) == &quot;number&quot; then
+      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. value)
+    elseif type(value) == &quot;string&quot; then
+      print((prefix or &quot;&quot;).. &quot;|&quot; .. key_s .. &quot; = \&quot;&quot; .. value .. &quot;\&quot;&quot;)
+    elseif type(value) == &quot;table&quot; then
+      if (depth or 0) &lt; 5 then
+        print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = |&quot;)
+        lib.lua.print_table(value,
+            (prefix or &quot;&quot;) .. &quot;|&quot; .. string.rep(&quot; &quot;, string.len(key_s) + 3),
+            (depth or 0) + 1)
+        print((prefix or &quot;&quot;) .. &quot;|&quot;)
+      else
+        print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = | ...&quot;)
+      end
+    else
+      print((prefix or &quot;&quot;).. &quot;|&quot; .. key_s .. &quot; of type &quot; .. type(value))
+    end
+  end
+end
+
+---------------------------------------------------------------------
+--  MATHEMATICAL  FUNCTIONS
+---------------------------------------------------------------------
+
+-- As Lua uses different names for the modulo-function in its
+-- versions, it's sometimes better to wrap them.
+-- Even worse, lua's modulo function doesn't handle negative
+-- values as it should. The following function returns (given
+-- an integer) another integer between 0 and MODUL-1.
+function lib.lua.mod(value, modul)
+  if (type(value) ~= &quot;number&quot;) or (type(modul) ~= &quot;number&quot;) then
+    error(&quot;lib.lua.mod: Arguments are not two numbers.&quot;, 2)
+  end
+  if modul &lt;= 0 then
+    error(&quot;lib.lua.mod: Second argument (modul) must be positive.&quot;, 2)
+  end
+  if value &lt; 0 then
+    -- No, the following call to lib.lua.mod is not a real
+    -- recursion, it's only for the case where VALUE is a
+    -- negative multiple of MODUL (otherwise we would get
+    -- MODUL as result, not zero).
+    return lib.lua.mod(modul + (math.fmod or math.mod)(value, modul), modul)
+  else
+    return (math.fmod or math.mod)(value, modul)
+  end
+end
+
+-- A wrapper of &quot;if&quot; to resemble the ternary ?:-function.
+-- Note that this function evaluates both IFTRUE as well as IFFALSE, e.g.
+--   lib.lua.cond(t == 0, 1/t, error(&quot;Division by zero&quot;))
+-- will evaluate the error-function and thus halt for any T.
+-- Hence: Make sure there are no sideeffects in IFTRUE and IFFALSE!
+function lib.lua.cond(condition, iftrue, iffalse)
+  if condition then
+    return iftrue
+  else
+    return iffalse
+  end
+end
+
+    ]]&gt;&lt;/el:luamain&gt;
+    &lt;el:i18n&gt;
+    &lt;/el:i18n&gt;
+  &lt;/el:protected&gt;
+&lt;/el:level&gt;
+

Deleted: trunk/data/levels/lib/libluatools.xml
===================================================================
--- trunk/data/levels/lib/libluatools.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/lib/libluatools.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -1,375 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
-&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
-  &lt;el:protected&gt;
-    &lt;el:info el:type=&quot;library&quot;&gt;
-      &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libluatools&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;released&quot;/&gt;
-      &lt;el:author  el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
-      &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
-      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
-      &lt;el:compatibility el:enigma=&quot;1.00&quot;&gt;
-      &lt;/el:compatibility&gt;
-      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
-      &lt;el:comments&gt;
-      &lt;/el:comments&gt;
-      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;-&quot;/&gt;
-    &lt;/el:info&gt;
-    &lt;el:luamain&gt;&lt;![CDATA[
-
----------------------------------------------------------------------
--- libluatools holds some general utilities for working with Lua.
--- It includes functions for deep-copying tables, combining tables,
--- and shuffling tables, a function to calculate Manhattan
--- distances and a wrapper for Lua's modulo-function, which has
--- been renamed from math.mod to math.fmod.
----------------------------------------------------------------------
-
-luatools = {}
-
----------------------------------------------------------------------
---  TABLE  HANDLING
----------------------------------------------------------------------
-
--- deep_copy returns a copy of SOURCE, where table entries are
--- not copied as memory references, but complete (&quot;deep copy&quot;).
--- Metatables are transfered, but not deep-copied.
--- TODO: use rawset/rawget instead.
-function luatools.deep_copy(source)
- if type(source) ~= &quot;table&quot; then
-   return source
- end
- local dest = {}
- for k, v in pairs(source) do
-   if type(source[k]) == &quot;table&quot; then
-     dest[k] = luatools.deep_copy(source[k])
-   else
-     dest[k] = source[k]
-   end
- end
- setmetatable(dest, getmetatable(source))
- return dest
-end 
-
--- combine_tables returns a table consisting of all entries of the
--- entries of OVER_TABLE: OVER_TABLE is a table of tables, say
--- {T1, T2, T3, ...}. The result of combine_tables will be a new
--- table with all entries of T1, T2, T3 etc., with the first table
--- having highest priority etc.
-function luatools.combine_tables(arg1, ...)
-  local args = {arg1, ...}
-  if table.getn(args) == 1 then
-    args = arg1
-  end
-  if type(args) ~= &quot;table&quot; then
-    error(&quot;combine_tables: None or only one argument, and it's not a table!&quot;)
-  end
-  local result = {}
-  for j,t in pairs(args) do
-    if type(t) ~= &quot;table&quot; then
-      error(&quot;combine_tables: Main table does not consist of tables alone!&quot;)
-    end
-    for k,v in pairs(t) do
-      result[k] = result[k] or luatools.deep_copy(v)
-    end
-  end
-  return result
-end
-
--- shuffle_table resorts the table T randomly. Note that only those entries
--- of T can be sorted, that are indexed with integers from 1 to table.getn(T).
--- No return value, the table itself is shuffled.
-function luatools.shuffle_table(t)
-  if table.getn(t) &lt; 2 then
-    return
-  end
-  for n = table.getn(t), 2, -1 do
-    local m = math.random(n)
-    t[n], t[m] = t[m], t[n]
-  end
-end
-
--- print_table uses the print command to print all
--- entries of a table, one table per line.
--- It should be used for debug reasons only.
--- PREFIX can be a string to be put in front of each
--- line of the output, in case you need to distinguish
--- several outputs from each other.
--- print_table is recursive, i.e. a table with table
--- as entries will call print_table again. To avoid
--- infinite loops, DEPTH is used as additional argument.
--- Don't use it in levels. If you want to suppress
--- the recursive function, use DEPTH = -1.
-function luatools.print_table(t, prefix, depth)
-  if type(t) ~= &quot;table&quot; then
-    print(&quot;print_table: Argument is of type &quot;..type(t)..&quot;, not table.&quot;)
-    return
-  end
-  for key, value in pairs(t) do
-    local key_s
-    if type(key) == &quot;string&quot; then
-      key_s = &quot;\&quot;&quot; .. key .. &quot;\&quot;&quot;
-    elseif type(key) == &quot;number&quot; then
-      key_s = key
-    else
-      key_s = &quot;&lt;&quot; .. type(key) .. &quot;&gt;&quot;
-    end
-    if type(value) == &quot;number&quot; then
-      print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = &quot; .. value)
-    elseif type(value) == &quot;string&quot; then
-      print((prefix or &quot;&quot;).. &quot;|&quot; .. key_s .. &quot; = \&quot;&quot; .. value .. &quot;\&quot;&quot;)
-    elseif type(value) == &quot;table&quot; then
-      if (depth or 0) &lt; 5 then
-        print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = |&quot;)
-        luatools.print_table(value,
-            (prefix or &quot;&quot;) .. &quot;|&quot; .. string.rep(&quot; &quot;, string.len(key_s) + 3),
-            (depth or 0) + 1)
-        print((prefix or &quot;&quot;) .. &quot;|&quot;)
-      else
-        print((prefix or &quot;&quot;) .. &quot;|&quot; .. key_s .. &quot; = | ...&quot;)
-      end
-    else
-      print((prefix or &quot;&quot;).. &quot;|&quot; .. key_s .. &quot; of type &quot; .. type(value))
-    end
-  end
-end
-
----------------------------------------------------------------------
---  ADVANCED  POSITION  HANDLING  AND  CALCULATIONS
----------------------------------------------------------------------
-
--- manhattan_distance calculates the Manhattan-distance between
--- (X1,Y1) and (X2, Y2), which is |X1 - X2| + |Y1 - Y2|.
--- If X2 and Y2 are nil, X1 and Y1 are assumed to be positions
--- instead of coordinates.
-function luatools.manhattan_distance(x1, y1, x2, y2)
-  if x1 and y1 and x2 and y2 then
-    -- x1, y1, x2, y2 are coordinates
-    return math.abs(x1 - x2) + math.abs(y1 - y2)
-  end
-  if x1 and y1 then
-    -- x1 and y1 are positions, possibly tables.
-    local p1 = x1
-    local p2 = y1
-    if type(p1) == &quot;table&quot; then
-      p1 = po(p1)
-    end
-    if type(p2) == &quot;table&quot; then
-      p2 = po(p2)
-    end
-    return math.abs(p1.x - p2.x) + math.abs(p1.y - p2.y)
-  end
-  error(&quot;manhattan_distance: Too less arguments.&quot;)  
-end
-
----------------------------------------------------------------------
---  MATHEMATICAL  FUNCTIONS
----------------------------------------------------------------------
-
--- As Lua uses different names for the modulo-function in its
--- versions, it's sometimes better to wrap them.
--- Even worse, lua's modulo function doesn't handle negative
--- values as it should. The following function returns (given
--- an integer) another integer between 0 and MODUL-1.
-function luatools.mod(value, modul)
-  if (type(value) ~= &quot;number&quot;) or (type(modul) ~= &quot;number&quot;) then
-    error(&quot;luatools.mod: Arguments are not two numbers.&quot;)
-  end
-  if modul &lt;= 0 then
-    error(&quot;luatools.mod: Second argument (modul) must be positive.&quot;)
-  end
-  if value &lt; 0 then
-    -- No, the following call to luatools.mod is not a real
-    -- recursion, it's only for the case where VALUE is a
-    -- negative multiple of MODUL (otherwise we would get
-    -- MODUL as result, not zero).
-    return luatools.mod(modul + (math.fmod or math.mod)(value, modul), modul)
-  else
-    return (math.fmod or math.mod)(value, modul)
-  end
-end
-
--- A wrapper of &quot;if&quot; to resemble the ternary ?:-function.
--- Note that this function evaluates both IFTRUE as well as IFFALSE, e.g.
---   luatools.cond(t == 0, 1/t, error(&quot;Division by zero&quot;))
--- will evaluate the error-function and thus halt for any T.
--- Hence: Make sure there are no sideeffects in IFTRUE and IFFALSE!
-function luatools.cond(condition, iftrue, iffalse)
-  if condition then
-    return iftrue
-  else
-    return iffalse
-  end
-end
-
--- digits returns a table whose elements are the digits of NUMBER
--- in base BASE. BASE can be a number (e.g. 3 to get ternary)
--- as well as a table (then the table entries with numerical
--- keys will be used as digits).
--- Examples:
---   luatools.digits(13, 2) = {1, 0, 1, 1}
---   luatools.digits(15, 16) = {15}
---   luatools.digits(17, 3) = {2, 2, 1}
---   luatools.digits(17, {2, &quot;b&quot;, 5}) = {5, 5, &quot;b&quot;}
--- Hexadecimal would be:
---   luatools.digits(x, {0,1,2,3,4,5,6,7,8,9,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;})
--- NUMBER is supposed to be a non-negative integer.
-function luatools.digits(number, base)
-  -- Check arguments and calculate fullbase and exponent
-  if type(number) ~= &quot;number&quot; then
-    error(&quot;digits: First argument not a number (&quot;..type(number)..&quot; instead).&quot;)
-  end
-  if (type(base) ~= &quot;number&quot;) and (type(base) ~= &quot;table&quot;) then
-    error(&quot;digits: Second argument not valid type (&quot;..type(base)..&quot;).&quot;)
-  end
-  if (number &lt; 0) or (number ~= math.ceil(number)) then
-    error(&quot;digits: First argument out of range (&quot;..number..&quot;).&quot;)
-  end
-  local fullbase = {}
-  local exponent = 0
-  if type(base) == &quot;number&quot; then
-    if (base &lt; 2) or (base ~= math.ceil(base)) then
-      error(&quot;digits: Second argument out of range (&quot;..base..&quot;).&quot;)
-    end
-    for j = 1, base do
-      table.insert(fullbase, j - 1)
-    end
-  else -- type(base) == &quot;table&quot;
-    if table.getn(base) &lt; 2 then
-      error(&quot;digits: Second argument has not enough elements.&quot;)
-    end
-    fullbase = base
-  end
-  exponent = table.getn(fullbase)
-  -- Decompose NUMBER
-  local remains = number
-  local result = {}
-  while remains &gt; 0 do
-    local d = luatools.mod(remains, exponent)
-    table.insert(result, fullbase[d + 1])
-    remains = (remains - d) / exponent
-    if remains ~= math.ceil(remains) then
-      error(&quot;digits: Internal error during calculation (remains = &quot;..remains..&quot;).&quot;)
-    end
-  end
-  return result
-end
-
--- Return a table of all combinations of DEPTH entries,
--- each of which is chosen from DIGITS.
--- Example: luatools.combinations(3, {7, 8, &quot;a&quot;}) will return
---   { {7,7,7}, {7,7,8}, {7,7,&quot;a&quot;}, {7,8,7}, {7,8,8}, {7,8,&quot;a&quot;},
---     {7,&quot;a&quot;,7}, {7,&quot;a&quot;,8}, {7,&quot;a&quot;,&quot;a&quot;}, {8,7,7}, ... }
--- Mathematically, it builds the leafs of an #DIGITS-ary tree
--- of depth DEPTH.
-function luatools.combinations(depth, digits)
-  local all_combinations = {{}}
-  local digs = digits
-  if (type(depth) ~= &quot;number&quot;) or (depth &lt; 1) or (depth ~= math.floor(depth)) then
-    error(&quot;combinations: First argument (depth) not a number or out of range.&quot;)
-  end
-  if type(digits) == &quot;number&quot; then
-    if (digits &lt; 1) or (digits ~= math.floor(digits)) then
-      error(&quot;combinations: Second argument (digits) out of range.&quot;)
-    end
-    digs = {}
-    for j = 1, digits do
-      digs[j] = j
-    end
-  end
-  if type(digs) ~= &quot;table&quot; then
-    error(&quot;combinations: Second argument (digits) should be number or table.&quot;)
-  end
-  for _ = 1, depth do
-    local next_step = {}
-    for _, old_combination in pairs(all_combinations) do
-      for _, new_digit in pairs(digs) do
-        local new_combination = luatools.deep_copy(old_combination)
-        table.insert(new_combination, new_digit)
-        table.insert(next, new_combination)
-      end
-    end
-    all_combinations = next_step
-  end
-  return all_combinations
-end
-
--- cubic_polynomial returns the result of the
--- following polynomial with coefficients in A:
--- a[10]*y*y*y + a[9]*x*y*y + a[8]*x*x*y + a[7]*x*x*x
---   + a[6]*y*y + a[5]*x*y + a[4]*x*x + a[3]*y + a[2]*x + a[1]
--- You can use luatools.random_vector(10, ...) and
--- a modulo operation to easily form a random
--- pattern of a floor, or choose the coefficients
--- to your own liking. Entries in A which are not
--- numbers are considered zero.
-function luatools.cubic_polynomial(a, x, y)
-  if type(a) ~= &quot;table&quot; then
-    error(&quot;cubic_polynomial: First argument not a table (&quot; .. type(a)
-          .. &quot; instead).&quot;)
-  end
-  if (type(x) ~= &quot;number&quot;) or (type(y) ~= &quot;number&quot;) then
-    error(&quot;cubic_polynomial: Second or third argument not a number.&quot;)
-  end
-  return   (a[10] or 0)*y*y*y + (a[9] or 0)*x*y*y + (a[8] or 0)*x*x*y
-         + (a[7] or 0)*x*x*x + (a[6] or 0)*y*y + (a[5] or 0)*x*y
-         + (a[4] or 0)*x*x + (a[3] or 0)*y + (a[2] or 0)*x + (a[1] or 0)
-end
-
----------------------------------------------------------------------
---  PERMUTATIONS  AND  RANDOM  NUMBERS
----------------------------------------------------------------------
-
--- Return a random permutation of n elements.
--- This function outputs a table with integer entries between
--- 1 and n at positions 1 to n.
-function luatools.permutation(n)
-  if type(n) ~= &quot;number&quot; then
-    error(&quot;permutation: Expected number, got &quot;..type(n)..&quot;!&quot;)
-  end
-  if (n &lt; 1) or (n ~= math.floor(n)) then
-    error(&quot;permutation: Argument must be positive integer.&quot;)
-  end
-  local sequence = {}
-  for j = 1, n do
-    table.insert(sequence, j)
-  end
-  luatools.shuffle_table(sequence)
-  return sequence
-end
-
--- Return a random cyclic permutation (i.e. with only one cycle) of n elements.
-function luatools.cyclic_permutation(n)  
-  if type(n) ~= &quot;number&quot; then
-    error(&quot;cyclic_permutation: Expected number, got &quot;..type(n)..&quot;!&quot;)
-  end
-  local sequence1 = luatools.permutation(n)
-  local sequence2 = {}
-  for j = 1, n - 1 do
-    sequence2[sequence1[j]] = sequence1[j+1]
-  end
-  sequence2[sequence1[n]] = sequence1[1]
-  return sequence2
-end
-
--- Return a table with NUMBER random entries.
--- Additional arguments like with math.random.
-function luatools.random_vector(number, ...)
-  if type(number) ~= &quot;number&quot; then
-    error(&quot;random_vector: First argument not a number (&quot;..type(number)..&quot; instead).&quot;)
-  end
-  if (number &lt; 0) or (number ~= math.ceil(number)) then
-    error(&quot;random_vector: First argument out of range (&quot;..number..&quot;).&quot;)
-  end
-  local result = {}
-  for j = 1, number do
-    result[j] = math.random(...)
-  end
-  return result
-end
-
-    ]]&gt;&lt;/el:luamain&gt;
-    &lt;el:i18n&gt;
-    &lt;/el:i18n&gt;
-  &lt;/el:protected&gt;
-&lt;/el:level&gt;
-

Modified: trunk/data/levels/lib/libmap.xml
===================================================================
--- trunk/data/levels/lib/libmap.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/lib/libmap.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -131,7 +131,7 @@
   for y = 1, new_h do
     result[y] = &quot;&quot;
     for x = 1, new_w do
-      result[y] = result[y] .. map[rot({x - 1, y - 1})]
+      result[y] = result[y] .. map[rot(x - 1, y - 1)]
     end
   end
   return wo:newMap(map.defaultkey, result)  
@@ -431,7 +431,8 @@
           end
           local line_width = string.len(entry) / kl
           if line_width ~= math.floor(line_width) then
-            error(&quot;newMap: Line &quot; .. key .. &quot; doesn't fit to key length.&quot;, 2)
+            error(&quot;newMap: Line &quot; .. key .. &quot; doesn't fit to key length (&quot;
+                  .. kl .. &quot;).&quot;, 2)
           end
           width = math.max(width, line_width)
           newmap[key] = entry

Added: trunk/data/levels/lib/libmath.xml
===================================================================
--- trunk/data/levels/lib/libmath.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/lib/libmath.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -0,0 +1,253 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;
+&lt;el:level xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:schemaLocation=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A> level.xsd&quot; xmlns:el=&quot;<A HREF="http://enigma-game.org/schema/level/1">http://enigma-game.org/schema/level/1</A>&quot;&gt;
+  &lt;el:protected&gt;
+    &lt;el:info el:type=&quot;library&quot;&gt;
+      &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libmath&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;released&quot;/&gt;
+      &lt;el:author  el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
+      &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
+      &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
+      &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
+      &lt;/el:compatibility&gt;
+      &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
+      &lt;el:comments&gt;
+      &lt;/el:comments&gt;
+      &lt;el:score el:easy=&quot;-&quot; el:difficult=&quot;-&quot;/&gt;
+    &lt;/el:info&gt;
+    &lt;el:luamain&gt;&lt;![CDATA[
+
+---------------------------------------------------------------------
+-- libmath includes mathematical and functions and algorithms
+-- of various origins.
+---------------------------------------------------------------------
+--
+-- libmath provides the following functions:
+--   lib.math.manhattan_distance(x1, y1, x2, y2)
+--   lib.math.digits(number, base)
+--   lib.math.combinations(depth, digits)
+--   lib.math.cubic_polynomial(a, x, y)
+--   lib.math.permutation(n)
+--   lib.math.cyclic_permutation(n)  
+--   lib.math.random_vector(number, ...)
+-- Additional mathematically relevant functions are part of liblua:
+--   lib.lua.mod(value, modul)
+--   lib.lua.cond(condition, iftrue, iffalse)
+--
+
+lib.math = {}
+setmetatable(lib.math, getmetatable(lib))
+
+---------------------------------------------------------------------
+--  ADVANCED  POSITION  HANDLING  AND  CALCULATIONS
+---------------------------------------------------------------------
+
+-- manhattan_distance calculates the Manhattan-distance between
+-- (X1,Y1) and (X2, Y2), which is |X1 - X2| + |Y1 - Y2|.
+-- If X2 and Y2 are nil, X1 and Y1 are assumed to be positions
+-- instead of coordinates.
+function lib.math.manhattan_distance(x1, y1, x2, y2)
+  if x1 and y1 and x2 and y2 then
+    -- x1, y1, x2, y2 are coordinates
+    return math.abs(x1 - x2) + math.abs(y1 - y2)
+  end
+  if x1 and y1 then
+    -- x1 and y1 are positions, possibly tables.
+    local p1 = x1
+    local p2 = y1
+    if type(p1) == &quot;table&quot; then
+      p1 = po(p1)
+    end
+    if type(p2) == &quot;table&quot; then
+      p2 = po(p2)
+    end
+    return math.abs(p1.x - p2.x) + math.abs(p1.y - p2.y)
+  end
+  error(&quot;manhattan_distance: Too less arguments.&quot;, 2)
+end
+
+---------------------------------------------------------------------
+--  MATHEMATICAL  FUNCTIONS
+---------------------------------------------------------------------
+
+-- digits returns a table whose elements are the digits of NUMBER
+-- in base BASE. BASE can be a number (e.g. 3 to get ternary)
+-- as well as a table (then the table entries with numerical
+-- keys will be used as digits).
+-- Examples:
+--   lib.math.digits(13, 2) = {1, 0, 1, 1}
+--   lib.math.digits(15, 16) = {15}
+--   lib.math.digits(17, 3) = {2, 2, 1}
+--   lib.math.digits(17, {2, &quot;b&quot;, 5}) = {5, 5, &quot;b&quot;}
+-- Hexadecimal would be:
+--   lib.math.digits(x, {0,1,2,3,4,5,6,7,8,9,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;})
+-- NUMBER is supposed to be a non-negative integer.
+function lib.math.digits(number, base)
+  -- Check arguments and calculate fullbase and exponent
+  if type(number) ~= &quot;number&quot; then
+    error(&quot;digits: First argument not a number (&quot;..type(number)..&quot; instead).&quot;, 2)
+  end
+  if (type(base) ~= &quot;number&quot;) and (type(base) ~= &quot;table&quot;) then
+    error(&quot;digits: Second argument not valid type (&quot;..type(base)..&quot;).&quot;, 2)
+  end
+  if (number &lt; 0) or (number ~= math.ceil(number)) then
+    error(&quot;digits: First argument out of range (&quot;..number..&quot;).&quot;, 2)
+  end
+  local fullbase = {}
+  local exponent = 0
+  if type(base) == &quot;number&quot; then
+    if (base &lt; 2) or (base ~= math.ceil(base)) then
+      error(&quot;digits: Second argument out of range (&quot;..base..&quot;).&quot;, 2)
+    end
+    for j = 1, base do
+      table.insert(fullbase, j - 1)
+    end
+  else -- type(base) == &quot;table&quot;
+    if table.getn(base) &lt; 2 then
+      error(&quot;digits: Second argument has not enough elements.&quot;, 2)
+    end
+    fullbase = base
+  end
+  exponent = table.getn(fullbase)
+  -- Decompose NUMBER
+  local remains = number
+  local result = {}
+  while remains &gt; 0 do
+    local d = remains % exponent
+    table.insert(result, fullbase[d + 1])
+    remains = (remains - d) / exponent
+    if remains ~= math.ceil(remains) then
+      error(&quot;digits: Internal error during calculation (remains = &quot;..remains..&quot;).&quot;, 2)
+    end
+  end
+  return result
+end
+
+-- Return a table of all combinations of DEPTH entries,
+-- each of which is chosen from DIGITS.
+-- Example: lib.math.combinations(3, {7, 8, &quot;a&quot;}) will return
+--   { {7,7,7}, {7,7,8}, {7,7,&quot;a&quot;}, {7,8,7}, {7,8,8}, {7,8,&quot;a&quot;},
+--     {7,&quot;a&quot;,7}, {7,&quot;a&quot;,8}, {7,&quot;a&quot;,&quot;a&quot;}, {8,7,7}, ... }
+-- Mathematically, it builds the leafs of an #DIGITS-ary tree
+-- of depth DEPTH. Note that liblua has to be loaded to use
+-- lib.math.combinations.
+function lib.math.combinations(depth, digits)
+  if not lib.lua then
+    error(&quot;combinations: Please include the library liblua to use lib.math.combinations.&quot;, 2)
+  end
+  local all_combinations = {{}}
+  local digs = digits
+  if (type(depth) ~= &quot;number&quot;) or (depth &lt; 1) or (depth ~= math.floor(depth)) then
+    error(&quot;combinations: First argument (depth) not a number or out of range.&quot;, 2)
+  end
+  if type(digits) == &quot;number&quot; then
+    if (digits &lt; 1) or (digits ~= math.floor(digits)) then
+      error(&quot;combinations: Second argument (digits) out of range.&quot;, 2)
+    end
+    digs = {}
+    for j = 1, digits do
+      digs[j] = j
+    end
+  end
+  if type(digs) ~= &quot;table&quot; then
+    error(&quot;combinations: Second argument (digits) should be number or table.&quot;, 2)
+  end
+  for _ = 1, depth do
+    local next_step = {}
+    for _, old_combination in pairs(all_combinations) do
+      for _, new_digit in pairs(digs) do
+        local new_combination = lib.lua.deep_copy(old_combination)
+        table.insert(new_combination, new_digit)
+        table.insert(next, new_combination)
+      end
+    end
+    all_combinations = next_step
+  end
+  return all_combinations
+end
+
+-- cubic_polynomial returns the result of the
+-- following polynomial with coefficients in A:
+-- a[10]*y*y*y + a[9]*x*y*y + a[8]*x*x*y + a[7]*x*x*x
+--   + a[6]*y*y + a[5]*x*y + a[4]*x*x + a[3]*y + a[2]*x + a[1]
+-- You can use lib.math.random_vector(10, ...) and
+-- a modulo operation to easily form a random
+-- pattern of a floor, or choose the coefficients
+-- to your own liking. Entries in A which are not
+-- numbers are considered zero.
+function lib.math.cubic_polynomial(a, x, y)
+  if type(a) ~= &quot;table&quot; then
+    error(&quot;cubic_polynomial: First argument not a table (&quot; .. type(a)
+          .. &quot; instead).&quot;, 2)
+  end
+  if (type(x) ~= &quot;number&quot;) or (type(y) ~= &quot;number&quot;) then
+    error(&quot;cubic_polynomial: Second or third argument not a number.&quot;, 2)
+  end
+  return   (a[10] or 0)*y*y*y + (a[9] or 0)*x*y*y + (a[8] or 0)*x*x*y
+         + (a[7] or 0)*x*x*x + (a[6] or 0)*y*y + (a[5] or 0)*x*y
+         + (a[4] or 0)*x*x + (a[3] or 0)*y + (a[2] or 0)*x + (a[1] or 0)
+end
+
+---------------------------------------------------------------------
+--  PERMUTATIONS  AND  RANDOM  NUMBERS
+---------------------------------------------------------------------
+
+-- Return a random permutation of n elements.
+-- This function outputs a table with integer entries between
+-- 1 and n at positions 1 to n.
+function lib.math.permutation(n)
+  if type(n) ~= &quot;number&quot; then
+    error(&quot;permutation: Expected number, got &quot;..type(n)..&quot;!&quot;, 2)
+  end
+  if (n &lt; 1) or (n ~= math.floor(n)) then
+    error(&quot;permutation: Argument must be positive integer.&quot;, 2)
+  end
+  if n == 1 then
+    return {1}
+  end
+  local sequence = {}
+  for j = 1, n do
+    table.insert(sequence, j)
+  end
+  for n = table.getn(sequence), 2, -1 do
+    local m = math.random(n)
+    sequence[n], sequence[m] = sequence[m], sequence[n]
+  end
+  return sequence
+end
+
+-- Return a random cyclic permutation (i.e. with only one cycle) of n elements.
+function lib.math.cyclic_permutation(n)  
+  if type(n) ~= &quot;number&quot; then
+    error(&quot;cyclic_permutation: Expected number, got &quot;..type(n)..&quot;!&quot;, 2)
+  end
+  local sequence1 = lib.math.permutation(n)
+  local sequence2 = {}
+  for j = 1, n - 1 do
+    sequence2[sequence1[j]] = sequence1[j+1]
+  end
+  sequence2[sequence1[n]] = sequence1[1]
+  return sequence2
+end
+
+-- Return a table with NUMBER random entries.
+-- Additional arguments like with math.random.
+function lib.math.random_vector(number, ...)
+  if type(number) ~= &quot;number&quot; then
+    error(&quot;random_vector: First argument not a number (&quot;..type(number)..&quot; instead).&quot;, 2)
+  end
+  if (number &lt; 0) or (number ~= math.ceil(number)) then
+    error(&quot;random_vector: First argument out of range (&quot;..number..&quot;).&quot;, 2)
+  end
+  local result = {}
+  for j = 1, number do
+    result[j] = math.random(...)
+  end
+  return result
+end
+
+    ]]&gt;&lt;/el:luamain&gt;
+    &lt;el:i18n&gt;
+    &lt;/el:i18n&gt;
+  &lt;/el:protected&gt;
+&lt;/el:level&gt;
+

Modified: trunk/data/levels/lib/libsoko-endphase.xml
===================================================================
--- trunk/data/levels/lib/libsoko-endphase.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/lib/libsoko-endphase.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -74,7 +74,7 @@
   -- ensure a correctly set endphase-attribute
   local endp = sokoarea[nr].design.endp
   if not endp then
-    sokoarea[nr].design.endp = luatools.deep_copy(default_design.endp)
+    sokoarea[nr].design.endp = lib.lua.deep_copy(default_design.endp)
     endp = sokoarea[nr].design.endp
   end
   if type(endp) ~= &quot;table&quot; then
@@ -83,7 +83,7 @@
   end
   local alg = endp.alg
   if alg == nil then
-    sokoarea[nr].design.endp.alg = luatools.deep_copy(default_design.endp.alg)
+    sokoarea[nr].design.endp.alg = lib.lua.deep_copy(default_design.endp.alg)
     alg = endp.alg
   end
   if type(alg) ~= &quot;string&quot; then
@@ -131,7 +131,7 @@
 function endphase(sokoarea_number)
   -- Correct structure of endp-attribute has been checked
   -- by prepare_endphase, we trust it blindly.
-  local endp = luatools.deep_copy(sokoarea[sokoarea_number].design.endp)
+  local endp = lib.lua.deep_copy(sokoarea[sokoarea_number].design.endp)
   local alg = endp.alg
   local param = &quot;&quot;
   local px, py = enigma.GetPos(enigma.GetNamedObject(&quot;marble_&quot;..sokoarea_number..&quot;_1&quot;))
@@ -150,7 +150,7 @@
 
   -- redraw level and give items
   endphase_redraw_level_array(sokoarea_number)
-  local give = luatools.deep_copy(endp.give)
+  local give = lib.lua.deep_copy(endp.give)
   if type(give) == &quot;string&quot; then
     give = {give}
   end
@@ -210,7 +210,7 @@
 
 function endphase_redraw_level_array(sokoarea_number)
   local nr = sokoarea_number or 1
-  local endp = luatools.deep_copy(sokoarea[nr].design.endp)
+  local endp = lib.lua.deep_copy(sokoarea[nr].design.endp)
   local dx = sokoarea[nr].offset.x
   local dy = sokoarea[nr].offset.y
 
@@ -307,7 +307,7 @@
 
   -- Select all places outside or in the walls, unreachable
   -- for the marble.
-  for p, v in pairs(luatools.combine_tables(sokoarea[nr].list_outside,
+  for p, v in pairs(lib.lua.combine_tables(sokoarea[nr].list_outside,
                 sokoarea[nr].list_wall_two)) do
     if (mod(v.lx, 2) == 0) and (mod(v.ly, 2) == 0) then
       table.insert(places, v)
@@ -337,11 +337,11 @@
     end    
   end
 
-  luatools.shuffle_table(places)
+  lib.lua.shuffle_table(places)
 
   for j = 1, number_pairs do
-    set_oxyd(sokoarea_number, luatools.deep_copy(places[2*j-1]), flavor, j - 1)
-    set_oxyd(sokoarea_number, luatools.deep_copy(places[2*j]), flavor, j - 1)
+    set_oxyd(sokoarea_number, lib.lua.deep_copy(places[2*j-1]), flavor, j - 1)
+    set_oxyd(sokoarea_number, lib.lua.deep_copy(places[2*j]), flavor, j - 1)
   end
   oxyd_shuffle()
 end
@@ -362,10 +362,10 @@
       -- and no other oxyd or blocker is near the new oxyd or its
       -- blocker.
       for j, w in pairs(oxyds) do
-        if    (luatools.manhattan_distance(w.blocker.lx, w.blocker.ly, x, y) &lt;= 1)
-           or (luatools.manhattan_distance(w.lx, w.ly, x, y) &lt;= 1)
-           or (luatools.manhattan_distance(w.blocker.lx, w.blocker.ly, x-dx, y-dy) &lt;= 1)
-           or (luatools.manhattan_distance(w.lx, w.ly, x-dx, y-dy) &lt;= 1) then
+        if    (lib.math.manhattan_distance(w.blocker.lx, w.blocker.ly, x, y) &lt;= 1)
+           or (lib.math.manhattan_distance(w.lx, w.ly, x, y) &lt;= 1)
+           or (lib.math.manhattan_distance(w.blocker.lx, w.blocker.ly, x-dx, y-dy) &lt;= 1)
+           or (lib.math.manhattan_distance(w.lx, w.ly, x-dx, y-dy) &lt;= 1) then
           return false
         end
       end
@@ -404,11 +404,11 @@
     end    
   end
 
-  luatools.shuffle_table(oxyds)
+  lib.lua.shuffle_table(oxyds)
 
   -- set oxyds and blockers
   local function set_block(w)
-    local myblocker = luatools.deep_copy(blocker)
+    local myblocker = lib.lua.deep_copy(blocker)
     -- if there's an entry &quot;st-door&quot;, choose between st-door-h and st-door-v.
     if type(myblocker) == &quot;string&quot; then
       myblocker = {myblocker}
@@ -425,11 +425,11 @@
     -- now set in-floor and blocker, and add to list_blocker.
     set_element(w.lx, w.ly, nr, &quot;inf&quot;)
     set_element(w.lx, w.ly, nr, &quot;&quot;, myblocker)
-    sokoarea[nr].list_blocker[(w.lx)..&quot;/&quot;..(w.ly)] = luatools.deep_copy(w)
+    sokoarea[nr].list_blocker[(w.lx)..&quot;/&quot;..(w.ly)] = lib.lua.deep_copy(w)
   end
   for j = 1, number_pairs do   -- Testlevel: 14
-    set_oxyd(nr, luatools.deep_copy(oxyds[2*j-1]), flavor, j - 1)
-    set_oxyd(nr, luatools.deep_copy(oxyds[2*j]), flavor, j - 1)
+    set_oxyd(nr, lib.lua.deep_copy(oxyds[2*j-1]), flavor, j - 1)
+    set_oxyd(nr, lib.lua.deep_copy(oxyds[2*j]), flavor, j - 1)
     set_block(oxyds[2*j-1].blocker)
     set_block(oxyds[2*j].blocker)
   end
@@ -442,7 +442,7 @@
   for p, v in pairs(sokoarea[nr].list_goal) do
     table.insert(goal_table, v)
   end
-  luatools.shuffle_table(goal_table)
+  lib.lua.shuffle_table(goal_table)
   for j = 2, math.min(table.getn(goal_table), table.getn(oxyds)) do
     sokoarea[nr].goal_to_blocker[goal_table[j].goal_number] = oxyds[j].blocker
   end
@@ -459,7 +459,7 @@
     table.insert(places, v)
   end
 
-  luatools.shuffle_table(places)
+  lib.lua.shuffle_table(places)
   
   -- choose number of oxyds
   local max = table.getn(places)
@@ -508,7 +508,7 @@
     end
   end
 
-  luatools.shuffle_table(places)
+  lib.lua.shuffle_table(places)
 
   -- choose number of magnets
   local number_magnets = math.floor(table.getn(places)/6)
@@ -529,7 +529,7 @@
     table.insert(places, v)
   end
 
-  luatools.shuffle_table(places)
+  lib.lua.shuffle_table(places)
 
   -- choose number of fourswitchs/oxyds
   local max = table.getn(places)
@@ -552,7 +552,7 @@
     places[j].correct = false
   end
   places.number_pairs = number_pairs
-  sokoarea[sokoarea_number].places = luatools.deep_copy(places)
+  sokoarea[sokoarea_number].places = lib.lua.deep_copy(places)
 end
 
 function endphase_call_fourswitch(onoff, sender)
@@ -661,13 +661,13 @@
     local it = enigma.GetItem(x, y)
     local fl = enigma.GetFloor(x, y)
     if st and enigma.GetAttrib(st, &quot;_sokoarea&quot;) then
-      SendMessage(st, luatools.cond(open, &quot;open&quot;, &quot;close&quot;))
+      SendMessage(st, lib.lua.cond(open, &quot;open&quot;, &quot;close&quot;))
     end
     if it and enigma.GetAttrib(it, &quot;_sokoarea&quot;) then
-      SendMessage(it, luatools.cond(open, &quot;open&quot;, &quot;close&quot;))
+      SendMessage(it, lib.lua.cond(open, &quot;open&quot;, &quot;close&quot;))
     end
     if fl then
-      SendMessage(fl, luatools.cond(open, &quot;close&quot;, &quot;open&quot;))
+      SendMessage(fl, lib.lua.cond(open, &quot;close&quot;, &quot;open&quot;))
     end
   end  
 end
@@ -675,7 +675,7 @@
 function endphase_vortex(sokoarea_number)
   local nr = sokoarea_number or 1
   local list_way = 
-    luatools.combine_tables(sokoarea[nr].list_way, sokoarea[nr].list_blocker)
+    lib.lua.combine_tables(sokoarea[nr].list_way, sokoarea[nr].list_blocker)
   local components = 0
   local component = {}
 
@@ -737,7 +737,7 @@
       table.insert(u, component[j])
     end
   end
-  luatools.shuffle_table(u)
+  lib.lua.shuffle_table(u)
   while (table.getn(t) &lt; 5) and (table.getn(u) &gt; 0) do
     table.insert(t, u[table.getn(u)])
     table.remove(u)
@@ -754,7 +754,7 @@
   
   -- Find a cyclic permutation (i.e. with only one cycle) to connect the
   -- vortices (each vortex shall be reached by starting from any other).
-  local connect = luatools.cyclic_permutation(components)
+  local connect = lib.math.cyclic_permutation(components)
 
   -- Now set and connect the vortices
   for j, v in pairs(vortex) do
@@ -782,7 +782,7 @@
     table.insert(places, v)
   end
 
-  luatools.shuffle_table(places)
+  lib.lua.shuffle_table(places)
   
   -- set items (for Enigma 1.0), set attributes of door (&gt;= 1.1)
   for j, v in pairs(places) do
@@ -792,16 +792,16 @@
     if st then
       enigma.SetAttrib(st, &quot;action&quot;, &quot;callback&quot;)
       enigma.SetAttrib(st, &quot;target&quot;, &quot;endphase_call_knocking&quot;)
-      local closepos = places[luatools.mod(j, table.getn(places)) + 1]
-      local openpos = places[luatools.mod(j+1, table.getn(places)) + 1]
+      local closepos = places[lib.lua.mod(j, table.getn(places)) + 1]
+      local openpos = places[lib.lua.mod(j+1, table.getn(places)) + 1]
       enigma.SetAttrib(st, &quot;_close_x&quot;, closepos.lx)
       enigma.SetAttrib(st, &quot;_close_y&quot;, closepos.ly)
       enigma.SetAttrib(st, &quot;_open_x&quot;, openpos.lx)
       enigma.SetAttrib(st, &quot;_open_y&quot;, openpos.ly)
       --enigma.SetAttrib(st, &quot;_close&quot;,
-      --  luatools.deep_copy(places[luatools.mod(j+1, table.getn(places)) + 1]))
+      --  lib.lua.deep_copy(places[lib.lua.mod(j+1, table.getn(places)) + 1]))
       --enigma.SetAttrib(st, &quot;_open&quot;,
-      --  luatools.deep_copy(places[luatools.mod(j+2, table.getn(places)) + 1]))
+      --  lib.lua.deep_copy(places[lib.lua.mod(j+2, table.getn(places)) + 1]))
     end
   end
 end

Modified: trunk/data/levels/lib/libsoko.xml
===================================================================
--- trunk/data/levels/lib/libsoko.xml	2008-08-23 12:20:31 UTC (rev 1283)
+++ trunk/data/levels/lib/libsoko.xml	2008-08-23 16:58:35 UTC (rev 1284)
@@ -8,7 +8,8 @@
       &lt;el:copyright&gt;Copyright &#169; 2007 Enigma Team&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.00&quot;&gt;
-        &lt;el:dependency el:path=&quot;lib/libluatools&quot; el:id=&quot;lib/libluatools&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/liblua&quot; el:id=&quot;lib/liblua&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
         &lt;el:dependency el:path=&quot;lib/libsoko-designlist&quot; el:id=&quot;lib/libsoko-designlist&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
         &lt;el:dependency el:path=&quot;lib/libsoko-endphase&quot; el:id=&quot;lib/libsoko-endphase&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
       &lt;/el:compatibility&gt;
@@ -137,7 +138,7 @@
 -- set_oxyd sets an oxyd with given flavor and color and adds
 -- the neccessary entry to list_oxyd.
 function set_oxyd(sokoarea_number, list_entry, flavor, color)
-  local entry = luatools.deep_copy(list_entry)
+  local entry = lib.lua.deep_copy(list_entry)
   entry.flavor = flavor
   entry.color = color
   oxyd(entry.lx, entry.ly, flavor, color)
@@ -824,16 +825,16 @@
   -- choose design
   local design = {}
   if type(design_description) == &quot;number&quot; then
-    design = luatools.deep_copy(design_list[design_description])
+    design = lib.lua.deep_copy(design_list[design_description])
   elseif type(design_description) == &quot;table&quot; then
-    design = luatools.deep_copy(design_description)
+    design = lib.lua.deep_copy(design_description)
   elseif (type(design_description) == &quot;nil&quot;) and (type(level_array) == &quot;table&quot;) then
-    design = luatools.deep_copy(design_from_level(level_array, maxdesignnumber))
+    design = lib.lua.deep_copy(design_from_level(level_array, maxdesignnumber))
   else
     myerror(&quot;Can't make sense of design type &quot;..type(design)..&quot;.&quot;)
   end
   -- fill chosen design with default values where neccessary
-  design = luatools.combine_tables({design, default_design})
+  design = lib.lua.combine_tables({design, default_design})
   -- No stone set for outf, not even &quot;st-none&quot;?
   -- Use the default outf-stone instead, and remove it on endphase.
   if type(design.outf) ~= &quot;table&quot; then


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000713.html">[Enigma-game-svn] r1283 - in homepage/input: . articles
</A></li>
	<LI>Next message: <A HREF="000715.html">[Enigma-game-svn] r1285 - trunk/doc/reference
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#714">[ date ]</a>
              <a href="thread.html#714">[ thread ]</a>
              <a href="subject.html#714">[ subject ]</a>
              <a href="author.html#714">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
