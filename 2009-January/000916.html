<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1487 - in trunk: data data/gfx32 data/gfx40	data/gfx48 data/schemas src src/floors src/items src/stones
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1487%20-%20in%20trunk%3A%20data%20data/gfx32%20data/gfx40%0A%09data/gfx48%20data/schemas%20src%20src/floors%20src/items%20src/stones&In-Reply-To=%3C200901262320.n0QNKtEa018436%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000915.html">
   <LINK REL="Next"  HREF="000917.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1487 - in trunk: data data/gfx32 data/gfx40	data/gfx48 data/schemas src src/floors src/items src/stones</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1487%20-%20in%20trunk%3A%20data%20data/gfx32%20data/gfx40%0A%09data/gfx48%20data/schemas%20src%20src/floors%20src/items%20src/stones&In-Reply-To=%3C200901262320.n0QNKtEa018436%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1487 - in trunk: data data/gfx32 data/gfx40	data/gfx48 data/schemas src src/floors src/items src/stones">ral at mail.berlios.de
       </A><BR>
    <I>Tue Jan 27 00:20:55 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000915.html">[Enigma-game-svn] r1486 - team_levelpacks/team_test_new_api
</A></li>
        <LI>Next message: <A HREF="000917.html">[Enigma-game-svn] r1488 - in trunk: data data/gfx32 data/gfx40	data/gfx48 data/schemas src src/items
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#916">[ date ]</a>
              <a href="thread.html#916">[ thread ]</a>
              <a href="subject.html#916">[ subject ]</a>
              <a href="author.html#916">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2009-01-27 00:20:47 +0100 (Tue, 27 Jan 2009)
New Revision: 1487

Added:
   trunk/data/gfx32/it_bag.png
   trunk/data/gfx32/st_dongle.png
   trunk/data/gfx40/it_bag.png
   trunk/data/gfx40/st_dongle.png
   trunk/data/gfx48/it_bag.png
   trunk/data/gfx48/st_dongle.png
   trunk/src/items/BagItem.cc
   trunk/src/items/BagItem.hh
Removed:
   trunk/data/gfx32/it-bag.png
   trunk/data/gfx32/st-magic.png
   trunk/data/gfx40/it-bag.png
   trunk/data/gfx40/st-magic.png
   trunk/data/gfx48/it-bag.png
   trunk/data/gfx48/st-magic.png
Modified:
   trunk/data/api1init.lua
   trunk/data/models-2d.lua
   trunk/data/schemas/objects.xml
   trunk/src/Makefile.am
   trunk/src/floors/ThiefFloor.cc
   trunk/src/items.cc
   trunk/src/lua.cc
   trunk/src/ox_extra.cc
   trunk/src/ox_magnum.cc
   trunk/src/ox_oxyd1.cc
   trunk/src/ox_peroxyd.cc
   trunk/src/stones.cc
   trunk/src/stones.hh
   trunk/src/stones/CompatibilityStones.cc
   trunk/src/stones/CompatibilityStones.hh
   trunk/src/stones/FlatStone.cc
   trunk/src/stones/ThiefStone.cc
   trunk/src/stones_simple.cc
Log:
Trunk 1.1: new API reengineering
- reenigineering bag item:
  - renaming it-bag -&gt; it_bag
- extend wo:add()
  - wo:add( YIN | YANG, tile | table)  to add arbitrary, non static, items to
      the player's inventories
  - wo:add(no[&quot;mybag&quot;], tile | table)  to add arbitrary, non static, items to
      existing bag items - the bags may even be part of an inventory or another
      bag
- remove/rename old st-magic:
  - new name st_dongle
  - this stone will not be available in new API, it remains for compatibility
    issues


Modified: trunk/data/api1init.lua
===================================================================
--- trunk/data/api1init.lua	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/data/api1init.lua	2009-01-26 23:20:47 UTC (rev 1487)
@@ -131,6 +131,7 @@
     fl_yinyang_yin = &quot;fl-acblack&quot;,
     fl_yinyang_yang = &quot;fl-acwhite&quot;,    
     it_banana = &quot;it-banana&quot;,
+    it_bag = &quot;it-bag&quot;,
     it_blocker = &quot;it-blocker&quot;,
     it_blocker_new = &quot;it-blocker-new&quot;,
     it_brake = &quot;it-brake&quot;,
@@ -276,6 +277,7 @@
     st_chess_white = &quot;st-chess_white&quot;,
     st_coinslot = &quot;st-coinslot&quot;,
     st_concrete = &quot;st-rock8&quot;,
+    st_dongle = &quot;st-magic&quot;,
     st_darkglass = &quot;st-glass2&quot;,
     st_darkglass_hollow = &quot;st-glass2_hole&quot;,
     st_darkglass_movable = &quot;st-glass2_move&quot;,

Deleted: trunk/data/gfx32/it-bag.png
===================================================================
(Binary files differ)

Copied: trunk/data/gfx32/it_bag.png (from rev 1483, trunk/data/gfx32/it-bag.png)

Deleted: trunk/data/gfx32/st-magic.png
===================================================================
(Binary files differ)

Copied: trunk/data/gfx32/st_dongle.png (from rev 1483, trunk/data/gfx32/st-magic.png)

Deleted: trunk/data/gfx40/it-bag.png
===================================================================
(Binary files differ)

Copied: trunk/data/gfx40/it_bag.png (from rev 1483, trunk/data/gfx40/it-bag.png)

Deleted: trunk/data/gfx40/st-magic.png
===================================================================
(Binary files differ)

Copied: trunk/data/gfx40/st_dongle.png (from rev 1483, trunk/data/gfx40/st-magic.png)

Deleted: trunk/data/gfx48/it-bag.png
===================================================================
(Binary files differ)

Copied: trunk/data/gfx48/it_bag.png (from rev 1483, trunk/data/gfx48/it-bag.png)

Deleted: trunk/data/gfx48/st-magic.png
===================================================================
(Binary files differ)

Copied: trunk/data/gfx48/st_dongle.png (from rev 1483, trunk/data/gfx48/st-magic.png)

Modified: trunk/data/models-2d.lua
===================================================================
--- trunk/data/models-2d.lua	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/data/models-2d.lua	2009-01-26 23:20:47 UTC (rev 1487)
@@ -450,7 +450,7 @@
 
 do
     itemlist = {
-        &quot;it-bag&quot;,
+        &quot;it_bag&quot;,
         &quot;it-blackbomb&quot;,
         &quot;it-blocker&quot;,
         &quot;it-booze&quot;,
@@ -1042,15 +1042,15 @@
     DefAnim(&quot;st-lightpassenger-break-hv&quot;, BuildFrames(anim_hv, 50), false)
 end
 
--- st-magic :-) --
+-- st_dongle :-) --
 do
-    local img = DefSubimages(&quot;st-magic&quot;, {h=4, modelname=&quot;st-magic-fg&quot;})
+    local img = DefSubimages(&quot;st_dongle&quot;, {h=4, modelname=&quot;st_dongle-fg&quot;})
     local nlist = {}
     for i=1, table.getn(img) do
-        nlist[i] = &quot;st-magic&quot;..i
+        nlist[i] = &quot;st_dongle&quot;..i
         DefRoundStone(nlist[i], img[i])
     end
-    display.DefineRandModel(&quot;st-magic&quot;, table.getn(nlist), nlist)
+    display.DefineRandModel(&quot;st_dongle&quot;, table.getn(nlist), nlist)
 end
 
 -- st-mail --

Modified: trunk/data/schemas/objects.xml
===================================================================
--- trunk/data/schemas/objects.xml	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/data/schemas/objects.xml	2009-01-26 23:20:47 UTC (rev 1487)
@@ -377,6 +377,7 @@
     &lt;object name=&quot;fl_yinyang_yang&quot;&gt;
       &lt;attr name=&quot;state&quot; value=&quot;1&quot;/&gt;
     &lt;/object&gt;
+    &lt;object name=&quot;it_bag&quot;/&gt;
     &lt;object name=&quot;it_blocker_new&quot; init=&quot;true&quot;&gt;
     &lt;/object&gt;
     &lt;object name=&quot;it_brake&quot;/&gt;

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/Makefile.am	2009-01-26 23:20:47 UTC (rev 1487)
@@ -202,6 +202,8 @@
 	gui/TextField.hh	\
 	gui/widgets.cc		\
 	gui/widgets.hh		\
+	items/BagItem.cc	\
+	items/BagItem.hh	\
 	items/BrakeItem.cc	\
 	items/BrakeItem.hh	\
 	items/BlockerItem.cc	\

Modified: trunk/src/floors/ThiefFloor.cc
===================================================================
--- trunk/src/floors/ThiefFloor.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/floors/ThiefFloor.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -124,7 +124,7 @@
                     enigma::Inventory *inv = player::GetInventory(owner);
                     if (inv &amp;&amp; inv-&gt;size() &gt; 0) {
                         if (bag == NULL) {
-                            bag = MakeItem(&quot;it-bag&quot;);
+                            bag = MakeItem(&quot;it_bag&quot;);
                             bag-&gt;setOwnerPos(get_pos());
                         }
                         int i = IntegerRand(0, int (inv-&gt;size()-1));
@@ -140,7 +140,7 @@
         if(Item *it = GetItem(get_pos())) {
             if (!(it-&gt;get_traits().flags &amp; itf_static)) {
                 if (bag == NULL) {
-                    bag = MakeItem(&quot;it-bag&quot;);
+                    bag = MakeItem(&quot;it_bag&quot;);
                     bag-&gt;setOwnerPos(get_pos());                
                 }
                 dynamic_cast&lt;ItemHolder *&gt;(bag)-&gt;add_item(YieldItem(get_pos()));

Added: trunk/src/items/BagItem.cc
===================================================================
--- trunk/src/items/BagItem.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/items/BagItem.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007,2008,2009 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include &quot;items/BagItem.hh&quot;
+#include &quot;errors.hh&quot;
+//#include &quot;main.hh&quot;
+#include &quot;items/GlassesItem.hh&quot;
+#include &quot;Inventory.hh&quot;
+#include &quot;player.hh&quot;
+#include &quot;world.hh&quot;
+
+namespace enigma {
+
+    BagItem::BagItem() {
+    }
+    
+    BagItem::~BagItem() {
+        // Bags on the grid are disposed, but bags in the inventory need to be
+        // delete their contents on the destructor
+        ecl::delete_sequence (m_contents.begin(), m_contents.end());
+    }
+    
+    BagItem * BagItem::clone() {
+        ASSERT(is_empty(), XLevelRuntime, &quot;Bag:: Clone of a full bag!&quot;);
+        return new BagItem(*this);
+    }
+
+    void BagItem::dispose() {
+        Item * it = yield_first();
+        while (it != NULL) {
+            DisposeObject(it);
+            it = yield_first();
+        }
+        delete this;
+    }
+
+    std::string BagItem::getClass() const {
+        return &quot;it_bag&quot;;
+    }
+    
+    void BagItem::on_creation(GridPos p) {
+        GridObject::on_creation(p);
+        for (std::vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
+            (*itr)-&gt;setOwnerPos(p);
+    }
+
+    void BagItem::on_removal(GridPos p) {
+        GridObject::on_removal(p);
+        for (std::vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
+            (*itr)-&gt;setOwner(-1);            
+    }
+    
+    void BagItem::setOwner(int player) {
+        GridObject::setOwner(player);
+        for (std::vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
+            (*itr)-&gt;setOwner(player);            
+    }
+
+    void BagItem::setOwnerPos(GridPos p) {
+        GridObject::setOwnerPos(p);
+        for (std::vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
+            (*itr)-&gt;setOwnerPos(p);
+    }
+        
+    bool BagItem::actor_hit(Actor *a) {
+        if (Item::actor_hit(a)) {
+            if (Inventory *inv = player::MayPickup(a, NULL)) {
+                std::vector&lt;Item *&gt;::size_type oldSize = m_contents.size();
+                inv-&gt;takeItemsFrom(this);
+                Glasses::updateGlasses();
+                if (oldSize != m_contents.size() &amp;&amp; !inv-&gt;willAddItem(this)) {
+                    // some items have been picked up but the bag will not
+                    // be picked up (and cause the following actions)
+                    player::RedrawInventory (inv);
+                    sound_event (&quot;pickup&quot;);
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    // ItemHolder interface
+    bool BagItem::is_full() const {
+        return m_contents.size() &gt;= BAGSIZE;
+    }
+    void BagItem::add_item(Item *it) {
+        // thieves may add items beyond pick up limit BAGSIZE
+        m_contents.insert (m_contents.begin(), it);
+        it-&gt;setOwnerPos(get_pos());  // item is at same position as bag
+    }
+
+    bool BagItem::is_empty() const {
+        return m_contents.size() == 0;
+    }
+
+    Item * BagItem::yield_first() {
+        if (m_contents.size() &gt; 0) {
+            Item *it = m_contents[0];
+            m_contents.erase (m_contents.begin());
+            it-&gt;setOwner(-1);  // no owner
+            return it;
+        }
+        return NULL;
+    }
+    
+    DEF_ITEMTRAITS(BagItem, &quot;it_bag&quot;, it_bag);    
+
+    BOOT_REGISTER_START
+        BootRegister(new BagItem(), &quot;it_bag&quot;);
+    BOOT_REGISTER_END
+
+} // namespace enigma


Property changes on: trunk/src/items/BagItem.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/items/BagItem.hh
===================================================================
--- trunk/src/items/BagItem.hh	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/items/BagItem.hh	2009-01-26 23:20:47 UTC (rev 1487)
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2009 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+#ifndef BAGITEM_HH
+#define BAGITEM_HH
+
+#include &quot;items.hh&quot;
+#include &quot;Inventory.hh&quot;
+#include &lt;vector&gt;
+
+namespace enigma {
+    /**
+     */
+    class BagItem : public Item, public ItemHolder {
+        DECL_ITEMTRAITS;
+
+    private:
+       enum { BAGSIZE = 13 };
+         
+    public:
+        BagItem();
+        ~BagItem();
+
+        // Object interface
+        virtual BagItem *clone();
+        virtual void dispose();
+        virtual std::string getClass() const;
+ 
+        // GridObject interface
+        virtual void on_creation(GridPos p);
+        virtual void on_removal(GridPos p);
+        virtual void setOwner(int player);
+        virtual void setOwnerPos(GridPos po);
+
+        // Item interface
+        virtual bool actor_hit(Actor *a);
+    
+        // ItemHolder interface
+        virtual bool is_full() const;
+        virtual bool is_empty() const;
+        virtual void add_item (Item *it);
+        virtual Item *yield_first();
+        
+    private:
+        std::vector&lt;Item *&gt; m_contents;
+    };
+   
+} // namespace enigma
+
+#endif


Property changes on: trunk/src/items/BagItem.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/items.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -1016,109 +1016,7 @@
                 itf_invisible | itf_fireproof);
 }
 
-/* -------------------- Bag -------------------- */
-namespace
-{
-    class Bag : public Item, public enigma::ItemHolder {
-        DECL_ITEMTRAITS;
 
-        enum { BAGSIZE = 13 };
-        vector&lt;Item *&gt; m_contents;
-
-        // Item interface
-        bool actor_hit (Actor *a) {
-            if (Item::actor_hit(a)) {
-                if (Inventory *inv = player::MayPickup(a, NULL)) {
-                    std::vector&lt;Item *&gt;::size_type oldSize = m_contents.size();
-                    inv-&gt;takeItemsFrom(this);
-                    Glasses::updateGlasses();
-                    if (oldSize != m_contents.size() &amp;&amp; !inv-&gt;willAddItem(this)) {
-                        // some items have been picked up but the bag will not
-                        // be picked up (and cause the following actions)
-                        player::RedrawInventory (inv);
-                        sound_event (&quot;pickup&quot;);
-                    }
-                    return true;
-                }
-            }
-            return false;
-        }
-
-    public:
-        virtual Bag * clone() {
-            ASSERT(is_empty(), XLevelRuntime, &quot;Bag:: Clone of a full bag!&quot;);
-            return new Bag(*this);
-        }
-
-        virtual void dispose() {
-            Item * it = yield_first();
-            while (it != NULL) {
-                DisposeObject(it);
-                it = yield_first();
-            }
-            delete this;
-        }
-
-        virtual void on_creation (GridPos p) {
-            GridObject::on_creation(p);
-            for (vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
-                (*itr)-&gt;setOwnerPos(p);
-        }
-    
-        virtual void on_removal (GridPos p) {
-            GridObject::on_removal(p);
-            for (vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
-                (*itr)-&gt;setOwner(-1);            
-        }
-        
-        virtual void setOwner(int player) {
-            GridObject::setOwner(player);
-            for (vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
-                (*itr)-&gt;setOwner(player);            
-        }
-    
-        virtual void setOwnerPos(GridPos p) {
-            GridObject::setOwnerPos(p);
-            for (vector&lt;Item *&gt;::iterator itr = m_contents.begin(); itr != m_contents.end(); ++itr)
-                (*itr)-&gt;setOwnerPos(p);
-        }
-    	
-        // ItemHolder interface
-        virtual bool is_full() const {
-            return m_contents.size() &gt;= BAGSIZE;
-        }
-        virtual void add_item (Item *it) {
-            // thieves may add items beyond pick up limit BAGSIZE
-            m_contents.insert (m_contents.begin(), it);
-            it-&gt;setOwnerPos(get_pos());  // item is at same position as bag
-        }
-
-        virtual bool is_empty() const {
-            return m_contents.size() == 0;
-        }
-
-        virtual Item *yield_first() {
-            if (m_contents.size() &gt; 0) {
-                Item *it = m_contents[0];
-                m_contents.erase (m_contents.begin());
-                it-&gt;setOwner(-1);  // no owner
-                return it;
-            }
-            return NULL;
-        }
-
-        Bag()
-        {}
-
-        ~Bag() {
-            // Bags on the grid are disposed, but bags in the inventory need to be
-            // delete their contents on the destructor
-            ecl::delete_sequence (m_contents.begin(), m_contents.end());
-        }
-    };
-    DEF_ITEMTRAITS(Bag, &quot;it-bag&quot;, it_bag);
-}
-
 /* -------------------- it-surprise -------------------- */
 namespace
 {
@@ -1232,7 +1130,6 @@
 
 void InitItems()
 {
-    RegisterItem (new Bag);
     RegisterItem (new BlackBomb);
     RegisterItem (new BlackBombBurning);
     RegisterItem (new Booze);

Modified: trunk/src/lua.cc
===================================================================
--- trunk/src/lua.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/lua.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -26,6 +26,9 @@
 #include &quot;server.hh&quot;
 #include &quot;SoundEffectManager.hh&quot;
 #include &quot;options.hh&quot;
+#include &quot;player.hh&quot;
+#include &quot;Inventory.hh&quot;
+#include &quot;ItemHolder.hh&quot;
 #include &quot;WorldProxy.hh&quot;
 #include &quot;lev/Index.hh&quot;
 #include &quot;lev/Proxy.hh&quot;
@@ -2067,7 +2070,7 @@
 }
 
 
-static int setObjectByTable(lua_State *L, double x, double y, bool onlyFloors = false) {
+static int setObjectByTable(lua_State *L, double x, double y, bool onlyFloors = false, ItemHolder *itemHolder =NULL) {
     // table at -1 
     int xi = round_down&lt;int&gt;(x);
     int yi = round_down&lt;int&gt;(y);
@@ -2117,69 +2120,83 @@
     }
     lua_pop(L, 1);   // object type
     setObjectAttributes(obj, L);
-    switch (obj-&gt;getObjectType()) {
-        case Object::FLOOR :
-            if (Value odd = obj-&gt;getAttr(&quot;checkerboard&quot;)) {
-                if ((xi+yi)%2 != (int)odd) {
-                    DisposeObject(obj);
-                    break;
-                }
-            }
-            SetFloor(GridPos(xi,yi), dynamic_cast&lt;Floor *&gt;(obj));
-            break;
-        case Object::STONE :
-            if (!onlyFloors) {
+    if (itemHolder != NULL) {
+        if (obj-&gt;getObjectType() != Object::ITEM) {
+            DisposeObject(obj);
+            throwLuaError(L, &quot;Attempt to add an object to a bag or inventory that is no item&quot;);
+        } else {
+            Item * it = dynamic_cast&lt;Item *&gt;(obj);
+            if (it-&gt;isStatic()) {
+                DisposeObject(obj);
+                throwLuaError(L, &quot;Attempt to add a static item to a bag or inventory&quot;);
+            } else
+                itemHolder-&gt;add_item(it);
+        }
+    } else {
+        switch (obj-&gt;getObjectType()) {
+            case Object::FLOOR :
                 if (Value odd = obj-&gt;getAttr(&quot;checkerboard&quot;)) {
                     if ((xi+yi)%2 != (int)odd) {
                         DisposeObject(obj);
                         break;
                     }
                 }
-                SetStone(GridPos(xi,yi), dynamic_cast&lt;Stone *&gt;(obj));
-            } else {
-                DisposeObject(obj);
-            }
-            break;
-        case Object::ITEM  :
-            if (!onlyFloors) {
-                if (Value odd = obj-&gt;getAttr(&quot;checkerboard&quot;)) {
-                    if ((xi+yi)%2 != (int)odd) {
-                        DisposeObject(obj);
-                        break;
+                SetFloor(GridPos(xi,yi), dynamic_cast&lt;Floor *&gt;(obj));
+                break;
+            case Object::STONE :
+                if (!onlyFloors) {
+                    if (Value odd = obj-&gt;getAttr(&quot;checkerboard&quot;)) {
+                        if ((xi+yi)%2 != (int)odd) {
+                            DisposeObject(obj);
+                            break;
+                        }
                     }
+                    SetStone(GridPos(xi,yi), dynamic_cast&lt;Stone *&gt;(obj));
+                } else {
+                    DisposeObject(obj);
                 }
-                SetItem(GridPos(xi,yi), dynamic_cast&lt;Item *&gt;(obj));
-            } else {
-                DisposeObject(obj);
-            }
-            break;
-        case Object::ACTOR :
-            if (!onlyFloors) {
-                lua_rawgeti(L, -1, 2);
-                if (lua_isnumber(L, -1))
-                    x += lua_tonumber(L, -1);
-                lua_rawgeti(L, -2, 3);
-                if (lua_isnumber(L, -1))
-                    y += lua_tonumber(L, -1);
-                lua_pop(L, 2);               
-                if (IsInsideLevel(GridPos(round_down&lt;int&gt;(x), round_down&lt;int&gt;(y)))) 
-                    AddActor(x, y, dynamic_cast&lt;Actor *&gt;(obj));
-                else
-                    throwLuaError(L, &quot;World: actor addition to position outside of world&quot;);
-            } else
-                DisposeObject(obj);
-            break;
-        case Object::OTHER :
-            if (x &lt; 0)
-                AddOther(dynamic_cast&lt;Other *&gt;(obj));
-            break;
-        default :
-            throwLuaError(L, &quot;World set of unknown object&quot;);
+                break;
+            case Object::ITEM  :
+                if (!onlyFloors) {
+                    if (Value odd = obj-&gt;getAttr(&quot;checkerboard&quot;)) {
+                        if ((xi+yi)%2 != (int)odd) {
+                            DisposeObject(obj);
+                            break;
+                        }
+                    }
+                    SetItem(GridPos(xi,yi), dynamic_cast&lt;Item *&gt;(obj));
+                } else {
+                    DisposeObject(obj);
+                }
+                break;
+            case Object::ACTOR :
+                if (!onlyFloors) {
+                    lua_rawgeti(L, -1, 2);
+                    if (lua_isnumber(L, -1))
+                        x += lua_tonumber(L, -1);
+                    lua_rawgeti(L, -2, 3);
+                    if (lua_isnumber(L, -1))
+                        y += lua_tonumber(L, -1);
+                    lua_pop(L, 2);               
+                    if (IsInsideLevel(GridPos(round_down&lt;int&gt;(x), round_down&lt;int&gt;(y)))) 
+                        AddActor(x, y, dynamic_cast&lt;Actor *&gt;(obj));
+                    else
+                        throwLuaError(L, &quot;World: actor addition to position outside of world&quot;);
+                } else
+                    DisposeObject(obj);
+                break;
+            case Object::OTHER :
+                if (x &lt; 0)
+                    AddOther(dynamic_cast&lt;Other *&gt;(obj));
+                break;
+            default :
+                throwLuaError(L, &quot;World set of unknown object&quot;);
+        }
     }
     return 0;
 }
 
-static int setObjectByTile(lua_State *L, double x, double y, bool onlyFloors = false) {
+static int setObjectByTile(lua_State *L, double x, double y, bool onlyFloors = false, ItemHolder *itemHolder =NULL) {
     // tile at -1
     
     // this is a recursive function - ensure enough space on the stack
@@ -2189,16 +2206,16 @@
     lua_getmetatable(L, -1);
     lua_rawgeti(L, -1, 1);    // first tile part
     if (is_tile(L, -1))
-        setObjectByTile(L, x, y, onlyFloors);
+        setObjectByTile(L, x, y, onlyFloors, itemHolder);
     else
-        setObjectByTable(L, x, y, onlyFloors);
+        setObjectByTable(L, x, y, onlyFloors, itemHolder);
     lua_pop(L, 1);  // tile or table
     lua_rawgeti(L, -1, 2);    // second optional tile part
     if (!lua_isnil(L, -1)) {
         if (is_tile(L, -1))
-            setObjectByTile(L, x, y, onlyFloors);
+            setObjectByTile(L, x, y, onlyFloors, itemHolder);
         else
-            setObjectByTable(L, x, y, onlyFloors);
+            setObjectByTable(L, x, y, onlyFloors, itemHolder);
     }
     lua_pop(L, 2);  // tile or table or nil + metatable
     return 0;
@@ -2556,6 +2573,22 @@
             setObjectByTable(L, -1, -1);
         else // is tile
             setObjectByTile(L, -1, -1);
+    } else if (lua_isnumber(L, 2) &amp;&amp; (is_tile(L, 3)  || is_table(L, 3))) {
+        int player = lua_tointeger(L, 2);
+        if (player != YIN &amp;&amp; player != YANG)
+            throwLuaError(L, &quot;World attempt to add objects to not existing player&quot;);
+        if (is_table(L, -1))
+            setObjectByTable(L, -1, -1, false, player::GetInventory(player));
+        else // is tile
+            setObjectByTile(L, -1, -1, false, player::GetInventory(player));         
+    } else if (is_object(L, 2) &amp;&amp; (is_tile(L, 3)  || is_table(L, 3))) {
+        ItemHolder *ih = dynamic_cast&lt;ItemHolder *&gt;(to_object(L, 2));
+        if (ih == NULL)
+            throwLuaError(L, &quot;World attempt to add objects to an object that can not take other objects&quot;);
+        if (is_table(L, -1))
+            setObjectByTable(L, -1, -1, false, ih);
+        else // is tile
+            setObjectByTile(L, -1, -1, false, ih);         
     }
     return 0;
 }

Modified: trunk/src/ox_extra.cc
===================================================================
--- trunk/src/ox_extra.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/ox_extra.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -347,7 +347,7 @@
     UNUSED,                  // OxydExtra item 0x24
     UNUSED,                  // OxydExtra item 0x25
     UNUSED,                  // OxydExtra item 0x26
-    &quot;it-bag&quot;,                     // OxydExtra item 0x27
+    &quot;it_bag&quot;,                     // OxydExtra item 0x27
     UNUSED,                  // OxydExtra item 0x28
     UNUSED,                  // OxydExtra item 0x29
     &quot;it_sensor&quot;,                  // OxydExtra item 0x2a

Modified: trunk/src/ox_magnum.cc
===================================================================
--- trunk/src/ox_magnum.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/ox_magnum.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -330,7 +330,7 @@
     &quot;it_seed&quot;,          // OxydMagnum item 0x25
     &quot;it-spring2&quot;,       // OxydMagnum item 0x26
     &quot;it-spring1&quot;,       // OxydMagnum item 0x27
-    &quot;it-bag&quot;,           // OxydMagnum item 0x28
+    &quot;it_bag&quot;,           // OxydMagnum item 0x28
     &quot;it_magnet_off&quot;,    // OxydMagnum item 0x29
     &quot;it_inversesensor&quot;, // OxydMagnum item 0x2a
     &quot;it_sensor&quot;,        // OxydMagnum item 0x2b

Modified: trunk/src/ox_oxyd1.cc
===================================================================
--- trunk/src/ox_oxyd1.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/ox_oxyd1.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -346,7 +346,7 @@
     &quot;it_seed&quot;,                    // 0x25
     &quot;it-spring2&quot;,                 // 0x26
     &quot;it-spring1&quot;,                 // 0x27
-    &quot;it-bag&quot;,                     // 0x28
+    &quot;it_bag&quot;,                     // 0x28
     &quot;it_magnet_off&quot;,              // 0x29
     &quot;it_inversesensor&quot;,           // 0x2a
     &quot;it_sensor&quot;,                  // 0x2b

Modified: trunk/src/ox_peroxyd.cc
===================================================================
--- trunk/src/ox_peroxyd.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/ox_peroxyd.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -40,7 +40,7 @@
     case 0x39: case 0x3a: case 0x3b:
         // Create magic stones only if they are absolutely necessary
         if (level.getRequireMagicPiece())
-            st = MakeStone (&quot;st-magic&quot;);
+            st = MakeStone (&quot;st_dongle&quot;);
         break;
     default:
         st = OxydLoader::make_stone (type, x, y);
@@ -245,9 +245,9 @@
     &quot;st_oneway_white_e&quot;,        // PerOxyd stone 0x36
     &quot;st_oneway_white_n&quot;,        // PerOxyd stone 0x37
     &quot;st_oneway_white_s&quot;,        // PerOxyd stone 0x38
-    &quot;st-magic&quot;,                 // PerOxyd stone 0x39 ('st-magic')
-    &quot;st-magic&quot;,                 // PerOxyd stone 0x3a ('st-magic')
-    &quot;st-magic&quot;,                 // PerOxyd stone 0x3b ('st-magic')
+    &quot;st_dongle&quot;,                 // PerOxyd stone 0x39 ('st-magic')
+    &quot;st_dongle&quot;,                 // PerOxyd stone 0x3a ('st-magic')
+    &quot;st_dongle&quot;,                 // PerOxyd stone 0x3b ('st-magic')
     &quot;st_actorimpulse&quot;,          // PerOxyd stone 0x3c
     &quot;st_actorimpulse_invisible&quot;, // PerOxyd stone 0x3d
     &quot;st-laser-1&quot;,               // PerOxyd stone 0x3e  The laser-names are fake names!
@@ -418,7 +418,7 @@
     &quot;it_seed&quot;,                    // 0x24
     &quot;it-spring2&quot;,                 // 0x25
     &quot;it-spring1&quot;,                 // 0x26
-    &quot;it-bag&quot;,                     // 0x27
+    &quot;it_bag&quot;,                     // 0x27
     &quot;it_magnet_off&quot;,              // 0x28
     &quot;it_sensor_filter0&quot;,          // 0x29
     &quot;it_sensor_filter1&quot;,          // 0x2a

Modified: trunk/src/stones/CompatibilityStones.cc
===================================================================
--- trunk/src/stones/CompatibilityStones.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/stones/CompatibilityStones.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -19,12 +19,59 @@
 
 #include &quot;stones/CompatibilityStones.hh&quot;
 #include &quot;errors.hh&quot;
+#include &quot;client.hh&quot;
 //#include &quot;main.hh&quot;
 
 namespace enigma {
 
 /* -------------------- Oxyd compatibility stones -------------------- */
 
+/* -------------------- DongleStone -------------------- */
+
+    DongleStone::DongleStone() {
+    }
+    
+    void DongleStone::actor_hit(const StoneContact &amp;sc) {
+        if (sc.actor-&gt;getAttr(&quot;owner&quot;) &amp;&amp; 
+            sc.actor-&gt;get_vel() * sc.normal &lt; -4)
+        {
+            KillStone(get_pos());
+            client::Msg_ShowText(&quot;We don't sell books..&quot;, false, 2.0);
+        }
+    }
+    
+    DEF_TRAITSM(DongleStone, &quot;st_dongle&quot;, st_dongle, MOVABLE_BREAKABLE);
+
+
+    /**  st-easymode Easy-Mode Stone
+    
+    In easy game mode this stone converts the floor at its
+    position to fl-normal.
+    In normal game mode the stone kills any item at its position.
+    Then in both modes it kills itself.
+    
+    E.g. it can be used to hide water-barriers or to insert helper
+    items that make the level easier in easy game mode.
+    */
+    
+    EasyModeStone::EasyModeStone() {
+    }
+    
+    Value EasyModeStone::message(const Message &amp;m) {
+        if (m.message == &quot;_init&quot;) {
+            if (server::GetDifficulty() == DIFFICULTY_EASY) {
+                SetFloor (get_pos(), MakeFloor (&quot;fl_metal_7n&quot;));
+            } else {
+                KillItem (get_pos());
+            }
+            KillStone (get_pos());
+            return Value();
+        }
+        return Stone::message(m);
+    }
+
+    DEF_TRAITSM(EasyModeStone, &quot;st-easymode&quot;, st_easymode, MOVABLE_BREAKABLE);
+
     /* I have no idea what these stones are _really_ supposed to do;
        they seemingly do not appear in the landscape and they create
        normal floor tiles on creation.  Other than that... who
@@ -62,6 +109,8 @@
     DEF_TRAITSM(Oxyd_0x18, &quot;st-oxyd-0x18&quot;, st_oxyd_0x18, MOVABLE_BREAKABLE);
     
     BOOT_REGISTER_START
+        BootRegister(new DongleStone(), &quot;st_dongle&quot;);
+        BootRegister(new EasyModeStone(), &quot;st-easymode&quot;);
         BootRegister(new Peroxyd_0xb8(), &quot;st-peroxyd-0xb8&quot;);
         BootRegister(new Peroxyd_0xb9(), &quot;st-peroxyd-0xb9&quot;);
         BootRegister(new Oxyd_0x18(), &quot;st-oxyd-0x18&quot;);

Modified: trunk/src/stones/CompatibilityStones.hh
===================================================================
--- trunk/src/stones/CompatibilityStones.hh	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/stones/CompatibilityStones.hh	2009-01-26 23:20:47 UTC (rev 1487)
@@ -25,6 +25,26 @@
 
 namespace enigma {
 
+    class DongleStone : public Stone {
+        CLONEOBJ(DongleStone);
+        DECL_TRAITS;
+    public:
+        DongleStone();
+        
+        // Stone interface
+        virtual void actor_hit (const StoneContact &amp;sc);
+    };
+    
+    class EasyModeStone : public Stone {
+        CLONEOBJ(EasyModeStone);
+        DECL_TRAITS;
+    public:
+        EasyModeStone();
+        
+        // Object interface
+        virtual Value message(const Message &amp;m);
+    };
+
     /** 
      * 
      */

Modified: trunk/src/stones/FlatStone.cc
===================================================================
--- trunk/src/stones/FlatStone.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/stones/FlatStone.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -167,7 +167,7 @@
         if (((objFlags &amp; OBJBIT_BREAKABLE) || state == CRACKED) &amp;&amp; player::WieldedItemIs(sc.actor, &quot;it_hammer&quot;))
             doBreak();
         else if ((state == IDLE &amp;&amp; !(objFlags &amp; (OBJBIT_BREAKABLE | OBJBIT_HOLLOW))) &amp;&amp;
-                (player::WieldedItemIs(sc.actor, &quot;it-pencil&quot;))) {
+                (player::WieldedItemIs(sc.actor, &quot;it_pencil&quot;))) {
             enigma::Inventory *inv = player::GetInventory(sc.actor);
             if (inv &amp;&amp; inv-&gt;size() &gt; 0) {
                 delete inv-&gt;yield_item(0);

Modified: trunk/src/stones/ThiefStone.cc
===================================================================
--- trunk/src/stones/ThiefStone.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/stones/ThiefStone.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -126,7 +126,7 @@
                     enigma::Inventory *inv = player::GetInventory(owner);
                     if (inv &amp;&amp; inv-&gt;size() &gt; 0) {
                         if (bag == NULL) {
-                            bag = MakeItem(&quot;it-bag&quot;);
+                            bag = MakeItem(&quot;it_bag&quot;);
                             bag-&gt;setOwnerPos(get_pos());
                         }
                         int i = IntegerRand(0, int (inv-&gt;size()-1));

Modified: trunk/src/stones.cc
===================================================================
--- trunk/src/stones.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/stones.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -423,7 +423,7 @@
                 &quot;st_death&quot;,
                 &quot;st-surprise&quot;,
                 &quot;st_lightglass_hollow&quot;,
-                &quot;st-magic&quot;,
+                &quot;st_dongle&quot;,
                 &quot;st_knight&quot;,
                 &quot;st_thief&quot;,
                 &quot;st_flat_breakable&quot;,

Modified: trunk/src/stones.hh
===================================================================
--- trunk/src/stones.hh	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/stones.hh	2009-01-26 23:20:47 UTC (rev 1487)
@@ -66,7 +66,7 @@
         st_greenbrown,
         st_key,
         st_knight,
-        st_magic,
+        st_dongle,
         st_mirror,
         st_oneway,
         st_oxyd_0x18,

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2009-01-26 21:18:06 UTC (rev 1486)
+++ trunk/src/stones_simple.cc	2009-01-26 23:20:47 UTC (rev 1487)
@@ -56,53 +56,6 @@
     };
 }
 
-
-/* -------------------- EasyModeStone -------------------- */
-
-/** \page st-easymode Easy-Mode Stone
-
-In easy game mode this stone converts the floor at its
-position to fl-normal.
-In normal game mode the stone kills any item at its position.
-Then in both modes it kills itself.
-
-E.g. it can be used to hide water-barriers or to insert helper
-items that make the level easier in easy game mode.
-
-\subsection easye Example
-\verbatim
-set_stone(&quot;st-easymode&quot;, 10,10)
-\endverbatim
-
-\ref it-easymode
-*/
-
-namespace
-{
-    class EasyModeStone : public Stone {
-        CLONEOBJ(EasyModeStone);
-        DECL_TRAITS;
-
-        virtual Value message(const Message &amp;m) {
-            if (m.message == &quot;_init&quot;) {
-                if (server::GetDifficulty() == DIFFICULTY_EASY) {
-                    SetFloor (get_pos(), MakeFloor (&quot;fl_metal_7n&quot;));
-                } else {
-                    KillItem (get_pos());
-                }
-                KillStone (get_pos());
-                return Value();
-            }
-            return Stone::message(m);
-        }
-    public:
-        EasyModeStone() 
-        {}
-    };
-    DEF_TRAITSM(EasyModeStone, &quot;st-easymode&quot;, st_easymode, MOVABLE_BREAKABLE);
-}
-
-
 /* -------------------- Grates -------------------- */
 
 namespace
@@ -242,29 +195,6 @@
     }
 }
 
-
-/* -------------------- MagicStone -------------------- */
-namespace
-{
-    class MagicStone : public Stone {
-        CLONEOBJ(MagicStone);
-        DECL_TRAITS;
-        void actor_hit(const StoneContact &amp;sc) {
-            if (sc.actor-&gt;getAttr(&quot;owner&quot;) &amp;&amp; 
-                sc.actor-&gt;get_vel() * sc.normal &lt; -4)
-            {
-                KillStone(get_pos());
-                client::Msg_ShowText (&quot;We don't sell books..&quot;, false, 2.0);
-            }
-        }
-    public:
-        MagicStone()
-        {}
-    };
-    DEF_TRAITSM(MagicStone, &quot;st-magic&quot;, st_magic, MOVABLE_BREAKABLE);
-}
-
-
 /* -------------------- Functions -------------------- */
 
 void Init_simple()
@@ -276,9 +206,7 @@
     Register(new ChameleonStone);
 
     Register(new DummyStone);
-    Register(new EasyModeStone);
     Register(new Grate3);
-    Register(new MagicStone);
 }
 
 } // namespace enigma


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000915.html">[Enigma-game-svn] r1486 - team_levelpacks/team_test_new_api
</A></li>
	<LI>Next message: <A HREF="000917.html">[Enigma-game-svn] r1488 - in trunk: data data/gfx32 data/gfx40	data/gfx48 data/schemas src src/items
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#916">[ date ]</a>
              <a href="thread.html#916">[ thread ]</a>
              <a href="subject.html#916">[ subject ]</a>
              <a href="author.html#916">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
