<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1099 - in trunk: data data/schemas src src/stones
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1099%20-%20in%20trunk%3A%20data%20data/schemas%20src%20src/stones&In-Reply-To=%3C200804120814.m3C8EoiJ022608%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000531.html">
   <LINK REL="Next"  HREF="000533.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1099 - in trunk: data data/schemas src src/stones</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1099%20-%20in%20trunk%3A%20data%20data/schemas%20src%20src/stones&In-Reply-To=%3C200804120814.m3C8EoiJ022608%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1099 - in trunk: data data/schemas src src/stones">ral at mail.berlios.de
       </A><BR>
    <I>Sat Apr 12 10:14:50 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000531.html">[Enigma-game-svn] r1098 - in trunk: data data/schemas src src/stones
</A></li>
        <LI>Next message: <A HREF="000533.html">[Enigma-game-svn] r1100 - team_levelpacks/team_test_new_api
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#532">[ date ]</a>
              <a href="thread.html#532">[ thread ]</a>
              <a href="subject.html#532">[ subject ]</a>
              <a href="author.html#532">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2008-04-12 10:14:48 +0200 (Sat, 12 Apr 2008)
New Revision: 1099

Modified:
   trunk/data/api1init.lua
   trunk/data/models-2d.lua
   trunk/data/schemas/objects.xml
   trunk/src/items.cc
   trunk/src/items.hh
   trunk/src/oxyd.cc
   trunk/src/oxyd_internal.hh
   trunk/src/stones/KeySwitch.cc
   trunk/src/stones/WindowStone.cc
   trunk/src/stones_complex.cc
   trunk/src/stones_simple.cc
   trunk/src/world.cc
Log:
Trunk 1.1: new API reengineering 
- renaming it-wrench to it_wrench
- renaming it-brush to it_brush
- it_key as successor of all it-key_*, attribute &quot;code&quot; instead &quot;keycode&quot;
- it_vortex, it_vortex_open, it_vortex_closed
  autoclose defaults to false for all variations


Modified: trunk/data/api1init.lua
===================================================================
--- trunk/data/api1init.lua	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/data/api1init.lua	2008-04-12 08:14:48 UTC (rev 1099)
@@ -47,6 +47,7 @@
 RenamingObjectsNew2Old = {
     it_blocker = &quot;it-blocker&quot;,
     it_blocker_new = &quot;it-blocker-new&quot;,
+    it_brush = &quot;it-brush&quot;,
     it_coin_s = &quot;it-coin1&quot;,
     it_coin_m = &quot;it-coin2&quot;,
     it_coin_l = &quot;it-coin4&quot;,
@@ -59,8 +60,12 @@
     it_sword = &quot;it-sword&quot;,
     it_trigger = &quot;it-trigger&quot;,
     it_umbrella = &quot;it-umbrella&quot;,
+    it_vortex = &quot;it-vortex-open&quot;,
+    it_vortex_open = &quot;it-vortex-open&quot;,
+    it_vortex_closed = &quot;it-vortex-closed&quot;,
     it_wormhole_on = &quot;it-wormhole&quot;,
     it_wormhole_off = &quot;it-wormhole-off&quot;,
+    it_wrench = &quot;it-wrench&quot;,
     st_blocker = &quot;st-blocker&quot;,
     st_blocker_new = &quot;st-blocker-growing&quot;,
     st_bluesand = &quot;st-blue-sand&quot;,
@@ -128,19 +133,19 @@
     if name == &quot;st-key&quot; then
         local obj = enigma._MakeObject(&quot;st_key&quot;)
         -- Old API keycode default was 0 for st-key, but 1 for it-key!
-        enigma._SetAttrib(obj, &quot;keycode&quot;, 0)
+        enigma._SetAttrib(obj, &quot;code&quot;, 0)
         return obj
     elseif name == &quot;st-key_a&quot; then
         local obj = enigma._MakeObject(&quot;st_key&quot;)
-        enigma._SetAttrib(obj, &quot;keycode&quot;, 1)
+        enigma._SetAttrib(obj, &quot;code&quot;, 1)
         return obj
     elseif name == &quot;st-key_b&quot; then
         local obj = enigma._MakeObject(&quot;st_key&quot;)
-        enigma._SetAttrib(obj, &quot;keycode&quot;, 2)
+        enigma._SetAttrib(obj, &quot;code&quot;, 2)
         return obj
     elseif name == &quot;st-key_c&quot; then
         local obj = enigma._MakeObject(&quot;st_key&quot;)
-        enigma._SetAttrib(obj, &quot;keycode&quot;, 3)
+        enigma._SetAttrib(obj, &quot;code&quot;, 3)
         return obj
     elseif name == &quot;st-switch&quot; then
         local obj = enigma._MakeObject(&quot;st_switch&quot;)
@@ -154,6 +159,18 @@
         local obj = enigma._MakeObject(&quot;st_switch_white&quot;)
         enigma._SetAttrib(obj, &quot;instant&quot;, true)
         return obj
+    elseif name == &quot;it-key_a&quot; or  name == &quot;it-key&quot; then
+        local obj = enigma._MakeObject(&quot;it_key&quot;)
+        enigma._SetAttrib(obj, &quot;code&quot;, 1)
+        return obj
+    elseif name == &quot;it-key_b&quot; then
+        local obj = enigma._MakeObject(&quot;it_key&quot;)
+        enigma._SetAttrib(obj, &quot;code&quot;, 2)
+        return obj
+    elseif name == &quot;it-key_c&quot; then
+        local obj = enigma._MakeObject(&quot;it_key&quot;)
+        enigma._SetAttrib(obj, &quot;code&quot;, 3)
+        return obj
     elseif name == &quot;it-wormhole&quot; then
         local obj = enigma._MakeObject(&quot;it_wormhole_on&quot;)
         enigma._SetAttrib(obj, &quot;scissor&quot;, false)
@@ -162,6 +179,15 @@
         local obj = enigma._MakeObject(&quot;it_wormhole_off&quot;)
         enigma._SetAttrib(obj, &quot;scissor&quot;, false)
         return obj
+    elseif name == &quot;it-vortex-open&quot; then
+        local obj = enigma._MakeObject(&quot;it_vortex_open&quot;)
+        enigma._SetAttrib(obj, &quot;scissor&quot;, false)
+        return obj
+    elseif name == &quot;it-vortex-closed&quot; then
+        local obj = enigma._MakeObject(&quot;it_vortex_closed&quot;)
+        enigma._SetAttrib(obj, &quot;scissor&quot;, false)
+        enigma._SetAttrib(obj, &quot;autoclose&quot;, true)
+        return obj
     end
 
     newname = RenamingObjectsOld2New[name]
@@ -182,7 +208,7 @@
     local _oldname = RenamingObjectsNew2Old[_newname]
 
     if _newname == &quot;st_key&quot; then
-        local code = enigma._GetAttrib(obj, &quot;keycode&quot;)
+        local code = enigma._GetAttrib(obj, &quot;code&quot;)
         if code == 0 then
             return &quot;st-key&quot;
         elseif code == 1 then
@@ -195,6 +221,18 @@
             return &quot;st-key&quot;
         end
     end
+    if _newname == &quot;it_key&quot; then
+        local code = enigma._GetAttrib(obj, &quot;code&quot;)
+        if code == 1 then
+            return &quot;it-key_a&quot;
+        elseif code == 2 then
+            return &quot;it-key_b&quot;
+        elseif code == 3 then
+            return &quot;it-key_c&quot;
+        else -- arbitrary keycodes
+            return &quot;it-key_a&quot;
+        end
+    end
     if string.sub(_newname, 1, 8) == &quot;st_laser&quot; then
         return &quot;st-laser&quot;
     end
@@ -235,6 +273,9 @@
          elseif  val == 16 then _val = &quot;nesw&quot;
          end
      end
+     if key == &quot;keycode&quot; then
+         _key = &quot;code&quot;
+     end
      if key == &quot;delay&quot; then
          _key = &quot;interval&quot;
      end
@@ -298,6 +339,9 @@
 function enigma.GetAttrib(obj, key)
      local _key = key
      local _obj_name = enigma.GetKind(obj)
+     if key == &quot;keycode&quot; then
+         _key = &quot;code&quot;
+     end
      if key == &quot;delay&quot; then
          _key = &quot;interval&quot;
      end
@@ -392,8 +436,8 @@
     it_magnet__onoff = &quot;toggle&quot;,
     [&quot;it-tinyhill__trigger&quot;] = &quot;flip&quot;,
     [&quot;it-tinyhollow__trigger&quot;] = &quot;flip&quot;,
-    [&quot;it-vortex-open__trigger&quot;] = &quot;toggle&quot;,
-    [&quot;it-vortex-closed__trigger&quot;] = &quot;toggle&quot;,
+    it_vortex__openclose = &quot;toggle&quot;,
+    it_vortex__trigger = &quot;toggle&quot;,
     it_wormhole__onoff = &quot;toggle&quot;,
     [&quot;st-black1__trigger&quot;] = &quot;signal&quot;,
     [&quot;st-black2__trigger&quot;] = &quot;signal&quot;,

Modified: trunk/data/models-2d.lua
===================================================================
--- trunk/data/models-2d.lua	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/data/models-2d.lua	2008-04-12 08:14:48 UTC (rev 1099)
@@ -393,7 +393,6 @@
         &quot;it-blocker&quot;,
         &quot;it-booze&quot;,
         &quot;it-booze-broken&quot;,
-        &quot;it-brush&quot;,
         &quot;it-cherry&quot;,
         &quot;it-cross&quot;,
         &quot;it-document&quot;,
@@ -407,7 +406,6 @@
         &quot;it-hill&quot;,
         &quot;it-hollow&quot;,
         &quot;it-hstrip&quot;,
-        &quot;it-key&quot;,
         &quot;it-landmine&quot;,
         &quot;it-magicwand&quot;,
         &quot;it-odometer&quot;,
@@ -425,21 +423,23 @@
         &quot;it-tinyhollow&quot;,
         &quot;it-vstrip&quot;,
         &quot;it-weight&quot;,
-        &quot;it-whitebomb&quot;,
-        &quot;it-wrench&quot;
+        &quot;it-whitebomb&quot;
     }
 
     DefImages(itemlist)
 
     DefImage(&quot;it-brake&quot;, {filename=&quot;st-brake&quot;})
+    DefImage(&quot;it_brush&quot;, {filename=&quot;it-brush&quot;})
     DefImage(&quot;it_coin_s&quot;, {filename=&quot;it-coin1&quot;})
     DefImage(&quot;it_coin_m&quot;, {filename=&quot;it-coin2&quot;})
     DefImage(&quot;it_coin_l&quot;, {filename=&quot;it-coin4&quot;})
     DefImage(&quot;it_extralife&quot;, {filename=&quot;it-extralife&quot;})
     DefImage(&quot;it_floppy&quot;, {filename=&quot;it-floppy&quot;})
     DefImage(&quot;it_hammer&quot;, {filename=&quot;it-hammer&quot;})
+    DefImage(&quot;it_key&quot;, {filename=&quot;it-key&quot;})
     DefImage(&quot;it_sword&quot;, {filename=&quot;it-sword&quot;})
     DefImage(&quot;it_umbrella&quot;, {filename=&quot;it-umbrella&quot;})
+    DefImage(&quot;it_wrench&quot;, {filename=&quot;it-wrench&quot;})
 end
 
 -------------------------

Modified: trunk/data/schemas/objects.xml
===================================================================
--- trunk/data/schemas/objects.xml	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/data/schemas/objects.xml	2008-04-12 08:14:48 UTC (rev 1099)
@@ -4,6 +4,7 @@
     &lt;attr name=&quot;action&quot; type=&quot;tokens&quot; default=&quot;nil&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;autoclose&quot; type=&quot;bool&quot; default=&quot;false&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;cluster&quot; type=&quot;int&quot; default=&quot;nil&quot; min=&quot;0&quot; max=&quot;1&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;code&quot; type=&quot;int&quot; default=&quot;1&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;coin_value&quot; type=&quot;double&quot; default=&quot;1&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;color&quot; type=&quot;int&quot; default=&quot;nil&quot; min=&quot;0&quot; max=&quot;1&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;connections&quot; type=&quot;string&quot; default=&quot;nil&quot; rw=&quot;rw&quot;/&gt;
@@ -79,6 +80,7 @@
     &lt;/object&gt;
     &lt;object name=&quot;it_blocker_new&quot; init=&quot;true&quot;&gt;
     &lt;/object&gt;
+    &lt;object name=&quot;it_brush&quot;/&gt;
     &lt;object name=&quot;it_coin&quot;&gt;
       &lt;attr name=&quot;coin_value&quot; default=&quot;3&quot;/&gt;
       &lt;attr name=&quot;state&quot; rw=&quot;r&quot;/&gt;
@@ -97,6 +99,9 @@
     &lt;object name=&quot;it_floppy&quot;/&gt;
     &lt;object name=&quot;it_hammer&quot;/&gt;
     &lt;object name=&quot;it_hammer_new&quot; init=&quot;true&quot;/&gt;
+    &lt;object name=&quot;it_key&quot;&gt;
+      &lt;attr name=&quot;code&quot;/&gt;
+    &lt;/object&gt;
     &lt;object name=&quot;it_magnet&quot;&gt;
       &lt;attr name=&quot;range&quot; default=&quot;nil&quot;/&gt;
       &lt;attr name=&quot;strength&quot; default=&quot;nil&quot;/&gt;
@@ -120,6 +125,20 @@
     &lt;/object&gt;
     &lt;object name=&quot;it_umbrella&quot;/&gt;
     &lt;object name=&quot;it_umbrella_new&quot; init=&quot;true&quot;/&gt;
+    &lt;object name=&quot;it_vortex&quot;&gt;
+      &lt;attr name=&quot;destination&quot;/&gt;
+      &lt;attr name=&quot;autoclose&quot;/&gt;
+      &lt;attr name=&quot;scissor&quot; default=&quot;true&quot;/&gt;
+      &lt;msg name=&quot;open&quot;/&gt;
+      &lt;msg name=&quot;close&quot;/&gt;
+      &lt;msg name=&quot;signal&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;it_vortex_closed&quot;&gt;
+      &lt;attr name=&quot;state&quot; value=&quot;0&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;it_vortex_open&quot;&gt;
+      &lt;attr name=&quot;state&quot; value=&quot;1&quot;/&gt;
+    &lt;/object&gt;
     &lt;object name=&quot;it_wormhole&quot;&gt;
       &lt;attr name=&quot;destination&quot;/&gt;
       &lt;attr name=&quot;interval&quot; default=&quot;0&quot;/&gt;
@@ -136,6 +155,7 @@
     &lt;object name=&quot;it_wormhole_on&quot;&gt;
       &lt;attr name=&quot;state&quot; value=&quot;1&quot;/&gt;
     &lt;/object&gt;
+    &lt;object name=&quot;it_wrench&quot;/&gt;
     &lt;object name=&quot;st&quot; abstract=&quot;true&quot;/&gt;
     &lt;object name=&quot;st_clusterstone&quot; abstract=&quot;true&quot;&gt;
       &lt;attr name=&quot;cluster&quot;/&gt;
@@ -285,6 +305,12 @@
       &lt;msg name=&quot;signal&quot;/&gt;
       &lt;msg name=&quot;_trigger&quot;/&gt;
     &lt;/object&gt;
+    &lt;object name=&quot;st_key&quot;&gt;
+      &lt;attr name=&quot;code&quot;/&gt;
+      &lt;msg name=&quot;on&quot;/&gt;
+      &lt;msg name=&quot;off&quot;/&gt;
+      &lt;msg name=&quot;signal&quot;/&gt;
+    &lt;/object&gt;
     &lt;object name=&quot;st_laser&quot;&gt;
       &lt;attr name=&quot;counterclock&quot;/&gt;
       &lt;attr name=&quot;orientation&quot;/&gt;

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/items.cc	2008-04-12 08:14:48 UTC (rev 1099)
@@ -185,8 +185,9 @@
 {
     DEF_ITEM(MagicWand, &quot;it-magicwand&quot;, it_magicwand);
     DEF_ITEM(Floppy,    &quot;it_floppy&quot;, it_floppy);
+    DEF_ITEM(Key,       &quot;it_key&quot;, it_key);
     DEF_ITEM(Odometer,  &quot;it-odometer&quot;, it_odometer);
-    DEF_ITEM(Wrench,    &quot;it-wrench&quot;, it_wrench);
+    DEF_ITEM(Wrench,    &quot;it_wrench&quot;, it_wrench);
     DEF_ITEM(BrokenGlasses, &quot;it-glasses-broken&quot;, it_glasses_broken);
     DEF_ITEMF(Coffee,   &quot;it-coffee&quot;, it_coffee, itf_inflammable);
 }
@@ -566,29 +567,6 @@
     DEF_TRAITS(Spoon, &quot;it-spoon&quot;, it_spoon);
 }
 
-/* -------------------- Keys -------------------- */
-namespace
-{
-    class Key : public Item {
-        CLONEOBJ(Key);
-        DECL_TRAITS_ARRAY(3, subtype);
-
-    public:
-        enum SubType { KEY1, KEY2, KEY3 } subtype;
-    	Key(SubType type = KEY1)
-        : subtype(type)
-        {
-            setAttr(&quot;keycode&quot;, subtype+1);
-        }
-    };
-
-    ItemTraits Key::traits[3] = {
-        {&quot;it-key_a&quot;, it_key_a, itf_none, 0.0},
-        {&quot;it-key_b&quot;, it_key_b, itf_none, 0.0},
-        {&quot;it-key_c&quot;, it_key_c, itf_none, 0.0}
-    };
-}
-
 /* -------------------- Booze -------------------- */
 
 namespace
@@ -645,25 +623,31 @@
 }
 
 /* -------------------- Brush -------------------- */
-namespace
-{
     /* Can &quot;paint&quot; some stones and remove ash. */
     class Brush : public Item {
         CLONEOBJ(Brush);
         DECL_TRAITS;
 
-        ItemAction activate(Actor *, GridPos p) {
-            if (Item *it = GetItem(p))
-                SendMessage (it, &quot;brush&quot;);
-            return ITEM_DROP;
-        }
     public:
-        Brush() {}
+        Brush();
+        
+        // Item interface
+        virtual ItemAction activate(Actor* a, GridPos p);
     };
-    DEF_TRAITSF(Brush, &quot;it-brush&quot;, it_brush, itf_inflammable);
-}
+    
+    Brush::Brush() {
+    }
+    
+    ItemAction Brush::activate(Actor *a, GridPos p) {
+        if (Item *it = GetItem(p))
+            SendMessage (it, &quot;brush&quot;);
+        return ITEM_DROP;
+    }
+    
+    DEF_TRAITSF(Brush, &quot;it_brush&quot;, it_brush, itf_inflammable);
 
 
+
 /* -------------------- Coins -------------------- */
 
 // TODO id renaming when names are stable
@@ -2079,306 +2063,293 @@
 - \b signal     signal value: 1 -&gt; &quot;open&quot;; 0 -&gt; &quot;close&quot;
 */
 
-namespace
-{
     class Vortex : public Item, public TimeHandler {
+    private:
+        enum iState {
+            OPEN,          ///&lt; TODO exchange OPEN, CLOSED to match external state 
+            CLOSED,        ///&lt;
+            OPENING,       ///&lt;
+            CLOSING,       ///&lt;
+            WARPING,       ///&lt; an open vortex occupied in process of sending a marble
+            EMITTING,      ///&lt; an open vortex occupied, waiting for the destination to open
+            SWALLOWING     ///&lt; an open vortex eats up a marble
+        };
+
+    public:
         CLONEOBJ(Vortex);
         DECL_TRAITS_ARRAY(2, is_open());
-    public:
+        
         Vortex(bool opened);
         virtual ~Vortex();
 
-    private:
-        static const double RANGE;
-
-        // Item interface
-        bool actor_hit(Actor*);
-        void init_model();
-        void animcb();
+        // Object interface
+        virtual std::string getClass() const;
         virtual Value message(const Message &amp;m);
 
-        // TimeHandler interface
-        void alarm();
+        // StateObject interface
+        virtual int externalState() const;
+        virtual void setState(int extState);
+        virtual void toggleState();
 
-        // Private methods
+        // GridObject interface
+        virtual void init_model();
+        virtual void on_removal(GridPos p);
+        
+        // ModelCallback interface
+        virtual void animcb();
 
-        V2 vec_to_center (V2 v) {
-            return v-get_pos().center();
-        }
-        bool near_center_p (Actor *a) {
-            return length(vec_to_center(a-&gt;get_pos())) &lt; RANGE;
-        }
+        // Item interface
+        virtual bool actor_hit(Actor*);
 
-        void open();
-        void close();
-        void openclose();
+        // TimeHandler interface
+        virtual void alarm();
 
-        void prepare_for_warp (Actor *actor);
+    private:
+        void prepare_for_warp(Actor *actor);
         void emit_actor(Vortex *destVortex);
 
         void perform_warp();    // warp swallowed actor(s)
         void warp_to(const V2 &amp;target);
 
-        bool is_open() const { return state == OPEN; }
+        bool is_open() const { return externalState() == 1 ; }
 
-        void on_removal(GridPos p);
-
-        // Variables
-        enum State {
-            OPEN,
-            CLOSED,
-            OPENING,
-            CLOSING,
-            WARPING,
-            EMITTING,
-            SWALLOWING,
-        };
-
-        State  state;
     };
 
     ItemTraits Vortex::traits[2] = {
-        {&quot;it-vortex-closed&quot;, it_vortex_closed, itf_static | itf_fireproof, 0.0},
-        {&quot;it-vortex-open&quot;, it_vortex_open,     itf_static | itf_fireproof, 0.0}
+        {&quot;it_vortex_closed&quot;, it_vortex_closed, itf_static | itf_fireproof, 0.0},
+        {&quot;it_vortex_open&quot;, it_vortex_open,     itf_static | itf_fireproof, 0.0}
     };
 
-    const double Vortex::RANGE = 0.5/2;
-}
+    Vortex::Vortex(bool open) : Item() {
+        state = open ? OPEN : CLOSED;
+        setAttr(&quot;$dest_idx&quot;, 0);
+        setAttr(&quot;$dest_vortex&quot;, (Object *)NULL);
+        setAttr(&quot;$grabbed_actor&quot;, (Object *)NULL);
+    }
 
-Vortex::Vortex(bool open) : state(open ? OPEN : CLOSED) {
-    setAttr(&quot;autoclose&quot;, !open);
-    setAttr(&quot;$dest_idx&quot;, 0);
-    setAttr(&quot;$dest_vortex&quot;, (Object *)NULL);
-    setAttr(&quot;$grabbed_actor&quot;, (Object *)NULL);
-}
+    Vortex::~Vortex() {
+        GameTimer.remove_alarm(this);
+        if (Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;))) {
+            // release an actor that is grabbed on behalf of this vortex - actor state FALLING_VORTEX
+            SendMessage(actor, &quot;rise&quot;);
+        }
+    }
 
-Vortex::~Vortex() {
-    GameTimer.remove_alarm(this);
-    if (Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;))) {
-        // release an actor that is grabbed on behalf of this vortex - actor state FALLING_VORTEX
-        SendMessage(actor, &quot;rise&quot;);
+    std::string Vortex::getClass() const {
+        return &quot;it_vortex&quot;;
     }
     
-}
-
-void Vortex::on_removal(GridPos p) {
-    Item::on_removal(p);
-    ASSERT(state != WARPING &amp;&amp; state != SWALLOWING &amp;&amp; state != EMITTING,
-        XLevelRuntime, &quot;Tried to kill a busy vortex. Please use another way.&quot;);
-}
-
-void Vortex::prepare_for_warp (Actor *actor) {
-    SendMessage(actor, &quot;fallvortex&quot;);
-    setAttr(&quot;$dest_idx&quot;, 0);
-    setAttr(&quot;$grabbed_actor&quot;, actor);
-    state = SWALLOWING;
-
-    GameTimer.set_alarm(this, 0.4, false);
-}
-
-
-bool Vortex::actor_hit (Actor *actor) {
-    if (state == OPEN &amp;&amp; near_center_p(actor) &amp;&amp; actor-&gt;can_be_warped())
-        prepare_for_warp (actor);
-    return false;
-}
-
-Value Vortex::message(const Message &amp;m)
-{
-    if (m.message == &quot;signal&quot;) {
-        int ival = m.value;
-        if (ival != 0)
-            open();
-        else
-            close();
-        return Value();
-    } else if (m.message == &quot;openclose&quot; || m.message == &quot;toggle&quot;) {
-        openclose();
-        return Value();
-    } else if (m.message == &quot;open&quot;) {
-        open();
-        return Value();
-    } else if (m.message == &quot;close&quot; || (m.message == &quot;_passed&quot; &amp;&amp; getAttr(&quot;autoclose&quot;).to_bool())) {
-        close();
-        if (m.message == &quot;_passed&quot;)
+    Value Vortex::message(const Message &amp;m) {
+        if (m.message == &quot;_passed&quot; &amp;&amp; getAttr(&quot;autoclose&quot;).to_bool()) {
+            setState(0);
             performAction(getAttr(&quot;$grabbed_actor&quot;));
-        return Value();
+            return Value();
+        }
+        return Item::message(m);
     }
-    return Item::message(m);
-}
 
-void Vortex::init_model() {
-    switch(state) {
-        case WARPING:
-        case OPEN:
-        case EMITTING:
-        case SWALLOWING:
-            set_model(&quot;it-vortex-open&quot;);
-            break;
-        case CLOSED: 
-            set_model(&quot;it-vortex-closed&quot;); break;
-        case OPENING: 
-            set_anim(&quot;it-vortex-opening&quot;); break;
-        case CLOSING: 
-            set_anim(&quot;it-vortex-closing&quot;); break;
+    int Vortex::externalState() const {
+        return (state &gt;= CLOSED &amp;&amp; state &lt;= CLOSING) ? 0 : 1 ;
     }
-}
-
-void Vortex::animcb() {
-    if (state == CLOSING) {
-        state = CLOSED;
-        init_model();
+    
+    void Vortex::setState(int extState) {
+        if (isDisplayable()) {
+            if (extState == 1) {  // open
+                if (state == CLOSING) {
+                    state = OPENING;
+                    get_model()-&gt;reverse(); // reverse animation
+                }
+                else if (state == CLOSED) {
+                    state = OPENING;
+                    sound_event (&quot;vortexopen&quot;);
+                    init_model();
+                }
+            } else if (extState == 0) { // close
+                if (state == OPENING) {
+                    state = CLOSING;
+                    get_model()-&gt;reverse(); // reverse animation
+                }
+                else if (state == OPEN) {
+                    state = CLOSING;
+                    sound_event (&quot;vortexclose&quot;);
+                    init_model();
+                }
+            }
+        } else {
+            if (extState &lt;= 1 &amp;&amp; extState &gt;= 0)
+                state = 1 - extState;
+        }
     }
-    else if (state == OPENING) {
-        state = OPEN;
-        init_model();
+        
+    void Vortex::toggleState() {
+        if (state == OPEN || state == OPENING)
+            setState(0);
+        else
+            setState(1);
     }
-}
-
-void Vortex::open() {
-    if (state == CLOSING) {
-        state = OPENING;
-        get_model()-&gt;reverse(); // reverse animation
+    
+    void Vortex::init_model() {
+        switch(state) {
+            case WARPING:
+            case OPEN:
+            case EMITTING:
+            case SWALLOWING:
+                set_model(&quot;it-vortex-open&quot;);
+                break;
+            case CLOSED: 
+                set_model(&quot;it-vortex-closed&quot;); break;
+            case OPENING: 
+                set_anim(&quot;it-vortex-opening&quot;); break;
+            case CLOSING: 
+                set_anim(&quot;it-vortex-closing&quot;); break;
+        }
     }
-    else if (state == CLOSED) {
-        state = OPENING;
-        sound_event (&quot;vortexopen&quot;);
-        init_model();
+    
+    void Vortex::on_removal(GridPos p) {
+        Item::on_removal(p);
+        ASSERT(state != WARPING &amp;&amp; state != SWALLOWING &amp;&amp; state != EMITTING,
+            XLevelRuntime, &quot;Tried to kill a busy vortex. Please use another way.&quot;);
     }
-}
-
-void Vortex::close() {
-    if (state == OPENING) {
-        state = CLOSING;
-        get_model()-&gt;reverse(); // reverse animation
+    
+    void Vortex::animcb() {
+        if (state == CLOSING) {
+            state = CLOSED;
+            init_model();
+        }
+        else if (state == OPENING) {
+            state = OPEN;
+            init_model();
+        }
     }
-    else if (state == OPEN) {
-        state = CLOSING;
-        sound_event (&quot;vortexclose&quot;);
-        init_model();
+    
+    bool Vortex::actor_hit (Actor *actor) {
+        if (state == OPEN &amp;&amp; (length((actor-&gt;get_pos()) - get_pos().center()) &lt; 0.25) &amp;&amp; actor-&gt;can_be_warped())
+            prepare_for_warp (actor);
+        return false;
     }
-}
+    
+    void Vortex::alarm() {
+        if (state == WARPING) {
+            perform_warp();
+        } else if (state == EMITTING) {
+            emit_actor(dynamic_cast&lt;Vortex *&gt;((Object *)getAttr(&quot;$dest_vortex&quot;)));
+        } else if (state == SWALLOWING) {
+            state = WARPING;
+            sound_event (&quot;hitfloor&quot;);
+            perform_warp();
+        } else
+            ASSERT (0, XLevelRuntime, &quot;Vortex: alarm called with inconsistent state&quot;);
+    }
+    
+    void Vortex::prepare_for_warp (Actor *actor) {
+        SendMessage(actor, &quot;fallvortex&quot;);
+        setAttr(&quot;$dest_idx&quot;, 0);
+        setAttr(&quot;$grabbed_actor&quot;, actor);
+        state = SWALLOWING;
+    
+        GameTimer.set_alarm(this, 0.4, false);
+    }
+    
+    void Vortex::emit_actor(Vortex *destVortex) {
+        if (destVortex == NULL)   // destination vortex got killed in meantime
+            destVortex = this;    // reemit from source vortex 
+        V2 v(destVortex-&gt;get_pos().center());
+        if (Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;))) {
+            WarpActor(actor, v[0], v[1], false);
+            SendMessage(actor, &quot;rise&quot;);
+            if (destVortex != this) {
+                bool isScissor = to_bool(getDefaultedAttr(&quot;scissor&quot;, 
+                        (server::EnigmaCompatibility &gt;= 1.10) || server::GameCompatibility != GAMET_ENIGMA));
+                if (isScissor)
+                    KillRubberBands(actor);
+            }
+        }
+        state = OPEN;
+        if (this != destVortex &amp;&amp; getAttr(&quot;autoclose&quot;).to_bool())  // do not close source vortex if destination is currently blocked
+            setState(0);
+        if (this != destVortex)
+            performAction(getAttr(&quot;$grabbed_actor&quot;));
+    
+        setAttr(&quot;$grabbed_actor&quot;, (Object *)NULL);
+    }
 
-void Vortex::openclose() {
-    if (state == OPEN || state == OPENING)
-        close();
-    else
-        open();
-}
-
-void Vortex::alarm() {
-    if (state == WARPING) {
-        perform_warp();
-    } else if (state == EMITTING) {
-        emit_actor(dynamic_cast&lt;Vortex *&gt;((Object *)getAttr(&quot;$dest_vortex&quot;)));
-    } else if (state == SWALLOWING) {
-        state = WARPING;
-        sound_event (&quot;hitfloor&quot;);
-        perform_warp();
-    } else
-        ASSERT (0, XLevelRuntime, &quot;Vortex: alarm called with inconsistent state&quot;);
-}
-
-void Vortex::emit_actor(Vortex *destVortex) {
-    if (destVortex == NULL)   // destination vortex got killed in meantime
-        destVortex = this;    // reemit from source vortex 
-    V2 v(destVortex-&gt;get_pos().center());
-    if (Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;))) {
-        WarpActor(actor, v[0], v[1], false);
-        SendMessage(actor, &quot;rise&quot;);
-        if (destVortex != this) {
+    void Vortex::warp_to(const V2 &amp;target) {
+        client::Msg_Sparkle (target);
+        if (Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;))) {
+            WarpActor(actor, target[0], target[1], false);
+            SendMessage(actor, &quot;appear&quot;);
             bool isScissor = to_bool(getDefaultedAttr(&quot;scissor&quot;, 
                     (server::EnigmaCompatibility &gt;= 1.10) || server::GameCompatibility != GAMET_ENIGMA));
             if (isScissor)
                 KillRubberBands(actor);
         }
-    }
-    state = OPEN;
-    if (this != destVortex &amp;&amp; getAttr(&quot;autoclose&quot;).to_bool())  // do not close source vortex if destination is currently blocked
-        close();
-    if (this != destVortex)
+        state = OPEN;
+        if (getAttr(&quot;autoclose&quot;).to_bool())
+            setState(0);
+    
         performAction(getAttr(&quot;$grabbed_actor&quot;));
-
-    setAttr(&quot;$grabbed_actor&quot;, (Object *)NULL);
-}
-
-void Vortex::warp_to(const V2 &amp;target) {
-    client::Msg_Sparkle (target);
-    if (Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;))) {
-        WarpActor(actor, target[0], target[1], false);
-        SendMessage(actor, &quot;appear&quot;);
-        bool isScissor = to_bool(getDefaultedAttr(&quot;scissor&quot;, 
-                (server::EnigmaCompatibility &gt;= 1.10) || server::GameCompatibility != GAMET_ENIGMA));
-        if (isScissor)
-            KillRubberBands(actor);
+        setAttr(&quot;$grabbed_actor&quot;, (Object *)NULL);
     }
-    state = OPEN;
-    if (getAttr(&quot;autoclose&quot;).to_bool())
-        close();
 
-    performAction(getAttr(&quot;$grabbed_actor&quot;));
-    setAttr(&quot;$grabbed_actor&quot;, (Object *)NULL);
-}
-
-void Vortex::perform_warp() {
-    Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;));
-    if (actor == NULL)
-        return;
-
-    ASSERT (state == WARPING, XLevelRuntime, &quot;Vortex: perform_warp called with inconsistent state&quot;);
-
-    V2 v_target;
-
-    // is another target position defined?
-    int dest_idx = getAttr(&quot;$dest_idx&quot;);
-    if (Object::getDestinationByIndex(dest_idx, v_target)) {
-        GridPos  p_target(v_target);
-
-        Vortex *v = dynamic_cast&lt;Vortex*&gt;(GetItem(p_target));
-
-        if (v) {                // Destination is also a vortex
-            Stone *st = GetStone(p_target);
-
-            if (st &amp;&amp; !st-&gt;is_floating()) {
-                // is destination vortex blocked? redirect
-                setAttr(&quot;$dest_idx&quot;, dest_idx + 1);
-                client::Msg_Sparkle(v_target);
-                WarpActor(actor, v_target[0], v_target[1], false);
-                GameTimer.set_alarm(this, 0.4, false);
-            }
-            else {
-                switch (v-&gt;state) {
-                    case OPEN:
-                    case OPENING:
-                        // destination is open
-                        emit_actor(v);
-                        break;
+    void Vortex::perform_warp() {
+        Actor *actor = dynamic_cast&lt;Actor *&gt;((Object *)getAttr(&quot;$grabbed_actor&quot;));
+        if (actor == NULL)
+            return;
     
-                    case CLOSED:
-                    case CLOSING:
-                        // destination is closed
-                        SendMessage(v, &quot;open&quot;);
-                        setAttr(&quot;$dest_vortex&quot;, v);
-                        state = EMITTING;
-                        GameTimer.set_alarm(this, 0.4, false);
-                        break;
-                    case SWALLOWING:
-                    case WARPING:
-                    case EMITTING:
-                        // destination is busy -&gt; don't warp actor, emit
-                        // it where it has started
-                        emit_actor(this);
+        ASSERT (state == WARPING, XLevelRuntime, &quot;Vortex: perform_warp called with inconsistent state&quot;);
+    
+        V2 v_target;
+    
+        // is another target position defined?
+        int dest_idx = getAttr(&quot;$dest_idx&quot;);
+        if (Object::getDestinationByIndex(dest_idx, v_target)) {
+            GridPos  p_target(v_target);
+    
+            Vortex *v = dynamic_cast&lt;Vortex*&gt;(GetItem(p_target));
+    
+            if (v) {                // Destination is also a vortex
+                Stone *st = GetStone(p_target);
+    
+                if (st &amp;&amp; !st-&gt;is_floating()) {
+                    // is destination vortex blocked? redirect
+                    setAttr(&quot;$dest_idx&quot;, dest_idx + 1);
+                    client::Msg_Sparkle(v_target);
+                    WarpActor(actor, v_target[0], v_target[1], false);
+                    GameTimer.set_alarm(this, 0.4, false);
                 }
+                else {
+                    switch (v-&gt;state) {
+                        case OPEN:
+                        case OPENING:
+                            // destination is open
+                            emit_actor(v);
+                            break;
+        
+                        case CLOSED:
+                        case CLOSING:
+                            // destination is closed
+                            SendMessage(v, &quot;open&quot;);
+                            setAttr(&quot;$dest_vortex&quot;, v);
+                            state = EMITTING;
+                            GameTimer.set_alarm(this, 0.4, false);
+                            break;
+                        case SWALLOWING:
+                        case WARPING:
+                        case EMITTING:
+                            // destination is busy -&gt; don't warp actor, emit
+                            // it where it has started
+                            emit_actor(this);
+                    }
+                }
+            } else {
+                warp_to(v_target);
             }
-        } else {
-            warp_to(v_target);
         }
+        else {
+            // if no target defined, don't warp actor
+            emit_actor(this);
+        }
     }
-    else {
-        // if no target defined, don't warp actor
-        emit_actor(this);
-    }
-}
 
 
 /* -------------------- YinYang item -------------------- */
@@ -3977,10 +3948,7 @@
     RegisterItem (new HStrip);
     RegisterItem (new InverseSensor);
     RegisterItem (new InvisibleAbyss);
-    Register (&quot;it-key&quot;, new Key);
-    RegisterItem (new Key(Key::KEY1));
-    RegisterItem (new Key(Key::KEY2));
-    RegisterItem (new Key(Key::KEY3));
+    RegisterItem (new Key);
     RegisterItem (new Landmine);
     RegisterItem (new MagicWand);
     Register (&quot;it_magnet&quot;, new Magnet(false));
@@ -4017,6 +3985,7 @@
     RegisterItem (new TwoPKillStone);
     RegisterItem (new Umbrella(false));
     Register (&quot;it_umbrella_new&quot;, new Umbrella(true));
+    Register (&quot;it_vortex&quot;, new Vortex(true));
     RegisterItem (new Vortex(false));
     RegisterItem (new Vortex(true));
     RegisterItem (new VStrip);

Modified: trunk/src/items.hh
===================================================================
--- trunk/src/items.hh	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/items.hh	2008-04-12 08:14:48 UTC (rev 1099)
@@ -84,9 +84,7 @@
         it_hollow,
         it_hstrip,
         it_inversesensor,
-        it_key_a,
-        it_key_b,
-        it_key_c,
+        it_key,
         it_landmine,
         it_laserbeam,
         it_magicwand,

Modified: trunk/src/oxyd.cc
===================================================================
--- trunk/src/oxyd.cc	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/oxyd.cc	2008-04-12 08:14:48 UTC (rev 1099)
@@ -382,12 +382,30 @@
 	}
         break;
     case 0x03:                  // note 2
-	{
-	    it = MakeItem (it_document);
-	    string text = convert_encoding(level.getNoteText(1, lang));
-	    it-&gt;setAttr (&quot;text&quot;, text.c_str());
-	}
-	break;
+    {
+        it = MakeItem (it_document);
+        string text = convert_encoding(level.getNoteText(1, lang));
+        it-&gt;setAttr (&quot;text&quot;, text.c_str());
+    }
+    break;
+    case 0x14:                  // key a
+    {
+        it = MakeItem(it_key);
+        it-&gt;setAttr (&quot;code&quot;, 1);
+    }
+    break;
+    case 0x15:                  // key b
+    {
+        it = MakeItem(it_key);
+        it-&gt;setAttr (&quot;code&quot;, 2);
+    }
+    break;
+    case 0x16:                  // key c
+    {
+        it = MakeItem(it_key);
+        it-&gt;setAttr (&quot;code&quot;, 3);
+    }
+    break;
     default:
         {
             ItemID id = config.itemtable[type];
@@ -395,9 +413,11 @@
                 Log &lt;&lt; ecl::strf (&quot;Unknown item %X\n&quot;,type);
                 it = MakeItem (it_dummy);
                 it-&gt;setAttr(&quot;code&quot;, type);
+            } else {
+                it = MakeItem (id);
+                if (id == it_vortex_closed)
+                    it-&gt;setAttr(&quot;autoclose&quot;, true);
             }
-            else
-                it = MakeItem (id);
         }
     }
     return it;

Modified: trunk/src/oxyd_internal.hh
===================================================================
--- trunk/src/oxyd_internal.hh	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/oxyd_internal.hh	2008-04-12 08:14:48 UTC (rev 1099)
@@ -32,7 +32,11 @@
 #define it_UNUSED it_INVALID
 #define it_EXTERNAL it_INVALID
 #define it_MISSING it_INVALID
+#define it_key_a it_key
+#define it_key_b it_key
+#define it_key_c it_key
 
+
 #define UNUSED &quot;&quot;
 #define SPECIAL &quot;&quot;
 

Modified: trunk/src/stones/KeySwitch.cc
===================================================================
--- trunk/src/stones/KeySwitch.cc	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/stones/KeySwitch.cc	2008-04-12 08:14:48 UTC (rev 1099)
@@ -26,7 +26,6 @@
 
 namespace enigma {
     KeySwitch::KeySwitch() : Stone () {
-        setAttr(&quot;keycode&quot;, Value(1));
     }
 
     void KeySwitch::setState(int extState) {
@@ -60,8 +59,8 @@
         if (server::GameCompatibility == enigma::GAMET_ENIGMA) {
             if (state == ON) {
                 if (!inv-&gt;is_full()) {
-                    Item *key = MakeItem(&quot;it-key&quot;);
-                    key-&gt;setAttr(&quot;keycode&quot;, getAttr(&quot;keycode&quot;));
+                    Item *key = MakeItem(&quot;it_key&quot;);
+                    key-&gt;setAttr(&quot;code&quot;, getAttr(&quot;code&quot;));
                     inv-&gt;add_item(key);
                     toggle = true;
                 }
@@ -89,8 +88,8 @@
     {
         Item *it = inv-&gt;get_item(0);
         return (it
-             &amp;&amp; it-&gt;is_kind(&quot;it-key*&quot;)
-             &amp;&amp; it-&gt;getAttr(&quot;keycode&quot;) == getAttr(&quot;keycode&quot;));
+             &amp;&amp; it-&gt;isKind(&quot;it_key&quot;)
+             &amp;&amp; it-&gt;getAttr(&quot;code&quot;) == getAttr(&quot;code&quot;));
     }
 
     DEF_TRAITS(KeySwitch, &quot;st_key&quot;, st_key);

Modified: trunk/src/stones/WindowStone.cc
===================================================================
--- trunk/src/stones/WindowStone.cc	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/stones/WindowStone.cc	2008-04-12 08:14:48 UTC (rev 1099)
@@ -61,7 +61,7 @@
                 set_anim(&quot;st_window_anim&quot;);  // TODO anim with remaining unbroken faces
             }
             
-            else if (player::WieldedItemIs (sc.actor, &quot;it-wrench&quot;)) {
+            else if (player::WieldedItemIs (sc.actor, &quot;it_wrench&quot;)) {
                 if (sc.faces == WESTBIT &amp;&amp; sc.normal[0] &lt; 0){
                     tryInnerPull(EAST);
                 } else if (sc.faces == EASTBIT &amp;&amp; sc.normal[0] &gt; 0) {

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/stones_complex.cc	2008-04-12 08:14:48 UTC (rev 1099)
@@ -103,7 +103,7 @@
         }
 
         void actor_hit (const StoneContact &amp;sc) {
-            if (player::WieldedItemIs (sc.actor, &quot;it-wrench&quot;)) {
+            if (player::WieldedItemIs (sc.actor, &quot;it_wrench&quot;)) {
                 clockwise = !clockwise;
                 init_model();
             }
@@ -1987,7 +1987,7 @@
             bool clockwise = (a == ROTR);
             Actor *a = dynamic_cast&lt;Actor*&gt;(impulse.sender);
             if ((pivot-&gt;get_traits().id == st_turnstile_green) &amp;&amp; a != NULL &amp;&amp;
-                    player::WieldedItemIs(a, &quot;it-wrench&quot;))
+                    player::WieldedItemIs(a, &quot;it_wrench&quot;))
                 clockwise = !clockwise;
             pivot-&gt;rotate(clockwise, impulse.sender); // ROTR is clockwise
         }

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/stones_simple.cc	2008-04-12 08:14:48 UTC (rev 1099)
@@ -864,7 +864,7 @@
 
         void actor_hit(const StoneContact &amp;sc) {
             if( state == INVISIBLE) {
-                if (player::WieldedItemIs (sc.actor, &quot;it-brush&quot;)) {
+                if (player::WieldedItemIs (sc.actor, &quot;it_brush&quot;)) {
                     sound_event (&quot;stonepaint&quot;);
                     state = BRUSH;
                     if (server::GameCompatibility == GAMET_PEROXYD) {
@@ -909,7 +909,7 @@
         State state;
         void actor_hit(const StoneContact &amp;sc) {
             if (state == INVISIBLE) {
-                if (player::WieldedItemIs (sc.actor, &quot;it-brush&quot;)) {
+                if (player::WieldedItemIs (sc.actor, &quot;it_brush&quot;)) {
                     sound_event (&quot;stonepaint&quot;);
                     state = BRUSH;
                     set_model(&quot;st-stone_break&quot;);
@@ -1529,7 +1529,7 @@
         ActorImpulseStoneInvisible() : ActorImpulseBase(&quot;st-actorimpulse_invisible&quot;) {}
 
         void actor_hit(const StoneContact&amp; sc) {
-            if (player::WieldedItemIs (sc.actor, &quot;it-brush&quot;)) {
+            if (player::WieldedItemIs (sc.actor, &quot;it_brush&quot;)) {
                 Stone *st = MakeStone(&quot;st-actorimpulse&quot;);
                 SetStone(get_pos(), st);
                 st-&gt;actor_hit(sc);
@@ -1694,7 +1694,7 @@
     private:
         void actor_hit(const StoneContact &amp;sc) {
             if (player::WieldedItemIs (sc.actor, &quot;it-magicwand&quot;) ||
-                player::WieldedItemIs (sc.actor, &quot;it-brush&quot;))
+                player::WieldedItemIs (sc.actor, &quot;it_brush&quot;))
             {
                 Value color = sc.actor-&gt;getAttr(&quot;color&quot;);
                 if      (color &amp;&amp; color == BLACK) 
@@ -2112,7 +2112,7 @@
         }
 
         void actor_hit(const StoneContact &amp;sc) {
-            if (player::WieldedItemIs(sc.actor, &quot;it-brush&quot;)) {
+            if (player::WieldedItemIs(sc.actor, &quot;it_brush&quot;)) {
                 sound_event(&quot;stonepaint&quot;);
                 ReplaceStone(get_pos(), MakeStone(&quot;st-plain&quot;));
             } else
@@ -2143,7 +2143,7 @@
         }
 
         void actor_hit(const StoneContact &amp;sc) {
-            if (player::WieldedItemIs(sc.actor, &quot;it-brush&quot;)) {
+            if (player::WieldedItemIs(sc.actor, &quot;it_brush&quot;)) {
                 sound_event(&quot;stonepaint&quot;);
                 ReplaceStone(get_pos(), MakeStone(&quot;st-plain_move&quot;));
             } else

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2008-04-11 22:42:10 UTC (rev 1098)
+++ trunk/src/world.cc	2008-04-12 08:14:48 UTC (rev 1099)
@@ -1884,8 +1884,8 @@
     // activate which key hole
     if (src-&gt;getObjectType() == Object::ITEM) {
         ItemID src_id = get_id(dynamic_cast&lt;Item *&gt;(src));
-        if (src_id &gt;= it_key_a &amp;&amp; src_id &lt;= it_key_c &amp;&amp; dst-&gt;is_kind(&quot;st_key&quot;)) {
-            dst-&gt;setAttr(&quot;keycode&quot;, src-&gt;getAttr(&quot;keycode&quot;));
+        if (src_id == it_key &amp;&amp; dst-&gt;is_kind(&quot;st_key&quot;)) {
+            dst-&gt;setAttr(&quot;code&quot;, src-&gt;getAttr(&quot;code&quot;));
             return;
         }
     }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000531.html">[Enigma-game-svn] r1098 - in trunk: data data/schemas src src/stones
</A></li>
	<LI>Next message: <A HREF="000533.html">[Enigma-game-svn] r1100 - team_levelpacks/team_test_new_api
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#532">[ date ]</a>
              <a href="thread.html#532">[ thread ]</a>
              <a href="subject.html#532">[ subject ]</a>
              <a href="author.html#532">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
