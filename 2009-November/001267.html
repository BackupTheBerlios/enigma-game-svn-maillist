<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1838 - in trunk: doc/reference/images src/gui	src/lev
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1838%20-%20in%20trunk%3A%20doc/reference/images%20src/gui%0A%09src/lev&In-Reply-To=%3C200911022324.nA2NO82X014908%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001266.html">
   <LINK REL="Next"  HREF="001268.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1838 - in trunk: doc/reference/images src/gui	src/lev</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1838%20-%20in%20trunk%3A%20doc/reference/images%20src/gui%0A%09src/lev&In-Reply-To=%3C200911022324.nA2NO82X014908%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1838 - in trunk: doc/reference/images src/gui	src/lev">ral at mail.berlios.de
       </A><BR>
    <I>Tue Nov  3 00:24:08 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001266.html">[Enigma-game-svn] r1837 - in trunk: data/levels/enigma_experimental	src/gui
</A></li>
        <LI>Next message: <A HREF="001268.html">[Enigma-game-svn] r1839 - in trunk/src: . gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1267">[ date ]</a>
              <a href="thread.html#1267">[ thread ]</a>
              <a href="subject.html#1267">[ subject ]</a>
              <a href="author.html#1267">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2009-11-03 00:24:05 +0100 (Tue, 03 Nov 2009)
New Revision: 1838

Modified:
   trunk/doc/reference/images/
   trunk/src/gui/LevelPackConfig.cc
   trunk/src/lev/PersistentIndex.cc
   trunk/src/lev/PersistentIndex.hh
   trunk/src/lev/Proxy.cc
Log:
Trunk 1.1: 
- svn ignore refman generated images
- levelpack registration: handle system updates on user path
  - handle normal packs as well as enigma_cross packs
  - evaluate releases and revisions of indices
  - just load matching updates
  - handle wizard mode and composer for level admins
Note:
- deinstall any enigma_cross indices that you installed of unofficial trunk
  enigma versions between release 1.01 and now. They do not suit the naming
  conventions.



Property changes on: trunk/doc/reference/images
___________________________________________________________________
Name: svn:ignore
   - Makefile
Makefile.in
*.pdf

   + Makefile
Makefile.in
*.pdf
ac_bug.png
ac_horse.png
ac_marble_black.png
ac_marble_white.png
ac_pearl_white.png
ac_rotor.png
ac_top.png
fl_abyss.png
fl_adhesionless.png
fl_aquamarine.png
fl_aquamarine_framed.png
fl_bast.png
fl_bast_framed.png
fl_bluegray.png
fl_bluegray_framed.png
fl_bluegreen.png
fl_bluegreen_framed.png
fl_blueslab.png
fl_blueslab_framed.png
fl_brick.png
fl_brick_framed.png
fl_bridge_bw_closed.png
fl_bridge_gc_closed.png
fl_bright.png
fl_bright_framed.png
fl_concrete.png
fl_concrete_framed.png
fl_dark.png
fl_dark_framed.png
fl_darkgray.png
fl_darkgray_framed.png
fl_dunes.png
fl_dunes_framed.png
fl_fake_trigger.png
fl_fake_trigger_framed.png
fl_gravel.png
fl_gravel_framed.png
fl_gray.png
fl_gray_framed.png
fl_hay.png
fl_hay_framed.png
fl_himalaya.png
fl_himalaya_framed.png
fl_ice.png
fl_ice_heating.png
fl_inverse_gray.png
fl_inverse_white.png
fl_ivory.png
fl_ivory_framed.png
fl_lawn.png
fl_lawn_c.png
fl_lawn_e.png
fl_lawn_e2.png
fl_lawn_f.png
fl_lawn_f2.png
fl_lawn_g.png
fl_lawn_g2.png
fl_lawn_h.png
fl_lawn_h2.png
fl_lawn_i.png
fl_lawn_i2.png
fl_lawn_j.png
fl_lawn_j2.png
fl_marble.png
fl_marble_framed.png
fl_metal.png
fl_metal_2.png
fl_metal_3.png
fl_metal_4.png
fl_metal_5.png
fl_metal_6.png
fl_metal_7.png
fl_metal_framed.png
fl_mortar.png
fl_mortar_framed.png
fl_pinkbumps.png
fl_pinkbumps_framed.png
fl_plank.png
fl_plank_framed.png
fl_platinum.png
fl_platinum_framed.png
fl_red.png
fl_red_framed.png
fl_redslab.png
fl_redslab_framed.png
fl_rock.png
fl_rock_framed.png
fl_rough.png
fl_rough_framed.png
fl_sahara.png
fl_sahara_framed.png
fl_samba.png
fl_samba_2.png
fl_samba_framed.png
fl_sand.png
fl_sand_framed.png
fl_slope.png
fl_slope_2.png
fl_slope_3.png
fl_slope_4.png
fl_slope_b.png
fl_slope_b2.png
fl_slope_b3.png
fl_slope_b4.png
fl_slope_c.png
fl_slope_c2.png
fl_slope_c3.png
fl_slope_c4.png
fl_slope_f.png
fl_space.png
fl_stone.png
fl_stone_framed.png
fl_swamp.png
fl_swamp_heating.png
fl_thief.png
fl_thief_capture.png
fl_thief_drunken.png
fl_tigris.png
fl_tigris_framed.png
fl_water.png
fl_water_heating.png
fl_white.png
fl_white_framed.png
fl_wood.png
fl_wood_3.png
fl_wood_framed.png
fl_wood_framed_2.png
fl_woven.png
fl_woven_framed.png
fl_yinyang_yang.png
fl_yinyang_yin.png
it_bag.png
it_banana.png
it_blocker.png
it_bomb_black.png
it_bomb_white.png
it_bottle_broken.png
it_bottle_idle.png
it_brush.png
it_burnable_ash.png
it_burnable_burning.png
it_burnable_fireproof.png
it_burnable_oil.png
it_cherry.png
it_coffee.png
it_coin_l.png
it_coin_m.png
it_coin_s.png
it_crack_abyss.png
it_crack_abyss_2.png
it_crack_abyss_3.png
it_crack_water.png
it_crack_water_2.png
it_crack_water_3.png
it_cross.png
it_death.png
it_document.png
it_drop.png
it_dynamite.png
it_dynamite_burning.png
it_explosion.png
it_extinguisher.png
it_extinguisher_2.png
it_extinguisher_3.png
it_extralife.png
it_flag_black.png
it_flag_white.png
it_floppy.png
it_glasses.png
it_glasses_broken.png
it_hammer.png
it_key.png
it_landmine.png
it_laser.png
it_magicwand.png
it_magnet_off.png
it_magnet_on.png
it_meditation_bump.png
it_meditation_caldera.png
it_meditation_dent.png
it_meditation_hill.png
it_meditation_hollow.png
it_meditation_volcano.png
it_pencil.png
it_pin.png
it_pipe.png
it_pipe_b.png
it_pipe_c.png
it_pipe_d.png
it_pipe_e.png
it_pipe_f.png
it_pipe_g.png
it_pipe_h.png
it_pipe_i.png
it_pipe_j.png
it_puller.png
it_puller_2.png
it_puller_3.png
it_puller_4.png
it_ring.png
it_rubberband.png
it_seed.png
it_sensor.png
it_sensor_exit.png
it_shogun_l.png
it_shogun_m.png
it_shogun_s.png
it_spade.png
it_spoon.png
it_spring_drop.png
it_spring_keep.png
it_springboard.png
it_squashed.png
it_strip.png
it_strip_2.png
it_strip_3.png
it_strip_4.png
it_strip_b.png
it_strip_b2.png
it_strip_b3.png
it_strip_b4.png
it_strip_c.png
it_strip_c2.png
it_strip_c3.png
it_strip_c4.png
it_strip_d.png
it_strip_d2.png
it_strip_d3.png
it_strip_d4.png
it_surprise.png
it_sword.png
it_trap.png
it_trigger.png
it_umbrella.png
it_vortex.png
it_vortex_4.png
it_weight.png
it_wormhole.png
it_wrench.png
it_yinyang.png
st_actorimpulse.png
st_ancient.png
st_beads.png
st_blocker.png
st_bluegray.png
st_bluesand.png
st_bluesand_2.png
st_bluesand_3.png
st_bluesand_4.png
st_bluesand_b.png
st_bluesand_b2.png
st_bluesand_b3.png
st_bluesand_b4.png
st_bluesand_c.png
st_bluesand_c2.png
st_bluesand_c3.png
st_bluesand_c4.png
st_bluesand_d.png
st_bluesand_d2.png
st_bluesand_d3.png
st_bluesand_d4.png
st_blur_cross.png
st_blur_straight.png
st_boulder.png
st_boulder_b.png
st_boulder_c.png
st_boulder_d.png
st_box_hay.png
st_box_hay_growing.png
st_box_rock.png
st_box_wood.png
st_box_wood_2.png
st_box_wood_growing.png
st_brake.png
st_break_black.png
st_break_boulder.png
st_break_bug.png
st_break_oxydc.png
st_break_plain.png
st_break_white.png
st_brick.png
st_brick_2.png
st_brick_3.png
st_brick_4.png
st_brick_b.png
st_brick_b2.png
st_brick_b3.png
st_brick_b4.png
st_brick_c.png
st_brick_c2.png
st_brick_c3.png
st_brick_c4.png
st_brick_d.png
st_brick_d2.png
st_brick_d3.png
st_brick_d4.png
st_brownie.png
st_brownmarble.png
st_brownpyramide.png
st_camouflage.png
st_charge_minus.png
st_charge_plus.png
st_charge_zero.png
st_chess_black.png
st_chess_white.png
st_coinslot.png
st_concrete.png
st_darkglass.png
st_darkgray.png
st_death.png
st_death_light.png
st_disco.png
st_disco_2.png
st_disco_3.png
st_dispenser_bombblack.png
st_dispenser_bombwhite.png
st_dispenser_dynamite.png
st_dispenser_extralife.png
st_door_d_ew.png
st_door_d_ew_g.png
st_door_d_ns.png
st_door_d_ns_7.png
st_fakeoxyd_blink_0003.png
st_flash.png
st_flat.png
st_flat_break.png
st_flat_cracked.png
st_flat_fire.png
st_floppy_off.png
st_floppy_on.png
st_fourswitch.png
st_granite.png
st_grate_cross.png
st_grate_framed.png
st_greenbrown.png
st_greenbrown_growing.png
st_greengray.png
st_ice.png
st_jamb_black.png
st_jamb_white.png
st_key_off.png
st_key_on.png
st_knight.png
st_laser_e_0001.png
st_laser_e_0006.png
st_laser_n_0001.png
st_laser_n_0006.png
st_laser_s_0001.png
st_laser_s_0006.png
st_laser_w_0001.png
st_laser_w_0006.png
st_lightglass.png
st_lightpassenger.png
st_mail.png
st_mail_2.png
st_mail_3.png
st_mail_4.png
st_metal.png
st_mirror_movable_01.png
st_mirror_movable_02.png
st_mirror_movable_03.png
st_mirror_movable_04.png
st_mirror_movable_05.png
st_mirror_movable_06.png
st_mirror_movable_07.png
st_mirror_movable_08.png
st_mirror_movable_09.png
st_mirror_movable_10.png
st_mirror_movable_11.png
st_mirror_movable_12.png
st_mirror_movable_13.png
st_mirror_movable_14.png
st_mirror_movable_15.png
st_mirror_movable_16.png
st_mirror_movable_17.png
st_mirror_movable_18.png
st_mirror_movable_19.png
st_mirror_movable_20.png
st_mirror_static_01.png
st_mirror_static_02.png
st_mirror_static_03.png
st_mirror_static_04.png
st_mirror_static_05.png
st_mirror_static_06.png
st_mirror_static_07.png
st_mirror_static_08.png
st_mirror_static_09.png
st_mirror_static_10.png
st_mirror_static_11.png
st_mirror_static_12.png
st_mirror_static_13.png
st_mirror_static_14.png
st_mirror_static_15.png
st_mirror_static_16.png
st_mirror_static_17.png
st_mirror_static_18.png
st_mirror_static_19.png
st_mirror_static_20.png
st_monoflop.png
st_monoflop_2.png
st_oneway.png
st_oneway_2.png
st_oneway_3.png
st_oneway_4.png
st_oneway_b.png
st_oneway_b2.png
st_oneway_b3.png
st_oneway_b4.png
st_oneway_c.png
st_oneway_c2.png
st_oneway_c3.png
st_oneway_c4.png
st_oxyd_color_0001.png
st_oxyd_color_0002.png
st_oxyd_color_0003.png
st_oxyd_color_0004.png
st_oxyd_color_0005.png
st_oxyd_color_0006.png
st_oxyd_color_0007.png
st_oxyd_color_0008.png
st_oxyd_color_0009.png
st_oxyd_color_0010.png
st_oxyd_color_0011.png
st_oxyd_color_0012.png
st_oxyd_color_0096.png
st_oxyd_color_0097.png
st_oxyda.png
st_oxyda_open.png
st_oxydb.png
st_oxydb_open.png
st_oxydc.png
st_oxydc_open.png
st_oxydd.png
st_oxyde.png
st_panel.png
st_panel_2.png
st_panel_3.png
st_panel_4.png
st_panel_b.png
st_panel_b2.png
st_panel_b3.png
st_panel_b4.png
st_panel_c.png
st_panel_c2.png
st_panel_c3.png
st_panel_c4.png
st_panel_d.png
st_panel_d2.png
st_panel_d3.png
st_panel_d4.png
st_passage_black_cross.png
st_passage_black_frame.png
st_passage_black_slash.png
st_passage_black_square.png
st_passage_white_cross.png
st_passage_white_frame.png
st_passage_white_slash.png
st_passage_white_square.png
st_pinkbumps.png
st_plaster.png
st_plop_slate.png
st_portal_horse.png
st_pull.png
st_purplegray.png
st_purplemarble.png
st_puzzle_blue.png
st_puzzle_blue_2.png
st_puzzle_blue_3.png
st_puzzle_blue_4.png
st_puzzle_blue_b.png
st_puzzle_blue_b2.png
st_puzzle_blue_b3.png
st_puzzle_blue_b4.png
st_puzzle_blue_c.png
st_puzzle_blue_c2.png
st_puzzle_blue_c3.png
st_puzzle_blue_c4.png
st_puzzle_blue_d.png
st_puzzle_blue_d2.png
st_puzzle_blue_d3.png
st_puzzle_blue_d4.png
st_puzzle_blue_hollow.png
st_puzzle_blue_hollow_2.png
st_puzzle_blue_hollow_3.png
st_puzzle_blue_hollow_4.png
st_puzzle_blue_hollow_b.png
st_puzzle_blue_hollow_b2.png
st_puzzle_blue_hollow_b3.png
st_puzzle_blue_hollow_b4.png
st_puzzle_blue_hollow_c.png
st_puzzle_blue_hollow_c2.png
st_puzzle_blue_hollow_c3.png
st_puzzle_blue_hollow_c4.png
st_puzzle_blue_hollow_d.png
st_puzzle_blue_hollow_d2.png
st_puzzle_blue_hollow_d3.png
st_puzzle_blue_hollow_d4.png
st_puzzle_yellow.png
st_puzzle_yellow_2.png
st_puzzle_yellow_3.png
st_puzzle_yellow_4.png
st_puzzle_yellow_b.png
st_puzzle_yellow_b2.png
st_puzzle_yellow_b3.png
st_puzzle_yellow_b4.png
st_puzzle_yellow_c.png
st_puzzle_yellow_c2.png
st_puzzle_yellow_c3.png
st_puzzle_yellow_c4.png
st_puzzle_yellow_d.png
st_puzzle_yellow_d2.png
st_puzzle_yellow_d3.png
st_puzzle_yellow_d4.png
st_puzzle_yellow_hollow.png
st_puzzle_yellow_hollow_2.png
st_puzzle_yellow_hollow_3.png
st_puzzle_yellow_hollow_4.png
st_puzzle_yellow_hollow_b.png
st_puzzle_yellow_hollow_b2.png
st_puzzle_yellow_hollow_b3.png
st_puzzle_yellow_hollow_b4.png
st_puzzle_yellow_hollow_c.png
st_puzzle_yellow_hollow_c2.png
st_puzzle_yellow_hollow_c3.png
st_puzzle_yellow_hollow_c4.png
st_puzzle_yellow_hollow_d.png
st_puzzle_yellow_hollow_d2.png
st_puzzle_yellow_hollow_d3.png
st_puzzle_yellow_hollow_d4.png
st_quake_break.png
st_rawglass.png
st_rawglass_quad.png
st_redbrown.png
st_redfiber.png
st_redmarble.png
st_redrock.png
st_rotator_ccw.png
st_rotator_cw.png
st_rubberband.png
st_scissors.png
st_shogun.png
st_shogun_2.png
st_shogun_3.png
st_shogun_4.png
st_shogun_5.png
st_shogun_6.png
st_shogun_7.png
st_spitter_idle.png
st_stoneimpulse.png
st_stoneimpulse_6.png
st_stoneimpulse_hollow.png
st_surprise.png
st_swap.png
st_switch.png
st_switch_black.png
st_switch_white.png
st_thief.png
st_thief_capture.png
st_thief_drunken.png
st_tigris.png
st_timer.png
st_timer_2.png
st_turnstile.png
st_turnstile_green.png
st_volcano_growing.png
st_window_blue_2.png
st_window_blue_3.png
st_window_blue_4.png
st_window_blue_b.png
st_window_blue_b2.png
st_window_blue_b3.png
st_window_blue_b4.png
st_window_blue_c.png
st_window_blue_c2.png
st_window_blue_c3.png
st_window_blue_c4.png
st_window_blue_d.png
st_window_blue_d2.png
st_window_blue_d3.png
st_window_blue_d4.png
st_window_green_2.png
st_window_green_3.png
st_window_green_4.png
st_window_green_b.png
st_window_green_b2.png
st_window_green_b3.png
st_window_green_b4.png
st_window_green_c.png
st_window_green_c2.png
st_window_green_c3.png
st_window_green_c4.png
st_window_green_d.png
st_window_green_d2.png
st_window_green_d3.png
st_window_green_d4.png
st_woven.png
st_yellow.png
st_yinyang.png
st_yinyang_inactive.png


Modified: trunk/src/gui/LevelPackConfig.cc
===================================================================
--- trunk/src/gui/LevelPackConfig.cc	2009-11-02 13:11:34 UTC (rev 1837)
+++ trunk/src/gui/LevelPackConfig.cc	2009-11-02 23:24:05 UTC (rev 1838)
@@ -108,7 +108,7 @@
         
         if (indexName.empty())
             // new levelpack
-            packIndex = new lev::PersistentIndex(&quot; &quot;, false, false,
+            packIndex = new lev::PersistentIndex(&quot; &quot;, false, true, false,
                     INDEX_DEFAULT_PACK_LOCATION,  &quot;&quot;, 
                     INDEX_STD_FILENAME, lev::Index::getCurrentGroup()); // mark as incomplete
         else

Modified: trunk/src/lev/PersistentIndex.cc
===================================================================
--- trunk/src/lev/PersistentIndex.cc	2009-11-02 13:11:34 UTC (rev 1837)
+++ trunk/src/lev/PersistentIndex.cc	2009-11-02 23:24:05 UTC (rev 1838)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006, 2007 Ronald Lamprecht
+ * Copyright (C) 2006,2007,2008,2009 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -65,27 +65,88 @@
     PersistentIndex * PersistentIndex::historyIndex = NULL;
     std::vector&lt;PersistentIndex *&gt; PersistentIndex::indexCandidates;
     
-    void PersistentIndex::checkCandidate(PersistentIndex * candidate) {
-        if (candidate-&gt;getName().empty() ||
-        	candidate-&gt;getCompatibility() &gt; ENIGMACOMPATIBITLITY) {
+    void PersistentIndex::checkCandidate(std::string thePackPath, bool systemOnly, bool userOwned,
+            bool isAuto, bool isSystemCross, double defaultLocation, std::string anIndexName, 
+            std::string theIndexFilename, std::string aGroupName) {
+        int minRevision = 0;
+        int systemPackIndex = -1;
+        if (!isAuto) {
+            for (int i = 0; i &lt; indexCandidates.size(); i++) {
+                if (indexCandidates[i]-&gt;packPath == thePackPath) {
+                    if (!systemOnly &amp;&amp; isSystemCross) {   // a system cross index update like enigma_cross
+//                        Log &lt;&lt; &quot;cross update check : &quot; &lt;&lt; theIndexFilename &lt;&lt; &quot;\n&quot;;
+                        std::string::size_type p = theIndexFilename.find_last_of('_');
+                        if (p == std::string::npos)  // ignore wizard saves of system cross indices 
+                            return;
+                        std::string indexBase = theIndexFilename.substr(0, p);
+                        if ( indexBase + &quot;.xml&quot; == indexCandidates[i]-&gt;indexFilename) {
+                            if (theIndexFilename == indexBase + ecl::strf(&quot;_%d.xml&quot;, indexCandidates[i]-&gt;release)) {
+                                // it is an update to an already loaded system pack
+                                systemPackIndex = i;
+                                minRevision = indexCandidates[i]-&gt;revision + 1;
+                                break;
+                            } else {
+                                // wrong release - reject
+                                return;
+                            }
+                        } else {
+                            // update to another system index
+                            continue;
+                        }
+                    } else if (systemOnly &amp;&amp; isSystemCross &amp;&amp; theIndexFilename == indexCandidates[i]-&gt;indexFilename) {
+//                        Log &lt;&lt; &quot;cross second copy check : &quot; &lt;&lt; theIndexFilename &lt;&lt; &quot;\n&quot;;
+                        systemPackIndex = i;
+                        minRevision = indexCandidates[i]-&gt;revision + 1;
+                        break;                        
+                    } else if (!isSystemCross) {
+//                        Log &lt;&lt; &quot;other update check : &quot; &lt;&lt; thePackPath &lt;&lt; &quot;\n&quot;;
+                        // it is an update to an already loaded system pack
+                        systemPackIndex = i;
+                        userOwned = false;
+                        if (!systemOnly) {  // no changes for multiple sys paths like ./data shadowing installed version
+                            // add release to index name to retrieve matching version, e.g. &quot;index_2.xml&quot;
+                            theIndexFilename = theIndexFilename.insert(theIndexFilename.size() - 4, 
+                                    ecl::strf(&quot;_%d&quot;, indexCandidates[i]-&gt;release));
+                        }
+                        minRevision = indexCandidates[i]-&gt;revision + 1;
+                        break;
+                    }
+                }
+            }
+        }
+        PersistentIndex * candidate = new PersistentIndex(thePackPath, systemOnly, userOwned, isAuto,
+                defaultLocation, anIndexName, theIndexFilename, aGroupName);
+        if (candidate-&gt;getName().empty() || candidate-&gt;getCompatibility() &gt; ENIGMACOMPATIBITLITY) {
             delete candidate;
+//    Log &lt;&lt; &quot;candidate check : &quot; &lt;&lt; thePackPath &lt;&lt; &quot; -- &quot; &lt;&lt; theIndexFilename &lt;&lt; &quot; -- deleted\n&quot;;
         } else {
             // check if new Index is an update of another
-            for (int i = 0; i &lt; indexCandidates.size(); i++) {
-                if (indexCandidates[i]-&gt;getName() != candidate-&gt;getName()) {
-                    continue;
-                } else if (indexCandidates[i]-&gt;getRelease() != candidate-&gt;getRelease() ||
-                	indexCandidates[i]-&gt;getRevision() &gt;= candidate-&gt;getRevision()) {
+            if (systemPackIndex &gt;= 0) {
+                if (indexCandidates[systemPackIndex]-&gt;getRevision() &gt;= candidate-&gt;getRevision()) {
+//    Log &lt;&lt; &quot;candidate check : &quot; &lt;&lt; thePackPath &lt;&lt; &quot; -- &quot; &lt;&lt; theIndexFilename &lt;&lt; &quot; -- old revision\n&quot;;
                     delete candidate;
                     return;
                 } else {
                     // it is an update
-                    delete indexCandidates[i];
-                    indexCandidates[i] = candidate;
+//    Log &lt;&lt; &quot;candidate check : &quot; &lt;&lt; thePackPath &lt;&lt; &quot; -- &quot; &lt;&lt; theIndexFilename &lt;&lt; &quot; -- an update\n&quot;;
+                    delete indexCandidates[systemPackIndex];
+                    indexCandidates[systemPackIndex] = candidate;
                     return;
                 }
+            } else {
+                // check for levelpacks that would be overriden by the button name
+                for (int i = 0; i &lt; indexCandidates.size(); i++) {
+                    if (indexCandidates[i]-&gt;getName() == candidate-&gt;getName()) {
+                        // always prefer the first one, the one with more official background
+//    Log &lt;&lt; &quot;candidate check : &quot; &lt;&lt; thePackPath &lt;&lt; &quot; -- &quot; &lt;&lt; theIndexFilename &lt;&lt; &quot; -- name duplicate\n&quot;;
+                        delete candidate;
+                        return;
+                    }
+                }
+                
+//    Log &lt;&lt; &quot;candidate check : &quot; &lt;&lt; thePackPath &lt;&lt; &quot; -- &quot; &lt;&lt; theIndexFilename &lt;&lt; &quot; -- first one\n&quot;;
+                indexCandidates.push_back(candidate);
             }
-            indexCandidates.push_back(candidate);
         }
     }
     
@@ -93,7 +154,7 @@
         DirIter * dirIter;
         DirEntry dirEntry;
         
-        // SysemPath: register dirs and zips with xml-indices 
+        // SystemPath: register dirs and zips with xml-indices 
         std::vector&lt;std::string&gt; sysPaths = app.systemFS-&gt;getPaths();
         std::set&lt;std::string&gt; candidates;
         std::set&lt;std::string&gt; candidates2;
@@ -135,10 +196,8 @@
             // register the index just on the system path even if the
             // user has an update on his path. We need to know the release to
             // decide if a user copy is an update
-            PersistentIndex * anIndex = new PersistentIndex(*i, true);
-            anIndex-&gt;isUserOwned = false;
+            checkCandidate(*i, true, false);
 //            Log &lt;&lt; &quot;precheck: &quot; &lt;&lt; *i &lt;&lt; &quot;\n&quot;;
-            checkCandidate(anIndex);
         }
 
         //add system cross indices
@@ -147,10 +206,9 @@
             while (dirIter-&gt;get_next(dirEntry)) {
                 if (!dirEntry.is_dir &amp;&amp; dirEntry.name.size() &gt; 4 &amp;&amp; 
                         (dirEntry.name.rfind(&quot;.xml&quot;) == dirEntry.name.size() - 4)) {
-                    PersistentIndex * anIndex = new PersistentIndex(&quot;enigma_cross&quot;, true, false,
+//                            Log &lt;&lt; &quot;enigma cross check: &quot; &lt;&lt; dirEntry.name &lt;&lt; &quot;\n&quot;; 
+                    checkCandidate(&quot;enigma_cross&quot;, true, false, false, true,
                             INDEX_DEFAULT_PACK_LOCATION, &quot;&quot;, dirEntry.name);
-                    anIndex-&gt;isUserOwned = false;
-                    checkCandidate(anIndex);
                 }
             }
         }
@@ -161,13 +219,13 @@
         
         // register index free auto folder
         // this needs to be done prior history registration to avoid outdated proxies
-        PersistentIndex * autoIndex = new PersistentIndex(&quot;auto&quot;, false, true,
+        PersistentIndex * autoIndex = new PersistentIndex(&quot;auto&quot;, false, true, true,
                 INDEX_AUTO_PACK_LOCATION, INDEX_AUTO_PACK_NAME);
         autoIndex-&gt;isEditable = false;
         Index::registerIndex(autoIndex);
         
         // register team auto not yet registered new files
-        PersistentIndex * teamautoIndex = new PersistentIndex(&quot;team_test_new_api&quot;, false, true,
+        PersistentIndex * teamautoIndex = new PersistentIndex(&quot;team_test_new_api&quot;, false, true, true,
                 75000, &quot;test_new_api&quot;);
         if (teamautoIndex-&gt;size() &gt; 0) {
             teamautoIndex-&gt;isEditable = false;
@@ -219,18 +277,27 @@
         for (std::set&lt;std::string&gt;::iterator i = candidates2.begin(); 
                 i != candidates2.end(); i++) {
 //            Log &lt;&lt; &quot;sokoball candidate2 &quot; &lt;&lt; *i &lt;&lt; &quot; - check \n&quot;;
-            PersistentIndex * anIndex = new PersistentIndex(*i, false);
-            checkCandidate(anIndex);
+            checkCandidate(*i, false,true);
         }
        
+        //add system cross indices updates
+        dirIter = DirIter::instance(app.userPath + &quot;/levels/enigma_cross&quot;);
+        while (dirIter-&gt;get_next(dirEntry)) {
+            if (!dirEntry.is_dir &amp;&amp; dirEntry.name.size() &gt; 4 &amp;&amp; 
+                    (dirEntry.name.rfind(&quot;.xml&quot;) == dirEntry.name.size() - 4)) {
+                checkCandidate(&quot;enigma_cross&quot;, false, false, false, true,
+                        INDEX_DEFAULT_PACK_LOCATION, &quot;&quot;, dirEntry.name);
+            }
+        }
+        delete dirIter;
+        
         //add user cross indices
         dirIter = DirIter::instance(app.userPath + &quot;/levels/cross&quot;);
         while (dirIter-&gt;get_next(dirEntry)) {
             if (!dirEntry.is_dir &amp;&amp; dirEntry.name.size() &gt; 4 &amp;&amp; 
                     (dirEntry.name.rfind(&quot;.xml&quot;) == dirEntry.name.size() - 4)) {
-                PersistentIndex * anIndex = new PersistentIndex(&quot;cross&quot;, false, false,
+                checkCandidate(&quot;cross&quot;, false, true, false, false,
                         INDEX_DEFAULT_PACK_LOCATION, &quot;&quot;, dirEntry.name);
-                checkCandidate(anIndex);
             }
         }
         delete dirIter;
@@ -244,7 +311,7 @@
         if ( foundHistory != NULL) {
             historyIndex = dynamic_cast&lt;PersistentIndex *&gt;(foundHistory);
         } else {
-            historyIndex = new PersistentIndex(&quot;cross&quot;, false, false, INDEX_HISTORY_PACK_LOCATION, 
+            historyIndex = new PersistentIndex(&quot;cross&quot;, false, true, false, INDEX_HISTORY_PACK_LOCATION, 
                     INDEX_HISTORY_PACK_NAME, &quot;history.xml&quot;);
             Index::registerIndex(historyIndex);
         }
@@ -267,22 +334,22 @@
         }
     }
 
-    PersistentIndex::PersistentIndex(std::string thePackPath, bool systemOnly, bool autoLoading,
-            double defaultLocation, std::string anIndexName, 
+    PersistentIndex::PersistentIndex(std::string thePackPath, bool loadSystemFS, bool userOwned, 
+            bool autoLoading, double defaultLocation, std::string anIndexName, 
             std::string theIndexFilename, std::string aGroupName) : 
             Index(anIndexName, aGroupName, defaultLocation), packPath (thePackPath), isAuto (autoLoading),
             indexFilename(theIndexFilename), isModified (false),
-            isUserOwned (true), isEditable (true), release (1), revision (1),
+            isUserOwned (userOwned), isEditable (true), release (1), revision (1),
             compatibility (1.00), doc(NULL) {
 //        Log &lt;&lt; &quot;PersistentIndex AddLevelPack &quot; &lt;&lt; thePackPath &lt;&lt; &quot; - &quot; &lt;&lt; anIndexName &lt;&lt;  &quot; - &quot; &lt;&lt; indexDefaultLocation &lt;&lt;&quot;\n&quot;;
-        load(systemOnly);
+        load(loadSystemFS);
     }
     
     int autoIndexProxyCompare(Proxy * first, Proxy * second) {
         return first-&gt;getNormLevelPath() &lt; second-&gt;getNormLevelPath();
     }
     
-    void PersistentIndex::load(bool systemOnly, bool update) {
+    void PersistentIndex::load(bool loadSystemFS, bool update) {
         if (doc != NULL) {
             doc-&gt;release();
             doc = NULL;
@@ -330,8 +397,8 @@
         std::string errMessage;
         absIndexPath = &quot;&quot;;
         std::string relIndexPath = &quot;levels/&quot; + packPath + &quot;/&quot; + indexFilename;
-        if ((!systemOnly &amp;&amp; app.resourceFS-&gt;findFile(relIndexPath, absIndexPath, isptr)) ||
-                (systemOnly &amp;&amp; app.systemFS-&gt;findFile(relIndexPath, absIndexPath, isptr))) {
+        if ((!loadSystemFS &amp;&amp; app.resourceFS-&gt;findFile(relIndexPath, absIndexPath, isptr)) ||
+                (loadSystemFS &amp;&amp; app.systemFS-&gt;findFile(relIndexPath, absIndexPath, isptr))) {
             // preload index file or zipped index
             if (isptr.get() != NULL) {
                 // zipped file
@@ -406,7 +473,7 @@
                 gui::ErrorMenu m(message, N_(&quot;Continue&quot;));
                 m.manage();
                 if (update) {
-                    load(systemOnly, false);  // reload local version                    
+                    load(loadSystemFS, false);  // reload local version                    
                 }
                 return;
             } else if (doc != NULL) {
@@ -822,23 +889,23 @@
                     Utf8ToXML(level-&gt;hasEasyMode() ? &quot;true&quot; : &quot;false&quot;).x_str());
             std::string control;
             switch (variations[i].ctrl) {
-            case lev::force:
-                control = &quot;force&quot;; break;
-            case lev::balance:
-                control = &quot;balance&quot;; break;
-            case lev::key:
-                control = &quot;key&quot;; break;
-            default:
-                control = &quot;other&quot;; break;
+                case lev::force:
+                    control = &quot;force&quot;; break;
+                case lev::balance:
+                    control = &quot;balance&quot;; break;
+                case lev::key:
+                    control = &quot;key&quot;; break;
+                default:
+                    control = &quot;other&quot;; break;
             }
             levelElem-&gt;setAttribute( Utf8ToXML(&quot;ctrl&quot;).x_str(),
                     Utf8ToXML(control).x_str());
             std::string unit;
             switch (variations[i].unit) {
-            case lev::duration:
-                unit = &quot;duration&quot;; break;
-            case lev::number:
-                unit = &quot;number&quot;; break;
+                case lev::duration:
+                    unit = &quot;duration&quot;; break;
+                case lev::number:
+                    unit = &quot;number&quot;; break;
             }
             levelElem-&gt;setAttribute( Utf8ToXML(&quot;unit&quot;).x_str(),
                     Utf8ToXML(unit).x_str());
@@ -868,7 +935,7 @@
             try {
                 // auto-create the directory if necessary
                 std::string directory;
-                if (ecl::split_path (path, &amp;directory, 0) &amp;&amp; !ecl::FolderExists(directory)) {
+                if (ecl::split_path(path, &amp;directory, 0) &amp;&amp; !ecl::FolderExists(directory)) {
                     ecl::FolderCreate (directory);
                 }
     

Modified: trunk/src/lev/PersistentIndex.hh
===================================================================
--- trunk/src/lev/PersistentIndex.hh	2009-11-02 13:11:34 UTC (rev 1837)
+++ trunk/src/lev/PersistentIndex.hh	2009-11-02 23:24:05 UTC (rev 1838)
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006 Ronald Lamprecht
+ * Copyright (C) 2006,2007,2008,2009 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -60,7 +60,7 @@
          * 
          * thePackPath &quot; &quot; for a new not yet defined path
          */
-        PersistentIndex(std::string thePackPath, bool systemOnly, bool isAuto =false,
+        PersistentIndex(std::string thePackPath, bool systemOnly, bool userOwned = true, bool isAuto =false,
                 double defaultLocation = INDEX_DEFAULT_PACK_LOCATION,
                 std::string anIndexName = &quot;&quot;,
                 std::string theIndexFilename = INDEX_STD_FILENAME, 
@@ -73,7 +73,11 @@
         PersistentIndex(std::istream *legacyIndex, std::string thePackPath,  bool isZip = false,
                 std::string anIndexName = &quot;&quot;, std::string theIndexFilename = INDEX_STD_FILENAME);
         ~PersistentIndex();
-        void load(bool systemOnly, bool update = false);
+        
+        /**
+         * 
+         */
+        void load(bool loadSystemFS = false, bool update = false);
         void loadDoc();
         std::string getPackPath();
         bool setName(std::string newName, bool isSokoball);
@@ -104,7 +108,7 @@
         virtual void updateFromFolder();
         bool save(bool allowOverwrite = true);
     protected:
-        std::string packPath;  // &quot;auto&quot;, &quot;&quot;,...
+        std::string packPath;  // &quot;auto&quot;, &quot;&quot;, &quot;enigma_i&quot;, ...
         std::string indexFilename;
         std::string owner;
         int release;
@@ -124,7 +128,11 @@
         XERCES_CPP_NAMESPACE_QUALIFIER DOMElement *updateElem;
         XERCES_CPP_NAMESPACE_QUALIFIER DOMElement *levelsElem;
         
-        static void checkCandidate(PersistentIndex * candidate);
+//        static void checkCandidate(PersistentIndex * candidate);
+        static void checkCandidate(std::string thePackPath, bool systemOnly, bool userOwned =true, 
+                bool isAuto =false, bool isSystemCross =false, 
+                double defaultLocation =INDEX_DEFAULT_PACK_LOCATION, std::string anIndexName =&quot;&quot;,
+                std::string theIndexFilename =INDEX_STD_FILENAME, std::string aGroupName =INDEX_DEFAULT_GROUP);
         // legacy 0.92
         void parsePar(const string&amp; par, int&amp; par_value, std::string&amp; par_text);
     };

Modified: trunk/src/lev/Proxy.cc
===================================================================
--- trunk/src/lev/Proxy.cc	2009-11-02 13:11:34 UTC (rev 1837)
+++ trunk/src/lev/Proxy.cc	2009-11-02 23:24:05 UTC (rev 1838)
@@ -449,7 +449,11 @@
                 basic_ifstream&lt;char&gt; ifs(absLevelPath.c_str(), ios::binary | ios::in);
                 Readfile(ifs, levelCode);
             }
-            std::string oPath = newBasePath + &quot;/&quot; + newPackPath + &quot;/&quot; + filename;
+            // auto-create the destination directory if necessary
+            std::string directory = newBasePath + &quot;/&quot; + newPackPath;
+            if (!ecl::FolderExists(directory))
+                ecl::FolderCreate (directory);
+            std::string oPath =  directory + &quot;/&quot; + filename;
             if (backup) {
                 std::remove((oPath + &quot;~&quot;).c_str());
                 std::rename(oPath.c_str(), (oPath + &quot;~&quot;).c_str());
@@ -554,7 +558,7 @@
                 throw XLevelLoading(&quot;Unknown file extension in &quot; + absLevelPath);
             }
         } else {
-                throw XLevelLoading(&quot;Unknown file extension in &quot; + absLevelPath);
+            throw XLevelLoading(&quot;Unknown file extension in &quot; + absLevelPath);
         }
 
         // preload file into buffer


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001266.html">[Enigma-game-svn] r1837 - in trunk: data/levels/enigma_experimental	src/gui
</A></li>
	<LI>Next message: <A HREF="001268.html">[Enigma-game-svn] r1839 - in trunk/src: . gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1267">[ date ]</a>
              <a href="thread.html#1267">[ thread ]</a>
              <a href="subject.html#1267">[ subject ]</a>
              <a href="author.html#1267">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
