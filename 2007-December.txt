From ral at mail.berlios.de  Sat Dec  1 20:16:03 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sat, 1 Dec 2007 20:16:03 +0100
Subject: [Enigma-game-svn] r930 - homepage/input
Message-ID: <200712011916.lB1JG3el007137@sheep.berlios.de>

Author: ral
Date: 2007-12-01 20:16:02 +0100 (Sat, 01 Dec 2007)
New Revision: 930

Modified:
   homepage/input/stat-other.html
   homepage/input/table-hcp.html
   homepage/input/table-rat.html
   homepage/input/table-solved.html
   homepage/input/table-wr.html
   homepage/input/userlist.html
Log:
Homepage:
- statistics November 2007

Modified: homepage/input/stat-other.html
===================================================================
--- homepage/input/stat-other.html	2007-11-27 23:08:19 UTC (rev 929)
+++ homepage/input/stat-other.html	2007-12-01 19:16:02 UTC (rev 930)
@@ -1,22 +1,22 @@
   <div class="stat-help">
     <h3>$$Other_Statistics$$</h3>
     <h4>$$Scores$$</h4>
-      60446 $$single_level_scores$$.
+      64290 $$single_level_scores$$.
     <h4>$$Ratings$$</h4>
-      10884 $$single_level_ratings$$ 4.88 $$and_distribution$$: 
+      12065 $$single_level_ratings$$ 4.86 $$and_distribution$$: 
       <table>
         <colgroup><col width="80"><col width="80"></colgroup>
         <tr><th>$$rating$$</th><th>$$count$$</th></tr>
-        <tr><td class="num">0</td><td class="num">38</td></tr>
-        <tr><td class="num">1</td><td class="num">216</td></tr>
-        <tr><td class="num">2</td><td class="num">579</td></tr>
-        <tr><td class="num">3</td><td class="num">1613</td></tr>
-        <tr><td class="num">4</td><td class="num">2110</td></tr>
-        <tr><td class="num">5</td><td class="num">2630</td></tr>
-        <tr><td class="num">6</td><td class="num">1718</td></tr>
-        <tr><td class="num">7</td><td class="num">1234</td></tr>
-        <tr><td class="num">8</td><td class="num">463</td></tr>
-        <tr><td class="num">9</td><td class="num">193</td></tr>
-        <tr><td class="num">10</td><td class="num">90</td></tr>
+        <tr><td class="num">0</td><td class="num">47</td></tr>
+        <tr><td class="num">1</td><td class="num">244</td></tr>
+        <tr><td class="num">2</td><td class="num">652</td></tr>
+        <tr><td class="num">3</td><td class="num">1795</td></tr>
+        <tr><td class="num">4</td><td class="num">2347</td></tr>
+        <tr><td class="num">5</td><td class="num">2877</td></tr>
+        <tr><td class="num">6</td><td class="num">1971</td></tr>
+        <tr><td class="num">7</td><td class="num">1350</td></tr>
+        <tr><td class="num">8</td><td class="num">488</td></tr>
+        <tr><td class="num">9</td><td class="num">201</td></tr>
+        <tr><td class="num">10</td><td class="num">93</td></tr>
       </table>
   </div>

Modified: homepage/input/table-hcp.html
===================================================================
--- homepage/input/table-hcp.html	2007-11-27 23:08:19 UTC (rev 929)
+++ homepage/input/table-hcp.html	2007-12-01 19:16:02 UTC (rev 930)
@@ -1,119 +1,125 @@
   <table>
-    <caption>$$Handicap_Statistics$$ $$October$$ 2007</caption>
+    <caption>$$Handicap_Statistics$$ $$November$$ 2007</caption>
     <colgroup><col width="130"><col width="220"></colgroup>
     <tr><th>$$solved_hcp$$</th><th class="left">$$user$$</th></tr>
-     <tr><td class="num">-137.0</td><td class="left">'Moneymaker'</td></tr>
-     <tr><td class="num"> -89.0</td><td class="left">'Johannes'</td></tr>
-     <tr><td class="num"> -88.5</td><td class="left">'Stupid'</td></tr>
-     <tr><td class="num"> -77.3</td><td class="left">'Great Scott'</td></tr>
-     <tr><td class="num"> -66.3</td><td class="left">'Duffy'</td></tr>
-     <tr><td class="num"> -51.5</td><td class="left">'Django'</td></tr>
-     <tr><td class="num"> -51.5</td><td class="left">'daydreamer'</td></tr>
-     <tr><td class="num"> -44.6</td><td class="left">'Alexandros'</td></tr>
-     <tr><td class="num"> -40.8</td><td class="left">'Taztunes'</td></tr>
-     <tr><td class="num"> -37.7</td><td class="left">'Safalra'</td></tr>
-     <tr><td class="num"> -32.2</td><td class="left">'bojster'</td></tr>
-     <tr><td class="num"> -31.9</td><td class="left">'ryujun'</td></tr>
-     <tr><td class="num"> -24.8</td><td class="left">'Ludmian'</td></tr>
-     <tr><td class="num"> -23.8</td><td class="left">'Raoul'</td></tr>
-     <tr><td class="num"> -22.0</td><td class="left">'ged'</td></tr>
-     <tr><td class="num"> -20.9</td><td class="left">'Ghatotkacha'</td></tr>
-     <tr><td class="num"> -19.8</td><td class="left">'hendrik'</td></tr>
-     <tr><td class="num"> -17.8</td><td class="left">'dpl'</td></tr>
-     <tr><td class="num"> -16.9</td><td class="left">'Ronald'</td></tr>
-     <tr><td class="num"> -16.5</td><td class="left">'Lukas'</td></tr>
-     <tr><td class="num"> -15.6</td><td class="left">'HuB34'</td></tr>
-     <tr><td class="num"> -12.1</td><td class="left">'joseba'</td></tr>
-     <tr><td class="num"> -11.8</td><td class="left">'Iceshark7'</td></tr>
-     <tr><td class="num">  -9.2</td><td class="left">'Daniel'</td></tr>
-     <tr><td class="num">  -7.6</td><td class="left">'fabian'</td></tr>
-     <tr><td class="num">  -5.5</td><td class="left">'Craven'</td></tr>
-     <tr><td class="num">  -5.3</td><td class="left">'Wuzzy'</td></tr>
-     <tr><td class="num">  -5.3</td><td class="left">'JuSt'</td></tr>
-     <tr><td class="num">  -2.2</td><td class="left">'para_doks'</td></tr>
-     <tr><td class="num">  -2.2</td><td class="left">'Tobias'</td></tr>
-     <tr><td class="num">  -1.1</td><td class="left">'Guglielmo'</td></tr>
-     <tr><td class="num">   1.3</td><td class="left">'Zekobah'</td></tr>
-     <tr><td class="num">   2.1</td><td class="left">'Emmanuel'</td></tr>
-     <tr><td class="num">   6.2</td><td class="left">'mrduke'</td></tr>
-     <tr><td class="num">   6.3</td><td class="left">'ABS'</td></tr>
-     <tr><td class="num">   7.1</td><td class="left">'ShadowPhrogg32642342'</td></tr>
-     <tr><td class="num">   9.1</td><td class="left">'Andreas'</td></tr>
-     <tr><td class="num">   9.7</td><td class="left">'Chocolate Zero'</td></tr>
-     <tr><td class="num">  10.9</td><td class="left">'Sim_Ed'</td></tr>
-     <tr><td class="num">  11.3</td><td class="left">'Agnieszka'</td></tr>
-     <tr><td class="num">  11.7</td><td class="left">'shoki'</td></tr>
-     <tr><td class="num">  12.1</td><td class="left">'Mark P.'</td></tr>
-     <tr><td class="num">  14.2</td><td class="left">'Tiza'</td></tr>
-     <tr><td class="num">  16.1</td><td class="left">'U-Punkt'</td></tr>
-     <tr><td class="num">  16.5</td><td class="left">'Alex'</td></tr>
-     <tr><td class="num">  19.2</td><td class="left">'Klaus'</td></tr>
-     <tr><td class="num">  19.5</td><td class="left">'Marc-Hendrik'</td></tr>
-     <tr><td class="num">  19.5</td><td class="left">'Chris'</td></tr>
-     <tr><td class="num">  19.7</td><td class="left">'Bent'</td></tr>
-     <tr><td class="num">  20.2</td><td class="left">'Thomas'</td></tr>
-     <tr><td class="num">  21.3</td><td class="left">'hdwow'</td></tr>
-     <tr><td class="num">  22.1</td><td class="left">'Gottseinsohn'</td></tr>
-     <tr><td class="num">  23.2</td><td class="left">'Ale'</td></tr>
-     <tr><td class="num">  24.2</td><td class="left">'J3FF'</td></tr>
-     <tr><td class="num">  24.4</td><td class="left">'Little_Mole'</td></tr>
-     <tr><td class="num">  24.6</td><td class="left">'alfred69'</td></tr>
-     <tr><td class="num">  25.9</td><td class="left">'biotopa'</td></tr>
-     <tr><td class="num">  27.1</td><td class="left">'redsantz'</td></tr>
-     <tr><td class="num">  28.2</td><td class="left">'IChrisI'</td></tr>
-     <tr><td class="num">  28.8</td><td class="left">'NorthForty'</td></tr>
-     <tr><td class="num">  28.8</td><td class="left">'Melanie'</td></tr>
-     <tr><td class="num">  29.0</td><td class="left">'erich'</td></tr>
-     <tr><td class="num">  29.3</td><td class="left">'Davacardo'</td></tr>
-     <tr><td class="num">  29.6</td><td class="left">'Andy'</td></tr>
-     <tr><td class="num">  30.6</td><td class="left">'Vinksu'</td></tr>
-     <tr><td class="num">  31.7</td><td class="left">'Edgar_Flesk'</td></tr>
-     <tr><td class="num">  32.0</td><td class="left">'MicWa'</td></tr>
-     <tr><td class="num">  32.2</td><td class="left">'niebie'</td></tr>
-     <tr><td class="num">  33.4</td><td class="left">'WP319'</td></tr>
-     <tr><td class="num">  34.2</td><td class="left">'Rugby4ever'</td></tr>
-     <tr><td class="num">  35.8</td><td class="left">'Gorn'</td></tr>
-     <tr><td class="num">  36.0</td><td class="left">'Drotten'</td></tr>
-     <tr><td class="num">  36.5</td><td class="left">'B-man'</td></tr>
-     <tr><td class="num">  36.5</td><td class="left">'Archcorenth'</td></tr>
-     <tr><td class="num">  38.2</td><td class="left">'Tiger'</td></tr>
-     <tr><td class="num">  39.4</td><td class="left">'Nfol'</td></tr>
-     <tr><td class="num">  40.1</td><td class="left">'Vlad'</td></tr>
-     <tr><td class="num">  40.4</td><td class="left">'Momcat'</td></tr>
-     <tr><td class="num">  41.0</td><td class="left">'Uli'</td></tr>
-     <tr><td class="num">  42.7</td><td class="left">'Liam Sheehan'</td></tr>
-     <tr><td class="num">  43.0</td><td class="left">'Tarim'</td></tr>
-     <tr><td class="num">  43.5</td><td class="left">'IntKecsk'</td></tr>
-     <tr><td class="num">  43.8</td><td class="left">'Breezy'</td></tr>
-     <tr><td class="num">  45.4</td><td class="left">'mhatta'</td></tr>
-     <tr><td class="num">  45.7</td><td class="left">'Harry Lim'</td></tr>
-     <tr><td class="num">  46.5</td><td class="left">'Zak'</td></tr>
-     <tr><td class="num">  47.3</td><td class="left">'Valkyrie2'</td></tr>
-     <tr><td class="num">  47.6</td><td class="left">'Sandra'</td></tr>
-     <tr><td class="num">  49.1</td><td class="left">'Jeffrey S'</td></tr>
-     <tr><td class="num">  49.9</td><td class="left">'Vaily'</td></tr>
-     <tr><td class="num">  51.0</td><td class="left">'Neophilus'</td></tr>
-     <tr><td class="num">  51.1</td><td class="left">'Turbogurk'</td></tr>
-     <tr><td class="num">  51.8</td><td class="left">'Cyphase'</td></tr>
-     <tr><td class="num">  51.9</td><td class="left">'brynn'</td></tr>
-     <tr><td class="num">  53.7</td><td class="left">'krazy62'</td></tr>
-     <tr><td class="num">  54.6</td><td class="left">'Adonica'</td></tr>
-     <tr><td class="num">  60.2</td><td class="left">'Asbel'</td></tr>
+     <tr><td class="num">-137.2</td><td class="left">'Moneymaker'</td></tr>
+     <tr><td class="num"> -88.3</td><td class="left">'Johannes'</td></tr>
+     <tr><td class="num"> -88.1</td><td class="left">'Stupid'</td></tr>
+     <tr><td class="num"> -76.4</td><td class="left">'Great Scott'</td></tr>
+     <tr><td class="num"> -65.6</td><td class="left">'Duffy'</td></tr>
+     <tr><td class="num"> -59.7</td><td class="left">'daydreamer'</td></tr>
+     <tr><td class="num"> -50.9</td><td class="left">'Django'</td></tr>
+     <tr><td class="num"> -43.9</td><td class="left">'Alexandros'</td></tr>
+     <tr><td class="num"> -43.4</td><td class="left">'Taztunes'</td></tr>
+     <tr><td class="num"> -39.0</td><td class="left">'Safalra'</td></tr>
+     <tr><td class="num"> -31.3</td><td class="left">'bojster'</td></tr>
+     <tr><td class="num"> -31.3</td><td class="left">'ryujun'</td></tr>
+     <tr><td class="num"> -28.2</td><td class="left">'hendrik'</td></tr>
+     <tr><td class="num"> -25.1</td><td class="left">'ged'</td></tr>
+     <tr><td class="num"> -23.8</td><td class="left">'Ludmian'</td></tr>
+     <tr><td class="num"> -23.4</td><td class="left">'Raoul'</td></tr>
+     <tr><td class="num"> -20.1</td><td class="left">'Ghatotkacha'</td></tr>
+     <tr><td class="num"> -18.3</td><td class="left">'Ronald'</td></tr>
+     <tr><td class="num"> -17.1</td><td class="left">'dpl'</td></tr>
+     <tr><td class="num"> -16.0</td><td class="left">'Lukas'</td></tr>
+     <tr><td class="num"> -15.2</td><td class="left">'HuB34'</td></tr>
+     <tr><td class="num"> -11.8</td><td class="left">'ABS'</td></tr>
+     <tr><td class="num"> -11.7</td><td class="left">'joseba'</td></tr>
+     <tr><td class="num"> -11.0</td><td class="left">'dev0'</td></tr>
+     <tr><td class="num"> -10.9</td><td class="left">'Iceshark7'</td></tr>
+     <tr><td class="num">  -8.3</td><td class="left">'Daniel'</td></tr>
+     <tr><td class="num">  -6.7</td><td class="left">'fabian'</td></tr>
+     <tr><td class="num">  -5.3</td><td class="left">'B-Huff'</td></tr>
+     <tr><td class="num">  -5.2</td><td class="left">'Craven'</td></tr>
+     <tr><td class="num">  -4.8</td><td class="left">'JuSt'</td></tr>
+     <tr><td class="num">  -4.6</td><td class="left">'Wuzzy'</td></tr>
+     <tr><td class="num">  -1.8</td><td class="left">'para_doks'</td></tr>
+     <tr><td class="num">  -1.6</td><td class="left">'Tobias'</td></tr>
+     <tr><td class="num">  -0.6</td><td class="left">'Guglielmo'</td></tr>
+     <tr><td class="num">   0.7</td><td class="left">'serpent'</td></tr>
+     <tr><td class="num">   2.1</td><td class="left">'Zekobah'</td></tr>
+     <tr><td class="num">   2.6</td><td class="left">'Emmanuel'</td></tr>
+     <tr><td class="num">   6.0</td><td class="left">'mrduke'</td></tr>
+     <tr><td class="num">   7.7</td><td class="left">'ShadowPhrogg32642342'</td></tr>
+     <tr><td class="num">   9.3</td><td class="left">'Andreas'</td></tr>
+     <tr><td class="num">  10.1</td><td class="left">'alfred69'</td></tr>
+     <tr><td class="num">  10.3</td><td class="left">'Chocolate Zero'</td></tr>
+     <tr><td class="num">  11.6</td><td class="left">'Sim_Ed'</td></tr>
+     <tr><td class="num">  11.8</td><td class="left">'Agnieszka'</td></tr>
+     <tr><td class="num">  12.0</td><td class="left">'shoki'</td></tr>
+     <tr><td class="num">  12.5</td><td class="left">'Mark P.'</td></tr>
+     <tr><td class="num">  14.2</td><td class="left">'U-Punkt'</td></tr>
+     <tr><td class="num">  14.9</td><td class="left">'Tiza'</td></tr>
+     <tr><td class="num">  16.7</td><td class="left">'Alex'</td></tr>
+     <tr><td class="num">  17.5</td><td class="left">'Andy'</td></tr>
+     <tr><td class="num">  19.8</td><td class="left">'Klaus'</td></tr>
+     <tr><td class="num">  19.8</td><td class="left">'Chris'</td></tr>
+     <tr><td class="num">  19.9</td><td class="left">'Marc-Hendrik'</td></tr>
+     <tr><td class="num">  20.5</td><td class="left">'Bent'</td></tr>
+     <tr><td class="num">  20.8</td><td class="left">'Thomas'</td></tr>
+     <tr><td class="num">  21.8</td><td class="left">'hdwow'</td></tr>
+     <tr><td class="num">  22.7</td><td class="left">'Gottseinsohn'</td></tr>
+     <tr><td class="num">  23.6</td><td class="left">'Ale'</td></tr>
+     <tr><td class="num">  24.9</td><td class="left">'J3FF'</td></tr>
+     <tr><td class="num">  24.9</td><td class="left">'Little_Mole'</td></tr>
+     <tr><td class="num">  26.1</td><td class="left">'biotopa'</td></tr>
+     <tr><td class="num">  27.1</td><td class="left">'geembo_90'</td></tr>
+     <tr><td class="num">  27.4</td><td class="left">'redsantz'</td></tr>
+     <tr><td class="num">  28.5</td><td class="left">'Edgar_Flesk'</td></tr>
+     <tr><td class="num">  28.7</td><td class="left">'IChrisI'</td></tr>
+     <tr><td class="num">  29.0</td><td class="left">'Melanie'</td></tr>
+     <tr><td class="num">  29.2</td><td class="left">'NorthForty'</td></tr>
+     <tr><td class="num">  29.3</td><td class="left">'erich'</td></tr>
+     <tr><td class="num">  29.7</td><td class="left">'Davacardo'</td></tr>
+     <tr><td class="num">  31.1</td><td class="left">'Vinksu'</td></tr>
+     <tr><td class="num">  32.7</td><td class="left">'niebie'</td></tr>
+     <tr><td class="num">  32.7</td><td class="left">'MicWa'</td></tr>
+     <tr><td class="num">  32.8</td><td class="left">'WP319'</td></tr>
+     <tr><td class="num">  32.9</td><td class="left">'Gorn'</td></tr>
+     <tr><td class="num">  34.7</td><td class="left">'Rugby4ever'</td></tr>
+     <tr><td class="num">  36.5</td><td class="left">'Drotten'</td></tr>
+     <tr><td class="num">  37.1</td><td class="left">'B-man'</td></tr>
+     <tr><td class="num">  37.1</td><td class="left">'Archcorenth'</td></tr>
+     <tr><td class="num">  37.3</td><td class="left">'Harry Lim'</td></tr>
+     <tr><td class="num">  38.4</td><td class="left">'Nfol'</td></tr>
+     <tr><td class="num">  38.8</td><td class="left">'Tiger'</td></tr>
+     <tr><td class="num">  39.8</td><td class="left">'Vlad'</td></tr>
+     <tr><td class="num">  40.8</td><td class="left">'Momcat'</td></tr>
+     <tr><td class="num">  41.3</td><td class="left">'Uli'</td></tr>
+     <tr><td class="num">  42.6</td><td class="left">'Breezy'</td></tr>
+     <tr><td class="num">  43.1</td><td class="left">'Liam Sheehan'</td></tr>
+     <tr><td class="num">  43.3</td><td class="left">'Tarim'</td></tr>
+     <tr><td class="num">  43.8</td><td class="left">'IntKecsk'</td></tr>
+     <tr><td class="num">  44.3</td><td class="left">'Antonio EE'</td></tr>
+     <tr><td class="num">  45.6</td><td class="left">'mhatta'</td></tr>
+     <tr><td class="num">  47.0</td><td class="left">'Zak'</td></tr>
+     <tr><td class="num">  47.6</td><td class="left">'Valkyrie2'</td></tr>
+     <tr><td class="num">  48.0</td><td class="left">'Sandra'</td></tr>
+     <tr><td class="num">  49.1</td><td class="left">'jdcampo'</td></tr>
+     <tr><td class="num">  49.4</td><td class="left">'Jeffrey S'</td></tr>
+     <tr><td class="num">  50.3</td><td class="left">'Vaily'</td></tr>
+     <tr><td class="num">  50.4</td><td class="left">'brynn'</td></tr>
+     <tr><td class="num">  51.6</td><td class="left">'Neophilus'</td></tr>
+     <tr><td class="num">  51.7</td><td class="left">'Turbogurk'</td></tr>
+     <tr><td class="num">  51.9</td><td class="left">'Cyphase'</td></tr>
+     <tr><td class="num">  54.1</td><td class="left">'krazy62'</td></tr>
+     <tr><td class="num">  54.8</td><td class="left">'Adonica'</td></tr>
+     <tr><td class="num">  60.6</td><td class="left">'Asbel'</td></tr>
      <tr><td class="num">  62.1</td><td class="left">'Meeve'</td></tr>
-     <tr><td class="num">  65.0</td><td class="left">'ael'</td></tr>
-     <tr><td class="num">  65.4</td><td class="left">'Samuel'</td></tr>
-     <tr><td class="num">  66.3</td><td class="left">'Alf'</td></tr>
-     <tr><td class="num">  67.7</td><td class="left">'Magnus and Susi'</td></tr>
-     <tr><td class="num">  68.2</td><td class="left">'Mecki'</td></tr>
-     <tr><td class="num">  69.1</td><td class="left">'xmouse'</td></tr>
-     <tr><td class="num">  70.7</td><td class="left">'Joona'</td></tr>
-     <tr><td class="num">  71.1</td><td class="left">'AQZ'</td></tr>
-     <tr><td class="num">  73.1</td><td class="left">'Dvorhagen'</td></tr>
-     <tr><td class="num">  74.2</td><td class="left">'jojo'</td></tr>
-     <tr><td class="num">  74.3</td><td class="left">'AsuCaga'</td></tr>
-     <tr><td class="num">  78.8</td><td class="left">'AkRa'</td></tr>
-     <tr><td class="num">  79.6</td><td class="left">'Agares'</td></tr>
-     <tr><td class="num">  84.4</td><td class="left">'Miel56'</td></tr>
-     <tr><td class="num">  89.6</td><td class="left">'The red O'</td></tr>
+     <tr><td class="num">  65.1</td><td class="left">'ael'</td></tr>
+     <tr><td class="num">  65.5</td><td class="left">'Samuel'</td></tr>
+     <tr><td class="num">  66.4</td><td class="left">'Alf'</td></tr>
+     <tr><td class="num">  67.9</td><td class="left">'Magnus and Susi'</td></tr>
+     <tr><td class="num">  68.4</td><td class="left">'Mecki'</td></tr>
+     <tr><td class="num">  69.2</td><td class="left">'xmouse'</td></tr>
+     <tr><td class="num">  70.9</td><td class="left">'Joona'</td></tr>
+     <tr><td class="num">  71.3</td><td class="left">'AQZ'</td></tr>
+     <tr><td class="num">  73.3</td><td class="left">'Dvorhagen'</td></tr>
+     <tr><td class="num">  74.3</td><td class="left">'jojo'</td></tr>
+     <tr><td class="num">  74.5</td><td class="left">'AsuCaga'</td></tr>
+     <tr><td class="num">  79.0</td><td class="left">'AkRa'</td></tr>
+     <tr><td class="num">  79.7</td><td class="left">'Agares'</td></tr>
+     <tr><td class="num">  84.5</td><td class="left">'Miel56'</td></tr>
+     <tr><td class="num">  89.7</td><td class="left">'The red O'</td></tr>
      <tr><td class="num">  92.1</td><td class="left">'Michael'</td></tr>
   </table>

Modified: homepage/input/table-rat.html
===================================================================
--- homepage/input/table-rat.html	2007-11-27 23:08:19 UTC (rev 929)
+++ homepage/input/table-rat.html	2007-12-01 19:16:02 UTC (rev 930)
@@ -1,50 +1,54 @@
   <table>
-    <caption>$$Rating_Statistics$$ $$October$$ 2007</caption>
+    <caption>$$Rating_Statistics$$ $$November$$ 2007</caption>
     <colgroup><col width="80"><col width="80"><col width="220"></colgroup>
     <tr><th>$$count$$</th><th>$$average$$</th><th class="left">$$user$$</th></tr>    <tr><td class="num">1039</td><td class="num"> 5.03</td><td class="left">'ryujun'</td></tr>
-    <tr><td class="num">1028</td><td class="num"> 4.81</td><td class="left">'Taztunes'</td></tr>
+    <tr><td class="num">1029</td><td class="num"> 4.81</td><td class="left">'Taztunes'</td></tr>
     <tr><td class="num">871</td><td class="num"> 5.09</td><td class="left">'Stupid'</td></tr>
-    <tr><td class="num">838</td><td class="num"> 4.77</td><td class="left">'daydreamer'</td></tr>
+    <tr><td class="num">847</td><td class="num"> 4.78</td><td class="left">'daydreamer'</td></tr>
     <tr><td class="num">653</td><td class="num"> 5.01</td><td class="left">'Duffy'</td></tr>
     <tr><td class="num">625</td><td class="num"> 4.98</td><td class="left">'Moneymaker'</td></tr>
     <tr><td class="num">613</td><td class="num"> 4.20</td><td class="left">'shoki'</td></tr>
+    <tr><td class="num">570</td><td class="num"> 4.74</td><td class="left">'dev0'</td></tr>
     <tr><td class="num">505</td><td class="num"> 5.07</td><td class="left">'dpl'</td></tr>
     <tr><td class="num">496</td><td class="num"> 5.27</td><td class="left">'Lukas'</td></tr>
+    <tr><td class="num">453</td><td class="num"> 5.02</td><td class="left">'Ronald'</td></tr>
     <tr><td class="num">448</td><td class="num"> 5.08</td><td class="left">'Johannes'</td></tr>
     <tr><td class="num">428</td><td class="num"> 4.22</td><td class="left">'Alexandros'</td></tr>
-    <tr><td class="num">425</td><td class="num"> 5.04</td><td class="left">'Ronald'</td></tr>
-    <tr><td class="num">402</td><td class="num"> 4.34</td><td class="left">'ged'</td></tr>
-    <tr><td class="num">351</td><td class="num"> 4.93</td><td class="left">'U-Punkt'</td></tr>
+    <tr><td class="num">424</td><td class="num"> 4.35</td><td class="left">'ged'</td></tr>
+    <tr><td class="num">379</td><td class="num"> 4.93</td><td class="left">'U-Punkt'</td></tr>
     <tr><td class="num">348</td><td class="num"> 4.09</td><td class="left">'Vinksu'</td></tr>
     <tr><td class="num">307</td><td class="num"> 4.01</td><td class="left">'Sim_Ed'</td></tr>
     <tr><td class="num">254</td><td class="num"> 4.91</td><td class="left">'JuSt'</td></tr>
+    <tr><td class="num">226</td><td class="num"> 4.95</td><td class="left">'B-Huff'</td></tr>
     <tr><td class="num">208</td><td class="num"> 6.15</td><td class="left">'Momcat'</td></tr>
-    <tr><td class="num">150</td><td class="num"> 5.05</td><td class="left">'WP319'</td></tr>
+    <tr><td class="num">187</td><td class="num"> 5.05</td><td class="left">'WP319'</td></tr>
+    <tr><td class="num">135</td><td class="num"> 4.13</td><td class="left">'Edgar_Flesk'</td></tr>
     <tr><td class="num">129</td><td class="num"> 5.64</td><td class="left">'Raoul'</td></tr>
+    <tr><td class="num">123</td><td class="num"> 4.38</td><td class="left">'ABS'</td></tr>
     <tr><td class="num"> 99</td><td class="num"> 5.01</td><td class="left">'Tiza'</td></tr>
-    <tr><td class="num"> 96</td><td class="num"> 4.20</td><td class="left">'Safalra'</td></tr>
+    <tr><td class="num"> 97</td><td class="num"> 4.16</td><td class="left">'Safalra'</td></tr>
     <tr><td class="num"> 85</td><td class="num"> 4.76</td><td class="left">'para_doks'</td></tr>
     <tr><td class="num"> 72</td><td class="num"> 5.63</td><td class="left">'Wuzzy'</td></tr>
     <tr><td class="num"> 51</td><td class="num"> 6.39</td><td class="left">'Little_Mole'</td></tr>
     <tr><td class="num"> 50</td><td class="num"> 5.26</td><td class="left">'Daniel'</td></tr>
-    <tr><td class="num"> 45</td><td class="num"> 5.16</td><td class="left">'hendrik'</td></tr>
+    <tr><td class="num"> 49</td><td class="num"> 4.90</td><td class="left">'hendrik'</td></tr>
     <tr><td class="num"> 43</td><td class="num"> 3.74</td><td class="left">'Iceshark7'</td></tr>
     <tr><td class="num"> 30</td><td class="num"> 4.40</td><td class="left">'Archcorenth'</td></tr>
     <tr><td class="num"> 25</td><td class="num"> 4.88</td><td class="left">'Drotten'</td></tr>
-    <tr><td class="num"> 22</td><td class="num"> 5.95</td><td class="left">'mrduke'</td></tr>
+    <tr><td class="num"> 23</td><td class="num"> 6.00</td><td class="left">'mrduke'</td></tr>
     <tr><td class="num"> 17</td><td class="num"> 5.53</td><td class="left">'Jeffrey S'</td></tr>
     <tr><td class="num"> 16</td><td class="num"> 7.63</td><td class="left">'Ghatotkacha'</td></tr>
     <tr><td class="num"> 13</td><td class="num"> 7.69</td><td class="left">'Ale'</td></tr>
     <tr><td class="num"> 13</td><td class="num"> 5.23</td><td class="left">'Samuel'</td></tr>
     <tr><td class="num"> 11</td><td class="num"> 6.36</td><td class="left">'ShadowPhrogg32642342'</td></tr>
     <tr><td class="num"> 10</td><td class="num"> 7.80</td><td class="left">'hdwow'</td></tr>
-    <tr><td class="num"> 10</td><td class="num"> 6.10</td><td class="left">'ABS'</td></tr>
     <tr><td class="num">  8</td><td class="num"> 3.25</td><td class="left">'Vlad'</td></tr>
+    <tr><td class="num">  5</td><td class="num"> 6.80</td><td class="left">'Breezy'</td></tr>
     <tr><td class="num">  5</td><td class="num"> 9.20</td><td class="left">'HuB34'</td></tr>
     <tr><td class="num">  4</td><td class="num"> 6.75</td><td class="left">'Agares'</td></tr>
     <tr><td class="num">  4</td><td class="num">10.00</td><td class="left">'Mark P.'</td></tr>
     <tr><td class="num">  4</td><td class="num"> 5.75</td><td class="left">'joseba'</td></tr>
-    <tr><td class="num">  4</td><td class="num"> 6.25</td><td class="left">'Breezy'</td></tr>
+    <tr><td class="num">  4</td><td class="num"> 6.50</td><td class="left">'serpent'</td></tr>
     <tr><td class="num">  4</td><td class="num"> 7.00</td><td class="left">'redsantz'</td></tr>
     <tr><td class="num">  3</td><td class="num"> 0.67</td><td class="left">'Turbogurk'</td></tr>
     <tr><td class="num">  3</td><td class="num"> 7.67</td><td class="left">'Joona'</td></tr>
@@ -60,4 +64,5 @@
     <tr><td class="num">  1</td><td class="num"> 3.00</td><td class="left">'AkRa'</td></tr>
     <tr><td class="num">  1</td><td class="num"> 6.00</td><td class="left">'Emmanuel'</td></tr>
     <tr><td class="num">  1</td><td class="num"> 4.00</td><td class="left">'jojo'</td></tr>
+    <tr><td class="num">  1</td><td class="num">10.00</td><td class="left">'Antonio EE'</td></tr>
   </table>

Modified: homepage/input/table-solved.html
===================================================================
--- homepage/input/table-solved.html	2007-11-27 23:08:19 UTC (rev 929)
+++ homepage/input/table-solved.html	2007-12-01 19:16:02 UTC (rev 930)
@@ -1,94 +1,100 @@
   <table>
-    <caption>$$Solved_Level_Statistics$$ $$October$$ 2007</caption>
+    <caption>$$Solved_Level_Statistics$$ $$November$$ 2007</caption>
     <colgroup><col width="130"><col width="130"><col width="130"><col width="240"></colgroup>
     <tr><th>$$difficult$$</th><th>$$easy$$</th><th>$$total$$</th><th class="left">$$user$$</th></tr>
-    <tr><td class="num">1042/1045</td><td class="num">189/189</td><td class="num"> 99.76%</td><td class="left">'Taztunes'</td></tr>
+    <tr><td class="num">1043/1045</td><td class="num">189/189</td><td class="num"> 99.84%</td><td class="left">'Taztunes'</td></tr>
     <tr><td class="num">1029/1045</td><td class="num">183/189</td><td class="num"> 98.22%</td><td class="left">'Craven'</td></tr>
     <tr><td class="num">1028/1045</td><td class="num">178/189</td><td class="num"> 97.73%</td><td class="left">'Moneymaker'</td></tr>
     <tr><td class="num">1020/1045</td><td class="num">184/189</td><td class="num"> 97.57%</td><td class="left">'ryujun'</td></tr>
     <tr><td class="num">1014/1045</td><td class="num">175/189</td><td class="num"> 96.35%</td><td class="left">'Stupid'</td></tr>
+    <tr><td class="num">1006/1045</td><td class="num">178/189</td><td class="num"> 95.95%</td><td class="left">'Ronald'</td></tr>
     <tr><td class="num"> 999/1045</td><td class="num">177/189</td><td class="num"> 95.30%</td><td class="left">'biotopa'</td></tr>
-    <tr><td class="num"> 998/1045</td><td class="num">175/189</td><td class="num"> 95.06%</td><td class="left">'Ronald'</td></tr>
+    <tr><td class="num"> 966/1045</td><td class="num">168/189</td><td class="num"> 91.90%</td><td class="left">'daydreamer'</td></tr>
     <tr><td class="num"> 949/1045</td><td class="num">170/189</td><td class="num"> 90.68%</td><td class="left">'para_doks'</td></tr>
-    <tr><td class="num"> 951/1045</td><td class="num">165/189</td><td class="num"> 90.44%</td><td class="left">'daydreamer'</td></tr>
+    <tr><td class="num"> 943/1045</td><td class="num">158/189</td><td class="num"> 89.22%</td><td class="left">'Andy'</td></tr>
     <tr><td class="num"> 933/1045</td><td class="num">125/189</td><td class="num"> 85.74%</td><td class="left">'Alex'</td></tr>
     <tr><td class="num"> 914/1045</td><td class="num">135/189</td><td class="num"> 85.01%</td><td class="left">'JuSt'</td></tr>
     <tr><td class="num"> 894/1045</td><td class="num">140/189</td><td class="num"> 83.79%</td><td class="left">'Johannes'</td></tr>
     <tr><td class="num"> 863/1045</td><td class="num">161/189</td><td class="num"> 82.98%</td><td class="left">'Tobias'</td></tr>
     <tr><td class="num"> 915/1045</td><td class="num">105/189</td><td class="num"> 82.66%</td><td class="left">'Django'</td></tr>
-    <tr><td class="num"> 844/1045</td><td class="num">135/189</td><td class="num"> 79.34%</td><td class="left">'mrduke'</td></tr>
+    <tr><td class="num"> 849/1045</td><td class="num">151/189</td><td class="num"> 81.04%</td><td class="left">'WP319'</td></tr>
+    <tr><td class="num"> 858/1045</td><td class="num">135/189</td><td class="num"> 80.47%</td><td class="left">'mrduke'</td></tr>
     <tr><td class="num"> 874/1045</td><td class="num">103/189</td><td class="num"> 79.17%</td><td class="left">'Melanie'</td></tr>
     <tr><td class="num"> 841/1045</td><td class="num">123/189</td><td class="num"> 78.12%</td><td class="left">'shoki'</td></tr>
     <tr><td class="num"> 841/1045</td><td class="num">114/189</td><td class="num"> 77.39%</td><td class="left">'Lukas'</td></tr>
     <tr><td class="num"> 950/1045</td><td class="num">  0/189</td><td class="num"> 76.99%</td><td class="left">'Tarim'</td></tr>
-    <tr><td class="num"> 805/1045</td><td class="num">142/189</td><td class="num"> 76.74%</td><td class="left">'WP319'</td></tr>
+    <tr><td class="num"> 798/1045</td><td class="num">141/189</td><td class="num"> 76.09%</td><td class="left">'Safalra'</td></tr>
     <tr><td class="num"> 938/1045</td><td class="num">  1/189</td><td class="num"> 76.09%</td><td class="left">'Ale'</td></tr>
-    <tr><td class="num"> 782/1045</td><td class="num">138/189</td><td class="num"> 74.55%</td><td class="left">'Safalra'</td></tr>
     <tr><td class="num"> 762/1045</td><td class="num"> 73/189</td><td class="num"> 67.67%</td><td class="left">'redsantz'</td></tr>
+    <tr><td class="num"> 745/1045</td><td class="num"> 73/189</td><td class="num"> 66.29%</td><td class="left">'brynn'</td></tr>
     <tr><td class="num"> 734/1045</td><td class="num"> 82/189</td><td class="num"> 66.13%</td><td class="left">'bojster'</td></tr>
     <tr><td class="num"> 782/1045</td><td class="num"> 33/189</td><td class="num"> 66.05%</td><td class="left">'Sim_Ed'</td></tr>
-    <tr><td class="num"> 702/1045</td><td class="num"> 84/189</td><td class="num"> 63.70%</td><td class="left">'U-Punkt'</td></tr>
-    <tr><td class="num"> 714/1045</td><td class="num"> 68/189</td><td class="num"> 63.37%</td><td class="left">'Andy'</td></tr>
-    <tr><td class="num"> 743/1045</td><td class="num"> 32/189</td><td class="num"> 62.80%</td><td class="left">'alfred69'</td></tr>
+    <tr><td class="num"> 694/1045</td><td class="num">113/189</td><td class="num"> 65.40%</td><td class="left">'Gorn'</td></tr>
+    <tr><td class="num"> 716/1045</td><td class="num"> 90/189</td><td class="num"> 65.32%</td><td class="left">'U-Punkt'</td></tr>
+    <tr><td class="num"> 766/1045</td><td class="num"> 37/189</td><td class="num"> 65.07%</td><td class="left">'alfred69'</td></tr>
+    <tr><td class="num"> 675/1045</td><td class="num">126/189</td><td class="num"> 64.91%</td><td class="left">'ABS'</td></tr>
     <tr><td class="num"> 681/1045</td><td class="num"> 78/189</td><td class="num"> 61.51%</td><td class="left">'HuB34'</td></tr>
     <tr><td class="num"> 659/1045</td><td class="num"> 95/189</td><td class="num"> 61.10%</td><td class="left">'Marc-Hendrik'</td></tr>
-    <tr><td class="num"> 640/1045</td><td class="num">112/189</td><td class="num"> 60.94%</td><td class="left">'ABS'</td></tr>
-    <tr><td class="num"> 742/1045</td><td class="num">  4/189</td><td class="num"> 60.45%</td><td class="left">'brynn'</td></tr>
     <tr><td class="num"> 633/1045</td><td class="num">110/189</td><td class="num"> 60.21%</td><td class="left">'Raoul'</td></tr>
     <tr><td class="num"> 643/1045</td><td class="num"> 83/189</td><td class="num"> 58.83%</td><td class="left">'Great Scott'</td></tr>
     <tr><td class="num"> 714/1045</td><td class="num">  0/189</td><td class="num"> 57.86%</td><td class="left">'Gottseinsohn'</td></tr>
+    <tr><td class="num"> 605/1045</td><td class="num">106/189</td><td class="num"> 57.62%</td><td class="left">'dev0'</td></tr>
     <tr><td class="num"> 625/1045</td><td class="num"> 82/189</td><td class="num"> 57.29%</td><td class="left">'dpl'</td></tr>
     <tr><td class="num"> 636/1045</td><td class="num"> 55/189</td><td class="num"> 56.00%</td><td class="left">'fabian'</td></tr>
     <tr><td class="num"> 588/1045</td><td class="num"> 93/189</td><td class="num"> 55.19%</td><td class="left">'Ghatotkacha'</td></tr>
+    <tr><td class="num"> 599/1045</td><td class="num"> 80/189</td><td class="num"> 55.02%</td><td class="left">'serpent'</td></tr>
     <tr><td class="num"> 634/1045</td><td class="num"> 43/189</td><td class="num"> 54.86%</td><td class="left">'Klaus'</td></tr>
     <tr><td class="num"> 559/1045</td><td class="num">111/189</td><td class="num"> 54.29%</td><td class="left">'Mark P.'</td></tr>
     <tr><td class="num"> 576/1045</td><td class="num"> 93/189</td><td class="num"> 54.21%</td><td class="left">'Guglielmo'</td></tr>
-    <tr><td class="num"> 668/1045</td><td class="num">  0/189</td><td class="num"> 54.13%</td><td class="left">'Gorn'</td></tr>
+    <tr><td class="num"> 596/1045</td><td class="num"> 60/189</td><td class="num"> 53.16%</td><td class="left">'Breezy'</td></tr>
     <tr><td class="num"> 570/1045</td><td class="num"> 83/189</td><td class="num"> 52.92%</td><td class="left">'Ludmian'</td></tr>
     <tr><td class="num"> 537/1045</td><td class="num">113/189</td><td class="num"> 52.67%</td><td class="left">'Alexandros'</td></tr>
-    <tr><td class="num"> 579/1045</td><td class="num"> 56/189</td><td class="num"> 51.46%</td><td class="left">'Breezy'</td></tr>
     <tr><td class="num"> 525/1045</td><td class="num"> 95/189</td><td class="num"> 50.24%</td><td class="left">'ShadowPhrogg32642342'</td></tr>
     <tr><td class="num"> 589/1045</td><td class="num"> 26/189</td><td class="num"> 49.84%</td><td class="left">'hdwow'</td></tr>
     <tr><td class="num"> 533/1045</td><td class="num"> 82/189</td><td class="num"> 49.84%</td><td class="left">'Wuzzy'</td></tr>
     <tr><td class="num"> 506/1045</td><td class="num">108/189</td><td class="num"> 49.76%</td><td class="left">'Agnieszka'</td></tr>
     <tr><td class="num"> 613/1045</td><td class="num">  0/189</td><td class="num"> 49.68%</td><td class="left">'Little_Mole'</td></tr>
+    <tr><td class="num"> 498/1045</td><td class="num"> 93/189</td><td class="num"> 47.89%</td><td class="left">'B-Huff'</td></tr>
     <tr><td class="num"> 519/1045</td><td class="num"> 37/189</td><td class="num"> 45.06%</td><td class="left">'Valkyrie2'</td></tr>
     <tr><td class="num"> 516/1045</td><td class="num"> 24/189</td><td class="num"> 43.76%</td><td class="left">'niebie'</td></tr>
     <tr><td class="num"> 494/1045</td><td class="num"> 26/189</td><td class="num"> 42.14%</td><td class="left">'Daniel'</td></tr>
     <tr><td class="num"> 504/1045</td><td class="num"> 12/189</td><td class="num"> 41.82%</td><td class="left">'Duffy'</td></tr>
-    <tr><td class="num"> 495/1045</td><td class="num">  0/189</td><td class="num"> 40.11%</td><td class="left">'Edgar_Flesk'</td></tr>
-    <tr><td class="num"> 415/1045</td><td class="num"> 38/189</td><td class="num"> 36.71%</td><td class="left">'ged'</td></tr>
+    <tr><td class="num"> 503/1045</td><td class="num">  7/189</td><td class="num"> 41.33%</td><td class="left">'Edgar_Flesk'</td></tr>
+    <tr><td class="num"> 433/1045</td><td class="num"> 45/189</td><td class="num"> 38.74%</td><td class="left">'ged'</td></tr>
     <tr><td class="num"> 391/1045</td><td class="num"> 54/189</td><td class="num"> 36.06%</td><td class="left">'Tiza'</td></tr>
     <tr><td class="num"> 439/1045</td><td class="num">  6/189</td><td class="num"> 36.06%</td><td class="left">'Vinksu'</td></tr>
+    <tr><td class="num"> 392/1045</td><td class="num"> 40/189</td><td class="num"> 35.01%</td><td class="left">'hendrik'</td></tr>
     <tr><td class="num"> 391/1045</td><td class="num"> 36/189</td><td class="num"> 34.60%</td><td class="left">'Iceshark7'</td></tr>
     <tr><td class="num"> 397/1045</td><td class="num"> 24/189</td><td class="num"> 34.12%</td><td class="left">'Chocolate Zero'</td></tr>
     <tr><td class="num"> 376/1045</td><td class="num"> 35/189</td><td class="num"> 33.31%</td><td class="left">'Jeffrey S'</td></tr>
     <tr><td class="num"> 392/1045</td><td class="num"> 12/189</td><td class="num"> 32.74%</td><td class="left">'NorthForty'</td></tr>
     <tr><td class="num"> 344/1045</td><td class="num"> 51/189</td><td class="num"> 32.01%</td><td class="left">'Momcat'</td></tr>
     <tr><td class="num"> 382/1045</td><td class="num"> 10/189</td><td class="num"> 31.77%</td><td class="left">'J3FF'</td></tr>
+    <tr><td class="num"> 335/1045</td><td class="num"> 50/189</td><td class="num"> 31.20%</td><td class="left">'Harry Lim'</td></tr>
     <tr><td class="num"> 346/1045</td><td class="num"> 38/189</td><td class="num"> 31.12%</td><td class="left">'Liam Sheehan'</td></tr>
     <tr><td class="num"> 332/1045</td><td class="num"> 48/189</td><td class="num"> 30.79%</td><td class="left">'Zekobah'</td></tr>
     <tr><td class="num"> 361/1045</td><td class="num"> 18/189</td><td class="num"> 30.71%</td><td class="left">'MicWa'</td></tr>
     <tr><td class="num"> 306/1045</td><td class="num"> 71/189</td><td class="num"> 30.55%</td><td class="left">'Davacardo'</td></tr>
+    <tr><td class="num"> 336/1045</td><td class="num"> 41/189</td><td class="num"> 30.55%</td><td class="left">'Antonio EE'</td></tr>
     <tr><td class="num"> 370/1045</td><td class="num">  7/189</td><td class="num"> 30.55%</td><td class="left">'IChrisI'</td></tr>
     <tr><td class="num"> 350/1045</td><td class="num"> 25/189</td><td class="num"> 30.39%</td><td class="left">'IntKecsk'</td></tr>
-    <tr><td class="num"> 325/1045</td><td class="num"> 33/189</td><td class="num"> 29.01%</td><td class="left">'hendrik'</td></tr>
     <tr><td class="num"> 331/1045</td><td class="num"> 14/189</td><td class="num"> 27.96%</td><td class="left">'Archcorenth'</td></tr>
     <tr><td class="num"> 281/1045</td><td class="num"> 63/189</td><td class="num"> 27.88%</td><td class="left">'erich'</td></tr>
     <tr><td class="num"> 295/1045</td><td class="num"> 29/189</td><td class="num"> 26.26%</td><td class="left">'Tiger'</td></tr>
     <tr><td class="num"> 288/1045</td><td class="num"> 36/189</td><td class="num"> 26.26%</td><td class="left">'Drotten'</td></tr>
     <tr><td class="num"> 252/1045</td><td class="num"> 63/189</td><td class="num"> 25.53%</td><td class="left">'Emmanuel'</td></tr>
     <tr><td class="num"> 261/1045</td><td class="num"> 53/189</td><td class="num"> 25.45%</td><td class="left">'Andreas'</td></tr>
+    <tr><td class="num"> 287/1045</td><td class="num"> 18/189</td><td class="num"> 24.72%</td><td class="left">'Nfol'</td></tr>
     <tr><td class="num"> 276/1045</td><td class="num"> 15/189</td><td class="num"> 23.58%</td><td class="left">'Thomas'</td></tr>
-    <tr><td class="num"> 273/1045</td><td class="num"> 15/189</td><td class="num"> 23.34%</td><td class="left">'Nfol'</td></tr>
     <tr><td class="num"> 245/1045</td><td class="num"> 36/189</td><td class="num"> 22.77%</td><td class="left">'B-man'</td></tr>
+    <tr><td class="num"> 259/1045</td><td class="num">  7/189</td><td class="num"> 21.56%</td><td class="left">'geembo_90'</td></tr>
     <tr><td class="num"> 201/1045</td><td class="num"> 54/189</td><td class="num"> 20.66%</td><td class="left">'mhatta'</td></tr>
-    <tr><td class="num"> 209/1045</td><td class="num"> 44/189</td><td class="num"> 20.50%</td><td class="left">'Harry Lim'</td></tr>
     <tr><td class="num"> 210/1045</td><td class="num"> 38/189</td><td class="num"> 20.10%</td><td class="left">'Sandra'</td></tr>
     <tr><td class="num"> 208/1045</td><td class="num"> 33/189</td><td class="num"> 19.53%</td><td class="left">'Uli'</td></tr>
     <tr><td class="num"> 214/1045</td><td class="num"> 19/189</td><td class="num"> 18.88%</td><td class="left">'Adonica'</td></tr>
     <tr><td class="num"> 206/1045</td><td class="num">  4/189</td><td class="num"> 17.02%</td><td class="left">'krazy62'</td></tr>
     <tr><td class="num"> 181/1045</td><td class="num"> 20/189</td><td class="num"> 16.29%</td><td class="left">'Vaily'</td></tr>
+    <tr><td class="num"> 156/1045</td><td class="num"> 24/189</td><td class="num"> 14.59%</td><td class="left">'jdcampo'</td></tr>
     <tr><td class="num"> 125/1045</td><td class="num"> 55/189</td><td class="num"> 14.59%</td><td class="left">'Vlad'</td></tr>
     <tr><td class="num"> 149/1045</td><td class="num"> 30/189</td><td class="num"> 14.51%</td><td class="left">'Chris'</td></tr>
     <tr><td class="num"> 158/1045</td><td class="num"> 20/189</td><td class="num"> 14.42%</td><td class="left">'Turbogurk'</td></tr>

Modified: homepage/input/table-wr.html
===================================================================
--- homepage/input/table-wr.html	2007-11-27 23:08:19 UTC (rev 929)
+++ homepage/input/table-wr.html	2007-12-01 19:16:02 UTC (rev 930)
@@ -1,49 +1,52 @@
   <table>
-    <caption>$$Worldrecord_Statistics$$ $$October$$ 2007</caption>
+    <caption>$$Worldrecord_Statistics$$ $$November$$ 2007</caption>
     <colgroup><col width="80"><col width="80"><col width="470"></colgroup>
     <tr><th>$$total$$</th><th>$$shared$$</th><th class="left">$$user$$</th></tr>
-    <tr><td class="num">825</td><td class="num">246</td><td class="left">'Moneymaker'</td></tr>
-    <tr><td class="num">245</td><td class="num">120</td><td class="left">'Stupid'</td></tr>
-    <tr><td class="num">173</td><td class="num">136</td><td class="left">'Johannes'</td></tr>
-    <tr><td class="num"> 94</td><td class="num"> 51</td><td class="left">'Duffy'</td></tr>
-    <tr><td class="num"> 76</td><td class="num"> 60</td><td class="left">'Great Scott'</td></tr>
-    <tr><td class="num"> 53</td><td class="num"> 44</td><td class="left">'daydreamer'</td></tr>
-    <tr><td class="num"> 43</td><td class="num"> 37</td><td class="left">'Django'</td></tr>
-    <tr><td class="num"> 40</td><td class="num"> 33</td><td class="left">'Iceshark7'</td></tr>
-    <tr><td class="num"> 39</td><td class="num"> 34</td><td class="left">'joseba'</td></tr>
-    <tr><td class="num"> 34</td><td class="num"> 26</td><td class="left">'Alexandros'</td></tr>
-    <tr><td class="num"> 30</td><td class="num"> 26</td><td class="left">'Ghatotkacha'</td></tr>
-    <tr><td class="num"> 25</td><td class="num"> 20</td><td class="left">'Ludmian'</td></tr>
-    <tr><td class="num"> 24</td><td class="num">  8</td><td class="left">'Ronald'</td></tr>
-    <tr><td class="num"> 23</td><td class="num"> 14</td><td class="left">'Zekobah'</td></tr>
-    <tr><td class="num"> 21</td><td class="num"> 18</td><td class="left">'Safalra'</td></tr>
+    <tr><td class="num">823</td><td class="num">254</td><td class="left">'Moneymaker'</td></tr>
+    <tr><td class="num">243</td><td class="num">119</td><td class="left">'Stupid'</td></tr>
+    <tr><td class="num">168</td><td class="num">133</td><td class="left">'Johannes'</td></tr>
+    <tr><td class="num"> 91</td><td class="num"> 51</td><td class="left">'Duffy'</td></tr>
+    <tr><td class="num"> 87</td><td class="num"> 67</td><td class="left">'daydreamer'</td></tr>
+    <tr><td class="num"> 74</td><td class="num"> 58</td><td class="left">'Great Scott'</td></tr>
+    <tr><td class="num"> 42</td><td class="num"> 36</td><td class="left">'Django'</td></tr>
+    <tr><td class="num"> 37</td><td class="num"> 31</td><td class="left">'Iceshark7'</td></tr>
+    <tr><td class="num"> 36</td><td class="num"> 33</td><td class="left">'joseba'</td></tr>
+    <tr><td class="num"> 33</td><td class="num"> 26</td><td class="left">'Alexandros'</td></tr>
+    <tr><td class="num"> 29</td><td class="num"> 26</td><td class="left">'Ghatotkacha'</td></tr>
+    <tr><td class="num"> 24</td><td class="num">  9</td><td class="left">'Ronald'</td></tr>
+    <tr><td class="num"> 24</td><td class="num"> 19</td><td class="left">'Ludmian'</td></tr>
+    <tr><td class="num"> 24</td><td class="num"> 20</td><td class="left">'ged'</td></tr>
+    <tr><td class="num"> 23</td><td class="num"> 20</td><td class="left">'Safalra'</td></tr>
+    <tr><td class="num"> 22</td><td class="num"> 14</td><td class="left">'Zekobah'</td></tr>
     <tr><td class="num"> 20</td><td class="num"> 18</td><td class="left">'bojster'</td></tr>
-    <tr><td class="num"> 19</td><td class="num">  3</td><td class="left">'ryujun'</td></tr>
+    <tr><td class="num"> 18</td><td class="num">  5</td><td class="left">'ryujun'</td></tr>
     <tr><td class="num"> 18</td><td class="num"> 12</td><td class="left">'HuB34'</td></tr>
-    <tr><td class="num"> 18</td><td class="num"> 16</td><td class="left">'ged'</td></tr>
-    <tr><td class="num"> 15</td><td class="num"> 10</td><td class="left">'Chocolate Zero'</td></tr>
+    <tr><td class="num"> 14</td><td class="num">  9</td><td class="left">'Chocolate Zero'</td></tr>
+    <tr><td class="num"> 10</td><td class="num">  4</td><td class="left">'Taztunes'</td></tr>
     <tr><td class="num"> 10</td><td class="num">  5</td><td class="left">'ShadowPhrogg32642342'</td></tr>
+    <tr><td class="num"> 10</td><td class="num">  7</td><td class="left">'B-Huff'</td></tr>
+    <tr><td class="num"> 10</td><td class="num">  9</td><td class="left">'ABS'</td></tr>
     <tr><td class="num"> 10</td><td class="num"> 10</td><td class="left">'fabian'</td></tr>
-    <tr><td class="num">  9</td><td class="num">  6</td><td class="left">'dpl'</td></tr>
-    <tr><td class="num">  8</td><td class="num">  3</td><td class="left">'Taztunes'</td></tr>
-    <tr><td class="num">  8</td><td class="num">  5</td><td class="left">'Lukas'</td></tr>
+    <tr><td class="num">  9</td><td class="num">  7</td><td class="left">'dpl'</td></tr>
+    <tr><td class="num">  8</td><td class="num">  3</td><td class="left">'Breezy'</td></tr>
     <tr><td class="num">  8</td><td class="num">  7</td><td class="left">'Wuzzy'</td></tr>
-    <tr><td class="num">  7</td><td class="num">  3</td><td class="left">'Breezy'</td></tr>
-    <tr><td class="num">  6</td><td class="num">  3</td><td class="left">'para_doks' + 'Craven'</td></tr>
+    <tr><td class="num">  7</td><td class="num">  5</td><td class="left">'Lukas'</td></tr>
+    <tr><td class="num">  7</td><td class="num">  6</td><td class="left">'Edgar_Flesk'</td></tr>
+    <tr><td class="num">  6</td><td class="num">  3</td><td class="left">'para_doks'</td></tr>
     <tr><td class="num">  6</td><td class="num">  4</td><td class="left">'Raoul'</td></tr>
     <tr><td class="num">  6</td><td class="num">  5</td><td class="left">'Guglielmo'</td></tr>
     <tr><td class="num">  6</td><td class="num">  6</td><td class="left">'Tobias'</td></tr>
-    <tr><td class="num">  5</td><td class="num">  2</td><td class="left">'Bent'</td></tr>
+    <tr><td class="num">  5</td><td class="num">  2</td><td class="left">'Craven'</td></tr>
     <tr><td class="num">  5</td><td class="num">  5</td><td class="left">'Cyphase' + 'Emmanuel' + 'Thomas' + 'Chris' + 'Ralf'</td></tr>
+    <tr><td class="num">  4</td><td class="num">  2</td><td class="left">'Bent'</td></tr>
     <tr><td class="num">  4</td><td class="num">  4</td><td class="left">'J3FF'</td></tr>
-    <tr><td class="num">  3</td><td class="num">  0</td><td class="left">'Daniel'</td></tr>
     <tr><td class="num">  3</td><td class="num">  1</td><td class="left">'shoki'</td></tr>
     <tr><td class="num">  3</td><td class="num">  2</td><td class="left">'hendrik' + 'Stephanie'</td></tr>
-    <tr><td class="num">  3</td><td class="num">  3</td><td class="left">'Neophilus' + 'ABS'</td></tr>
-    <tr><td class="num">  2</td><td class="num">  0</td><td class="left">'Ale'</td></tr>
-    <tr><td class="num">  2</td><td class="num">  1</td><td class="left">'mrduke' + 'Edgar_Flesk' + 'Vlad' + 'JuSt'</td></tr>
-    <tr><td class="num">  2</td><td class="num">  2</td><td class="left">'Drotten' + 'Sim_Ed' + 'Ingo'</td></tr>
-    <tr><td class="num">  1</td><td class="num">  0</td><td class="left">'biotopa' + 'U-Punkt' + 'Alex' + 'krazy62' + 'Gorn' + 'Ant' + 'Melanie' + 'IChrisI' + 'Nat'</td></tr>
-    <tr><td class="num">  1</td><td class="num">  1</td><td class="left">'alfred69' + 'Agares' + 'Tiger' + 'Zak' + 'Tiza' + 'niebie' + 'Andreas' + 'Samuel' + 'Mark P.' + 'hdwow' + 'B-man' + 'Asbel' + 'Vaily' + 'Meeve'</td></tr>
-    <tr><td class="num">  0</td><td class="num">  0</td><td class="left">'AQZ' + 'Miel56' + 'Alf' + 'Turbogurk' + 'Gottseinsohn' + 'Mecki' + 'ael' + 'brynn' + 'IntKecsk' + 'Davacardo' + 'Adonica' + 'Joona' + 'Sandra' + 'Magnus and Susi' + 'WP319' + 'xmouse' + 'erich' + 'Vinksu' + 'Uli' + 'Little_Mole' + 'Harry Lim' + 'AkRa' + 'Momcat' + 'Andy' + 'NorthForty' + 'The red O' + 'Jeffrey S' + 'Nfol' + 'Marc-Hendrik' + 'jojo' + 'Klaus' + 'Valkyrie2' + 'MicWa' + 'AsuCaga' + 'Rugby4ever' + 'Archcorenth' + 'mhatta' + 'Dvorhagen' + 'Holger' + 'Ingo_K' + 'redsantz' + 'Markus' + 'Liam Sheehan' + 'Michael' + 'Tarim' + 'Agnieszka'</td></tr>
+    <tr><td class="num">  3</td><td class="num">  3</td><td class="left">'geembo_90' + 'Neophilus'</td></tr>
+    <tr><td class="num">  2</td><td class="num">  0</td><td class="left">'Ale' + 'Daniel'</td></tr>
+    <tr><td class="num">  2</td><td class="num">  1</td><td class="left">'mrduke' + 'U-Punkt' + 'Vlad' + 'JuSt'</td></tr>
+    <tr><td class="num">  2</td><td class="num">  2</td><td class="left">'Drotten' + 'Sim_Ed' + 'Ingo' + 'serpent'</td></tr>
+    <tr><td class="num">  1</td><td class="num">  0</td><td class="left">'biotopa' + 'Alex' + 'Gorn' + 'Ant' + 'Melanie' + 'IChrisI' + 'Nat'</td></tr>
+    <tr><td class="num">  1</td><td class="num">  1</td><td class="left">'alfred69' + 'Agares' + 'Tiger' + 'Zak' + 'Tiza' + 'niebie' + 'Andreas' + 'Samuel' + 'Mark P.' + 'jdcampo' + 'hdwow' + 'B-man' + 'Asbel' + 'Vaily' + 'Meeve' + 'krazy62'</td></tr>
+    <tr><td class="num">  0</td><td class="num">  0</td><td class="left">'AQZ' + 'Miel56' + 'Alf' + 'Turbogurk' + 'Gottseinsohn' + 'Mecki' + 'ael' + 'brynn' + 'IntKecsk' + 'Davacardo' + 'Adonica' + 'Joona' + 'Sandra' + 'Magnus and Susi' + 'WP319' + 'dev0' + 'xmouse' + 'erich' + 'Vinksu' + 'Uli' + 'Little_Mole' + 'Harry Lim' + 'AkRa' + 'Momcat' + 'Andy' + 'NorthForty' + 'The red O' + 'Jeffrey S' + 'Nfol' + 'Marc-Hendrik' + 'jojo' + 'Klaus' + 'Valkyrie2' + 'MicWa' + 'AsuCaga' + 'Rugby4ever' + 'Archcorenth' + 'mhatta' + 'Dvorhagen' + 'Antonio EE' + 'Holger' + 'Ingo_K' + 'redsantz' + 'Markus' + 'Liam Sheehan' + 'Michael' + 'Tarim' + 'Agnieszka'</td></tr>
   </table>

Modified: homepage/input/userlist.html
===================================================================
--- homepage/input/userlist.html	2007-11-27 23:08:19 UTC (rev 929)
+++ homepage/input/userlist.html	2007-12-01 19:16:02 UTC (rev 930)
@@ -15,11 +15,13 @@
     <li>Andreas</li>
     <li>Andy</li>
     <li>Ant</li>
+    <li>Antonio EE</li>
     <li>AQZ</li>
     <li>Archcorenth</li>
     <li>Asbel</li>
     <li>AsuCaga</li>
     <li>Bent</li>
+    <li>B-Huff</li>
     <li>biotopa</li>
     <li>B-man</li>
     <li>bojster</li>
@@ -32,6 +34,7 @@
     <li>Daniel</li>
     <li>Davacardo</li>
     <li>daydreamer</li>
+    <li>dev0</li>
     <li>Django</li>
     <li>dpl</li>
     <li>Drotten</li>
@@ -42,6 +45,7 @@
     <li>erich</li>
     <li>fabian</li>
     <li>ged</li>
+    <li>geembo_90</li>
     <li>Ghatotkacha</li>
     <li>Gorn</li>
     <li>Gottseinsohn</li>
@@ -58,6 +62,7 @@
     <li>Ingo_K</li>
     <li>IntKecsk</li>
     <li>J3FF</li>
+    <li>jdcampo</li>
     <li>Jeffrey S</li>
     <li>Johannes</li>
     <li>jojo</li>
@@ -99,6 +104,7 @@
     <li>Safalra</li>
     <li>Samuel</li>
     <li>Sandra</li>
+    <li>serpent</li>
     <li>ShadowPhrogg32642342</li>
     <li>shoki</li>
     <li>Sim_Ed</li>



From ral at mail.berlios.de  Mon Dec  3 22:59:23 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Mon, 3 Dec 2007 22:59:23 +0100
Subject: [Enigma-game-svn] r931 - in trunk: data src src/gui src/lev
Message-ID: <200712032159.lB3LxNoa006137@sheep.berlios.de>

Author: ral
Date: 2007-12-03 22:59:21 +0100 (Mon, 03 Dec 2007)
New Revision: 931

Modified:
   trunk/data/init.lua
   trunk/src/d_models.cc
   trunk/src/display.cc
   trunk/src/enigma.cc
   trunk/src/enigma.hh
   trunk/src/floors.cc
   trunk/src/gui/GameMenu.cc
   trunk/src/items.cc
   trunk/src/lev/ScoreManager.cc
   trunk/src/lua.cc
   trunk/src/main.cc
   trunk/src/server.cc
   trunk/src/server.hh
   trunk/src/stones_simple.cc
   trunk/src/video.cc
Log:
Trunk 1.1: reengineering of random functions
- replace all access to OS dependent random functions
- implementation of fast 31 bit BSD rand function for all OS
- managment of 2 seeds for level logic and other "system" random needs
- replace LUA random function by a compatible function that is based
  on Enimgas internal random algorithm.


Modified: trunk/data/init.lua
===================================================================
--- trunk/data/init.lua	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/data/init.lua	2007-12-03 21:59:21 UTC (rev 931)
@@ -17,6 +17,19 @@
 --
 ------------------------------------------------------------------------
 
+-----------------------------------------------
+-- Use Enigma internal random implementation --
+-----------------------------------------------
+
+if type(en) == "table" then
+    math.random = en.random
+else
+    math.random = enigma.random
+end
+random = math.random
+-- randseed is issued by Enigma application and must not be disturbed
+math.randomseed = function () end
+
 -------------------------------
 -- Compatibility for old API --
 -------------------------------
@@ -95,8 +108,6 @@
     enigma.LoadLib(string.sub(filename,8,string.len(filename)-4))
 end
 
--- randseed is issued by Enigma application and must not be disturbed
-math.randomseed = function () end
 
 ----------------------------------
 -- Routines for creating levels --

Modified: trunk/src/d_models.cc
===================================================================
--- trunk/src/d_models.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/d_models.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -498,11 +498,11 @@
 
 Model * RandomModel::clone() {
     if (!modelnames.empty()) {
-	int r = enigma::IntegerRand(0, modelnames.size()-1);
-	return MakeModel(modelnames[r]);
+        int r = enigma::IntegerRand(0, modelnames.size()-1, false);
+        return MakeModel(modelnames[r]);
     } else {
-	fprintf(stderr, "display_2d.cc: empty RandomModel\n");
-	return 0;
+        fprintf(stderr, "display_2d.cc: empty RandomModel\n");
+        return 0;
     }
 }
 

Modified: trunk/src/display.cc
===================================================================
--- trunk/src/display.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/display.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -667,7 +667,7 @@
 {
     Rect videoarea;
     if (m->has_changed(videoarea)) {
-        int delay = immediately ? 0 : enigma::IntegerRand (0, 2);
+        int delay = immediately ? 0 : enigma::IntegerRand (0, 2, false);
         WorldArea wa;
         get_engine()->video_to_world (videoarea, wa);
         get_engine()->mark_redraw_area(wa, delay);

Modified: trunk/src/enigma.cc
===================================================================
--- trunk/src/enigma.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/enigma.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -23,6 +23,7 @@
 #include "ecl.hh"
 #include "main.hh"
 #include "objects.hh"
+#include "server.hh"
 #include "world.hh"
 
 #include <iostream>
@@ -495,25 +496,42 @@
 
 /* -------------------- Random numbers -------------------- */
 
-void  Randomize ()
-{
-    srand (time(NULL));
+int32_t  SystemRandomState;
+
+void Randomize(bool isLevel) {
+    time_t seed = time(NULL) & 0x7fffffff;
+    Randomize(seed, isLevel);
 }
 
-void  Randomize (unsigned seed)
-{
-    srand (seed);
+void Randomize(unsigned seed, bool isLevel) {
+    if (isLevel) {
+        server::RandomState = seed;
+    } else {
+        srand (seed);
+        SystemRandomState =  seed;
+    }
 }
 
-int   IntegerRand (int min, int max)
-{
-    int r = round_down<int>((max-min+1) * (rand()/(RAND_MAX+1.0)));
+int Rand(bool isLevel) {
+    int32_t rand = isLevel ? server::RandomState : SystemRandomState;
+    // This is the 31 bit BSD rand generator. Its sequence is  x_{n+1} = (a x_n + c) mod m
+    // with a = 1103515245, c = 12345 and m = 2^31. The seed specifies the initial value, x_1. 
+    // The period of this generator is 2^31, and it uses 1 word of storage per generator. 
+    rand = ((rand * 1103515245) + 12345) & 0x7fffffff;
+    if (isLevel)
+        server::RandomState = rand;
+    else
+        SystemRandomState = rand;
+    return rand;
+}
+
+int IntegerRand(int min, int max, bool isLevel) {
+    int r = round_down<int>((max-min+1) * (Rand(isLevel)/(ENIGMA_RAND_MAX+1.0)));  // 1.0 converts to double to avoid int overflow!
     return r+min;
 }
 
-double DoubleRand (double min, double max)
-{
-    return min + double(rand())/RAND_MAX * (max-min);
+double DoubleRand(double min, double max, bool isLevel) {
+    return min + double(Rand(isLevel))/ENIGMA_RAND_MAX * (max-min);
 }
 
 

Modified: trunk/src/enigma.hh
===================================================================
--- trunk/src/enigma.hh	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/enigma.hh	2007-12-03 21:59:21 UTC (rev 931)
@@ -33,6 +33,7 @@
 #include "ecl_util.hh"
 #include "ecl_cache.hh"
 #include <list>
+#include <stdint.h>
 
 #define NUMENTRIES(array) (sizeof(array)/sizeof(*array))
 
@@ -408,11 +409,66 @@
 
 /* -------------------- Random Numbers -------------------- */
 
-    void   Randomize ();
-    void   Randomize (unsigned seed);
-    int    IntegerRand (int min, int max);
-    double DoubleRand (double min, double max);
+/**
+ * Maximum random number 2^16-1 that is valid for all operating systems
+ * and processor types. 
+ */
+#define ENIGMA_RAND_MAX  2147483647
 
+    extern int32_t  SystemRandomState;   ///< the internal seed used for system demands
+    
+    /**
+     * Initialization of the random generator by a random seed.
+     * @arg isLevel   random seed for the calculation of the level itself
+     */
+    void   Randomize(bool isLevel = true);
+    
+    /**
+     * Initialization of the random generator by a given seed. This function
+     * allows a reset of the level random sequence for replay of a level or
+     * calculation of parallel worlds.
+     * @arg isLevel   random seed for the calculation of the level itself
+     */
+    void   Randomize(unsigned seed, bool isLevel = true);
+    
+    /**
+     * Centralized mandatory random function that substitutes any operating
+     * system dependent std::rand() implementation. Enigma needs random
+     * number sequences that are repeatable and identical on all computers
+     * without any special demands on the distribution. This is a fast
+     * implementation of the classical BSD rand function that generates 31 bit
+     * integer random numbers with the number itself being the seed for the
+     * next number. All random functions take a bool argument, that seperates
+     * random requests based on commmon system demands from those based on
+     * the calculation of the level. The related seed for the level random
+     * requests is kept as part of the level thus allowing parallel calculations
+     * of different worlds in different threads. All random numbers, even those
+     * generated in the Lua random functions need to be based on this central function.
+     * @arg isLevel   random request for the calculation of the level itself
+     * @return        random integer in the range 0 - ENIGMA_RAND_MAX
+     */
+    int    Rand(bool isLevel = true);
+    
+    /**
+     * Random integer number that is guaranteed to be in the range [min, max]. See
+     * Rand() for details.
+     * @arg  min      lower included boundary of number range
+     * @arg  max      upper included boundary of number range
+     * @arg  isLevel  random request for the calculation of the level itself
+     * @return        random integer in the range [min, max]
+     */
+    int    IntegerRand(int min, int max, bool isLevel = true);
+    
+    /**
+     * Random integer number that is guaranteed to be in the range [min, max]. See
+     * Rand() for details.
+     * @arg  min      lower included boundary of number range
+     * @arg  max      upper included boundary of number range
+     * @arg  isLevel  random request for the calculation of the level itself
+     * @return        random integer in the range [min, max] 
+     */
+    double DoubleRand(double min, double max, bool isLevel = true);
+
 /* -------------------- Time & Date -------------------- */
 
     const char *date(const char *format); // format see 'man strftime'

Modified: trunk/src/floors.cc
===================================================================
--- trunk/src/floors.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/floors.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -878,9 +878,7 @@
 string Thief::get_modelname() {
     if(modelname == "") {
         // initialize on first call
-        int r = IntegerRand(1,4);
-        modelname = string("fl-thief")
-            + ((string) (r==1?"1":r==2?"2":r==3?"3":"4"));
+        modelname = ecl::strf("fl-thief%d", IntegerRand(1, 4));
     }
     return modelname;
 }

Modified: trunk/src/gui/GameMenu.cc
===================================================================
--- trunk/src/gui/GameMenu.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/gui/GameMenu.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -79,8 +79,8 @@
             // randomly choose ball offset
             int x, y;
             for (int trials = 5; trials; --trials) {
-                x = IntegerRand(0, 5);
-                y = IntegerRand(0, 3);
+                x = IntegerRand(0, 5, false);
+                y = IntegerRand(0, 3, false);
     
                 // try to avoid menu-ball overlap:
                 if (x<2 || x>3 || y<1 || y>2 || (trials == 1)) {

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/items.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -2497,8 +2497,7 @@
 void Burnable::init_model() {
     if(state == OIL) {
         string mymodel = "it-burnable_oil";
-        int r = IntegerRand(1,4);
-        mymodel = mymodel + ((string) (r==1?"1":r==2?"2":r==3?"3":"4"));
+        mymodel = mymodel + ecl::strf("%d", IntegerRand(1, 4));
         set_model(mymodel.c_str());
     } else
         Item::init_model();

Modified: trunk/src/lev/ScoreManager.cc
===================================================================
--- trunk/src/lev/ScoreManager.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/lev/ScoreManager.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -233,17 +233,7 @@
                         hasValidUserId = true;
                     } else {
                         // create first part of user id based on time stamp
-                        unsigned id;
-                        if (RAND_MAX > 0x10000) {
-                            id = std::rand() & 0xFFFFFFFF;
-                        } else {
-                            // MinGW 3.4.2 and maybe other configs
-                            unsigned t = std::time(NULL);
-                            std::srand(t >> 15);
-                            id = (std::rand() << 16) ^ (t & 0xFFFF);
-                            enigma::Randomize();
-                        }
-                        userId = ecl::strf("%.8lX",id);
+                        userId = ecl::strf("%.8lX", Rand(false));
                         // we need a second random part as 2 users may start Enigma
                         // within the same second - we postpone this part till we save
                     }
@@ -362,7 +352,7 @@
             Log << "ReId Windows 1.00 User Id: " << userId << "\n";
             setProperty("UserId1.00", userId);
             app.state->setProperty("UserId1.00", userId);
-            unsigned id1 = std::rand() & 0xFFFF;
+            unsigned id1 = Rand(false) & 0xFFFF;
             userId.replace(0, 4, ecl::strf("%.4lX",id1));
             unsigned id2, id3, id4;
             std::istringstream s2(userId.substr(4, 4));

Modified: trunk/src/lua.cc
===================================================================
--- trunk/src/lua.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/lua.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -801,6 +801,36 @@
 
 /* -------------------- new functions -------------------- */
 
+/**
+ * Replacement of Lua's random function based on Enigma's central random
+ * function with support of calculation of parallel worlds in seperated
+ * threads.
+ */
+static int mathRandom (lua_State *L) {
+    lua_Number r = (lua_Number)(Rand()) / (lua_Number)(ENIGMA_RAND_MAX+1.0);
+    switch (lua_gettop(L)) {      // check number of arguments
+        case 0: {                 // no arguments
+            lua_pushnumber(L, r); // Number between 0 and 1 
+            break;
+        }
+        case 1: {  // only upper limit
+            int u = luaL_checkint(L, 1);
+            luaL_argcheck(L, 1<=u, 1, "interval is empty");
+            lua_pushnumber(L, floor(r*u)+1);  // int between 1 and `u'
+            break;
+        }
+        case 2: {  // lower and upper limits 
+            int l = luaL_checkint(L, 1);
+            int u = luaL_checkint(L, 2);
+            luaL_argcheck(L, l<=u, 2, "interval is empty");
+            lua_pushnumber(L, floor(r*(u-l+1))+l);  // int between `l' and `u'
+            break;
+        }
+        default: return luaL_error(L, "wrong number of arguments");
+    }
+    return 1;
+}
+
 static int newPosition(lua_State *L) {
     // (pos|obj|table|(num,num))
     if (is_table(L, 1)) {  // table 
@@ -2211,10 +2241,12 @@
     {en_add_scramble,           "AddScramble"},
     {en_set_scramble_intensity, "SetScrambleIntensity"},
 
+    {mathRandom,                    "random"},
     {0,0}
 };
 
 static CFunction levelFuncs[] = {
+    {mathRandom,                    "random"},
     {newGroup,                      "grp"},
     {newPosition,                   "po"},
     {getFloor,                      "fl"},

Modified: trunk/src/main.cc
===================================================================
--- trunk/src/main.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/main.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -377,7 +377,8 @@
 #endif
 
     // initialize random
-    enigma::Randomize();
+    enigma::Randomize(false);
+    enigma::Randomize(true);
     
     //
     if (isMakePreviews) {

Modified: trunk/src/server.cc
===================================================================
--- trunk/src/server.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/server.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -98,6 +98,7 @@
 lev::levelStatusType   server::LevelStatus; // no Lua access
 double   server::MagnetForce;
 double   server::MagnetRange;
+int32_t  server::RandomState;               // no Lua access
 double   server::SlopeForce;
 double   server::SwampSinkSpeed;
 double   server::WaterSinkSpeed;

Modified: trunk/src/server.hh
===================================================================
--- trunk/src/server.hh	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/server.hh	2007-12-03 21:59:21 UTC (rev 931)
@@ -23,13 +23,13 @@
 #ifndef SERVER_HH_INCLUDED
 #define SERVER_HH_INCLUDED
 
-//#include "levels.hh"
 #include "lev/Proxy.hh"
 
+#include <stdint.h>
+
 namespace enigma_server 
 {
     using namespace enigma;
-//    using levels::LevelPack;
 
 /* -------------------- Global variables -------------------- */
 
@@ -51,6 +51,8 @@
 
     // The number of seconds passed since the level game started.
     extern double LevelTime;
+    
+    extern int32_t  RandomState;
 
     // True: do not reset level when player dies
     extern bool     ConserveLevel;

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/stones_simple.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -1033,7 +1033,7 @@
         RandomWoodenStone() : Stone("st-wood") {}
     private:
         Stone *clone() {
-            if(IntegerRand(0,1) == 0)
+            if(IntegerRand(0, 1) == 0)
                 return new WoodenStone("st-wood1", "fl-stwood1");
             else
                 return new WoodenStone("st-wood2", "fl-stwood2");

Modified: trunk/src/video.cc
===================================================================
--- trunk/src/video.cc	2007-12-01 19:16:02 UTC (rev 930)
+++ trunk/src/video.cc	2007-12-03 21:59:21 UTC (rev 931)
@@ -1018,8 +1018,8 @@
     case TM_PUSH_RANDOM: {
         int xo=0, yo=0;
         while (xo==0 && yo==0) {
-            xo = enigma::IntegerRand(-1,1)*scrw;
-            yo = enigma::IntegerRand(-1,1)*scrh;
+            xo = enigma::IntegerRand(-1, 1, false)*scrw;
+            yo = enigma::IntegerRand(-1, 1, false)*scrh;
         }
         return new Effect_Push(newscr, xo, yo);
     }



From ral at mail.berlios.de  Wed Dec  5 22:59:34 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Wed, 5 Dec 2007 22:59:34 +0100
Subject: [Enigma-game-svn] r932 - in trunk: data src src/stones
Message-ID: <200712052159.lB5LxYLg022819@sheep.berlios.de>

Author: ral
Date: 2007-12-05 22:59:33 +0100 (Wed, 05 Dec 2007)
New Revision: 932

Modified:
   trunk/data/sound-defaults.lua
   trunk/src/WorldProxy.cc
   trunk/src/server.cc
   trunk/src/server.hh
   trunk/src/stones/OxydStone.cc
Log:
Trunk 1.1: OxydStone
- add level variable "AllowSingleOxyds" with default false
  just for fake levels that use single oxyds but are meditations
- add sounds for pseudo oxyds of type FART and BOLD


Modified: trunk/data/sound-defaults.lua
===================================================================
--- trunk/data/sound-defaults.lua	2007-12-03 21:59:21 UTC (rev 931)
+++ trunk/data/sound-defaults.lua	2007-12-05 21:59:33 UTC (rev 932)
@@ -167,6 +167,7 @@
     shattersmall   = "enigma/shatter",   -- replace, "shattersmall" is missing
     shogunoff      = "",
     shogunon       = "",
+    shuffle        = "enigma/st-magic",
     skull          = "",
     spade          = "",
     squish         = "",
@@ -261,6 +262,7 @@
     shattersmall   = { silence_string = "CLIRR!" },
     shogunoff      = "",
     shogunon       = "",
+    shuffle        = "",
     skull          = "",
     spade          = "",
     squish         = "",
@@ -350,6 +352,7 @@
     shattersmall   = "OXKLIRR.SDD",
     shogunoff      = "",
     shogunon       = "",
+    shuffle        = "",
     skull          = "",
     spade          = "",
     squish         = "OXMATSCH.SDD",

Modified: trunk/src/WorldProxy.cc
===================================================================
--- trunk/src/WorldProxy.cc	2007-12-03 21:59:21 UTC (rev 931)
+++ trunk/src/WorldProxy.cc	2007-12-05 21:59:33 UTC (rev 932)
@@ -40,7 +40,9 @@
     }
 
     Value WorldProxy::getAttr(const string& key) const {
-        if (key == "AllowTogglePlayer") {
+        if (key == "AllowSingleOxyds") {
+            return server::AllowSingleOxyds;
+        } else if (key == "AllowTogglePlayer") {
             return server::AllowTogglePlayer;
         } else if (key == "ConserveLevel") {
             return server::ConserveLevel;
@@ -87,7 +89,9 @@
     }  
 
     void WorldProxy::set_attrib(const string& key, const Value &val) {
-        if (key == "AllowTogglePlayer") {
+        if (key == "AllowSingleOxyds") {
+            server::AllowSingleOxyds = val;
+        } else if (key == "AllowTogglePlayer") {
             server::AllowTogglePlayer = val;
         } else if (key == "ConserveLevel") {
             server::ConserveLevel = val.to_bool();

Modified: trunk/src/server.cc
===================================================================
--- trunk/src/server.cc	2007-12-03 21:59:21 UTC (rev 931)
+++ trunk/src/server.cc	2007-12-05 21:59:33 UTC (rev 932)
@@ -78,6 +78,7 @@
 
 bool server::NoCollisions = false;
 
+bool     server::AllowSingleOxyds;
 bool     server::AllowTogglePlayer;
 bool     server::CreatingPreview = false;   // read only for Lua
 bool     server::ConserveLevel;
@@ -234,6 +235,7 @@
     server::ConserveLevel     = true;
     server::TwoPlayerGame     = false;
     server::SingleComputerGame= true;
+    server::AllowSingleOxyds  = false;
     server::AllowTogglePlayer = true;
     server::ShowMoves         = false;
     server::Brittleness       = 0.5;

Modified: trunk/src/server.hh
===================================================================
--- trunk/src/server.hh	2007-12-03 21:59:21 UTC (rev 931)
+++ trunk/src/server.hh	2007-12-05 21:59:33 UTC (rev 932)
@@ -73,6 +73,9 @@
     // Detect double initialization (resize) attempts
     extern bool     WorldInitialized;
     
+    // Single oxyds make a level unsolvable, but sometimes they are just fake,... 
+    extern bool     AllowSingleOxyds;
+    
     // level compatibility
     extern double   EnigmaCompatibility;
    

Modified: trunk/src/stones/OxydStone.cc
===================================================================
--- trunk/src/stones/OxydStone.cc	2007-12-03 21:59:21 UTC (rev 931)
+++ trunk/src/stones/OxydStone.cc	2007-12-05 21:59:33 UTC (rev 932)
@@ -158,7 +158,7 @@
                     onlyPairs = false;
                     break;
                 } else {
-                    ASSERT(false, XLevelRuntime, "Oxyd init colors - too many unpaired oxyds with given color");
+                    ASSERT(server::AllowSingleOxyds, XLevelRuntime, "Oxyd init colors - too many unpaired oxyds with given color");
                 }
             }
             if (colorsUsageCountNoShuffle[i] % 2 == 1) {
@@ -188,7 +188,7 @@
             colorsUsageCount[lastColor]--;
             shuffledFakeCount++;
         } else {
-            ASSERT(onlyPairs, XLevelRuntime, "Oxyd init colors - too many unpaired oxyds with given color");
+            ASSERT(onlyPairs || server::AllowSingleOxyds, XLevelRuntime, "Oxyd init colors - too many unpaired oxyds with given color");
         }
         
         isInit = true;
@@ -1013,6 +1013,9 @@
                     set_anim(basemodelname + "-pseudo" + color);
                     if ((int)getAttr("color") == FART) {
                         closeAllStandardOxyds();
+                        sound_event("fart");
+                    } else if ((int)getAttr("color") == BOLD) {
+                        sound_event("shuffle");
                     }
                 } else
                     set_model(modelname + "-blink");



From ral at mail.berlios.de  Sat Dec  8 00:46:33 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sat, 8 Dec 2007 00:46:33 +0100
Subject: [Enigma-game-svn] r933 - in trunk/src: . gui
Message-ID: <200712072346.lB7NkXg6013980@sheep.berlios.de>

Author: ral
Date: 2007-12-08 00:46:31 +0100 (Sat, 08 Dec 2007)
New Revision: 933

Modified:
   trunk/src/client.cc
   trunk/src/game.cc
   trunk/src/gui/Menu.cc
   trunk/src/gui/Menu.hh
   trunk/src/gui/OptionsMenu.cc
   trunk/src/gui/SearchMenu.cc
   trunk/src/gui/TextField.cc
   trunk/src/gui/TextField.hh
   trunk/src/gui/widgets.cc
   trunk/src/gui/widgets.hh
   trunk/src/main.cc
   trunk/src/main.hh
Log:
Trunk 1.1: reengineering widget/menu key event handling
- active widget is now first event handler
- key focus widget like text fields are second - this allows
  entering in text in fields without the cursor being on the widget
- menu specific event handling is last
- introduce "boss key": ALT + ESC and window close button terminate
  Enigma immediatley (with save)
- Stop options menu from catching right mouse button events for quitting menu
Note:
- the only partial working active widget switching with cursor keys is
  even more restricted as a key focus widget will likely catch the cursor
  keys. In future tab should be used to switch active widgets.


Modified: trunk/src/client.cc
===================================================================
--- trunk/src/client.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/client.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -221,6 +221,7 @@
 
         case SDL_QUIT:
             client::Msg_Command("abort");
+            app.bossKeyPressed = true;
             break;
         }
     }
@@ -390,7 +391,11 @@
     }
     else if (keymod & KMOD_ALT) {
         switch (keysym) {
-        case SDLK_x: abort(); break;
+        case SDLK_ESCAPE:
+            app.bossKeyPressed = true;
+            // fall through
+        case SDLK_x: 
+            abort(); break;
         case SDLK_t:
             if (enigma::WizardMode) {
                 Screen *scr = video::GetScreen();
@@ -695,6 +700,7 @@
                 case SDL_KEYDOWN:
                 case SDL_QUIT:
                     client::Msg_Command("abort");
+                    app.bossKeyPressed = true;
                     break;
                 }
             }

Modified: trunk/src/game.cc
===================================================================
--- trunk/src/game.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/game.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -80,7 +80,7 @@
 
     double dtime = 0;
     last_tick_time=SDL_GetTicks();
-    while (!client::AbortGameP()) {
+    while (!client::AbortGameP() && !app.bossKeyPressed) {
         try {
             client::Tick (dtime);
             server::Tick (dtime);

Modified: trunk/src/gui/Menu.cc
===================================================================
--- trunk/src/gui/Menu.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/Menu.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -21,6 +21,7 @@
 #include "sound.hh"
 #include "video.hh"
 #include "options.hh"
+#include "main.hh"
 #include "nls.hh"
 #include "ecl.hh"
 #include <cassert>
@@ -37,7 +38,7 @@
     /* -------------------- Menu -------------------- */
     
     Menu::Menu()
-    : active_widget(0), quitp(false), abortp(false) {
+    : active_widget(NULL), key_focus_widget(NULL), quitp(false), abortp(false) {
     }
     
     void Menu::add(Widget *w) {
@@ -59,6 +60,17 @@
         abortp=true;
     }
     
+    void Menu::set_key_focus(Widget *newfocus) {
+        Widget *oldfocus = key_focus_widget;
+        key_focus_widget = newfocus;
+        if (oldfocus)
+            oldfocus->invalidate();
+    }
+    
+    bool Menu::is_key_focus(Widget *focus) {
+        return (key_focus_widget == focus);
+    }
+    
     bool Menu::manage() {
         quitp=abortp=false;
         SDL_Event e;
@@ -69,9 +81,11 @@
             SCREEN->flush_updates();
             while (SDL_PollEvent(&e)) {
                 handle_event(e);
+                if (app.bossKeyPressed) return true;
             }
             SDL_Delay(10);
             if(active_widget) active_widget->tick(0.01);
+            if(key_focus_widget && (key_focus_widget != active_widget)) key_focus_widget->tick(0.01);
             tick (0.01);
             refresh();
         }
@@ -110,53 +124,72 @@
         }
     }
     
-    void Menu::handle_event(const SDL_Event &e) 
-    {
-        if (e.type == SDL_KEYDOWN && 
-            e.key.keysym.sym == SDLK_RETURN && 
-            e.key.keysym.mod & KMOD_ALT)
-        {
+    void Menu::handle_event(const SDL_Event &e) {
+        
+        // Alt && Return for Fullscreen Toggle on Linux only
+        if (e.type == SDL_KEYDOWN &&  e.key.keysym.sym == SDLK_RETURN && 
+                e.key.keysym.mod & KMOD_ALT) {
             video::ToggleFullscreen();
             return;
         }
-    
+        
+        // Boss quit key Alt && ESC
+        if (e.type == SDL_KEYDOWN &&  e.key.keysym.sym == SDLK_ESCAPE && 
+                e.key.keysym.mod & KMOD_ALT) {
+            abort();
+            app.bossKeyPressed = true;
+            return;
+        }
+        
+        
+        // first allow active widget to handle event
+        if (active_widget && active_widget->on_event(e))
+            return;
+        
+        // key focus handler next to catch key events
+        if (key_focus_widget && key_focus_widget->on_event(e))
+            return;
+        
+        // menu subclass with special handling
         if (on_event(e))
             return;
     
         switch (e.type) {
-        case SDL_QUIT:
-            abort();
-            break;
-        case SDL_MOUSEMOTION:
-            track_active_widget( e.motion.x, e.motion.y );
-            break;
-        case SDL_KEYDOWN:
-            if (!active_widget || !active_widget->on_event(e)) {
-                // if not handled by active_widget
-                switch (e.key.keysym.sym) {
-                case SDLK_ESCAPE:
-                    abort();
-                    break;
-                case SDLK_DOWN:  goto_adjacent_widget( 0,  1); break;
-                case SDLK_UP:    goto_adjacent_widget( 0, -1); break;
-                case SDLK_RIGHT: goto_adjacent_widget( 1,  0); break;
-                case SDLK_LEFT:  goto_adjacent_widget(-1,  0); break;
-                default:
-                    break;
+            case SDL_QUIT:
+                abort();
+                app.bossKeyPressed = true;
+                break;
+            case SDL_MOUSEMOTION:
+                track_active_widget( e.motion.x, e.motion.y );
+                break;
+            case SDL_KEYDOWN:
+                if (!active_widget || !active_widget->on_event(e)) {
+                    // if not handled by active_widget
+                    switch (e.key.keysym.sym) {
+                    case SDLK_ESCAPE:
+                        abort();
+                        break;
+                    // TODO replace cursor keys with tab for gotos
+                    case SDLK_DOWN:  goto_adjacent_widget( 0,  1); break;
+                    case SDLK_UP:    goto_adjacent_widget( 0, -1); break;
+                    case SDLK_RIGHT: goto_adjacent_widget( 1,  0); break;
+                    case SDLK_LEFT:  goto_adjacent_widget(-1,  0); break;
+                    default:
+                        break;
+                    }
                 }
-            }
-    
-            break;
-        case SDL_MOUSEBUTTONDOWN:
-        case SDL_MOUSEBUTTONUP:
-            track_active_widget( e.button.x, e.button.y );
-            if (active_widget) active_widget->on_event(e);
-            break;
-        case SDL_VIDEOEXPOSE:
-            draw_all();
-            break;
-        default:
-            if (active_widget) active_widget->on_event(e);
+        
+                break;
+            case SDL_MOUSEBUTTONDOWN:
+            case SDL_MOUSEBUTTONUP:
+                track_active_widget( e.button.x, e.button.y );
+                if (active_widget) active_widget->on_event(e);
+                break;
+            case SDL_VIDEOEXPOSE:
+                draw_all();
+                break;
+            default:
+                if (active_widget) active_widget->on_event(e);
         }
     }
     

Modified: trunk/src/gui/Menu.hh
===================================================================
--- trunk/src/gui/Menu.hh	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/Menu.hh	2007-12-07 23:46:31 UTC (rev 933)
@@ -45,10 +45,13 @@
 
         virtual void quit();
         void abort();
+        
+        // Container interface
+        virtual void set_key_focus(Widget *newfocus);
+        virtual bool is_key_focus(Widget *focus);
 
     protected:
-        void reset_active_widget()
-        { active_widget = 0; }
+        void reset_active_widget() { active_widget = NULL; }
 
         // Menu interface.
         virtual void draw_background(ecl::GC &/*gc*/) {}
@@ -62,6 +65,7 @@
 
         // Variables.
         Widget *active_widget;
+        Widget *key_focus_widget;
         bool quitp, abortp;
     };
 

Modified: trunk/src/gui/OptionsMenu.cc
===================================================================
--- trunk/src/gui/OptionsMenu.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/OptionsMenu.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -433,13 +433,7 @@
     bool OptionsMenu::on_event (const SDL_Event &e)
     {
         bool handled=false;
-        if (e.type == SDL_MOUSEBUTTONDOWN
-            && e.button.button == SDL_BUTTON_RIGHT)
-        {
-            quit();
-            handled = true;
-        }
-        else if (e.type == SDL_KEYUP) {
+        if (e.type == SDL_KEYUP) {
             if ((e.key.keysym.sym==SDLK_RETURN) &&
                 (e.key.keysym.mod & KMOD_ALT))
             {

Modified: trunk/src/gui/SearchMenu.cc
===================================================================
--- trunk/src/gui/SearchMenu.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/SearchMenu.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -67,6 +67,8 @@
         commandHList->add_back(but_ignore);
         commandHList->add_back(but_search);
         this->add(commandHList, Rect(10, vminfo.height-50, vminfo.width-20, 35));
+        
+        set_key_focus(shallowSearch);
     }
     
     bool SearchMenu::isSearchQuit() {

Modified: trunk/src/gui/TextField.cc
===================================================================
--- trunk/src/gui/TextField.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/TextField.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -51,6 +51,12 @@
     textPostCursor= "";
 }
 
+void TextField::activate() {
+    Button::activate();
+    if (get_parent())
+        get_parent()->set_key_focus(this);
+}
+
 void TextField::set_text(const std::string &t) {
     textPreCursor = t;
     charSizesPreCursor.clear();
@@ -107,7 +113,7 @@
     f->render (gc, x, y, textPreCursor.c_str());
     
     x += w_pre; 
-    if (m_activep) {
+    if (m_activep || get_parent()->is_key_focus(this)) {
         if (showCursor) {
             set_color(gc, 200,200,200);
             vline(gc, x, y, h);
@@ -115,7 +121,7 @@
         x += w_cursor;
     }
     
-    f->render (gc, x, y, textPostCursor.c_str());
+    f->render(gc, x, y, textPostCursor.c_str());
    
 }
 
@@ -130,6 +136,7 @@
         case SDL_KEYDOWN:
             switch (e.key.keysym.sym) {
                 case SDLK_RETURN:
+                case SDLK_KP_ENTER:
                     handeled = true;
                     isLastActionReturn = true;
                     invoke_listener();

Modified: trunk/src/gui/TextField.hh
===================================================================
--- trunk/src/gui/TextField.hh	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/TextField.hh	2007-12-07 23:46:31 UTC (rev 933)
@@ -62,6 +62,7 @@
         bool wasLastActionReturn();
         
         // Widget interface.
+        virtual void activate();
         virtual void tick (double dtime);
         virtual bool on_event(const SDL_Event &/*e*/);
         void draw(ecl::GC &gc, const ecl::Rect &r);

Modified: trunk/src/gui/widgets.cc
===================================================================
--- trunk/src/gui/widgets.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/widgets.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -97,7 +97,7 @@
     }
 }
 
-
+
 /* -------------------- AreaManager -------------------- */
 
 AreaManager::AreaManager(Container *c)
@@ -290,7 +290,19 @@
         return get_area();
 }
 
-
+void Container::set_key_focus(Widget *newfocus) {
+    if (get_parent() != NULL) {
+        get_parent()->set_key_focus(newfocus);
+    }
+}
+
+bool Container::is_key_focus(Widget *focus) {
+    if (get_parent() != NULL) {
+        return get_parent()->is_key_focus(focus);
+    } else
+        return false;
+}
+
 /* -------------------- List -------------------- */
 
 List::List (int spacing) 
@@ -454,7 +466,6 @@
     return targetw >= naturalw;
 }
 
-
 /* -------------------- VList -------------------- */
 
 void VList::recalc()
@@ -504,7 +515,6 @@
     return targeth >= naturalh;
 }
 
-
 /* -------------------- Label -------------------- */
 
 Label::Label (const std::string &text,
@@ -583,7 +593,6 @@
     w = m_font->get_width (m_text == "" ? "" : get_text().c_str());
 }
 
-
 /* -------------------- UntranslatedLabel -------------------- */
 
 UntranslatedLabel::UntranslatedLabel (const std::string &text,
@@ -689,7 +698,6 @@
     }
 }
 
-
 /* -------------------- PushButton -------------------- */
 
 PushButton::PushButton() : m_pressedp (false) {
@@ -698,30 +706,30 @@
 bool PushButton::on_event(const SDL_Event &e) {
     Widget::on_event(e);
     bool was_pressed = m_pressedp;
+    bool handeled = false;
 
     switch (e.type) {
-    case SDL_KEYDOWN:
-        if (e.key.keysym.sym != SDLK_RETURN &&
-            e.key.keysym.sym != SDLK_SPACE) break;
-        // fall-through
-    case SDL_MOUSEBUTTONDOWN:
-        m_pressedp = true;
-        break;
-
-    case SDL_KEYUP:
-        if (e.key.keysym.sym != SDLK_RETURN &&
-            e.key.keysym.sym != SDLK_SPACE &&
-            e.key.keysym.sym != SDLK_PAGEDOWN &&
-            e.key.keysym.sym != SDLK_PAGEUP) break;
-        lastUpSym = e.key.keysym.sym;
-        lastUpBotton = 0;
-        m_pressedp = false;
-        break;
-    case SDL_MOUSEBUTTONUP:
-        lastUpSym = SDLK_UNKNOWN;
-        lastUpBotton = e.button.button;
-        m_pressedp = false;
-        break;
+        case SDL_KEYDOWN:
+            if (e.key.keysym.sym != SDLK_RETURN) break;
+            // fall-through
+        case SDL_MOUSEBUTTONDOWN:
+            m_pressedp = true;
+            handeled = true;
+            break;
+    
+        case SDL_KEYUP:
+            if (e.key.keysym.sym != SDLK_RETURN) break;
+            lastUpSym = e.key.keysym.sym;
+            lastUpBotton = 0;
+            m_pressedp = false;
+            handeled = true;
+            break;
+        case SDL_MOUSEBUTTONUP:
+            lastUpSym = SDLK_UNKNOWN;
+            lastUpBotton = e.button.button;
+            m_pressedp = false;
+            handeled = true;
+            break;
     }
 
     bool changed = (was_pressed != m_pressedp);
@@ -734,7 +742,7 @@
         }
     }
 
-    return changed;
+    return handeled;
 }
 
 void PushButton::deactivate() {
@@ -756,7 +764,7 @@
 bool PushButton::soundOk() {
     return true;
 }
-
+
 /* -------------------- TextButton -------------------- */
 
 ecl::Font *TextButton::menufont = 0;
@@ -782,7 +790,7 @@
     f->render (gc, x, y, text.c_str());
 }
 
-
+
 /* -------------------- StaticTextButton -------------------- */
 
 StaticTextButton::StaticTextButton(const string &t, ActionListener *al)
@@ -815,7 +823,7 @@
     return StaticTextButton::text;
 }
 
-
+
 /* -------------------- Buttons for Options -------------------- */
 
 BoolOptionButton::BoolOptionButton(const char    *option_name,

Modified: trunk/src/gui/widgets.hh
===================================================================
--- trunk/src/gui/widgets.hh	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/gui/widgets.hh	2007-12-07 23:46:31 UTC (rev 933)
@@ -88,7 +88,7 @@
         int get_h() const { return area.h; }
 
         void set_parent(Container *parent) { m_parent = parent; }
-        Container *get_parent () const { return m_parent; }
+        Container *get_parent() const { return m_parent; }
 
         void set_listener(ActionListener *al) {
             m_listener = al;
@@ -173,6 +173,9 @@
         void clear();
         void draw_all();
 
+        virtual void set_key_focus(Widget *newfocus);
+        virtual bool is_key_focus(Widget *focus);
+
         // Widget interface.
         void draw (ecl::GC& gc, const ecl::Rect &r);
         void move (int x, int y);

Modified: trunk/src/main.cc
===================================================================
--- trunk/src/main.cc	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/main.cc	2007-12-07 23:46:31 UTC (rev 933)
@@ -225,7 +225,7 @@
 
 Application::Application() : wizard_mode (false), nograb (false), language (""),
         defaultLanguage (""), argumentLanguage (""), errorInit (false),
-        isMakePreviews (false) {
+        isMakePreviews (false), bossKeyPressed (false) {
 }
 
 

Modified: trunk/src/main.hh
===================================================================
--- trunk/src/main.hh	2007-12-05 21:59:33 UTC (rev 932)
+++ trunk/src/main.hh	2007-12-07 23:46:31 UTC (rev 933)
@@ -210,6 +210,7 @@
         bool errorInit;
         bool isMakePreviews;
         video::VideoModes selectedVideoMode;
+        bool bossKeyPressed;
 
     private:
         void initSysDatapaths(const std::string &prefFilename);



From ral at mail.berlios.de  Sat Dec  8 14:15:46 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sat, 8 Dec 2007 14:15:46 +0100
Subject: [Enigma-game-svn] r934 - in trunk: data src src/gui
Message-ID: <200712081315.lB8DFk01019469@sheep.berlios.de>

Author: ral
Date: 2007-12-08 14:15:45 +0100 (Sat, 08 Dec 2007)
New Revision: 934

Modified:
   trunk/data/sound-defaults.lua
   trunk/src/client.cc
   trunk/src/gui/Menu.cc
Log:
Trunk 1.1:
- fix r933: change boss key to Shift+ESC for Windows
- fix r933: on level error message do not quit app on any key
- r932: change sound for shuffle to "switch" 

Modified: trunk/data/sound-defaults.lua
===================================================================
--- trunk/data/sound-defaults.lua	2007-12-07 23:46:31 UTC (rev 933)
+++ trunk/data/sound-defaults.lua	2007-12-08 13:15:45 UTC (rev 934)
@@ -167,7 +167,7 @@
     shattersmall   = "enigma/shatter",   -- replace, "shattersmall" is missing
     shogunoff      = "",
     shogunon       = "",
-    shuffle        = "enigma/st-magic",
+    shuffle        = "enigma/switch",
     skull          = "",
     spade          = "",
     squish         = "",

Modified: trunk/src/client.cc
===================================================================
--- trunk/src/client.cc	2007-12-07 23:46:31 UTC (rev 933)
+++ trunk/src/client.cc	2007-12-08 13:15:45 UTC (rev 934)
@@ -391,9 +391,6 @@
     }
     else if (keymod & KMOD_ALT) {
         switch (keysym) {
-        case SDLK_ESCAPE:
-            app.bossKeyPressed = true;
-            // fall through
         case SDLK_x: 
             abort(); break;
         case SDLK_t:
@@ -422,7 +419,14 @@
     }
     else {
         switch (keysym) {
-        case SDLK_ESCAPE: show_menu(); break;
+        case SDLK_ESCAPE:
+            if (keymod & KMOD_SHIFT) {
+                app.bossKeyPressed = true;
+                abort();
+            } else {
+                show_menu();
+            }
+            break;
         case SDLK_LEFT:   set_mousespeed(options::GetMouseSpeed() - 1); break;
         case SDLK_RIGHT:  set_mousespeed(options::GetMouseSpeed() + 1); break;
         case SDLK_TAB:    rotate_inventory(+1); break;
@@ -697,11 +701,12 @@
             SDL_Event e;
             while (SDL_PollEvent(&e)) {
                 switch (e.type) {
-                case SDL_KEYDOWN:
-                case SDL_QUIT:
-                    client::Msg_Command("abort");
-                    app.bossKeyPressed = true;
-                    break;
+                    case SDL_QUIT:
+                        app.bossKeyPressed = true;
+                        // fall through
+                    case SDL_KEYDOWN:
+                        client::Msg_Command("abort");
+                        break;
                 }
             }
         }

Modified: trunk/src/gui/Menu.cc
===================================================================
--- trunk/src/gui/Menu.cc	2007-12-07 23:46:31 UTC (rev 933)
+++ trunk/src/gui/Menu.cc	2007-12-08 13:15:45 UTC (rev 934)
@@ -133,9 +133,9 @@
             return;
         }
         
-        // Boss quit key Alt && ESC
+        // Boss quit key Shift && ESC
         if (e.type == SDL_KEYDOWN &&  e.key.keysym.sym == SDLK_ESCAPE && 
-                e.key.keysym.mod & KMOD_ALT) {
+                e.key.keysym.mod & KMOD_SHIFT) {
             abort();
             app.bossKeyPressed = true;
             return;



From andreasl at mail.berlios.de  Sun Dec  9 02:58:33 2007
From: andreasl at mail.berlios.de (andreasl at BerliOS)
Date: Sun, 9 Dec 2007 02:58:33 +0100
Subject: [Enigma-game-svn] r935 - in homepage: images/lotm input/lotm
Message-ID: <200712090158.lB91wXe6016745@sheep.berlios.de>

Author: andreasl
Date: 2007-12-09 02:58:22 +0100 (Sun, 09 Dec 2007)
New Revision: 935

Added:
   homepage/images/lotm/lotm_200712.png
   homepage/images/lotm/lotm_200712_ag.png
   homepage/images/lotm/lotm_200712_b.png
   homepage/images/lotm/lotm_200712_c.png
   homepage/images/lotm/lotm_200712_k.png
   homepage/images/lotm/lotm_200712_l.png
   homepage/images/lotm/lotm_200712_m.png
   homepage/images/lotm/lotm_200712_n.png
   homepage/images/lotm/lotm_200712_o.png
   homepage/images/lotm/lotm_200712_p.png
   homepage/input/lotm/lotm_200712.html
   homepage/input/lotm/lotm_200712_de.html
Modified:
   homepage/images/lotm/lotm-history.png
   homepage/input/lotm/lotm_archive_data.lua
Log:
LotM:
 - Added German and English version of LotM 12/2007.
 - The German page includes an invisible, preliminary
   counter, just to draw a sample.
Todo:
 - Russian translation
 - Validation, upload


Modified: homepage/images/lotm/lotm-history.png
===================================================================
(Binary files differ)

Added: homepage/images/lotm/lotm_200712.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_ag.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_ag.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_b.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_b.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_c.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_c.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_k.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_k.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_l.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_l.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_m.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_m.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_n.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_n.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_o.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_o.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/images/lotm/lotm_200712_p.png
===================================================================
(Binary files differ)


Property changes on: homepage/images/lotm/lotm_200712_p.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: homepage/input/lotm/lotm_200712.html
===================================================================
--- homepage/input/lotm/lotm_200712.html	2007-12-08 13:15:45 UTC (rev 934)
+++ homepage/input/lotm/lotm_200712.html	2007-12-09 01:58:22 UTC (rev 935)
@@ -0,0 +1,340 @@
+<div class="lotm">
+$$lotm_header$$
+<h3 class="lotm">
+<span class="date">December 2007: </span>
+&quot;Temple of Gold&quot;, by Jacob Scott &amp; Ronald Lamprecht
+</h3>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_m.png" alt="Level of the month" border="0">
+<div class="imagetitle">Enigma VII # 24 'Temple of Gold'<br>The whirlpool of the ancient godess</div>
+</div>
+
+<p>Welcome, dear fellow marblers, and please remain silent, as we enter the sacred halls of the &quot;Temple of Gold&quot;, December's Level of the Month. Many thought it only existed in the realm of fairy tales. We'll prove these skeptics wrong by exploring the temple's interior together, even those rooms still considered to be inaccessible (of course with due respect for the time-honoured traditions of this holy place, and with with the utmost caution not to walk into some trap set long ago by the founders of the temple to welcome uninvited guests).</p>
+
+<p>We are guided by the reports of two of our fellows, who managed not only to survive the golden perils of the temple, but also to gain access to the four altar rooms and there to illuminate the holy oxydian stones. These daredevils, worthy of our admiration, are Taztunes and Craven. Also detailed accounts have been submitted to us from the architect of the building, the amazing Mr Jacob Scott, and from Mr Ronald Lamprecht, this time in the position of a security consultant. Later on, member Daydreamer will talk about his observations of some secret ceremony being performed at the temple.</p>
+
+<table cellpadding="0" cellspacing="1" class="statistics">
+<caption class="normalcaption">Some records of October 2007</caption>
+<colgroup>
+   <col width="80">
+   <col width="160">
+</colgroup>
+<tr><td class="num"> 8:53</td>
+    <td class="left">Moneymaker</td></tr>
+<tr><td class="num">18:20</td>
+    <td class="left">Daydreamer</td></tr>
+<tr><td class="num">22:18</td>
+    <td class="left">Ronald</td></tr>
+<tr><td class="num">24:20</td>
+    <td class="left">Craven</td></tr>
+<tr><td class="num">34:23</td>
+    <td class="left">Taztunes</td></tr>  
+</table>
+
+<p></p>
+
+<table cellpadding="0" cellspacing="1" class="statistics">
+<caption class="normalcaption">The Easy Mode records</caption>
+<colgroup>
+   <col width="80">
+   <col width="160">
+</colgroup>
+<tr><td class="num"> 5:44</td>
+    <td class="left">Moneymaker</td></tr>
+<tr><td class="num"> 9:50</td>
+    <td class="left">Craven</td></tr>
+<tr><td class="num">10:06</td>
+    <td class="left">Ronald</td></tr>
+<tr><td class="num">11:06</td>
+    <td class="left">Tobias</td></tr>
+<tr><td class="num">11:37</td>
+    <td class="left">Daydreamer</td></tr>  
+<tr><td class="num">16:20</td>
+    <td class="left">para_doks</td></tr>
+<tr><td class="num">17:53</td>
+    <td class="left">ryujun</td></tr>
+<tr><td class="num">18:16</td>
+    <td class="left">Mark P.</td></tr>
+<tr><td class="num">18:29</td>
+    <td class="left">Taztunes</td></tr>
+<tr><td class="num">22:06</td>
+    <td class="left">dpl</td></tr>  
+</table>
+
+
+<h4>Instead of tiring statistic accumulations, this time some short &quot;Alien Glyphs&quot;:</h4>
+
+<p><img class="leftimage" src="$$imagedir$$/lotm/lotm_200712_ag.png" alt="ILCELATTOG" align="left"></p>
+
+<h4>9.25(8)9.13(8)9.11(9)9.00(5)</h4>
+
+<p>As always, you can find more details on the <a href="http://www.nongnu.org/enigma/lotm.html">LotM archive</a> page.</p>  
+
+<h4>Experience some sort of mystical sensation!</h4>
+
+<p>I can't think of any level better suited for the first jubilee edition of the LotM award than &quot;Temple of Gold&quot;. For the 10th time now &quot;we take a closer look at excellent Enigma levels&quot;. Christmas is approaching, which also can be referred to as an excellent level, though not of Enigmian origin, with a strong emphasis on exploring, not only piles of Christmas presents under the tree, but also the interiors of the soul, where piles of rubbish accumulated during the year - remnants of unpleasant experiences of everyday struggles. On this joyous occasion, what a relief it is, to finally enter the inner golden temple and leave the outer world behind. And exactly the same is happening, while you're exploring Enigma's Golden Temple: Nothing else matters!</p>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_k.png" alt="Level of the month" border="0">
+<div class="imagetitle">Blackish bedight, A marbleous knight,<br>
+In sunshine and in shadow,<br> 
+Had rolled along, Singing a song - <br>
+In search of Templo Dorado.<br>
+</div>
+</div>
+
+<p>Let us seize the opportunity to take a look back at our first Level of the Month, &quot;Island Labyrinth&quot;, another marvellous creation by Jacob. &quot;It's a level that makes the reality disappear&quot; Alejandro wrote about it, meaning the same as what I just said about &quot;Temple of Gold&quot;. Other prominent statements which can be applied to &quot;Temple of Gold&quot; without changing a single word are: &quot;Little by little, the pieces of the puzzle start to fit together as the marble explores this fascinating landscape&quot; (Taztunes), &quot;For me this level expresses what I call the true spirit of Enigma&quot; (Ronald), &quot;It would really be a pity to rush through this wonderful level&quot; (Ronald), &quot;One of the most charming characteristics of this level is provided by Jacob's consistent design&quot; (Andreas).</p>
+
+<p>Almost all players who have ever taken a glance at &quot;Island Labyrinth&quot; will ever since associate the stylistic combination of st-rock1, fl-water and fl-leaves with this level. In the very same way the significant combination of st-yellow and fl-sahara will furthermore inseparably be connected with &quot;Temple of Gold&quot;. It is essentially this colour design that get's one to experience some sort of mystical sensation, appropriate to the scene. Let's listen to some words of the author about his work:</p>
+
+<h4>&quot;I intended &quot;Temple of Gold&quot; to be reminiscent of some exotic temple&quot;</h4>
+
+<div class="quote">I do find the temple, at least the exotic sort, (as popularized by various 
+adventure books/films) a great place around which to center a level, largely 
+because of the mystery associated with it. I wasn't inspired by any particular 
+source, but I did tap into the sense of intrigue and exploration one usually 
+attaches to a temple, especially one recently discovered from a long-gone
+civilization, just waiting to be explored!</div>
+
+<div class="quote">&quot;Temple of Gold&quot; was another of my attempts, like &quot;Elaborate,&quot; to
+create a large exploration-oriented level. I wanted the main focus of
+the level to be discovering the various rooms and the objects in them
+without having to worry too much about dying for silly reasons. Thus
+I added few dangers likely to kill a cautious player, the worst being
+a slow rotor in one of the rooms, and kept the rooms for the most part
+open. The real challenge of the level comes in its nonlinearity,
+where it is not at all obvious what to do at any particular point. I
+tend to enjoy these conceptual puzzles a lot, which is why I thought
+it important to design a level that made one move and think between
+rooms, instead of focusing on only the nearby objects to complete
+whatever localized challenge I happened to design.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_c.png" alt="Level of the month" border="0">
+<div class="imagetitle">Indiana Marble &amp; Short Round: <br>The escape from the prison pit</div>
+</div>
+
+<div class="quote">I also intended &quot;Temple of Gold&quot; to be reminiscent of some exotic
+temple with numerous obstacles blocking the most obvious paths to
+exploration. As such, I kept the rooms largely open and clear of
+everything nonessential to make the level appear large and
+uncluttered. I also used only items one would expect (well, in the
+typical temple explorer sense, not what one would find in real life)
+to be native to a temple, things like abyss, a hammer, various guards,
+and brown/wood movable stones. Together, these properties should give
+a player in the level a sense of exploration, without having to avoid
+trivial dangers or solve picky, dense puzzles that would ruin the
+effect.</div>
+
+<div class="quote">Overall, I am quite pleased with what the level turned into. I think
+it maintains the illusion of an exotic temple quite well and is
+reasonably fair and balanced, with no one part being way too easy or
+difficult, and a large variety of puzzles being represented. It
+continues with the theme of &quot;Elaborate,&quot; but in a more interesting and
+sensation-evoking setting. I hope all Enigma players who attempt it
+find it as enjoyable to play and to explore as I found it to write.</div>
+
+<div class="quote">Also, I must thank Ronald a lot for his help finishing the level,
+particularly in difficult mode. I initially had a few shortcuts that
+could be exploited to finish the level faster than I intended, and
+Ronald not only found good ways to patch these but also to add more
+challenges, still within the theme, to difficult mode, to make it more
+complete.</div>
+
+<div class="author">Jacob Scott</div>
+
+<p>Indeed, &quot;Difficult Mode&quot; has turned out not to be an &quot;easy&quot; challenge, and those players 
+who gave a try to &quot;Houdini&quot; for instance, another &quot;Excellent Enigma Level&quot;, 
+will immediately recognize who had a hand in it. For all his efforts, he's overlooked something,  
+but, well, let's let him tell us about it himself:</p>
+
+<h4>&quot;It may be the first level that needs quite different solutions for easy and difficult mode&quot;</h4>
+
+<div class="quote">I received the draft version of this level together with a bunch of 
+mainly finished but still untitled levels from Jacob for shortcut 
+testing and for making title suggestions. I was immediately 
+fascinated by this level. No packed tight rooms, but majestic 
+passageways with unique challenges once in a while. An exploration level 
+without any hidden objects with a unique coloring scheme
+and the common blue oxyd pattern that satisfies.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_o.png" alt="Level of the month" border="0">
+<div class="imagetitle">This horse will be <br/>of good service to me, <br/>if I can set it free!</div>
+</div>
+
+<div class="quote">Seeing a totally empty room on the right I had to offer a ready pattern 
+with a blueish horse tied to a golden Brownie stone. It perfectly 
+fit the existing ditch and puzzle.</div>
+
+<div class="quote">But the remaining task was to fix the shortcut in the overall 
+storyboard. My solution was the addition of the golden puzzle around one 
+of the blue oxyd patterns. But I was still unsatisfied with the left and 
+south oxyd patterns that were totally plain. I really enjoyed searching 
+for different challenges for each unique oxyd pattern.</div>
+
+<div class="quote">But the final two challenges required yet another storyboard. The 
+solution was to offer two modes. An easy mode with the original 
+storyboard, that bypasses some of the added challenges. And a difficult 
+mode that adds new challenges and a quite different storyboard. It may 
+be the first level that needs quite different solutions for easy and 
+difficult mode - you should really play both!</div>
+
+<div class="quote">Unfortunaly even several pairs of eyes overlooked another dexterity 
+shortcut. User &quot;Moneymaker&quot; sent us a report. But looking at the 
+scores obviously nobody besides him has yet found and used this 
+shortcut. The fix has been easy and is unvisible. It will be delivered 
+with the next Enigma release for sure.</div>
+
+<div class="author">Ronald Lamprecht</div>
+
+<p>The attentive reader might recall, that the name &quot;Moneymaker&quot; has been 
+mentioned before in the record list. Racing through both, the Silver and the Golden 
+Temple, at incredible fast speed, he set up records for eternity, but I dare say
+he did not experience too much of the mystical sensation that the temple presents to 
+the attentive explorer!</p>
+
+<p>The reader, interested in charts and statistics, might find out more about  
+the &quot;Michael Schumacher&quot; of Formula Enigma at the <a href="$$statistics$$">Score Statistics</a> page. At top of the current &quot;Solved Level Statistics&quot; 
+he'll also find the names of those two brave explorers, who have returned victorous from the Golden Temple 
+and agreed to tell the Enigmian Nation about their adventures. Taztunes and Craven, would you please take the floor?!</p>
+
+<h4>&quot;Of hundreds of ways one actually works!&quot;</h4>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_p.png" alt="Level of the month" border="0">
+<div class="imagetitle">
+And, as his strength, Failed him at length,<br>
+He met a pilgrim rotor.<br>
+&quot;Rotor,&quot; said he, &quot;Where can they be - <br>
+The oxyds of Templo Dorado?&quot;<br>
+</div>
+</div>
+
+<div class="quote">This level has got a bit of everything: dangerous passages in which you need to maneuver skillfully, and most of all a complex riddle, which now and again takes you to the brink of despair.</div>
+
+<div class="quote">I didn't have much trouble with the easy mode because in most rooms it's quite obvious what to do. Only the barrier which you can see on the screenshot seemed to be invincible until I finally found the right &quot;key&quot;.</div>
+
+<div class="quote">Because of this, I was quite optimistic about the difficult mode, only to find out that more things had changed than I had expected: the Oxyds were still in the same place and the general way to solve the level stayed the same, but there were also a few nasty surprises, like e.g. suddenly appearing platforms or a seemingly open door that still didn't allow me to move stones past it (I already got this one on &quot;Houdini&quot;!).</div>
+
+<div class="quote">As there are practically hundreds of ways to overcome the riddles, of which but one actually works, the frustration factor is extremely high, so that I can absolutely understand, why only a few people could solve this level. However, you don't have to be as dexterous in &quot;Temple of Gold&quot; as e.g. in &quot;How Many Spirals?&quot; or, of course, &quot;The Aztec Temple&quot;, so that this level is definitely worth another try.</div>
+
+<div class="author">Craven</div>
+
+<h4>&quot;I love these big sprawling levels&quot;</h4>
+
+<div class="quote">One of the most interesting aspects of Temple of Gold for me is the paradox of both the need to avoid being pulverized by the Rotor and the need to enlist it in the service of your marble, for without the rotor's ability to fly across the chasm, you can't retrieve your first coin, and without the rotor's intense drive to pursue your marble, you can't enter one of the rooms with an oxyd in it. The other rotors in this level are all malicious, but you need to tame the first rotor to do your bidding, or your efforts will prove futile.</div> 
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_b.png" alt="Level of the month" border="0">
+<div class="imagetitle">
+&quot;Over fields of gold, Far to the south,<br>
+Across the Chasm of the Rotor!<br>
+Just stay by my side,&quot; The rotor replied -<br>
+&quot;If you seek for the first oxyd of Templo Dorado!&quot;</div>
+</div>
+
+<div class="quote">The other make or break moments of this level for me are those that involve pushing puzzle pieces across the chasm with various objects serving as a proxy for the marble (first the 'horse' and then the 'bug'). I found the bug, with its smaller size and lesser density quite a bit harder to control. You need just the right amount of force or you'll tumble into the chasm and the bug might end up floating above it, evermore inaccessible.</div>  
+
+<div class="quote">I love these big sprawling levels - you have a number of objects - coins, a cherry, a seed, a hammer - to gather from rooms that are all quite spread out which have to be employed in other distant locations. You have to find creative ways to deal with the fact that if you use the wood-stones to do what needs to be done, there just aren't enough to allow you to cross the chasm that leads to the rightmost oxyd.</div> 
+
+<div class="quote">I recall the enjoyment I had when I initially discovered the Temple of Gold and set about exploring the various facets, determining how to collect all my equipment and then discovering how all the components fit together to allow me access to the various seemingly unreachable oxyds. And in November, I returned to the Temple of Gold to enjoy exploring its secrets again.</div>
+
+<div class="quote">I recommend that folks just starting out try the easy version of the level first. It will serve as an excellent Geography lesson. I certainly hope that by the end of December, quite a few more marblers will have followed the five of us on this engaging journey!</div> 
+
+<div class="author">Taztunes</div>
+
+<h4>The main theme of the golden challenge &hellip;</h4>
+
+<p>&hellip; seems to be the right use of the wooden stones and the seed. The wooden supplies are strictly limited and you're running quickly short of wood, if you don't act wisely. It is quite interesting to see that besides the &quot;shortcut&quot; previously mentioned by Ronald, both of our imaginative explorers seem to have discovered some sort of &quot;longcut&quot;. Without enough wooden stones available to build a bridge, they managed to push the puzzle piece across the chasm with help of the bug. Craven has told me in private to have experimented with this solution before discovering the &quot;shortcut&quot;.</p>
+
+<p>An appropriate introductory level into the right use of seeds and wooden stones is &quot;Growing Boxes&quot; (II/21). The player has to realize the &quot;destructive&quot; power of the seed to &quot;succeed&quot;. This level also demonstrates the functionality of bridges quite well. An open bridge can't be recognized and just looks like abyss. When a stone is pushed onto it, the bridge closes, and re-opens automatically, when the stone is pushed off again. Thus, the wooden stone for instance doesn't fall into if pushed onto what seems like an abyss. It is crucial for the solution to know that there are (several) bridges near a certain oxyd stone. And there's a way to &hellip; Well, I won't tell anymore, not to spoil your exploring party. But I dare to predict, that equipped with such knowledge, with the beginning of the new year, much more players will have paid a visit to &quot;Temple of Gold&quot;</p>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_n.png" alt="Level of the month" border="0">
+<div class="imagetitle">One more seed would be nice!</div>
+</div>
+
+<p>If there's need for more extensive information, as always in such cases, the &quot;mag.heut.net&quot; forum is a good place to go. If I recall correctly, user &quot;Hairball&quot; has started a thread in the English Tipps &amp; Tricks section. As suggested by Ronald, other informative and entertaining levels, where the player's confronted with the challenge to make wise use of seeds and wooden stones, are the Seed Puzzles I &amp; II (IV/71&amp;74), also written by Jacob. And, of course, &quot;Tool Time&quot; occurs to me, our LotM September, where setting the seed at the right spot also is a central subject.</p>
+
+<p>But the foundation for such technical knowledge is the adjustment of the player's mind to the level that he wants to solve. The mind is a field of opportunity. If it is cultivated the right way, the player will harvest plenty of the fruits of knowledge, for example he'll know all about door_b of the temple without looking at the sacred codes -  or was it without eating the soured cakes? If the field's not cultivated the right way, the player will roll his marble through the most beautiful and amazing landscapes without understanding anything, as if he was rolling evermore in some neverending desert, nothing but fl-sand everywhere, just occasionally the marble stumbles across some st-rock1. Our fellow Daydreamer returned to us from the inner sanctum of the golden temple and told us about some very strange though instructive incident he was granted to observe:</p>
+
+<h4>The Summoning of the Codex of Ultimate Golden Wisdom</h4>
+
+<p>It is said that even the wildest and most cruel of all beasts, the
+dreadful rapid giant rotor rabbit, can be tamed, if the sacred verses of
+the golden twentyfive-fold path are recited by a truly devoted
+marble the right way.</p> 
+
+<p>And it is also said, that if four of such tamed
+beasts will start dancing around the four holy oxydian altars to the
+voice of the sacred verses accompanied by the beats of the holy golden
+hammer, then even those blueish fake stones will illuminate and their
+brightly golden shine will spread all across the temple's halls, and
+from the void in the room where the golden hammer has been kept, the
+Codex of Ultimate Golden Wisdom will rise, and it will reveal to the
+truly devoted seeker the eternal rules of the Golden Path of Level Solving.</p>
+
+<h4>The Golden Path of Level Solving &hellip;</h4>
+
+<div class="quote">&hellip; is the union of eye, mind and mouse - the union of
+your individual intelligence with the level creator's intelligence that
+orchestrates the level.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_l.png" alt="Level of the month" border="0">
+<div class="imagetitle">The followers of the golden path<br>won't get lost in the golden maze!</div>
+</div>
+
+<div class="quote">The Golden Path of Level Solving is a state of being, in which the
+elements and forces that comprise your biological organism are in
+harmonious interaction with the elements and forces that comprise the
+logical organism of the level. Established in this state, you will
+experience enhanced emotional, psychological, and spiritual well-being
+and will increasingly notice the spontaneous enlightenment of the
+level's oxyds.</div>
+
+<div class="quote">As you keep on following the Golden Path of Level Solving, all of your
+worries and even your worst nightmares fall away and you feel a sense of
+lightheartedness and joy. There is a spontaneous  blossoming of
+intuition, insight, imagination, creativity, meaning, and purpose.</div>
+
+<div class="quote">The Golden Path of Level Solving is not an enemy of spiritual awakening
+but rather a potentially helpful friend. December's Level of the Month
+reveals to us, the mysterious nonlocal domain where everything is
+instantly correlated with everything else. Where fl-sahara and
+st-yellow, fl-abyss and st-wood, fl-bridge-open and st-wood,
+it-trigger and st-brownie, st-door_b and it-seed, it-hammer and
+st-rock3_break, it-coin1 and st-coinslot, ac-rotor and it-cherry,
+ac-blackball and ac-bug resolve into a field of pure potentiality.</div>
+
+<div class="quote">&quot;Temple of Gold&quot; is the realm where the immeasurable potential of all
+that was, all that is, and all that ever will be in the world of Enigma,
+manifests and differentiates into the player and the level, the marbler
+and the marble, the oxyd seeker and the oxyd.</div>
+
+<p>These words of wisdom have been brought to us by our noble explorer
+Daydreamer, who reported to have been eye witness to this unbelievable
+ceremony. But due to the soporific effect of this litany he fell asleep,
+and didn't get the rest of the story.</p>
+
+<p>Hardly anyone other would fall asleep in such astonishing and exciting surroundings, 
+as which &quot;Temple of Gold&quot; presents to the attentive explorer. But I hope 
+this - ehm - entertaining narrative has its effect on one or the other reader, 
+in having him made curious to explore the mysteries of the temple on his own.</p>
+
+<p>I dare say that this golden star of level composing arts will shine
+brightly for eternity in the Heaven of Enigma.</p>
+
+<p>In January there will be no &quot;Level of the Month&quot;, because of the 
+&quot;Level of the Year&quot; award, and thus no LotM-article. There won't be
+a special article about the LotY as well, as it is one of the 10
+&quot;excellent&quot; levels of the month, which we already &quot;took a closer
+look at&quot;. Hence, we'll be back in February, when we say for the 11th time:
+&quot;Each month, we take a closer look at excellent Enigma levels&hellip;&quot;
+
+<p>Fare thee well, dear fellow marblers, and IV/2,<br/>
+<i>Harry &amp; Andreas</i></p>
+
+</div>

Added: homepage/input/lotm/lotm_200712_de.html
===================================================================
--- homepage/input/lotm/lotm_200712_de.html	2007-12-08 13:15:45 UTC (rev 934)
+++ homepage/input/lotm/lotm_200712_de.html	2007-12-09 01:58:22 UTC (rev 935)
@@ -0,0 +1,553 @@
+<div class="lotm">
+$$lotm_header$$
+
+<h3 class="lotm">
+<span class="date">Dezember 2007: </span>
+&quot;Temple of Gold&quot;, von Jacob Scott und Ronald Lamprecht
+</h3>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_m.png" alt="Level des Monats" border="0">
+<div class="imagetitle">Enigma VII # 24 'Temple of Gold'<br>Der Whirlpool der antiken G&ouml;ttin</div>
+</div>
+
+<p>Willkommen, liebe Mitmurmler, und lasst uns bitte still schweigen, da wir die
+geheiligten Hallen des &quot;Tempel of Gold&quot; betreten, den Level des Monats
+Dezember. Viele hielten ihn f&uuml;r ein blo&szlig;es M&auml;rchen. Diese
+Skeptiker werden wir widerlegen, indem wir gemeinsam das Innere des Tempels
+erkunden, selbst die R&auml;ume, die als unerreichbar eingesch&auml;tzt wurden,
+selbstverst&auml;ndlich mit dem n&ouml;tigen Respekt vor den altehrw&uuml;rdigen
+Traditionen dieses heiligen Ortes, und mit &auml;u&szlig;erster Vorsicht, um
+nicht in eine der Fallen zu treten, die vor langer Zeit von den Gr&uuml;ndern
+dieses Tempels f&uuml;r unwillkommene G&auml;ste gelegt wurden.</p>
+
+<p>Wir werden geleitet von den Berichten zweier unserer Kollegen, die es nicht nur
+geschafft haben, den goldenen Gefahren des Tempels zu trotzen, sondern sich
+auch Zutritt zu den vier Altarr&auml;umen verschafft und die heiligen oxydischen
+Steine erleuchtet haben. Diese Wagemutigen, wert unserer Bewunderung, sind
+Taztunes und Craven. Auch wurden uns detaillierte Beschreibungen vom Architekten
+dieses Geb&auml;udes zugesandt, dem erstaunlichen Herrn Jacob Scott, und von Herrn
+Ronald Lamprecht, dieses Mal in der Rolle des Sicherheitsbeauftragten. Sp&auml;ter
+wird Mitglied Daydreamer &uuml;ber seine Beobachtungen einer geheimen Zeremonie
+berichten, die im Tempel abgehalten wird.</p>
+
+<table cellpadding="0" cellspacing="1" class="statistics">
+<caption class="normalcaption">Einige Rekorde vom Oktober 2007</caption>
+<colgroup>
+   <col width="80">
+   <col width="160">
+</colgroup>
+    <tr><td class="num">8:53</td>
+        <td class="left">Moneymaker</td></tr>
+    <tr><td class="num">18:20</td>
+        <td class="left">daydreamer</td></tr>
+    <tr><td class="num">22:18</td>
+        <td class="left">Ronald</td></tr>
+    <tr><td class="num">24:20</td>
+        <td class="left">Craven</td></tr>
+    <tr><td class="num">34:23</td>
+        <td class="left">Taztunes</td></tr>
+</table>
+
+<table cellpadding="0" cellspacing="1" class="statistics">
+<caption class="normalcaption">Einfacher Modus</caption>
+<colgroup>
+   <col width="80">
+   <col width="160">
+</colgroup>
+    <tr><td class="num">5:44</td>
+        <td class="left">Moneymaker</td></tr>
+    <tr><td class="num">9:50</td>
+        <td class="left">Craven</td></tr>
+    <tr><td class="num">10:06</td>
+        <td class="left">Ronald</td></tr>
+    <tr><td class="num">11:06</td>
+        <td class="left">Tobias</td></tr>
+    <tr><td class="num">11:37</td>
+        <td class="left">daydreamer</td></tr>
+    <tr><td class="num">16:20</td>
+        <td class="left">para_doks</td></tr>
+    <tr><td class="num">17:53</td>
+        <td class="left">ryujun</td></tr>
+    <tr><td class="num">18:16</td>
+        <td class="left">Mark P.</td></tr>
+    <tr><td class="num">18:29</td>
+        <td class="left">Taztunes</td></tr>
+    <tr><td class="num">22:06</td>
+        <td class="left">dpl</td></tr>
+</table>
+
+<h4>Anstelle erm&uuml;dender statistischer Anh&auml;ufungen, diesmal ein paar kurze
+&quot;Alien Glyphs&quot;:</h4>
+
+<p><img class="leftimage" src="$$imagedir$$/lotm/lotm_200712_ag.png"
+alt="ILCELATTOG" align="left"></p>
+<h4>9.25(8)9.13(8)9.11(9)9.00(5)</h4>
+
+<p>Wie immer finden Sie weitere Details im <a
+href="$$lotm$$">LotM-Archiv</a>.</p>
+
+<h4>Erfahren Sie eine Art der mystischen Empfindung!</h4>
+
+<p>Ich kann mir keinen Level vorstellen, der besser als erste
+Jubil&auml;umsausgabe des LdM-Artikels geeignet w&auml;re, als &quot;Temple of
+Gold&quot;. Zum zehnten Male bereits &quot;werfen wir einen n&auml;heren Blick
+auf einen herausragenden Level&quot;. Weihnachten steht bevor, was ebenso als
+exzellenter Level beschrieben werden kann, wenn auch nicht von enigmatischem
+Ursprung, mit einer starken Betonung auf die Erforschung, nicht nur des Haufens
+von Weihnachtsgeschenken unter dem Baum, sondern auch des Inneren der Seele, wo
+sich gro&szlig;e Haufen an M&uuml;ll w&auml;hrend des Jahres angesammelt haben,
+&Uuml;berbleibsel unsch&ouml;ner Erfahrungen allt&auml;glicher Reibereien. Zu
+dieser fr&ouml;hlichen Gelegenheit ist es doch eine gro&szlig;e Erleichterung,
+schlie&szlig;lich den inneren goldenen Tempel zu betreten und die
+Au&szlig;enwelt hinter sich zu lassen. Und genau dasselbe geschieht,
+w&auml;hrend man Enigmas goldenen Tempel erforscht: Nichts anderes
+z&auml;hlt!</p>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_k.png" alt="Level of the month" border="0">
+<div class="imagetitle">Im schwarzen Panzer, ein runder Landser,<br>
+Den ganzen Tag, die Nacht ebenso,<br> 
+Den Weg entlang rollend, ein Lied anstimmend - <br>
+Auf der Suche nach Templo Dorado.<br>
+</div>
+</div>
+
+<p>Lassen Sie uns die Gelegenheit wahrnehmen, einen Blick zur&uuml;ck auf den
+ersten Level des Monats zu werfen, &quot;Island Labyrinth&quot;, einer weiteren
+herausragenden Kreation von Jacob. &quot;Dieser Level l&auml;sst die
+Realit&auml;t verblassen&quot; schrieb Alejandro &uuml;ber ihn, und meint dabei
+dasselbe, was ich &uuml;ber &quot;Temple of Gold&quot; gerade gesagt habe.
+Andere prominente Statements, die man wortw&ouml;rtlich auch auf &quot;Temple of
+Gold&quot; beziehen kann, lauteten: &quot;St&uuml;ck f&uuml;r St&uuml;ck setzen
+sich die Teile des Puzzles zusammen, wenn man mit der Murmel diese faszinierende
+Landschaft erforscht&quot; (Taztunes) &quot;F&uuml;r mich dr&uuml;ckt dieser
+Level den wahren Geist von Enigma aus&quot; (Ronald) &quot;Es w&auml;re auch
+eine Schande, einfach nur durch diesen sch&ouml;nen Level hindurchzueilen&quot;
+(Ronald) &quot;Einer der einnehmendsten Aspekte dieses Levels ist das durch und
+durch konsistente Design, das Jacob ihm gegeben hat&quot; (Andreas)</p>
+
+<p>Fast alle Spieler, die je einen Blick auf &quot;Island Labyrinth&quot;
+geworfen haben, werden die Stilkombination von st-rock1, fl-water und fl-leaves
+mit diesem Level assoziieren. Und in der selben Weise ist die signifikante
+Kombination von st-yellow und fl-sahara in Zukunft untrennbar verbunden mit
+&quot;Temple of Gold&quot;. Es ist im wesentlichen dieses Farbdesign, das einen
+dazu bringt, eine Form der mystischen Empfindung zu erfahren, der Szenerie
+angemessen.</p>
+
+<h4>&quot;&nbsp;'Temple Of Gold' sollte an eine Art exotischen Tempel
+erinnern&quot;</h4>
+
+<div class="quote">&quot;Temple of Gold&quot; war ein weiterer meiner Versuche,
+wie zuvor &quot;Elaborate&quot;, einen gro&szlig;en erforschungs-orientierten Level zu
+erschaffen. Es war mir daran gelegen, den Schwerpunkt des Levels auf die
+Entdeckung der verschiedenen R&auml;ume und der darin enthaltenen Objekte zu legen,
+ohne dass der Spieler sich allzuviele Sorgen darum machen muss, aus
+irgendwelchen dummen Gr&uuml;nden zu sterben. Daher habe ich nur Weniges hinzugef&uuml;gt,
+was einen vorsichtigen Spieler in Lebensgefahr bringen k&ouml;nnte, wovon das
+Bedrohlichste ein allerdings ziemlich langsamer Rotor in einem der R&auml;ume sein
+d&uuml;rfte, und ich habe die R&auml;ume weitestgehend offen gehalten.</div>
+
+<div class="quote">Die wahre Herausforderung des Levels resultiert aus seiner
+Nonlinearit&auml;t, wobei zun&auml;chst &uuml;berhaupt nicht ersichtlich ist, was an einer
+bestimmten Stelle getan werden muss. Mir bereiten diese konzeptuellen Puzzles
+eine Menge Vergn&uuml;gen, was auch der Grund daf&uuml;r ist, dass ich es f&uuml;r wichtig
+erachtet habe, einen Level zu gestalten, der den Spieler dazu bringt, sich
+sowohl mit der Kugel als auch gedanklich von Raum zu Raum zu bewegen, anstatt
+sich nur auf naheliegende Objekte zu konzentrieren, um die Herausforderungen
+bew&auml;ltigen zu k&ouml;nnen, wie auch immer ich diese im jeweiligen Fall gestaltet
+haben mag.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_c.png" alt="Level of the month" border="0">
+<div class="imagetitle">Indiana Murmel &amp; Shorty Rund: <br>
+Die Flucht aus der Grube der Gefangenen</div>
+</div>
+
+<div class="quote">Ebenso sollte &quot;Temple of Gold&quot; an eine Art
+exotischen Tempel erinnern, mit zahlreichen Hindernissen, welche die
+offensichtlichsten Wege zur weiteren Erkundung versperren. In diesem Sinne hielt
+ich die R&auml;ume gr&ouml;&szlig;tenteils offen und frei von allem Unwesentlichen, um den Level
+gro&szlig; und klar strukturiert erscheinen zu lassen.</div>
+
+<div class="quote">Ebenso habe ich ausschlie&szlig;lich Objekte verwendet, die man
+auch dort erwarten w&uuml;rde (nat&uuml;rlich im typischen
+Tempelkundschaftersinn, und nicht etwa auf's wirkliche Leben bezogen), wie
+beispielsweise Abgr&uuml;nde, einen Hammer, mehrere Wachen, und braune oder
+h&ouml;lzerne, verschiebbare Steine.</div>
+
+<div class="quote">Zusammen genommen sollten all diese Requisiten dem Spieler
+ein Gef&uuml;hl des Erforschens vermitteln, ohne dass dieser sich darum
+k&uuml;mmern muss, irgendwelche trivialen Gefahren zu vermeiden oder
+irgendwelche stupiden R&auml;tsel zu l&ouml;sen, was den sch&ouml;nen Effekt
+wieder ruinieren w&uuml;rde.</div>
+
+<div class="quote">Insgesamt betrachtet, bin ich sehr zufrieden mit dem, was aus
+dem Level geworden ist. Ich denke, die Illusion, sich in einem exotischen Tempel
+zu befinden, wird ganz passabel hergestellt, und &quot;Temple Of Gold&quot; ist,
+was die Schwierigkeit anbelangt, ziemlich fair und ausgewogen, ohne dass
+irgendein Abschnitt zu leicht oder zu schwierig geraten w&auml;re, au&szlig;erdem bekommt
+der Spieler abwechslungs- und zahlreiche Puzzles geboten. Er setzt das Thema von
+&quot;Elaborate&quot; fort, aber an einem interessanteren und
+aufsehenerregenderen Schauplatz. Ich hoffe, dass alle Enigma-Spieler, die sich
+an &quot;Temple Of Gold&quot; heranwagen, beim Spielen und Erforschen genauso
+viel Vergn&uuml;gen finden werden, wie ich beim Verfassen des Levels.</div>
+
+<div class="quote">Weiterhin m&ouml;chte ich Ronald f&uuml;r seine Hilfe bei der
+Vervollst&auml;ndigung dieses Levels danken, insbesondere beim &quot;normalen
+Modus&quot;. Anf&auml;nglich gab es einige Shortcuts, die dazu verwendet werden
+konnten, den Level schneller zu beenden als ich es beabsichtigt hatte, und
+Ronald hat nicht nur geeignete M&ouml;glichkeiten gefunden, diese zu patchen, sondern
+hat dar&uuml;ber hinaus noch weitere Herausforderungen zum &quot;normalen Modus&quot;
+hinzugef&uuml;gt, alle noch zum Themenbereich geh&ouml;rend, um ihn zu
+komplettieren.</div>
+
+<div class="quote">Ich halte den Tempel, zumindest die exotische Art (wie sie
+auch schon in diversen Abenteuerb&uuml;chern und -filmen f&uuml;r das breite Publikum
+dargestellt worden ist), f&uuml;r einen gro&szlig;artigen Schauplatz als zentrales Thema
+f&uuml;r einen Level, vor allem des Geheimnisvollen wegen, das einen solchen Ort
+umrankt.</div>
+
+<div class="quote">Ich bin zwar nicht von irgendeiner bestimmten Vorlage
+inspiriert worden, habe mich aber von der allgemeinen Vorstellung von Intrige
+und Exploration leiten lassen, die unweigerlich mit solch einer St&auml;tte verbunden
+ist, insbesondere mit einer erst k&uuml;rzlich entdeckten, vor Urzeiten von einer
+l&auml;ngst untergegangenen Zivilisation erbauten, die nur darauf wartet,
+erforscht zu werden.</div>
+
+<div class="author">Jacob Scott</div>
+
+<p>Tats&auml;chlich erweist sich der &quot;Difficult Mode&quot; als eine keinesfalls
+&quot;einfache&quot; Aufgabe, und diejenigen Spielern, die beispielsweise mal
+&quot;Houdini&quot;, einen weiteren &quot;exzellenten Enigmalevel&quot;
+angespielt haben, werden sofort wiedererkennen, wer da seine Hand im Spiel
+hatte. Doch trotz all seiner Bem&uuml;hungen, hat er noch etwas &uuml;bersehen, doch,
+okay, lassen wir's uns von ihm selbst erz&auml;hlen:</p>
+
+<h4>&quot;Dies k&ouml;nnte der erste Level sein, der sehr verschiedene L&ouml;sungen f&uuml;r
+einfachen und schwierigen Modus ben&ouml;tigt&quot;</h4>
+
+<div class="quote">Ich habe die urspr&uuml;ngliche Version dieses Levels in einem
+B&uuml;ndel von im wesentlichen fertigen, aber unbetitelten Levels von Jacob
+bekommen, zum Auffinden von Abk&uuml;rzungen und um Vorschl&auml;ge f&uuml;r die Titel zu
+machen. Ich war von Anfang an fasziniert von diesem Level. Keine eng gepackten
+R&auml;ume, sondern majest&auml;tische Korridore mit gelegentlichen, einzigartigen
+Herausforderungen. Ein Level zum Erforschen, g&auml;nzlich ohne versteckte Objekte,
+dass durch das einzigartige Farbschema und das gemeinsame blaue Oxydmuster
+besticht.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_o.png" alt="Level of the month" border="0">
+<div class="imagetitle">Ich muss einen Weg finden, <br>
+das arme Pferd loszubinden!</div>
+</div>
+
+<div class="quote">Als ich rechts einen v&ouml;llig leeren Raum gesehen hatte, musste
+ich einfach ein fertiges Muster mit einem blauen Pferd an goldenem Brownie-Stein
+anbieten. Es passte perfekt in den vorhandenen Graben und das R&auml;tsel.</div>
+
+<div class="quote">Aber die verbleibende Aufgabe war es, die Abk&uuml;rzungen im
+&uuml;berspannenden Ablaufplan zu flicken. Meine L&ouml;sung war das Hinzuf&uuml;gen des
+goldenen Puzzlesteins um eines der blauen Oxydmuster. Aber jetzt war ich
+unzufrieden mit dem linken und s&uuml;dlichen Oxydmuster, die v&ouml;llig leer waren. Es
+hat mir richtig Spa&szlig; gemacht, nach verschiedenen Herausforderungen zu suchen,
+die auf dieses vorgegebene Oxydmuster passen.</div>
+
+<div class="quote">Doch die zwei letzten Aufgaben erforderten wieder ein anderes
+Storyboard. Die L&ouml;sung war, zwei Modi anzubieten. Ein einfacher Modus nach dem
+urspr&uuml;nglichen Plan, der einige der neu hinzugef&uuml;gten Herausforderungen umgeht.
+Und ein schwieriger Modus, der die neuen Aufgaben enth&auml;lt und auf einem v&ouml;llig
+anderen Storyboard basiert. Dies k&ouml;nnte der erste Level sein, der sehr
+verschiedene L&ouml;sungen f&uuml;r einfachen und schwierigen Modus ben&ouml;tigt - man sollte
+hier wirklich beide spielen!</div>
+
+<div class="quote">Leider haben selbst mehrere Augenpaare eine weitere
+Geschicklichkeitsabk&uuml;rzung &uuml;bersehen. Spieler &quot;Moneymaker&quot; hat uns
+einen Bericht geschickt. Aber ein Blick auf die Scores verr&auml;t, dass
+offensichtlich niemand au&szlig;er ihm diese Abk&uuml;rzung gefunden und benutzt hat. Die
+Reparatur war einfach und ist unsichtbar. Sie wird im n&auml;chsten Release von
+Enigma sicherlich enthalten sein.</div>
+
+<div class="author">Ronald Lamprecht</div>
+
+<p>Der aufmerksame Leser wird sich daran erinnern, dass der Name
+&quot;Moneymaker&quot; bereits in der Rekordliste erw&auml;hnt wurde. Geradewegs
+rasend durch den silbernen wie den goldenen Tempel, mit unglaublich hoher
+Geschwindigkeit, setzte er Rekorde f&uuml;r die Ewigkeit, aber ich wage zu
+behaupten, dass er nicht allzu viel der mystischen Empfindungen erfahren hat,
+die der Tempel dem achtsamen Forscher bietet!</p>
+
+<p>Leser, die an Statistiken und Tabellen interessiert sind, m&ouml;gen mehr &uuml;ber
+den &quot;Michael Schumacher&quot; der Formel Enigma auf der <a
+href="$$statistics$$">Statistikseite</a> finden.
+Ganz oben auf der aktuellen &quot;Solved Level Statistics&quot; finden wir auch 
+die Namen jener zwei tapferen Forscher, die siegreich aus dem goldenen Tempel
+zur&uuml;ckgekehrt sind und der Enigmischen Nation &uuml;ber ihre Abenteuer berichten
+wollen. Taztunes und Craven, w&uuml;rden Sie bitte &uuml;bernehmen?</p>
+
+<h4>&quot;Es gibt praktisch hunderte von L&ouml;sungsans&auml;tzen, von denen nur ein
+einziger funktioniert&quot;</h4>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_p.png" alt="Level of the month" border="0">
+<div class="imagetitle">
+Und als er, ohne Kraft, v&ouml;llig geschafft,<br>
+einen wandernden Rotor noch fand, geradeso,<br>
+sprach er drein: &quot;Rotor, wo k&ouml;nnen sie sein -<br>
+Die Oxyds im Templo Dorado?&quot;<br>
+</div>
+</div>
+
+<div class="quote">Dieser Level hat von allem etwas: gef&auml;hrliche Passagen, in
+denen man geschickt man&ouml;vrieren muss, und vor allen Dingen ein komplexes R&auml;tsel,
+das einen hin und wieder zum verzweifeln bringt.</div>
+
+<div class="quote">Mit dem einfachen Modus hatte ich eigentlich keine gr&ouml;&szlig;eren
+Schwierigkeiten, da in fast allen R&auml;umen offensichtlich war, was getan werden
+musste. Allein die Barriere, die auf dem Titelbild (Screenshot) zu sehen ist,
+schien un&uuml;berwindbar, bis ich endlich den richtigen &quot;Schl&uuml;ssel&quot;
+gefunden hatte.</div>
+
+<div class="quote">An den schweren Modus ging ich deshalb auch recht
+optimistisch heran, um jedoch schnell festzustellen, dass sich doch mehr
+ge&auml;ndert hatte, als ich dachte: Die Oxyds waren zwar immer noch an denselben
+Stellen und die wesentlichen L&ouml;sungsschritte waren ebenfalls erhalten geblieben,
+aber es gab auch einige fiese &Uuml;berraschungen, wie z. B. pl&ouml;tzlich auftauchende
+Bodenplatten oder eine eigentlich offene T&uuml;r, die aber keine beweglichen Steine
+durchlie&szlig; (dasselbe Erlebnis hatte ich auch schon bei
+&quot;Houdini&quot;!).</div>
+
+<div class="quote">Dadurch, dass es praktisch hunderte von L&ouml;sungsans&auml;tzen gibt,
+von denen aber auch wirklich nur ein einziger funktioniert, ist der Frustfaktor
+extrem hoch, so dass ich durchaus verstehen kann, dass dieser Level offenbar nur
+von wenigen Leuten gel&ouml;st wurde. Allerdings muss man in &quot;Temple of
+Gold&quot; nicht so geschickt sein wie z. B. in &quot;How Many Spirals?&quot;
+oder nat&uuml;rlich &quot;The Aztec Temple&quot;, so dass dieser Level mit Sicherheit
+einen weiteren Versuch verdient.</div>
+
+<div class="author">Craven</div>
+
+<h4>&quot;Ich mag diese weit ausgedehnten Level&quot;</h4>
+
+<div class="quote">Einer der interessantesten Aspekte von &quot;Temple of
+Gold&quot; ist f&uuml;r mich das Paradoxon, dass man einerseits vermeiden muss, dem
+Rotor zu nahe zu kommen, um nicht pulverisiert zu werden, er aber andererseits
+ganz weit oben auf der Liste der Tempelbewohner steht, deren Dienste man
+dringend ben&ouml;tigt, denn ohne die F&auml;higkeit des Rotors &uuml;ber Schluchten hinweg
+fliegen zu k&ouml;nnen, kann man nicht in den Besitz der ersten M&uuml;nze gelangen, und
+w&auml;re da nicht das heftige Verlangen des Rotors der Murmel nachzustellen, so g&auml;be
+es keine M&ouml;glichkeit, einen bestimmten der Oxydr&auml;ume zu betreten. Die anderen
+Rotoren in diesem Level sind alle b&ouml;sartig, aber man muss den ersten Rotor
+z&auml;hmen und ihn dazu bringen, seinen Anweisungen Folge zu leisten, oder aber alle
+M&uuml;he wird vergeblich sein.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_b.png" alt="Level of the month" border="0">
+<div class="imagetitle">
+&quot;&Uuml;ber Felder aus Gold, weit im S&uuml;den,<br>
+Und &uuml;ber die Schlucht des Rotors, also<br>
+Bleib' bei mir, immerfort,&quot; das war des Rotors Antwort -<br>
+&quot;Suchst Du den ersten Oxyd des Templo Dorado!&quot;</div>
+</div>
+
+<div class="quote">Die anderen &quot;Alles-oder-Nichts&quot;-Momente in diesem
+Level waren f&uuml;r mich diejenigen, die etwas damit zu tun haben, das Puzzlest&uuml;ck
+&uuml;ber die Schlucht zu bef&ouml;rdern, wobei verschiedene Objekte als Stellvertreter
+f&uuml;r die Murmel dienten (zuerst das Pferd und dann der &quot;Bug&quot;). Ich
+fand, dass der &quot;Bug&quot; durch seine geringere Gr&ouml;&szlig;e und seine niedrigere
+Dichte schwieriger zu kontrollieren war. Man muss genau die passende Stosskraft
+anwenden, oder man stolpert in den Abgrund und der &quot;Bug&quot; endet &uuml;ber
+demselben schwebend, f&uuml;r immer unerreichbar.</div>
+
+<div class="quote">Ich mag diese weit ausgedehnten Level. Man muss eine
+bestimmte Anzahl von Objekten (2 M&uuml;nzen, 1 Kirsche, 1 Samen, 1 Hammer) in R&auml;umen
+auflesen, die weit auseinander liegen, um diese dann an ebenso weit entfernt
+liegenden Lokalit&auml;ten anzuwenden. Man muss schon recht erfinderisch sein, um der
+Tatsache begegnen zu k&ouml;nnen, dass, wenn man mithilfe der Holzsteine "getan hat,
+was getan werden musste", es nicht mehr gen&uuml;gend davon gibt, um eine Br&uuml;cke &uuml;ber
+die Schlucht bauen zu k&ouml;nnen, jenseits von welcher sich das am weitesten rechts
+liegende Oxyd befindet.</div>
+
+<div class="quote">Ich kann mir noch gut die freudige Erregung vergegenw&auml;rtigen,
+die ich versp&uuml;rt habe, als ich zum ersten Mal &quot;Temple of Gold&quot;
+entdeckte, und mich daranmachte, die verschiedenen Facetten zu erkunden, die
+entscheidend daf&uuml;r sind, wie die Ausr&uuml;stungsgegenst&auml;nde aufgesammelt werden
+m&uuml;ssen, und daraufhin zu entdecken, wie all die einzelnen Komponenten
+zusammenpassten, um mir schliesslich Zugang zu den einzelnen, scheinbar
+unerreichbaren Oxyds zu gew&auml;hren. Und im November bin ich dann zum goldenen
+Tempel zur&uuml;ckgekehrt, um noch einmal die Erkundung seiner Geheimnisse zu
+genie&szlig;en.</div>
+
+<div class="quote">Ich kann denen, die gerade erst mit der Erforschung des
+Tempels beginnen, nur empfehlen, zuerst den einfachen Modus zu spielen. Dies
+wird sich als eine vorz&uuml;gliche Geographie-Lektion erweisen. Ich hoffe, dass bis
+Ende Dezember noch eine ganze Reihe von Murmelspielern uns F&uuml;nfen auf der Reise
+durch diesen das Herz im Sturm erobernden Level gefolgt sein werden.</div>
+
+<div class="author">Taztunes</div>
+
+<h4>Das Hauptthema der goldenen Herausforderung &hellip;</h4>
+
+&hellip; scheint der richtige Gebrauch von Holzsteinen und Samen zu sein. Der
+h&ouml;lzerne Vorrat ist strikt begrenzt und man wird schnell knapp an Holz,
+wenn man nicht weise vorgeht. Es ist sehr interessant, dass, neben der
+&quot;Abk&uuml;rzung&quot;, die Ronald erw&auml;hnt hat, unsere beiden
+einfallsreichen Forscher eine Art von &quot;Abl&auml;ngerung&quot; entdeckt zu
+haben scheinen. Ohne &uuml;ber gen&uuml;gend Holzsteine zum Bau einer
+Br&uuml;cke zu verf&uuml;gen, haben sie es geschafft, das Puzzlest&uuml;ck
+&uuml;ber den Abgrund zu bringen, mit Hilfe des Bugs. Craven hat mir privat
+berichtet, dass er mit dieser L&ouml;sung experimentiert hat, bevor er die
+&quot;Abk&uuml;rzung&quot; entdeckt hat.</p>
+
+<p>Ein angemessener Einstiegslevel in die richtige Verwendung von Samen und
+Holzsteinen ist &quot;Growing Boxes&quot; (II/21). Der Spieler muss die
+&quot;destruktive&quot; Kraft eines Samen realisieren, um Erfolg zu haben.
+Dieser Level demonstriert auch die Funktion der Br&uuml;cken recht gut. Eine
+offene Br&uuml;cke kann nicht als solche gesehen werden, und sieht aus wie
+Abgrund. Wenn man einen Stein auf sie schiebt, schlie&szlig;t sich die
+Br&uuml;cke, und &ouml;ffnet sich von selbst erneut, wenn der Stein wieder
+heruntergeschoben wird. Folglich f&auml;llt beispielsweise ein Holzstein nicht
+in den scheinbaren Abgrund. Es ist wichtig f&uuml;r die L&ouml;sung, zu wissen,
+dass es (mehrere) Br&uuml;cken nahe einem bestimmten Oxydstein gibt. And es gibt
+eine M&ouml;glichkeit, um &hellip; Nun, ich werde nicht mehr verraten, um nicht die
+Erforschungsparty zu verderben. Aber ich wage vorherzusehen, dass,
+ausger&uuml;stet mit diesem Wissen, mit dem Beginn des neuen Jahres viel mehr
+Spielers dem &quot;Temple of Gold&quot; einen Besuch abgestattet haben
+werden.</p>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_n.png" alt="Level of the month" border="0">
+<div class="imagetitle">Noch ein Samen w&auml;re praktisch!</div>
+</div>
+
+<p>Falls Bedarf besteht f&uuml;r ausf&uuml;hrlichere Informationen, ist
+&quot;mag-heut.net&quot; wie immer in solchen F&auml;llen ein gutes Ziel. Wenn ich
+mich recht entsinne, hat der Spieler &quot;Hairball&quot; einen Threat auf der
+englischen Tipps&amp;Tricks-Seite begonnen. Ronald schl&auml;gt als weitere
+informative und unterhaltende Level, in denen der Spieler mit der Aufgabe
+konfrontiert wird, weise mit Samen und Holzsteinen umzugehen, Seed Puzzles I
+&amp; II (IV/71&amp;74) vor, der ebenfalls von Jacob stammt. Und nat&uuml;rlich
+denke ich da auch an &quot;Tool Time&quot;, unserem LdM September, in dem das
+Setzen eines Samen an die richtige Stelle ebenfalls von zentraler Bedeutung
+ist.</p>
+
+<p>Aber die Grundlage f&uuml;r solch technisches Wissen ist die innere
+Einstellung des Spielers zu dem Level, den er gerade zu l&ouml;sen
+beabsichtigt. Der menschliche Geist ist ein Feld voller M&ouml;glichkeiten:
+In der rechten Weise kultiviert, wird es dem Spieler eine reiche Ernte
+an den Fr&uuml;chten der Erkenntnis bescheren. Zum Beispiel wird er in der
+Lage sein, die Bedeutung von T&uuml;r B im Tempel unmittelbar zu erfassen,
+ohne in den &quot;Heiligen Schriften&quot; nachsehen zu m&uuml;ssen, und ohne vorher
+irgendwelche &quot;soured cakes&quot; zu verzehren.</p>
+
+<p>Wenn er das Feld brach liegen l&auml;sst, wird der Spieler die Murmel
+durch die erstaunlichsten und sch&ouml;nsten Landschaften rollen lassen, ohne
+auch nur das Allergeringste davon mitzubekommen, und es ist dann gerade
+so, als ob er in einer endlosen W&uuml;stenlandschaft umherirren w&uuml;rde,
+nichts als fl-sand, wohin auch immer das Auge blickt, nur hin und wieder
+stolpert die Murmel gegen einen st-rock1. Unser Murmelspielgef&auml;hrte
+Daydreamer ist aus dem innersten Heiligtum des goldenen Tempels
+zur&uuml;ckgekehrt, und hat uns eine sehr merkw&uuml;rdige, aber dennoch irgendwie
+lehrreiche Begebenheit geschildert, die ihm an diesem Ort zu beobachten
+verg&ouml;nnt war:</p>
+
+<h4>Die Anrufung des Codex der H&ouml;chsten Goldenen Weisheit</h4>
+
+<p>Man sagt, dass sogar das wildeste und grausamste aller Tiere, der
+schreckliche, schnelle, kaninchenartige Riesenrotor gez&auml;hmt werden kann,
+wenn die heiligen Verse des goldenen f&uuml;nfundzwanzigff&auml;ltigen Pfades von
+einer wahrhaft hingebungsvollen Murmel in der rechten Art und Weise
+rezitiert werden.</p>
+
+<p>Desweiteren wird gesagt, dass wenn vier dieser auf die eben
+beschriebene Weise gez&auml;hmten Bestien an den vier heiligen Oxydaltaren
+zur gleichen Zeit das Ritual des heiligen Tanzes zelebrieren, geleitet
+von den Harmonien der heiligen Verse und den Rhythmen des Goldenen
+Hammers, dass dann die bl&auml;ulichen Scheinoxydsteine zu leuchten beginnen
+werden, und dass wenn ihr goldenes Strahlen s&auml;mtliche Gew&ouml;lbe des
+Tempels durchdrungen hat, dass dann aus den Untiefen des Abgrundes in
+dem Raum, in dem der heilige goldene Hammer aufbewahrt wurde, der Kodex
+der H&ouml;chsten Goldenen Weisheit erscheinen wird, und dem wahrhaft
+hingebungsvoll Suchenden die ewigw&auml;hrenden Regeln des &quot;Goldenen Pfades
+des Level L&ouml;sens&quot; offenbaren werden.</p>
+
+<h4>Der Goldenen Pfad des Level L&ouml;sens &hellip;</h4>
+
+<div class="quote">&hellip; ist die Einheit von Auge, Geist und Maus - die
+Einheit Ihrer individuellen Intelligenz mit der den Level
+orchestrierenden Intelligenz des Levelsch&ouml;pfers.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_l.png" alt="Level of the month"
+border="0">
+<div class="imagetitle">Wer dem goldenen Pfad folgt, <br/>der wird auch
+den Weg <br/>durch den goldenen Irrgarten finden!</div>
+</div>
+
+<div class="quote">&quot;Der Goldene Pfad des Level L&ouml;sens&quot; ist ein
+Bewusstseinszustand, in dem sich die Elemente und Kr&auml;fte, die den
+biologischen Aufbau Ihres Organismus ausmachen, in harmonischer
+Interaktion mit den Elementen und Kr&auml;ften befinden, die den logischen
+Aufbau des Levels ausmachen. Wenn Sie sich in diesem Zustand befinden,
+werden Sie ein gesteigertes Wohlbefinden erfahren, sowohl in emotionaler
+als auch in psychischer und spiritueller Hinsicht, und sie werden eine
+deutlich gesteigerte F&auml;higkeit erleben, die Oxydsteine spontan
+aufleuchten lassen zu k&ouml;nnen.</div>
+
+<div class="quote">Wenn Sie dem &quot;Goldenen Pfad des Level L&ouml;sens&quot; weiter
+folgen, werden all Ihre Sorgen und selbst Ihre schlimmsten Albtr&auml;ume
+aufh&ouml;ren Sie zu belasten, und Sie werden ein Gef&uuml;hl der Unbeschwertheit
+und Freude empfinden. Sie werden ein Aufbl&uuml;hen von Intuition und
+Einsicht, von Imagination und Kreativit&auml;t, und von Sinn und Zweck
+erleben.</div>
+
+<div class="quote">&quot;Der Goldene Pfad des Level L&ouml;sens&quot; ist nicht etwa
+ein Gegner des spirituellen Erwachens, sondern ganz im Gegenteil ein
+ungemein hilfreicher Freund. Der Level des Monats Dezember offenbart uns
+jenen geheimnisvollen, nicht zu dieser Welt geh&ouml;renden Bereich, in dem
+unmittelbar Alles mit Allem verkn&uuml;pft ist. Wo fl-sahara und st-yellow,
+fl-abyss und st-wood, fl-bridge-open und st-wood, it-trigger und
+st-brownie, st-door_b und it-seed, it-hammer und st-rock3_break,
+it-coin1 und st-coinslot, ac-rotor und it-cherry, ac-blackball und
+ac-bug sich in einem Feld schier unbegrenzter L&ouml;sungsm&ouml;glichkeiten
+zusammenfinden.</div>
+
+<div class="quote">&quot;Temple of Gold&quot; ist der Bereich, in dem
+sich das unermessliche Potential von Allem, was war, was ist, und was
+jemals sein wird in der Welt von Enigma, manifestiert, und sich zum
+Levell&ouml;senden und dem Level differenziert, zum Murmelspieler und der
+Murmel, zum Oxydsuchenden und dem Oxyd.</div>
+
+<p>Wie schon einleitend erw&auml;hnt sind uns diese Worte der Weisheit von
+unserem werten Forschungsreisenden Daydreamer &uuml;berbracht worden, der
+berichtet, Augenzeuge dieser unglaublichen Zeremonie gewesen zu sein.
+Aber aufgrund der einschl&auml;fernden Wirkung dieser Litanei hat er den
+weiteren Verlauf der Geschichte leider nicht verfolgen k&ouml;nnen.</p>
+
+<p>Kaum sonst jemandem wird es gelingen, in dieser erstaunlichen und
+aufregenden Umgebung einzuschlafen, die &quot;Temple of Gold&quot; dem
+aufmerksamen Forscher pr&auml;sentiert. Aber ich hoffe, dass diese - &auml;hm -
+vielleicht als unterhaltsam zu bezeichnende Anekdote, doch den einen
+oder anderen Leser neugierig darauf gemacht hat, die Geheimnisse des
+Tempels selbst zu erkunden.</p>
+
+<p>Ich glaube, ich gehe kein allzu gro&szlig;es Wagnis ein, wenn ich behaupte,
+dass dieser goldene Stern der Levelkompositionskunst, noch unz&auml;hlbare
+Releases hell am Firmament von Enigma erstrahlen wird.</p>
+
+<p>Im Januar wird es wegen der &quot;Level des Jahres&quot; Auszeichnung
+keinen &quot;Level des Monats&quot; geben, und demzufolge auch keinen
+LdM Artikel. Auch &uuml;ber den LdJ wird es keinen Extra-Bericht geben, da es
+ja einer der 10 &quot;herausragenden&quot; Level des Monats sein wird, auf die wir
+schon einen &quot;n&auml;heren Blick&quot; geworfen haben. Wir sind im Februar wieder
+da, wenn es dann zum 11ten Mal hei&szlig;en wird: &quot;Jeden Monat werfen wir
+einen n&auml;heren Blick auf einen herausragenden Level &hellip;&quot;</p>
+
+<p>Bleibt auf dem goldenen Pfad, gesch&auml;tzte Murmelspielergef&auml;hrten,<br/>
+und schon mal IV/2,<br/>
+<i>Harry &amp; Andreas</i></p>
+
+<object data="http://enigma-game.berlios.de/lotm_200712_de_counter.php">
+</object>
+
+</div>

Modified: homepage/input/lotm/lotm_archive_data.lua
===================================================================
--- homepage/input/lotm/lotm_archive_data.lua	2007-12-08 13:15:45 UTC (rev 934)
+++ homepage/input/lotm/lotm_archive_data.lua	2007-12-09 01:58:22 UTC (rev 935)
@@ -85,22 +85,33 @@
   position_num   = "4100"
 }
 
+lotm_archive_data[10] = {
+  date           = { month = 12, year = 2007 },
+  chronological  = 10,
+  name           = "Temple of Gold",
+  author         = "J.Scott, R.Lamprecht",
+  position       = "VII/24",
+  position_num   = "7024"
+}
+
+
 -- LotM variable data
 -- format: Level Title, current_rating, current_votes, additional text
 
-lotm_rating(    "Island Labyrinth",  9.25,   8,  "(1 up)")
+lotm_rating(    "Island Labyrinth",  9.25,   8,  "")
 lotm_rating(  "Pneumatic Delivery",  7.77,  13,  "")
-lotm_rating(    "The Aztec Temple",  9.13,   8,  "")
+lotm_rating(    "The Aztec Temple",  9.13,   8,  "(1 up)")
 lotm_rating("Labyrinth of Puzzles",  8.92,  13,  "")
 lotm_rating(           "Elaborate",  8.63,   8,  "")
 lotm_rating(             "Houdini",  8.86,  10,  "")
 lotm_rating(           "Tool Time",  8.50,  16,  "")
-lotm_rating(         "Quadropolis",  9.25,   8,  "")
-lotm_rating(      "Big Adventures",  8.40,  15,  "<b>(newcomer)</b>")
+lotm_rating(         "Quadropolis",  9.11,   9,  "(2 down)")
+lotm_rating(      "Big Adventures",  8.33,  18,  "")
+lotm_rating(      "Temple of Gold",  9.00,   5,  "<b>(newcomer)</b>")
 
 -- Don't forget to adjust the archive dates:
 
-lotm_archive_data_from = { month = 9, year = 2007 }
+lotm_archive_data_from = { month = 10, year = 2007 }
 
 lotm_current = lotm_archive_data[table.getn(lotm_archive_data)]
 



From raoul at mail.berlios.de  Sun Dec  9 12:21:51 2007
From: raoul at mail.berlios.de (raoul at BerliOS)
Date: Sun, 9 Dec 2007 12:21:51 +0100
Subject: [Enigma-game-svn] r936 - homepage/input/lotm
Message-ID: <200712091121.lB9BLpOx027664@sheep.berlios.de>

Author: raoul
Date: 2007-12-09 12:21:51 +0100 (Sun, 09 Dec 2007)
New Revision: 936

Modified:
   homepage/input/lotm/lotm_200712.html
   homepage/input/lotm/lotm_200712_de.html
Log:
-> Validated html


Modified: homepage/input/lotm/lotm_200712.html
===================================================================
--- homepage/input/lotm/lotm_200712.html	2007-12-09 01:58:22 UTC (rev 935)
+++ homepage/input/lotm/lotm_200712.html	2007-12-09 11:21:51 UTC (rev 936)
@@ -161,7 +161,7 @@
 
 <div class="lotmpic">
 <img src="$$imagedir$$/lotm/lotm_200712_o.png" alt="Level of the month" border="0">
-<div class="imagetitle">This horse will be <br/>of good service to me, <br/>if I can set it free!</div>
+<div class="imagetitle">This horse will be <br>of good service to me, <br>if I can set it free!</div>
 </div>
 
 <div class="quote">Seeing a totally empty room on the right I had to offer a ready pattern 
@@ -334,7 +334,7 @@
 look at&quot;. Hence, we'll be back in February, when we say for the 11th time:
 &quot;Each month, we take a closer look at excellent Enigma levels&hellip;&quot;
 
-<p>Fare thee well, dear fellow marblers, and IV/2,<br/>
+<p>Fare thee well, dear fellow marblers, and IV/2,<br>
 <i>Harry &amp; Andreas</i></p>
 
 </div>

Modified: homepage/input/lotm/lotm_200712_de.html
===================================================================
--- homepage/input/lotm/lotm_200712_de.html	2007-12-09 01:58:22 UTC (rev 935)
+++ homepage/input/lotm/lotm_200712_de.html	2007-12-09 11:21:51 UTC (rev 936)
@@ -388,7 +388,7 @@
 
 <h4>Das Hauptthema der goldenen Herausforderung &hellip;</h4>
 
-&hellip; scheint der richtige Gebrauch von Holzsteinen und Samen zu sein. Der
+<p>&hellip; scheint der richtige Gebrauch von Holzsteinen und Samen zu sein. Der
 h&ouml;lzerne Vorrat ist strikt begrenzt und man wird schnell knapp an Holz,
 wenn man nicht weise vorgeht. Es ist sehr interessant, dass, neben der
 &quot;Abk&uuml;rzung&quot;, die Ronald erw&auml;hnt hat, unsere beiden
@@ -480,8 +480,8 @@
 <div class="lotmpic">
 <img src="$$imagedir$$/lotm/lotm_200712_l.png" alt="Level of the month"
 border="0">
-<div class="imagetitle">Wer dem goldenen Pfad folgt, <br/>der wird auch
-den Weg <br/>durch den goldenen Irrgarten finden!</div>
+<div class="imagetitle">Wer dem goldenen Pfad folgt, <br>der wird auch
+den Weg <br>durch den goldenen Irrgarten finden!</div>
 </div>
 
 <div class="quote">&quot;Der Goldene Pfad des Level L&ouml;sens&quot; ist ein
@@ -543,8 +543,8 @@
 da, wenn es dann zum 11ten Mal hei&szlig;en wird: &quot;Jeden Monat werfen wir
 einen n&auml;heren Blick auf einen herausragenden Level &hellip;&quot;</p>
 
-<p>Bleibt auf dem goldenen Pfad, gesch&auml;tzte Murmelspielergef&auml;hrten,<br/>
-und schon mal IV/2,<br/>
+<p>Bleibt auf dem goldenen Pfad, gesch&auml;tzte Murmelspielergef&auml;hrten,<br>
+und schon mal IV/2,<br>
 <i>Harry &amp; Andreas</i></p>
 
 <object data="http://enigma-game.berlios.de/lotm_200712_de_counter.php">



From andreasl at mail.berlios.de  Sun Dec  9 16:38:15 2007
From: andreasl at mail.berlios.de (andreasl at BerliOS)
Date: Sun, 9 Dec 2007 16:38:15 +0100
Subject: [Enigma-game-svn] r937 - homepage/input/lotm
Message-ID: <200712091538.lB9FcFpG031234@sheep.berlios.de>

Author: andreasl
Date: 2007-12-09 16:38:15 +0100 (Sun, 09 Dec 2007)
New Revision: 937

Modified:
   homepage/input/lotm/lotm_200712.html
   homepage/input/lotm/lotm_200712_de.html
Log:
LotM:
 - Add remark that it's possible to cross
   the chasm without the bug.
 - Change poem in German version.
Todo:
 - Russian translation of remark.


Modified: homepage/input/lotm/lotm_200712.html
===================================================================
--- homepage/input/lotm/lotm_200712.html	2007-12-09 11:21:51 UTC (rev 936)
+++ homepage/input/lotm/lotm_200712.html	2007-12-09 15:38:15 UTC (rev 937)
@@ -245,6 +245,9 @@
 
 <div class="author">Taztunes</div>
 
+<p>By the way, it's indeed possible to ration the wood stones in such a way
+that one doesn't need the bug at the chasm.</p>
+
 <h4>The main theme of the golden challenge &hellip;</h4>
 
 <p>&hellip; seems to be the right use of the wooden stones and the seed. The wooden supplies are strictly limited and you're running quickly short of wood, if you don't act wisely. It is quite interesting to see that besides the &quot;shortcut&quot; previously mentioned by Ronald, both of our imaginative explorers seem to have discovered some sort of &quot;longcut&quot;. Without enough wooden stones available to build a bridge, they managed to push the puzzle piece across the chasm with help of the bug. Craven has told me in private to have experimented with this solution before discovering the &quot;shortcut&quot;.</p>

Modified: homepage/input/lotm/lotm_200712_de.html
===================================================================
--- homepage/input/lotm/lotm_200712_de.html	2007-12-09 11:21:51 UTC (rev 936)
+++ homepage/input/lotm/lotm_200712_de.html	2007-12-09 15:38:15 UTC (rev 937)
@@ -106,7 +106,7 @@
 
 <div class="lotmpic">
 <img src="$$imagedir$$/lotm/lotm_200712_k.png" alt="Level of the month" border="0">
-<div class="imagetitle">Im schwarzen Panzer, ein runder Landser,<br>
+<div class="imagetitle">Im schwarzen Glitter, ein Murmelritter,<br>
 Den ganzen Tag, die Nacht ebenso,<br> 
 Den Weg entlang rollend, ein Lied anstimmend - <br>
 Auf der Suche nach Templo Dorado.<br>
@@ -386,6 +386,9 @@
 
 <div class="author">Taztunes</div>
 
+<p>Es ist &uuml;brigens durchaus m&ouml;glich, sich die Holzsteine so
+einzuteilen, dass man den Bug an der Schlucht nicht mehr ben&ouml;tigt.</p>
+
 <h4>Das Hauptthema der goldenen Herausforderung &hellip;</h4>
 
 <p>&hellip; scheint der richtige Gebrauch von Holzsteinen und Samen zu sein. Der



From andreasl at mail.berlios.de  Sun Dec  9 21:59:15 2007
From: andreasl at mail.berlios.de (andreasl at BerliOS)
Date: Sun, 9 Dec 2007 21:59:15 +0100
Subject: [Enigma-game-svn] r938 - in trunk: data data/levels/enigma_cross
	data/levels/enigma_v src
Message-ID: <200712092059.lB9KxFcM006509@sheep.berlios.de>

Author: andreasl
Date: 2007-12-09 21:59:14 +0100 (Sun, 09 Dec 2007)
New Revision: 938

Modified:
   trunk/data/levels/enigma_cross/newlevels.xml
   trunk/data/levels/enigma_v/andreas25_2.xml
   trunk/data/levels/enigma_v/index.xml
   trunk/data/sound-defaults.lua
   trunk/src/stones_complex.cc
Log:
Trunk:
 - Partial reverse of r925: "Acoustic Memory"
   has to be renamed on branch, not trunk.
 - Fix to Light Passenger: Blink state is now
   deactivated when a light beam is removed.
 - Allow missing entries in sound-default's
   silentstring-table.


Modified: trunk/data/levels/enigma_cross/newlevels.xml
===================================================================
--- trunk/data/levels/enigma_cross/newlevels.xml	2007-12-09 15:38:15 UTC (rev 937)
+++ trunk/data/levels/enigma_cross/newlevels.xml	2007-12-09 20:59:14 UTC (rev 938)
@@ -131,7 +131,7 @@
     <level _seq="123" _title="- Meditation -" _xpath="enigma_v/alain14_1" author="Alain Busser" ctrl="force" easy="false" id="alain14" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="124" _title="Frogger" _xpath="enigma_v/luc20_1" author="Lukas Sch?ller" ctrl="force" easy="false" id="luc20" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="125" _title="Fatal Attraction I" _xpath="enigma_v/spaceman01_2" author="Spaceman" ctrl="force" easy="true" id="spaceman1" rel="2" rev="2" score="2" target="time" unit="duration"/>
-    <level _seq="126" _title="Acoustic Reminiscence" _xpath="enigma_v/andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="2" score="1" target="time" unit="duration"/>
+    <level _seq="126" _title="Acoustic Memory" _xpath="enigma_v/andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="127" _title="Fatal Attraction II" _xpath="enigma_v/spaceman02_1" author="Spaceman" ctrl="force" easy="false" id="spaceman2" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="128" _title="Fatal Attraction III" _xpath="enigma_v/spaceman03_1" author="Spaceman" ctrl="force" easy="false" id="spaceman3" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="129" _title="Doors forever" _xpath="enigma_v/just03_1" author="JuSt" ctrl="force" easy="true" id="just03" rel="1" rev="3" score="1" target="time" unit="duration"/>

Modified: trunk/data/levels/enigma_v/andreas25_2.xml
===================================================================
--- trunk/data/levels/enigma_v/andreas25_2.xml	2007-12-09 15:38:15 UTC (rev 937)
+++ trunk/data/levels/enigma_v/andreas25_2.xml	2007-12-09 20:59:14 UTC (rev 938)
@@ -2,8 +2,8 @@
 <el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
   <el:protected>
     <el:info el:type="level">
-      <el:identity el:title="Acoustic Reminiscence" el:subtitle="" el:id="andreas25"/>
-      <el:version el:score="1" el:release="2" el:revision="2" el:status="released"/>
+      <el:identity el:title="Acoustic Memory" el:subtitle="" el:id="andreas25"/>
+      <el:version el:score="1" el:release="2" el:revision="0" el:status="released"/>
       <el:author  el:name="Andreas Lochmann" el:email="" el:homepage=""/>
       <el:copyright>Copyright ? 2006 Andreas Lochmann</el:copyright>
       <el:license el:type="GPL v2.0 or above" el:open="true"/>

Modified: trunk/data/levels/enigma_v/index.xml
===================================================================
--- trunk/data/levels/enigma_v/index.xml	2007-12-09 15:38:15 UTC (rev 937)
+++ trunk/data/levels/enigma_v/index.xml	2007-12-09 20:59:14 UTC (rev 938)
@@ -78,7 +78,7 @@
     <level _seq="70" _title="- Meditation -" _xpath="./alain14_1" author="Alain Busser" ctrl="force" easy="false" id="alain14" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="71" _title="Frogger" _xpath="./luc20_1" author="Lukas Sch?ller" ctrl="force" easy="false" id="luc20" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="72" _title="Fatal Attraction I" _xpath="./spaceman01_2" author="Spaceman" ctrl="force" easy="true" id="spaceman1" rel="2" rev="2" score="2" target="time" unit="duration"/>
-    <level _seq="73" _title="Acoustic Reminiscence" _xpath="./andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="2" score="1" target="time" unit="duration"/>
+    <level _seq="73" _title="Acoustic Memory" _xpath="./andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="74" _title="Fatal Attraction II" _xpath="./spaceman02_1" author="Spaceman" ctrl="force" easy="false" id="spaceman2" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="75" _title="Stranded" _xpath="./duffy51_2" author="Jacob Scott" ctrl="force" easy="false" id="duffy51" rel="2" rev="3" score="2" target="time" unit="duration"/>
     <level _seq="76" _title="Fatal Attraction III" _xpath="./spaceman03_1" author="Spaceman" ctrl="force" easy="false" id="spaceman3" rel="1" rev="0" score="1" target="time" unit="duration"/>

Modified: trunk/data/sound-defaults.lua
===================================================================
--- trunk/data/sound-defaults.lua	2007-12-09 15:38:15 UTC (rev 937)
+++ trunk/data/sound-defaults.lua	2007-12-09 20:59:14 UTC (rev 938)
@@ -62,7 +62,7 @@
     end
     -- Fill in the silence string if requested
     if (tt.silence_string == "$default$") then
-        tt.silence_string = soundtable_silent[k].silence_string or k
+        tt.silence_string = (soundtable_silent[k] or {}).silence_string or k
     end
     return tt
 end

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2007-12-09 15:38:15 UTC (rev 937)
+++ trunk/src/stones_complex.cc	2007-12-09 20:59:14 UTC (rev 938)
@@ -3125,7 +3125,7 @@
                     }
                 } else if(skateDir != NODIR) {
                     if(state == BLINK) {
-                        state == ACTIVE;
+                        state = ACTIVE;
                         init_model();
                     }
                     if(GetStone(move(p, skateDir))) {



From andreasl at mail.berlios.de  Sun Dec  9 21:59:23 2007
From: andreasl at mail.berlios.de (andreasl at BerliOS)
Date: Sun, 9 Dec 2007 21:59:23 +0100
Subject: [Enigma-game-svn] r939 - in branches/1.0/data/levels: enigma_cross
	enigma_v enigma_vi
Message-ID: <200712092059.lB9KxN90006541@sheep.berlios.de>

Author: andreasl
Date: 2007-12-09 21:59:22 +0100 (Sun, 09 Dec 2007)
New Revision: 939

Modified:
   branches/1.0/data/levels/enigma_cross/newlevels.xml
   branches/1.0/data/levels/enigma_v/andreas25_2.xml
   branches/1.0/data/levels/enigma_v/index.xml
   branches/1.0/data/levels/enigma_vi/duffy134_1.xml
Log:
Branch 1.0:
 - Partial switch of r925 from trunk to branch:
   Renaming of "Acoustic Memory" to "Acoustic
   Reminiscence".
 - Removed strange character at the beginning
   of duffy134_1.xml (possibly an editor artifact).


Modified: branches/1.0/data/levels/enigma_cross/newlevels.xml
===================================================================
--- branches/1.0/data/levels/enigma_cross/newlevels.xml	2007-12-09 20:59:14 UTC (rev 938)
+++ branches/1.0/data/levels/enigma_cross/newlevels.xml	2007-12-09 20:59:22 UTC (rev 939)
@@ -131,7 +131,7 @@
     <level _seq="123" _title="- Meditation -" _xpath="enigma_v/alain14_1" author="Alain Busser" ctrl="force" easy="false" id="alain14" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="124" _title="Frogger" _xpath="enigma_v/luc20_1" author="Lukas Sch?ller" ctrl="force" easy="false" id="luc20" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="125" _title="Fatal Attraction I" _xpath="enigma_v/spaceman01_2" author="Spaceman" ctrl="force" easy="true" id="spaceman1" rel="2" rev="2" score="2" target="time" unit="duration"/>
-    <level _seq="126" _title="Acoustic Memory" _xpath="enigma_v/andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="0" score="1" target="time" unit="duration"/>
+    <level _seq="126" _title="Acoustic Reminiscence" _xpath="enigma_v/andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="2" score="1" target="time" unit="duration"/>
     <level _seq="127" _title="Fatal Attraction II" _xpath="enigma_v/spaceman02_1" author="Spaceman" ctrl="force" easy="false" id="spaceman2" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="128" _title="Fatal Attraction III" _xpath="enigma_v/spaceman03_1" author="Spaceman" ctrl="force" easy="false" id="spaceman3" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="129" _title="Doors forever" _xpath="enigma_v/just03_1" author="JuSt" ctrl="force" easy="true" id="just03" rel="1" rev="3" score="1" target="time" unit="duration"/>

Modified: branches/1.0/data/levels/enigma_v/andreas25_2.xml
===================================================================
--- branches/1.0/data/levels/enigma_v/andreas25_2.xml	2007-12-09 20:59:14 UTC (rev 938)
+++ branches/1.0/data/levels/enigma_v/andreas25_2.xml	2007-12-09 20:59:22 UTC (rev 939)
@@ -2,8 +2,8 @@
 <el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
   <el:protected>
     <el:info el:type="level">
-      <el:identity el:title="Acoustic Memory" el:subtitle="" el:id="andreas25"/>
-      <el:version el:score="1" el:release="2" el:revision="0" el:status="released"/>
+      <el:identity el:title="Acoustic Reminiscence" el:subtitle="" el:id="andreas25"/>
+      <el:version el:score="1" el:release="2" el:revision="2" el:status="released"/>
       <el:author  el:name="Andreas Lochmann" el:email="" el:homepage=""/>
       <el:copyright>Copyright ? 2006 Andreas Lochmann</el:copyright>
       <el:license el:type="GPL v2.0 or above" el:open="true"/>

Modified: branches/1.0/data/levels/enigma_v/index.xml
===================================================================
--- branches/1.0/data/levels/enigma_v/index.xml	2007-12-09 20:59:14 UTC (rev 938)
+++ branches/1.0/data/levels/enigma_v/index.xml	2007-12-09 20:59:22 UTC (rev 939)
@@ -78,7 +78,7 @@
     <level _seq="70" _title="- Meditation -" _xpath="./alain14_1" author="Alain Busser" ctrl="force" easy="false" id="alain14" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="71" _title="Frogger" _xpath="./luc20_1" author="Lukas Sch?ller" ctrl="force" easy="false" id="luc20" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="72" _title="Fatal Attraction I" _xpath="./spaceman01_2" author="Spaceman" ctrl="force" easy="true" id="spaceman1" rel="2" rev="2" score="2" target="time" unit="duration"/>
-    <level _seq="73" _title="Acoustic Memory" _xpath="./andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="0" score="1" target="time" unit="duration"/>
+    <level _seq="73" _title="Acoustic Reminiscence" _xpath="./andreas25_2" author="Andreas Lochmann" ctrl="force" easy="true" id="andreas25" rel="2" rev="2" score="1" target="time" unit="duration"/>
     <level _seq="74" _title="Fatal Attraction II" _xpath="./spaceman02_1" author="Spaceman" ctrl="force" easy="false" id="spaceman2" rel="1" rev="0" score="1" target="time" unit="duration"/>
     <level _seq="75" _title="Stranded" _xpath="./duffy51_2" author="Jacob Scott" ctrl="force" easy="false" id="duffy51" rel="2" rev="4" score="2" target="time" unit="duration"/>
     <level _seq="76" _title="Fatal Attraction III" _xpath="./spaceman03_1" author="Spaceman" ctrl="force" easy="false" id="spaceman3" rel="1" rev="0" score="1" target="time" unit="duration"/>

Modified: branches/1.0/data/levels/enigma_vi/duffy134_1.xml
===================================================================
--- branches/1.0/data/levels/enigma_vi/duffy134_1.xml	2007-12-09 20:59:14 UTC (rev 938)
+++ branches/1.0/data/levels/enigma_vi/duffy134_1.xml	2007-12-09 20:59:22 UTC (rev 939)
@@ -1,4 +1,4 @@
-?<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
 <el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
   <el:protected>
     <el:info el:type="level">



From ral at mail.berlios.de  Sun Dec  9 23:49:59 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sun, 9 Dec 2007 23:49:59 +0100
Subject: [Enigma-game-svn] r940 - trunk/src/gui
Message-ID: <200712092249.lB9MnxvH019765@sheep.berlios.de>

Author: ral
Date: 2007-12-09 23:49:58 +0100 (Sun, 09 Dec 2007)
New Revision: 940

Modified:
   trunk/src/gui/Menu.cc
Log:
Tunk 1.1:
- fix 933: Levelmenu problems with navigation buttons and central widget


Modified: trunk/src/gui/Menu.cc
===================================================================
--- trunk/src/gui/Menu.cc	2007-12-09 20:59:22 UTC (rev 939)
+++ trunk/src/gui/Menu.cc	2007-12-09 22:49:58 UTC (rev 940)
@@ -151,7 +151,7 @@
             return;
         
         // menu subclass with special handling
-        if (on_event(e))
+        if (on_event(e) && e.type != SDL_MOUSEMOTION)   // track active widgets (LevelWidget)
             return;
     
         switch (e.type) {



From ral at mail.berlios.de  Tue Dec 11 00:24:46 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Tue, 11 Dec 2007 00:24:46 +0100
Subject: [Enigma-game-svn] r941 - trunk/src
Message-ID: <200712102324.lBANOkAa007795@sheep.berlios.de>

Author: ral
Date: 2007-12-11 00:24:46 +0100 (Tue, 11 Dec 2007)
New Revision: 941

Modified:
   trunk/src/enigma.cc
   trunk/src/enigma.hh
   trunk/src/lua.cc
   trunk/src/lua.hh
   trunk/src/world.cc
Log:
Trunk 1.1: new API - multitarget, multiaction
- new Value type TOKENS suited for strings, objects, groups and tables of
  these types as need for multitargets and multiactions
- reengineering of PerformAction as described in Draft 0.5
Note:
- This is a very critical patch - still needs some testing with existing
  levels.

Modified: trunk/src/enigma.cc
===================================================================
--- trunk/src/enigma.cc	2007-12-09 22:49:58 UTC (rev 940)
+++ trunk/src/enigma.cc	2007-12-10 23:24:46 UTC (rev 941)
@@ -175,6 +175,34 @@
 //    Log << "Value ObjectList '" << descriptor << "'\n";
 }
 
+Value::Value(TokenList aList) : type (TOKENS) {
+    std::string descriptor;
+    TokenList::iterator it;
+    for (it = aList.begin(); it != aList.end(); ++it) {
+        switch ((*it).type) {
+            case STRING :
+                ASSERT((*it).val.str[0] != 0, XLevelRuntime, "TokenList: illegal empty string value");                
+                descriptor.append((*it).val.str);
+                break;
+            case OBJECT :
+                descriptor.append(ecl::strf("$%d", (int)((*it).val.dval[0])));
+                break;
+            case GROUP :
+                descriptor.append("%");
+                descriptor.append((*it).val.str);
+                break;
+            default :
+                ASSERT(false, XLevelRuntime, "TokenList: illegal value type");
+                break;
+        }
+        descriptor.append(";");
+    }
+    val.str =  new char[descriptor.size() + 1];
+    strcpy(val.str, descriptor.c_str());
+ 
+//    Log << "Value TokenList '" << descriptor << "'\n";
+}
+
 Value::Value(ecl::V2 pos) : type (POSITION) {
      val.dval[0] = pos[0];
      val.dval[1] = pos[1];
@@ -195,6 +223,7 @@
             break;
         case STRING :
         case GROUP :
+        case TOKENS :
             val.str = new char[1];
             val.str[0] = 0;
             break;
@@ -251,6 +280,7 @@
                 return val.dval[0] == other.val.dval[0];
             case STRING :
             case GROUP :
+            case TOKENS :
                 return strcmp(val.str, other.val.str) == 0;
             case POSITION :
                 return (val.dval[0] == other.val.dval[0]) && (val.dval[1] == other.val.dval[1]);
@@ -306,15 +336,22 @@
             return Object::getObject(round_nearest<int>(val.dval[0]));
         case STRING:
             return GetNamedObject(val.str);            
-        default: return NULL;
+        default: 
+            return NULL;
     }
 }
 
 Value::operator ObjectList() const {
     ObjectList result;
     switch (type) {
+        case STRING:
+            if (std::string(val.str).find_first_of("*?") != std::string::npos) {
+                // wildcards in object name - we need to add all objects
+                result = GetNamedGroup(val.str);
+                break;
+            }
+            // else it is a single object name - fall through
         case OBJECT:
-        case STRING:
             result.push_back(*this);
             break;
         case GROUP:
@@ -323,7 +360,7 @@
             for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
                 if (it->size() > 0) {
                     if ((*it)[0] == '$') {
-                        result.push_back(Object::getObject(atoi((it->c_str()) + 1)));
+                        result.push_back(Object::getObject(atoi((*it).c_str() + 1)));
                     } else {
                         result.push_back(GetNamedObject(*it));
                     }
@@ -334,6 +371,41 @@
     return result;
 }
 
+Value::operator TokenList() const {
+    TokenList result;
+    switch (type) {
+        case OBJECT:
+        case STRING:
+        case GROUP:
+            result.push_back(*this);
+            break;
+        case TOKENS:
+            std::vector<std::string> vs;
+            ecl::split_copy(std::string(val.str), ';', back_inserter(vs));
+            for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
+                if (it->size() > 0) {
+                    if ((*it)[0] == '$') {
+                        // an object id
+                        Value v(OBJECT);
+                        v.val.dval[0] = atoi((*it).c_str() + 1);
+                        result.push_back(v);
+                    } else if ((*it)[0] == '%'){
+                        // a group
+                        Value v(NIL);
+                        v.assign((*it).c_str() + 1);
+                        v.type = GROUP;
+                        result.push_back(v);
+                    } else {
+                        // a string
+                        result.push_back(Value(*it));
+                    }
+                }
+            }
+            break;
+    }
+    return result;
+}
+
 Value::operator ecl::V2() const {
     switch (type) {
         case POSITION:

Modified: trunk/src/enigma.hh
===================================================================
--- trunk/src/enigma.hh	2007-12-09 22:49:58 UTC (rev 940)
+++ trunk/src/enigma.hh	2007-12-10 23:24:46 UTC (rev 941)
@@ -40,6 +40,7 @@
 namespace enigma { 
 
     class Object;
+    class Value;
     
 /* -------------------- Various types -------------------- */
 
@@ -192,6 +193,7 @@
 /* -------------------- Value -------------------- */
 
     typedef std::list<Object *> ObjectList;
+    typedef std::list<Value> TokenList;
 
     /**
      * A flexible container for various types of data. This class is one
@@ -249,7 +251,8 @@
             OBJECT,   ///< Value is an object id. The id is a persistent object
                       ///< identifier.
             GROUP,    ///< Value is a group of objects.
-            POSITION  ///< Value is a position
+            POSITION, ///< Value is a position
+            TOKENS    ///< Value is a list of token values
         };
 
         Value();                       ///< Constructor for NIL value that 
@@ -265,6 +268,8 @@
                                        ///< represents a persistent reference to an object
         Value(ObjectList aList);       ///< Constructor for OBJECT value that properly
                                        ///< represents a set of objects
+        Value(TokenList aList);        ///< Constructor for TOKENS value that properly
+                                       ///< represents a list of tokens
         Value(ecl::V2 pos);            ///< Constructor for POSITION value
         Value(GridPos gpos);           ///< Constructor for POSITION value
         Value(Type t);                 ///< Constructor for a given type. The
@@ -333,6 +338,11 @@
         operator ObjectList() const;
         
         /**
+         * Conversion of a value to a list of tokens.
+         */
+        operator TokenList() const;
+        
+        /**
          * Conversion of a value to a position vector.
          */
         operator ecl::V2() const;

Modified: trunk/src/lua.cc
===================================================================
--- trunk/src/lua.cc	2007-12-09 22:49:58 UTC (rev 940)
+++ trunk/src/lua.cc	2007-12-10 23:24:46 UTC (rev 941)
@@ -354,6 +354,16 @@
         case Value::POSITION:
             pushNewPosition(L, val);
             break;
+        case Value::TOKENS: {
+            TokenList tokens = val;
+            lua_newtable(L);
+            int n = 1;
+            for (TokenList::iterator it = tokens.begin(); it != tokens.end(); ++it, n++) {
+                push_value(L, *it);
+                lua_rawseti(L, -2, n);
+            }
+            break;
+        }
     }
 }
 
@@ -374,6 +384,19 @@
                 return Value(toObjectList(L, idx));
             else  if (is_position(L, idx))
                 return Value(toPosition(L, idx));
+        case LUA_TTABLE: {
+            TokenList tokens;
+            int i = 1;
+            lua_rawgeti(L, idx, i);
+            while (!lua_isnil(L, -1)) {
+                tokens.push_back(to_value(L, -1));
+                lua_pop(L, 1);  // this value
+                i++;
+                lua_rawgeti(L, idx, i);
+            }
+            lua_pop(L, 1);  // nil value
+            return Value(tokens);
+        }
         default: 
             throwLuaError(L,"Cannot convert type to Value.");
     }
@@ -2429,6 +2452,15 @@
     }
 }
 
+bool IsFunc(lua_State *L, const char *funcname) {
+    bool result;
+    
+    lua_getglobal(L, funcname);
+    result = lua_isfunction(L, -1);
+    lua_pop(L, 1);
+    return result;
+}
+
 Error CallFunc(lua_State *L, const char *funcname, const Value& arg, Object *obj) {
     int retval;
     lua_getglobal(L, funcname);

Modified: trunk/src/lua.hh
===================================================================
--- trunk/src/lua.hh	2007-12-09 22:49:58 UTC (rev 940)
+++ trunk/src/lua.hh	2007-12-10 23:24:46 UTC (rev 941)
@@ -87,6 +87,8 @@
     /*! Set the value of entry `name' in the global table `tablename'. */
     void SetTableVar (lua_State *L, const char *tablename, const char *name, double value);
 
+    bool IsFunc(lua_State *L, const char *funcname);
+    
     /*! Call a Lua function with one argument.  This is mainly used
       for callbacks during the game. */
     Error CallFunc(lua_State *L, const char *funcname, const enigma::Value& arg, Object *obj);

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-09 22:49:58 UTC (rev 940)
+++ trunk/src/world.cc	2007-12-10 23:24:46 UTC (rev 941)
@@ -1966,35 +1966,53 @@
 }
 
 
-void PerformAction (Object *o, bool onoff) 
-{
-    string action = "idle";
-    string target(o->getAttr("target"));
-
-    if (Value v = o->getAttr("action")) action = v.to_string();
-
-#if defined(VERBOSE_MESSAGES)
-    o->warning("PerformAction action=%s target=%s", action.c_str(), target.c_str());
-#endif // VERBOSE_MESSAGES
-
-    if (action == "callback") {
-        if (lua::CallFunc(lua::LevelState(), target.c_str(), Value(onoff), o) != 0) {
-            throw XLevelRuntime(string("callback '")+target+"' failed:\n"+lua::LastError(lua::LevelState()));
+void PerformAction (Object *obj, bool onoff) {
+    TokenList targets = obj->getAttr("target");
+    TokenList actions = obj->getAttr("action");
+    if (Value state = obj->getAttr("state")) {
+        int s = state;
+        if (Value stateTargets = obj->getAttr(ecl::strf("target_%d", s)))
+            targets = stateTargets;
+        if (Value actionTargets = obj->getAttr(ecl::strf("action_%d", s)))
+            actions = actionTargets;
+    }
+    
+    TokenList::iterator ait = actions.begin();
+    std::string action;  // empty string as default
+    for (TokenList::iterator tit = targets.begin(); tit != targets.end(); ++tit) {
+        action = (ait != actions.end()) ? ait->to_string() : "";
+        
+        ObjectList ol = *tit;  // get all objects described by target token
+        if (ol.size() == 0 || (ol.size() == 1 && ol.front() == NULL)) {  // no target object
+            if ((action == "callback" || action == "") && (tit->getType() == Value::STRING) 
+                    && lua::IsFunc(lua::LevelState(), tit->get_string())) {
+                // it is an existing callback function
+                if (lua::CallFunc(lua::LevelState(), tit->get_string(), Value(onoff), obj) != lua::NO_LUAERROR) {
+                    throw XLevelRuntime(string("callback '") + tit->get_string() + "' failed:\n"+lua::LastError(lua::LevelState()));
+                }
+            }
+            // else ignore this no longer valid target
+        } else {
+            // send message to all objects
+            if (action == "") 
+                action = "toggle";
+            for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
+                if (*oit != NULL) {
+                    if (GridObject *go = dynamic_cast<GridObject*>(*oit))
+                        SendMessage(*oit, Message(action, Value(onoff), go->get_pos()));
+                    else
+                        SendMessage(*oit, Message(action, Value(onoff)));
+                }
+            }
         }
+        
+        if (ait != actions.end()) ++ait;
     }
-    else if (action == "signal") {
-        emit_from (level->m_signals, o, onoff);
+    
+    if ((targets.size() == 0) && (actions.size() == 1) && actions.front().to_string() == "signal") {
+        // pre 1.10 signal handling
+        emit_from(level->m_signals, obj, onoff);
     }
-    else if (Object *t = GetNamedObject(target)) {
-        if (GridObject *go = dynamic_cast<GridObject*>(o))
-            SendMessage (t, Message (action, Value(onoff), go->get_pos()));
-        else
-            SendMessage (t, Message (action, Value(onoff)));
-    }
-    else if (action != "idle") {
-        fprintf (stderr, "Unknown target '%s' for action '%s'\n",
-                 target.c_str(), action.c_str());
-    }
 }
 
 



From ged at mail.berlios.de  Tue Dec 11 19:34:20 2007
From: ged at mail.berlios.de (ged at mail.berlios.de)
Date: Tue, 11 Dec 2007 19:34:20 +0100
Subject: [Enigma-game-svn] r942 - homepage/input/lotm
Message-ID: <200712111834.lBBIYKuM011518@sheep.berlios.de>

Author: ged
Date: 2007-12-11 19:34:19 +0100 (Tue, 11 Dec 2007)
New Revision: 942

Added:
   homepage/input/lotm/lotm_200712_ru.html
Log:
Homepage: Russian translation of LotM #12

Added: homepage/input/lotm/lotm_200712_ru.html
===================================================================
--- homepage/input/lotm/lotm_200712_ru.html	2007-12-10 23:24:46 UTC (rev 941)
+++ homepage/input/lotm/lotm_200712_ru.html	2007-12-11 18:34:19 UTC (rev 942)
@@ -0,0 +1,266 @@
+<div class="lotm">
+$$lotm_header$$
+<h3 class="lotm">
+<span class="date">??????? 2007: </span>
+&quot;Temple of Gold&quot;, ?? Jacob Scott &amp; Ronald Lamprecht
+</h3>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_m.png" alt="Level of the month" border="0">
+<div class="imagetitle">Enigma VII # 24 'Temple of Gold'<br>????????? ??????? ?????</div>
+</div>
+
+<p>????? ??????????, ????????? ?????????? ???????, ? ?????????? ?????? ???? ??????, ?????? ??? ?? ??????
+? ?????? ???? &quot;Temple of Gold&quot;, ???????????? ?????? ??????. ?????? ???????, ??? ?? ?????????? ?????? ?
+??????????? ????????? ??????. ?? ??????? ???? ?????????, ??? ??? ?? ?????, ?????? ?????????? ???????? ?????, ???? ??
+???????, ??????? ?????????? ??????????? (??????? ??-?? ???????? ????????? ? ???????????? ????????? ????? ??????? ?????,
+? ??-?? ???????? ????????????, ????? ?? ??????? ? ?????-?????? ???????, ???????????? ????? ????? ????? ???????????? ????? ??? ??????????? ??????????? ??????).</p>
+
+<p>??? ????? ???????????? ???? ????? ?????, ??????? ????? ?? ?????? ???????? ?????????? ?????, ?? ? ???????? ??????
+? ??????? ?????????? ???????? ? ??? ???????????? ?????? ???????? ?????. ??? ?????????, ????????????? ??????????,
+Taztunes ? Craven. ????? ?? ?????????? ?????? ? ??? ?????? ????????? ????? ? ?????????? Mr Jacob Scott ? Mr Ronald Lamprecht ? ???? ??? ????? ? ???? ?????????? ?? ????????????. ?????, ???????? Daydreamer ????????? ? ??? ??????????? ?? ??????????? ?????????? ?????????, ??????????? ? ?????.</p>
+
+<table cellpadding="0" cellspacing="1" class="statistics">
+<caption class="normalcaption">????????? ???????? ??????? 2007</caption>
+<colgroup>
+   <col width="80">
+   <col width="160">
+</colgroup>
+<tr><td class="num"> 8:53</td>
+    <td class="left">Moneymaker</td></tr>
+<tr><td class="num">18:20</td>
+    <td class="left">Daydreamer</td></tr>
+<tr><td class="num">22:18</td>
+    <td class="left">Ronald</td></tr>
+<tr><td class="num">24:20</td>
+    <td class="left">Craven</td></tr>
+<tr><td class="num">34:23</td>
+    <td class="left">Taztunes</td></tr>  
+</table>
+
+<p></p>
+
+<table cellpadding="0" cellspacing="1" class="statistics">
+<caption class="normalcaption">??????? ??????????? ??????</caption>
+<colgroup>
+   <col width="80">
+   <col width="160">
+</colgroup>
+<tr><td class="num"> 5:44</td>
+    <td class="left">Moneymaker</td></tr>
+<tr><td class="num"> 9:50</td>
+    <td class="left">Craven</td></tr>
+<tr><td class="num">10:06</td>
+    <td class="left">Ronald</td></tr>
+<tr><td class="num">11:06</td>
+    <td class="left">Tobias</td></tr>
+<tr><td class="num">11:37</td>
+    <td class="left">Daydreamer</td></tr>  
+<tr><td class="num">16:20</td>
+    <td class="left">para_doks</td></tr>
+<tr><td class="num">17:53</td>
+    <td class="left">ryujun</td></tr>
+<tr><td class="num">18:16</td>
+    <td class="left">Mark P.</td></tr>
+<tr><td class="num">18:29</td>
+    <td class="left">Taztunes</td></tr>
+<tr><td class="num">22:06</td>
+    <td class="left">dpl</td></tr>  
+</table>
+
+
+<h4>?????? ???????????? ?????? ??????????, ? ???? ??? ????????? &quot;????????? ??????&quot;:</h4>
+
+<p><img class="leftimage" src="$$imagedir$$/lotm/lotm_200712_ag.png" alt="ILCELATTOG" align="left"></p>
+
+<h4>9.25(8)9.13(8)9.11(9)9.00(5)</h4>
+
+<p>??? ??????, ?? ?????? ????? ????????? ?????????? ?? ???????? <a href="http://www.nongnu.org/enigma/lotm_ru.html">??????
+???</a>.</p>  
+
+<h4>????????? ????????????? ?????????? ????????!</h4>
+
+<p>? ?? ???? ????????? ????? ??????????? ?????? ??? ??????? ?????????? ??????? ?????? ???, ??? &quot;Temple of Gold&quot;. ?????? ?? ? 10? ??? &quot;????? ?????????? ???????????? ? ???????????? ??????? Enigma&quot;. ???????????? ?????????, ??????? ???? ????? ??????? ???????????? ???????, ???? ? ?? ?? Enigma, ? ??????? ???????? ?? ?????,
+?? ?????? ?????????????? ???????? ??? ?????, ?? ? ????????? ????, ????? ???? ?????, ?????????? ? ??????? ???? ?????????? ?????????? ??????? ?? ?????????? ??????. ?? ???? ??????? ????, ????? ??????????, ??????? ??????? ?????? ?????? ???????? ????? ? ???????? ?? ???????? ????. ?, ??? ?????? ??? ??????????, ???? ?? ?????????? ??????? ???? Enigma ????????? ?? ????? ????????!</p>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_k.png" alt="Level of the month" border="0">
+<div class="imagetitle">?????????? ??????, ???????????? ??????,<br>
+?? ?????? ? ? ????,<br> 
+????? ???????? ? ???? ?????,<br>
+? ??????? ????? ????.<br>
+</div>
+</div>
+
+<p>????????? ??? ??????????????? ???????????? ? ????????? ??? ?????? ??????? ??????, &quot;Island Labyrinth&quot;, ??? ???? ???????????? ???????? Jacob'?. Alejandro ??????? ? ???: &quot;??? ???????, ??????? ????????? ??????????&quot;, ???????????? ?? ??, ??? ? ?????? ? &quot;Temple of Gold&quot;. ??? ?????? ????????? ????????????, ??????? ????? ??????? ? &quot;Temple of Gold&quot; ??? ??????? ?????????: &quot;????-??????, ??????? ??????????? ???????? ???????????, ????? ????? ????????? ??? ?????????????? ?????????&quot; (Taztunes), &quot;??? ???????, ??? ? ???? ?????? ????????? ??? Enigma&quot; (Ronald), &quot;?? ????? ???? ????, ??? ?????? ?????? ??????????? ?? ????? ????????????? ??????&quot; (Ronald), &quot;???? ?? ????? ?????????????? ????????????? ????? ?????? ?????????????? ????????????? ???????? Jacob'?&quot; (Andreas).</p>
+
+<p>????? ??? ??????, ???? ??? ??????????? ?? &quot;Island Labyrinth&quot; ????? ????? ????????? ?????????????? ?????????? ?? st-rock1, fl-water ? fl-leaves ? ???? ???????. ????? ?? ??? ?? ??????? ???????? ?????????? ?? st-yellow ? fl-sahara ???? ?????????? ??????? ? &quot;Temple of Gold&quot;. ?????, ??? ??? ???????? ?????????? ???? ?????? ??????????? ???????? ????????????? ?????????? ????????, ????????? ? ???????????. ??????? ????????? ????????? ????????? ???? ? ??? ??????:</p>
+
+<h4>&quot;? ??????? &quot;Temple of Gold&quot; ???????????? ?????-?? ???????????? ????&quot;</h4>
+
+<div class="quote">? ????????, ??? ????, ?? ??????? ???? ????????????? ???? (???????????????? ?????????? 
+??????????????? ????/???????) - ??? ??????? ?????? ??? ??????, ? ???????? ????????? ?????????
+?????, ????????? ? ???. ???? ?? ????????? ?????-?? ?????????? ????????, ?? ???? ?? ???????? ??????? ???????
+? ???????????? ?????? ????????? ? ??????, ???????? ??????? ???????????? ????? ????? ??????? ???????????,
+?????? ???????, ????? ??? ?????????!</div>
+
+<div class="quote">&quot;Temple of Gold&quot; ???? ??? ????? ?? ???? ???????, ??? ???????? &quot;Elaborate&quot;,
+??????? ??????? ??????? ??? ????????????. ??? ???????? ????????????? ???????? ? ?????? ?? ???????????? ?????????
+?????? ? ???????? ? ???, ?? ????? ?????????? ? ?????? ?? ?????? ???????????. ????? ???????, ? ???????
+????????? ???????, ????? ????? ???????????? ???????, ????????? ?? ??? - ????????? ????? ? ????? ?? ??????,
+? ??????? ??????????? ?? ?????? ?????????. ???????? ????????? ?????? ???????? ?? ??? ????????????,
+????? ????????? ?? ????, ??? ?????? ? ?????? ?????????? ????????. ??? ???????? ???????? ??? ??????????? ???????????, ??????? ? ?????? ?????? ????????? ???????, ??????? ???????? ???????? ?????????? ?? ??????? ? ??????? ? ??????, ?????? ???? ????? ??? ?????? ?? ?????? ?????????? ???? ?????????? ?????????, ????????????????? ?????? ?? ????????? ????????.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_c.png" alt="Level of the month" border="0">
+<div class="imagetitle">Indiana Marble ? ????????? ????: <br>????? ?? ??????</div>
+</div>
+
+<div class="quote">????? ? ??????? &quot;Temple of Gold&quot; ???????????? ?????-?? ???????????? ????
+?? ?????????? ???????????, ????????????? ????? ???? ??? ????????????. ?? ????????, ? ??????? ??????????? ?????? ????????? ? ?????????? ?? ????? ???????????????, ????? ??????? ??????? ??????? ? ??????????. ????? ????, ? ??????????? ?????? ????????? ??????? ???????? (?????, ????????? ???????? ?????????????? ??????, ? ?? ????, ??????? ????? ????? ? ???????? ?????), ????? ?????????? ? ??????, ????? ??? ????????, ???????, ????????? ?????? ? ?????????? ????????????? ?????. ??????, ??? ???????? ?????? ???? ?????? ???????? ????????????, ??? ???????? ??????????? ????? ??? ??????? ?????????????? ? ????, ????? ????????????? ???????????, ??????? ????? ????????? ??????.</div>
+
+<div class="quote">? ?????, ? ?????? ??????? ???, ?? ??? ??????????? ???????. ? ??????, ?? ?????? ????????? ??????? ????????????? ????? ? ?????????? ??????? ? ?????????????, ??? ???????? ??????? ? ???????? ??????? ?????? ? ??????? ????????????? ???????????? ???????????. ?? ?????????? ???? &quot;Elaborate,&quot;, ?? ? ????? ?????????? ? ?????????????
+??????????. ? ??????? ??? ?????? Enigma, ??????? ???????? ???? ???????, ?????? ??? ???????? ? ????????? ??? ?? ??? ?.</div>
+
+<div class="quote">????? ? ????? ?????????? Ronald'? ?? ??? ?????? ? ????????? ??????, ???????? ? ??????? ??????.
+?????????? ? ???? ???? ????????? ??????? ?????, ??????? ????? ???? ????????????, ????? ????????? ??????? ???????, ??? ? ??????????, ? Ronald ?? ?????? ????? ??????? ??????? ????????? ???, ?? ?, ????? ????????? ??????? ??????? ??? ???????? ?????? ????? ?????????, ?? ????????? ?? ????????.</div>
+
+<div class="author">Jacob Scott</div>
+
+<p>?? ????? ????, &quot;??????? ?????&quot; ????????? &quot;?????????&quot; ??????????, ? ?? ??????, ??????? 
+??????, ????????, ? &quot;Houdini&quot;, ??? ???? &quot;???????????? ??????? Enigma&quot;, 
+????????? ??????, ??? ???????? ???? ? ??? ????????. ?? ??? ???? ???????, ??? ???? ???-?? ?? ???????,  
+??, ??????, ??????? ????? ?? ????? ?????????? ? ????:</p>
+
+<h4>&quot;???????? ??? ?????? ???????, ??????? ??????? ????????? ?????? ??????? ??? ???????? ? ???????? ??????&quot;</h4>
+
+<div class="quote">? ??????? ??????? ?????? ????? ?????? ?? Jacob'? ?????? ? ????? ????????????, ?? ?? ?????????? ????????, ????? ????? ???????? ???? ? ?????????? ????????. ? ????? ?? ??? ???????? ???? ???????. ??? ??????? ? ?????? ??????, ???? ? ??????????????? ?????????? ? ??????????? ????????????? ?? ????. ????????????????? ??????? ??? ?????-???? ??????? ???????? ? ?????????? ???????? ???????? ? ??????????????? ??????? ??????? ???????????.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_o.png" alt="Level of the month" border="0">
+<div class="imagetitle">??? ??????? ???????? <br/>??? ??????? ??????, <br/>???? ??? ??????? ?? ????????!</div>
+</div>
+
+<div class="quote">????????? ??????? ?????? ???? ??????????? ?????, ? ????????? ??????? ????????? ? ??????? ??????? ??????????? ? ????? ?????????-??????????? ?????. ??? ??????? ??????? ?????????????? ???? ? ???????? ???????????.</div>
+
+<div class="quote">?? ??? ??? ?????????? ?????????? ?????? ????? ? ????????? ?? ???? ?????? ???????? ????.
+???? ???????? ???? ?????????? ??????? ??????????? ?????? ?????? ?? ??????? ????? ???????. ?? ? ??? ??? ??? ?????????
+????? ? ?????? ??????? ???????, ??????? ???? ????????? ?????????????. ??? ????????????? ??????????? ?????????
+????????? ????????? ? ??????? ?????? ???????.</div>
+
+<div class="quote">?? ????????? ??? ????????? ????????? ??? ??????? ????????. ???????? ???? ?????????? ??? ??????.
+??????????, ? ??????? ?????????, ????????? ?? ?????????? ??????????? ?????????. ? ??????? ?????, ??????????? ????? ????????? ? ????????? ?????? ????????. ???????? ??? ?????? ???????, ??????? ??????? ????????? ?????? ??????? ??? ???????? ? ???????? ?????? - ?? ?????? ??????? ? ?????? ?? ???!</div>
+
+<div class="quote">? ????????? ???? ????????? ??? ???? ?????????? ???? ?????? ???????? ????. ???????????? &quot;Moneymaker&quot; ??????? ??? ?????. ?? ???? ?? ??????????? ???????, ???? ????????, ??? ????? ????? ???? ??? ?? ????? ? ?? ?????????????? ???? ???????? ?????. ??????????? ????? ??????? ? ??????????. ??????????, ??? ????? ???????? ? ????????? ?????? Enigma.</div>
+
+<div class="author">Ronald Lamprecht</div>
+
+<p>???????????? ???????? ????? ?????????, ??? ??? &quot;Moneymaker&quot; ??? ??????????? 
+? ?????? ????????. ??????????? ?? ????, ? ????????????, ? ???????? ??????, ?? ?????????? ??????? ????????, ?? ??? ?? ????????????? ??????? ?? ?????????????, ?? ???? ??? ????????, ?? ?? ??????? ??? ???????????? ????????, ??????? ?????????? ???? ????????????? ?????????????!</p>
+
+<p>????????, ?????????????? ????????? ? ???????????, ????? ?????? ?????? ? &quot;Michael'? Schumacher'?&quot; ??????? Enigma ?? ???????? <a href="$$statistics$$">?????????? ???????????</a>. ?? ??????? ??????? &quot;?????????? ???????? ???????&quot; ?? ????? ?????? ????? ??? ???????? ??????????????, ??????? ????????? ???????????? ?? ???????? ????? ? ??????????? ?????????? ??????????? ? ????? ????????????. Taztunes ? Craven, ??? ?????!</p>
+
+<h4>&quot;???? ??????? ????????? ???? ?? ?????!&quot;</h4>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_p.png" alt="Level of the month" border="0">
+<div class="imagetitle">
+?, ????? ??? ???? ??? ???????? ???????,<br>
+???????? ?? ????????? ??????.<br>
+&quot;?????&quot;, ?????? ??, &quot;??? ????? ???? - <br>
+??? ?????? Templo Dorado?&quot;<br>
+</div>
+</div>
+
+<div class="quote">? ???? ?????? ???? ????? ?????????: ??????? ???????, ?? ??????? ?? ?????? ????? ?????????????, ? ?????? ????? ??????? ???????, ??????? ????? ? ????? ???????? ??? ? ???? ????????.</div>
+
+<div class="quote">? ???? ?? ???? ?????? ??????? ? ?????????? ???????, ?????? ??? ? ??????????? ?????? ???????? ????, ??? ????? ???????. ???????????? ????????, ??????? ?? ?????? ??????? ?? ?????????, ???????? ????????????, ???? ? ??????? ?? ????? ?????? &quot;????&quot;.</div>
+
+<div class="quote">??????? ? ???, ????? ???????????? ???????? ?? ??????? ?????, ?????? ??? ????, ????? ??????????, ??? ?????????? ??????? ?????? ?????, ??? ? ??????: ?????? ?????????? ?? ??? ?? ?????? ? ???????? ???? ??????? ?????? ????????? ??? ??, ?? ???? ??? ? ????????? ?????????? ?????????, ??? ???????? ???????? ???????????? ????????? ??? ????????? ????????? ?????, ??????? ??? ?? ?? ????????? ??? ??????????? ????? ??? ????? (? ??? ??????????? ? ????? ? &quot;Houdini&quot;!).</div>
+
+<div class="quote">???? ?????????? ????? ???????? ?????????? ???????, ?? ??? ??????? ???????? ?????? ???? ? ???? ??????? ??????????? ?????, ??????? ? ?????? ???????, ?????? ????? ????????? ????? ?????? ???? ???????. ????, ??? ?? ????? ???? ? &quot;Temple of Gold&quot; ????? ?? ?????? ??? ? &quot;How Many Spirals?&quot; ???, ??????????, &quot;The Aztec Temple&quot; ???? ??????? ??????????? ??????????? ????????? ???????.</div>
+
+<div class="author">Craven</div>
+
+<h4>&quot;? ????? ??? ??????? ??????????? ??????&quot;</h4>
+
+<div class="quote">???? ?? ????? ?????????? ?????? Temple of Gold ??? ???? - ?????????????? ????????????? ???????????? ? ???????? ????, ????? ????? ??? ???????? ? ????????? ??? ????????? ?????? ??? ?????? ??????, ?????? ??? ??? ??????????? ?????? ?????? ????? ???????? ?? ?? ???????? ???? ?????? ??????, ? ??? ???????? ??????? ?????? ??????? ??? ????? ?? ??????? ????? ? ???? ?? ?????? ? ????????. ??? ????????? ?????? ????? ?????? ????, ?? ??? ????? ???????? ?????? ?????, ????? ?? ???????? ???? ???????, ????? ??? ???? ??????? ???????? ?? ??????.</div> 
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_b.png" alt="Level of the month" border="0">
+<div class="imagetitle">
+&quot;?? ???????? ??????, ?????? ?? ???,<br>
+?? ?? ??????? ???????? ??????!<br>
+?????? ?? ??????????? ?? ????&quot;, ????? ??????? -<br>
+&quot;???? ????? ?????? ????? Templo Dorado!&quot;</div>
+</div>
+
+<div class="quote">?????? ???????????? ?????? ????? ?????? ??? ???? ???, ??????? ???????? ??????????????, ? ??????? ????????? ????????-??????????? ??????, ???????? ??????????? ????? ???????? (?????? - '??????' ? ?????? - '???'). ? ????? ???? ? ???????? ????????? ? ??????? ????? ???????? ? ??????????. ??? ????? ?????? ????? ?????????? ???? ??? ?? ??????????? ? ????????, ? ??? ????? ???????? ??????? ??? ?????????, ?????? ?????????? ? ??????????????.</div>  
+
+<div class="quote">? ????? ??? ??????? ??????????? ?????? - ? ??? ????????? ???????? - ??????, ?????, ????????? ??????, ??????? - ????? ??????? ?? ?? ???????? ? ????? ???????????? ? ?????? ?????????? ??????. ??? ????????? ?????? ?????????? ????, ????? ??????, ??? ???? ?? ??????????? ?????????? ????? ??? ?????????? ????? ????, ?? ????? ?? ?????? ??? ????, ????? ???????? ???????? ?? ???? ? ??????? ?????? ???????.</div> 
+
+<div class="quote">? ?????????, ??? ??????? ?????????? Temple of Gold ? ????? ????????? ???????, ? ???? ??? ??? ??????? ??? ??? ??????????, ? ????? ??????????, ??? ??? ?????????? ?????? ?????? ???????? ??? ????????? ?? ????????? ????????? ???????????? ???????. ? ? ?????? ? ???????? ? Temple of Gold, ????? ????? ??????????? ????????????? ??? ????????.</div>
+
+<div class="quote">? ??????? ???? ??? ?????? ??????????? ?????? ?????????? ?????? ??????. ??? ???????? ???????? ?????? ?? ?????????. ? ??????? ?? ???????, ??? ? ????? ??????? ??? ?????? ????????? ??????? ????????? ?? ????? ???????? ? ??? ?????????????? ???????????!</div> 
+
+<div class="author">Taztunes</div>
+
+<p>??????, ?????????? ?????? ??? ?????????? ?????????? ?????, ??? ?? ????? ????????????? ? ???? ??? ?????????.</p>
+
+<h4>??????? ???? ???????? ??????????? &hellip;</h4>
+
+<p>&hellip; ??? ??????? ?????????? ????????????? ?????????? ?????? ? ?? ?????????. ?????? ?????? ?????? ?????????? ?, ???? ?? ?? ?????? ??????????? ?????, ?? ????? ???????????? ??????? ??????. ???????? ?????????, ??? ????? &quot;????????? ????&quot;, ??????????? ????? Ronald'??, ??? ????? ????????? ?????????????, ???????, ????? ? ????????? ???? &quot;???????? ????&quot;. ??? ???????????? ??? ????????? ????? ?????????? ?????????? ??????, ??? ??????????? ????? ??????????? ????? ????????, ???????? ?????. Craven ??????????? ??? ???????????????????? ? ???? ???????? ????? ???, ??? ????? &quot;???????? ????&quot;.</p>
+
+<p>??????????????? ????????????? ??????? ? ?????????? ????????????? ????????? ??? ?????????? ?????? ? ????? ?????? - ??? &quot;Growing Boxes&quot; (II/21). ????? ?????? ?????? &quot;??????????????&quot; ???? ??????, ????? &quot;???????? ??????&quot;. ???? ??????? ????? ?????? ???????????? ???????????????? ??????. ???????? ???? ???????? ? ???????? ??? ????????. ????? ???????? ?? ???? ????, ???? ??????????? ? ????????????? ??????????? ??????, ????? ???? ????? ???????. ????? ???????, ? ???? ?????? ?????????? ???? ?? ??????, ???? ?????????? ?? ??, ??? ?????????? ????????. ??? ??????? ?????? ???????? ???????? ?????? ????, ??? ????? ? ???????????? ??????? ?????????? (?????????) ??????. ? ??? ???? ?????? &hellip; ?????, ? ?????? ?????? ?? ?????, ????? ?? ????????? ??? ???????? ?? ????????????. ?? ???????? ???????????, ??? ? ????? ??????? ??????, ? ?????? ?????? ????, ??? ?????? ??????? ??????? ???????? &quot;Temple of Gold&quot;</p>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_n.png" alt="Level of the month" border="0">
+<div class="imagetitle">??? ???? ????????? ??? ??????????? ????? ?? ????????!</div>
+</div>
+
+<p>???? ??? ????? ????? ??????????? ??????????, ??? ?????? ? ???? ??????, ????? &quot;mag.heut.net&quot; ?????????? ?????. ????????? ? ?????, ???????????? &quot;Hairball&quot; ????? ????? ? ?????????? ??????? Tips &amp; Tricks. ??? ??? ????? ?????? Ronald, ????????? ?????? ?????????????? ? ??????????????? ??????, ??? ????? ???????????? ????????????, ????? ????? ???????????? ?????? ? ?????????? ????? - ??? Seed Puzzles I &amp; II (IV/71&amp;74), ???? ?????????? Jacob'??. ?, ??????? ??? ???????????? &quot;Tool Time&quot;, ??? ??????? ????????, ? ??????? ???????????? ?????? ? ?????????? ?????, ???? ??????? ????.</p>
+
+<p>?? ??????? ??? ????? ??????????? ?????? - ???????????? ?????? ?????? ?? ?????? ??????, ??????? ?? ????? ??????. ????? - ???? ????????????. ???? ??? ????????? ???????????, ????? ??????? ??????? ?????? ?????? ??????, ???????? ?? ?????? ??? ? door_b ? ?????, ?? ??? ????????? ????? -  ??? ????? ????????? ??????? ??????? ???? ???? ???????????? ???????????, ????? ???????? ???? ????? ?? ????? ?????????? ? ???????????? ?????? ??? ????????? ????-????, ??? ???? ?? ?? ?????????? ?? ?????-?????? ?????????? ???????, ??? ??????? ?????? fl-sand(?????),  ? ???? ??????? ????? ??????????? ?? st-rock1. ??? ??????? Daydreamer ???????? ? ??? ?? ?????????? ????????? ???????? ????? ? ????????? ??? ?? ????? ????????, ???? ? ???????????? ??????, ?? ??????? ??? ???????????? ???? ?????????:</p>
+
+<h4>?????? ??????? ?????????? ??????? ????????</h4>
+
+<p>?? ???????????? ? ???, ??? ???? ????? ????? ? ???????????? ?????, ??????? ??????? ?????????? ?????-??????, ????? ???? ????????, ???? ????? ??????????? ??????? ????????? ???????? ????????? ??????????, ???????? ???? ??? ?????? ?????? ???? ??????? ????.</p> 
+
+<p>????? ?? ???????????? ? ???, ??? ???? ?????? ?? ????? ??????????? ?????? ?????? ????????? ?????? ??????? ???????? ??????? ? ????????????? ? ????? ????????? ??????? ??????? ???????? ??????, ?? ???? ??? ??????? ??????-????? ???????? ? ?? ????-?????????? ?????? ?????? ??? ???? ?????, ? ?? ??????? ???????, ??? ???????? ??????? ????? ???????? ?????? ?????????? ??????? ????????, ? ??? ??????? ?????????? ????? ??????? ??????????? ????????? ?????? ?????? ???????? ???? ??????? ???????.</p>
+
+<h4>??????? ???? ??????? ??????? &hellip;</h4>
+
+<div class="quote">&hellip; ??? ??????????? ????, ?????? ? ???? - ??????????? ?????? ????????????
+?????????? ? ??????????? ????????? ??????, ??????? ? ?????? ?????????? ??????????.</div>
+
+<div class="lotmpic">
+<img src="$$imagedir$$/lotm/lotm_200712_l.png" alt="Level of the month" border="0">
+<div class="imagetitle">????????????? ???????? ????<br>?? ?????????? ? ??????? ?????????!</div>
+</div>
+
+<div class="quote">??????? ???? ??????? ?????? - ?????????, ? ??????? ?????? ? ????, ??????? ???????? ??? ???????? ????????? ? ???????? ?? ???????? ? ??????, ??????? ???????? ?????????? ???????? ??????. ????????? ? ???? ?????????, ?? ????????? ????????? ??????????????, ???????????????? ? ????????? ????????? ? ? ??????? ??????? ??????? ????????? ??????????? ??????? ??????.</div>
+
+<div class="quote">???? ?? ?????????? ????????? ???????? ???? ??????? ???????, ??? ???? ??????? ? ???? ???? ?????? ??????? ????? ????? ? ?? ??????? ??????? ????????????? ? ???????. ??? ?????????? ??????? ????????, ????????????????, ???????????, ??????????, ??????????????? ? ?????????.</div>
+
+<div class="quote">??????? ???? ??????? ?????? ?? ???? ????????? ???????????, ? ?????? ???????????? ???????? ????. ??????????? ??????? ?????? ??????? ??? ????????????, ????????? ??????????, ??? ??? ????????? ???????? ? ???????????? ????? ??????????. ??? fl-sahara ? st-yellow, fl-abyss ? st-wood, fl-bridge-open ? st-wood,
+it-trigger ? st-brownie, st-door_b ? it-seed, it-hammer ?
+st-rock3_break, it-coin1 ? st-coinslot, ac-rotor ? it-cherry,
+ac-blackball ? ac-bug ?????????? ? ???? ????? ????????????.</div>
+
+<div class="quote">&quot;Temple of Gold&quot; - ???????, ??? ????????? ?????, ??? ????, ???? ? ???? ????? ? ???? Enigma,
+?????????????? ? ?????????????? ? ?????? ? ??????, ???????? ??????? ? ?????, ???????? ??????? ? ?????.</div>
+
+<p>??? ????? ???????? ???????? ??? ????? ??????????? ?????????????? Daydreamer'??, ??????? ???????, ??? ?????? ??????? ????? ??? ????????? ?????????. ?? ?????????? ??????????? ??????? ???? ???????? ?? ????? ? ?? ?????? ????????? ???????.</p>
+
+<p>???????? ?????? ?? ????? ? ????? ???????? ? ????????? ??????????, ??????? &quot;Temple of Gold&quot; ???????????? ????????????? ?????????????. ??, ? ???????, ???? - ?? - ???????? ??????? ?????? ???? ?????? ?? ????-?? ?? ?????????,
+????????????? ??? ? ??????????????? ???????????? ???? ?????.</p>
+
+<p>?????? ???????, ??? ??? ??????? ?????? ????????, ???????????? ??????? ???? ???????? ? ????????????? ??? Enigma.</p>
+
+<p>? ?????? ?? ????? &quot;?????? ??????&quot;, ??-?? ??????? &quot;?????? ????&quot;, ? ?????? ?? ????? ? ?????? ?? ???. ????? ?? ????? ??????????? ?????? ?? ???, ?????? ??? ??? ????? ???? ?? 10 &quot;????????????&quot; ??????? ??????, ??????? ?? ??? &quot;??????????? ???????????&quot;. ????, ?? ??????? ? ???????, ????? ?? ? 11 ??? ??????:
+&quot;?? ????? ?????? ????? ????? ?????????? ??????????????? ? ???????????? ??????? Enigma&hellip;&quot;
+
+<p>????? ????????, ??????? ???????? ???????, ? IV/2,<br/>
+<i>Harry ? Andreas</i></p>
+
+</div>


Property changes on: homepage/input/lotm/lotm_200712_ru.html
___________________________________________________________________
Name: svn:eol-style
   + native



From ral at mail.berlios.de  Wed Dec 12 23:56:12 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Wed, 12 Dec 2007 23:56:12 +0100
Subject: [Enigma-game-svn] r943 - trunk/src/lev
Message-ID: <200712122256.lBCMuC8U004293@sheep.berlios.de>

Author: ral
Date: 2007-12-12 23:56:11 +0100 (Wed, 12 Dec 2007)
New Revision: 943

Modified:
   trunk/src/lev/Proxy.cc
Log:
Trunk 1.1: 
- fix oxyd coloring for odd number with old API


Modified: trunk/src/lev/Proxy.cc
===================================================================
--- trunk/src/lev/Proxy.cc	2007-12-11 18:34:19 UTC (rev 942)
+++ trunk/src/lev/Proxy.cc	2007-12-12 22:56:11 UTC (rev 943)
@@ -618,6 +618,8 @@
             server::SetCompatibility(this);
             server::EnigmaCompatibility = getEnigmaCompatibility();
             server::LevelStatus = getLevelStatus();
+            if (server::EnigmaCompatibility < 1.10)
+                server::AllowSingleOxyds = true;
         }
         processDependencies();
         loadLuaCode();



From raoul at mail.berlios.de  Fri Dec 14 22:44:39 2007
From: raoul at mail.berlios.de (raoul at BerliOS)
Date: Fri, 14 Dec 2007 22:44:39 +0100
Subject: [Enigma-game-svn] r944 - homepage/input/lotm
Message-ID: <200712142144.lBELid9k029108@sheep.berlios.de>

Author: raoul
Date: 2007-12-14 22:44:39 +0100 (Fri, 14 Dec 2007)
New Revision: 944

Modified:
   homepage/input/lotm/lotm_200712_ru.html
Log:
-> Fixed 3 validation warnings


Modified: homepage/input/lotm/lotm_200712_ru.html
===================================================================
--- homepage/input/lotm/lotm_200712_ru.html	2007-12-12 22:56:11 UTC (rev 943)
+++ homepage/input/lotm/lotm_200712_ru.html	2007-12-14 21:44:39 UTC (rev 944)
@@ -138,7 +138,7 @@
 
 <div class="lotmpic">
 <img src="$$imagedir$$/lotm/lotm_200712_o.png" alt="Level of the month" border="0">
-<div class="imagetitle">??? ??????? ???????? <br/>??? ??????? ??????, <br/>???? ??? ??????? ?? ????????!</div>
+<div class="imagetitle">??? ??????? ???????? <br>??? ??????? ??????, <br>???? ??? ??????? ?? ????????!</div>
 </div>
 
 <div class="quote">????????? ??????? ?????? ???? ??????????? ?????, ? ????????? ??????? ????????? ? ??????? ??????? ??????????? ? ????? ?????????-??????????? ?????. ??? ??????? ??????? ?????????????? ???? ? ???????? ???????????.</div>
@@ -260,7 +260,7 @@
 <p>? ?????? ?? ????? &quot;?????? ??????&quot;, ??-?? ??????? &quot;?????? ????&quot;, ? ?????? ?? ????? ? ?????? ?? ???. ????? ?? ????? ??????????? ?????? ?? ???, ?????? ??? ??? ????? ???? ?? 10 &quot;????????????&quot; ??????? ??????, ??????? ?? ??? &quot;??????????? ???????????&quot;. ????, ?? ??????? ? ???????, ????? ?? ? 11 ??? ??????:
 &quot;?? ????? ?????? ????? ????? ?????????? ??????????????? ? ???????????? ??????? Enigma&hellip;&quot;
 
-<p>????? ????????, ??????? ???????? ???????, ? IV/2,<br/>
+<p>????? ????????, ??????? ???????? ???????, ? IV/2,<br>
 <i>Harry ? Andreas</i></p>
 
 </div>



From ral at mail.berlios.de  Wed Dec 19 00:19:38 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Wed, 19 Dec 2007 00:19:38 +0100
Subject: [Enigma-game-svn] r945 - in trunk: data src src/lev
Message-ID: <200712182319.lBINJc2O029398@sheep.berlios.de>

Author: ral
Date: 2007-12-19 00:19:35 +0100 (Wed, 19 Dec 2007)
New Revision: 945

Modified:
   trunk/data/init.lua
   trunk/src/enigma.cc
   trunk/src/items.cc
   trunk/src/lev/Proxy.cc
   trunk/src/lua.cc
   trunk/src/st_switches.cc
   trunk/src/stones.hh
   trunk/src/stones_complex.cc
   trunk/src/stones_simple.cc
   trunk/src/world.cc
   trunk/src/world.hh
   trunk/src/world_internal.hh
Log:
Trunk 1.1: new API - reengineering signals
- signals eliminated in engine
- AddSignal and init.lua convert old API requests to new API substitutions
- engine bool Value made compatible to int Value - this allows 
  PerformAction bool values to feed as "signal" message int values
- "destination" attribute (position|tokens) for vortex and wormhole
  (successor of "targetx","targety" and signal coded targets)
- fix DAT levels did not run in correct compatibility mode


Modified: trunk/data/init.lua
===================================================================
--- trunk/data/init.lua	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/data/init.lua	2007-12-18 23:19:35 UTC (rev 945)
@@ -45,6 +45,24 @@
 	     _val = 0 + val   -- convert to int
 	 end
      end
+     if key == "targetx" then
+         local d = enigma._GetAttrib(obj, "destination")
+         if (en.usertype(d) == "position") then
+             _val = po(val + 0, d.y)
+         else
+             _val = po(val + 0, 0)
+         end
+         _key = "destination"
+     end
+     if key == "targety" then
+         local d = enigma._GetAttrib(obj, "destination")
+         if (en.usertype(d) == "position") then
+             _val = po(d.x, val + 0)
+         else
+             _val = po(0, val + 0)
+         end
+         _key = "destination"
+     end
      enigma._SetAttrib(obj, _key, _val)
 end
 
@@ -56,6 +74,18 @@
 	     val = "" .. val   -- convert to string
 	 end
      end
+     if key == "targetx" then
+         local d = enigma._GetAttrib(obj, "destination")
+         if (en.usertype(d) == "position") then
+             val = d.x
+         end
+     end
+     if key == "targety" then
+         local d = enigma._GetAttrib(obj, "destination")
+         if (en.usertype(d) == "position") then
+             val = d.y
+         end
+     end
      return val
 end
 

Modified: trunk/src/enigma.cc
===================================================================
--- trunk/src/enigma.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/enigma.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -159,14 +159,14 @@
     ObjectList::iterator it;
     for (it = aList.begin(); it != aList.end(); ++it) {
         if (*it == NULL)
-            descriptor.append("$0,");
+            descriptor.append("#0,");
         else {
             Value v = (*it)->getAttr("name");
             if (v && v.type == STRING && strcmp(v.val.str, "") != 0) {
                 descriptor.append(v);
                 descriptor.append(",");
             } else {
-                descriptor.append(ecl::strf("$%d,", (*it)->getId()));
+                descriptor.append(ecl::strf("#%d,", (*it)->getId()));
             }   
         }
     }
@@ -185,7 +185,7 @@
                 descriptor.append((*it).val.str);
                 break;
             case OBJECT :
-                descriptor.append(ecl::strf("$%d", (int)((*it).val.dval[0])));
+                descriptor.append(ecl::strf("#%d", (int)((*it).val.dval[0])));
                 break;
             case GROUP :
                 descriptor.append("%");
@@ -310,8 +310,9 @@
 Value::operator double() const {
     switch (type) {
         case DOUBLE: 
+            return val.dval[0];
         case BOOL: 
-            return val.dval[0];
+            return (val.dval[0] != 0) ? 1 : 0;
         case STRING:
             return atof(val.str);  // TODO use strtod and eval remaining part of string
         default:
@@ -322,8 +323,9 @@
 Value::operator int() const {
     switch (type) {
         case DOUBLE:
+            return round_nearest<int>(val.dval[0]);
         case BOOL: 
-            return round_nearest<int>(val.dval[0]);
+            return (val.dval[0] != 0) ? 1 : 0;
         case STRING: 
             return atoi(val.str);  //TODO use strtol and eval remaining part of string
         default: return 0;
@@ -359,7 +361,7 @@
             ecl::split_copy(std::string(val.str), ',', back_inserter(vs));
             for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
                 if (it->size() > 0) {
-                    if ((*it)[0] == '$') {
+                    if ((*it)[0] == '#') {
                         result.push_back(Object::getObject(atoi((*it).c_str() + 1)));
                     } else {
                         result.push_back(GetNamedObject(*it));
@@ -384,7 +386,7 @@
             ecl::split_copy(std::string(val.str), ';', back_inserter(vs));
             for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
                 if (it->size() > 0) {
-                    if ((*it)[0] == '$') {
+                    if ((*it)[0] == '#') {
                         // an object id
                         Value v(OBJECT);
                         v.val.dval[0] = atoi((*it).c_str() + 1);
@@ -486,7 +488,8 @@
 bool Value::to_bool() const {
     switch (type) {
         case BOOL :
-            return val.dval[0];
+        case DOUBLE :
+            return val.dval[0] != 0;
         case NIL :
         case DEFAULT :
             return false;

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/items.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -444,20 +444,6 @@
         CLONEOBJ(Key);
         DECL_TRAITS_ARRAY(3, subtype);
 
-        virtual Value message (const string &msg, const Value &) {
-            if (msg == "init") {
-                // Oxyd uses signals from keys to key switches to
-                // determine which keys activate which key hole.
-                GridPos keystonepos;
-                for (int idx=0; GetSignalTargetPos (this, keystonepos, idx); ++idx) {
-                    Stone *st = GetStone(keystonepos);
-                    if (st && st->is_kind("st-key"))
-                        st->set_attrib("keycode", getAttr("keycode"));
-                }
-            }
-            return Value();
-        }
-
     public:
         enum SubType { KEY1, KEY2, KEY3 } subtype;
     	Key(SubType type = KEY1)
@@ -747,7 +733,7 @@
         transmute(flippedkind[m_type]);
     }
     else if (m == "signal") {
-        if (to_double(val) != 0) {
+        if (val != 0) {
             Type flippedkind[] = {HILL,HILL, TINYHILL,TINYHILL};
             transmute(flippedkind[m_type]);
         } else {
@@ -1737,25 +1723,29 @@
 }
 
 bool WormHole::get_target(V2 &targetpos) {
-    Value vx = getAttr("targetx");
-    Value vy = getAttr("targety");
-    if (vx && vy) {
-        targetpos[0] = vx;
-        targetpos[1] = vy;
+    Value dest = getAttr("destination");
+    if (dest.getType() == Value::POSITION) {
+        // arbitrary precision position as destination
+        targetpos = dest;
         return true;
-    }
-    else {
-        // no target attributes -> search for signal
-        GridPos p;
-        if (GetSignalTargetPos(this, p)) {
-            targetpos = p.center();
-            return true;
-        }
-        else {
-            warning("no target attributes and no signal found");
+    } else {
+        // evaluate the first object 
+        TokenList tl = dest;  // convert any object type value to a tokenlist 
+        if (tl.empty())
             return false;
+        ObjectList ol = tl.front();  // convert first token to a objectlist
+        if (ol.empty())
+            return false;
+        GridObject *go = dynamic_cast<GridObject *>(ol.front());  // get first object
+        if (go != NULL) {   // no actors as destination!
+            GridPos p = go->get_pos();
+            if (IsInsideLevel(p)) {   // no objects in inventory,...
+                targetpos = p.center();
+                return true;
+            }
         }
     }
+    return false;
 }
 
 bool WormHole::actor_hit(Actor *actor)
@@ -2005,22 +1995,30 @@
         open();
 }
 
-bool Vortex::get_target_by_index (int idx, V2 &target)
-{
-    GridPos targetpos;
-    // signals take precedence over targetx, targety attributes
-    if (GetSignalTargetPos(this, targetpos, idx)) {
-        target = targetpos.center();
+bool Vortex::get_target_by_index (int idx, V2 &targetpos) {
+    int i = 0;  // counter for destination candidates
+    Value dest = getAttr("destination");
+    if (dest.getType() == Value::POSITION && idx == 0) {
+        // arbitrary precision position as destination
+        targetpos = dest;
         return true;
-    }
-    // no signal defined
-    else if (idx == 0) {
-        Value vx = getAttr("targetx");
-        Value vy = getAttr("targety");
-        if (vx && vy) {
-            target[0] = vx;
-            target[1] = vy;
-            return true;
+    } else {
+        // evaluate destination objects in sequence up to "idx"
+        TokenList tl = dest;  // convert any object type value to a tokenlist 
+        for (TokenList::iterator tit = tl.begin(); tit != tl.end(); ++tit) {
+            ObjectList ol = *tit;  // convert next token to an objectlist
+            for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit, i++) {
+                if (i == idx) {
+                    GridObject *go = dynamic_cast<GridObject *>(*oit);  // get the object
+                    if (go != NULL) {   // no actors as destination!
+                        GridPos p = go->get_pos();
+                        if (IsInsideLevel(p)) {   // no objects in inventory,...
+                            targetpos = p.center();
+                            return true;
+                        }
+                    }
+                }
+            }
         }
     }
     return false;
@@ -2729,13 +2727,7 @@
         int open = -1;
 
         if (msg == "signal") {
-            if (val.getType() == Value::DOUBLE) {
-                // val: 1 means "shrink", 0 means "grow"
-                open = (int)val;
-            }
-            else {
-                ASSERT(0, XLevelRuntime, "Blocker: message 'signal' with wrong typed value");
-            }
+            open = val;
         }
         else if (msg == "open")
             open = 1;

Modified: trunk/src/lev/Proxy.cc
===================================================================
--- trunk/src/lev/Proxy.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/lev/Proxy.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -439,6 +439,12 @@
         if (normPathType == pt_oxyd) {
             if(onlyMetadata)
                 return;
+            // set server flags
+            server::SetCompatibility(this);
+            server::EnigmaCompatibility = getEnigmaCompatibility();
+            server::LevelStatus = getLevelStatus();
+            if (server::EnigmaCompatibility < 1.10)
+                server::AllowSingleOxyds = true;
             // use oxyd loader
             std::string::size_type posSecondHash = normLevelPath.find('#',1);
             if (posSecondHash == string::npos)

Modified: trunk/src/lua.cc
===================================================================
--- trunk/src/lua.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/lua.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -854,6 +854,19 @@
     return 1;
 }
 
+static int userType(lua_State *L) {
+    std::string type;
+    if (is_object(L, 1)) type = "object";
+    else if (is_position(L, 1)) type = "position";
+    else if (is_tile(L, 1)) type = "tile";
+    else if (is_tiles(L, 1)) type = "tiles";
+    else if (is_group(L, 1)) type = "group";
+    else if (is_world(L, 1)) type = "world";
+    
+    lua_pushstring(L, type.c_str());
+    return 1;
+}
+
 static int newPosition(lua_State *L) {
     // (pos|obj|table|(num,num))
     if (is_table(L, 1)) {  // table 
@@ -2270,6 +2283,7 @@
 
 static CFunction levelFuncs[] = {
     {mathRandom,                    "random"},
+    {userType,                      "usertype"},
     {newGroup,                      "grp"},
     {newPosition,                   "po"},
     {getFloor,                      "fl"},

Modified: trunk/src/st_switches.cc
===================================================================
--- trunk/src/st_switches.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/st_switches.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -159,7 +159,7 @@
 }
 
 
-
+
 /* -------------------- Coin slot -------------------- */
 
 namespace
@@ -258,7 +258,7 @@
     }
 }
 
-
+
 /* -------------------- Key switches -------------------- */
 
 // Attributes:
@@ -358,7 +358,7 @@
     }
 }
 
-
+
 /* -------------------- FourSwitch -------------------- */
 
 // Attributes:
@@ -370,52 +370,56 @@
 {
     class FourSwitch : public OnOffStone {
         CLONEOBJ(FourSwitch);
+        DECL_TRAITS;
     public:
         FourSwitch() : OnOffStone("st-fourswitch"), 
                        m_direction(NORTH), 
                        m_inactive_so_far (true)
         {}
+        
+        Value getAttr(const string &key) const {
+            if (key == "state")
+                return direction2state(m_direction);
+            return Object::getAttr(key);
+        }
     private:
+        static int direction2state(Direction dir) {
+            return 3 - dir;
+        };
+        
         // Variables
         Direction m_direction;
         bool m_inactive_so_far;
 
         // Private methods
-        void turn() 
-        {
-            static int direction2idx[] = { 
-                3, // WEST
-                2, // SOUTH
-                1, // EAST
-                0  // NORTH
-            };
-
-            if (!m_inactive_so_far) {
-                EmitSignalByIndex(this, direction2idx[m_direction], 0);
+        void turn() {
+            bool isGlobalTarget = getAttr("target");
+            
+            if (!m_inactive_so_far && !isGlobalTarget) {
+                PerformAction(this, false);  // signal off for old direction state
             } else
                 m_inactive_so_far = false;
 
-            m_direction = rotate_cw (m_direction);
+            m_direction = rotate_cw(m_direction);
             init_model();
             set_on(!is_on());
-            sound_event ("fourswitch");
+            sound_event("fourswitch");
 
-            if (HaveSignals (this)) {
-                EmitSignalByIndex(this, direction2idx[m_direction], 1);
+            if (isGlobalTarget) {
+                PerformAction(this, (server::EnigmaCompatibility < 1.10) ? is_on() : 3 - m_direction);
             } else {
-                // no signal handler defined
-                PerformAction(this, is_on());
+                PerformAction(this, true);  // signal on for new direction state
             }
         }
 
         void init_model() {
             switch (m_direction) {
-            case NORTH: set_model("st-fourswitch-n"); break;
-            case EAST:  set_model("st-fourswitch-e"); break;
-            case SOUTH: set_model("st-fourswitch-s"); break;
-            case WEST:  set_model("st-fourswitch-w"); break;
-            case NODIR: ASSERT(0, XLevelRuntime,
-                "FourSwitch: no direction defined (found in init_model)");
+                case NORTH: set_model("st-fourswitch-n"); break;
+                case EAST:  set_model("st-fourswitch-e"); break;
+                case SOUTH: set_model("st-fourswitch-s"); break;
+                case WEST:  set_model("st-fourswitch-w"); break;
+                case NODIR: ASSERT(0, XLevelRuntime,
+                    "FourSwitch: no direction defined (found in init_model)");
             }
         }
 
@@ -423,7 +427,7 @@
             turn();
         }
 
-        virtual Value on_message (const Message &m)
+        virtual Value on_message(const Message &m)
         {
             if (m.message == "signal" || m.message == "trigger")
                 turn();
@@ -432,9 +436,10 @@
 
         const char *collision_sound() { return "metal"; }
     };
+    DEF_TRAITS(FourSwitch, "st-fourswitch", st_fourswitch);
 }
 
-
+
 /* -------------------- Laser / Time switches -------------------- */
 
 namespace
@@ -632,7 +637,7 @@
 void TimeSwitch::notify_laseron()  {} // ignore laser
 void TimeSwitch::notify_laseroff() {}
 
-
+
 /* -------------------- Floppy switch -------------------- */
 
 // Attributes:

Modified: trunk/src/stones.hh
===================================================================
--- trunk/src/stones.hh	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/stones.hh	2007-12-18 23:19:35 UTC (rev 945)
@@ -57,6 +57,7 @@
         st_fart,
         st_firebreak,
         st_firebreak_move,
+        st_fourswitch,
         st_greenbrown_growing,
         st_knight,
         st_laserbreak,

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/stones_complex.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -1571,7 +1571,6 @@
 
 Value DoorBase::message(const string &m, const Value &val) {
     State newstate = state;
-    int ival = to_int (val);
 
     if (m == "open")
         newstate = OPENING;
@@ -1580,7 +1579,7 @@
     else if (m == "openclose")
         newstate = (state==OPEN || state==OPENING) ? CLOSING : OPENING;
     else if (m == "signal")
-        newstate = ival > 0 ? OPENING : CLOSING;
+        newstate = val.to_bool() ? OPENING : CLOSING;
 
     if (newstate==OPENING && (state==CLOSED || state==CLOSING))
         change_state(OPENING);

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/stones_simple.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -22,6 +22,7 @@
 #include "server.hh"
 #include "player.hh"
 #include "client.hh"
+#include "main.hh"
 #include "Inventory.hh"
 
 #include "stones_internal.hh"
@@ -1562,25 +1563,41 @@
     class ActorImpulseStone : public ActorImpulseBase {
         CLONEOBJ(ActorImpulseStone);
 
-        int m_signalidx;
+        int signalidx;
 
         virtual Value message (const string &msg, const Value &) {
-            if (msg == "signal") {
-                EmitSignalByIndex (this, m_signalidx, 0);
-                m_signalidx += 1;
-                if (!EmitSignalByIndex (this, m_signalidx, 1)) {
-                    m_signalidx = 0;
-                    EmitSignalByIndex (this, m_signalidx, 1);
+            if(server::GameCompatibility != GAMET_ENIGMA) {
+                // Oxyd* usage of ActorImpulseStone as a signal multiplier
+                ObjectList ol = getAttr("$!oxyd!destinations");
+                
+                if (msg == "init" && ol.size() > 0) {
+                    signalidx = 0;
+                    SendMessage(ol.front(), "signal", 1);
+                } else if (msg == "signal") {
+                    int i = 0;
+                    bool didBreak = false;
+                    for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit, i++) {
+                        if (i == signalidx) {
+                            SendMessage(*oit, "signal", 0);
+                        } else if (i == signalidx + 1) {
+                            SendMessage(*oit, "signal", 1);
+                            didBreak = true;
+                            break;
+                        }
+                    }
+                    if (!didBreak && ol.size() > 0) {
+                        SendMessage(ol.front(), "signal", 1);
+                        signalidx = 0;                        
+                    } else
+                        signalidx++;
                 }
-            } else if (msg == "init") {
-                EmitSignalByIndex (this, m_signalidx, 1);
-            }
+            } // GameCompatibility != GAMET_ENIGMA
             return Value();
         }
 
     public:
         ActorImpulseStone() : ActorImpulseBase("st-actorimpulse"),
-                              m_signalidx(0)
+                              signalidx(0)
         {}
     };
 

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/world.cc	2007-12-18 23:19:35 UTC (rev 945)
@@ -98,89 +98,6 @@
 {
 }
 
-
-/* -------------------- Signals -------------------- */
-
-namespace
-{
-
-    void emit_signal (const Signal *s, int value)
-    {
-        Object *src = s->source;
-        Object *dst = GetObject(s->destloc);
-
-#if defined(VERBOSE_MESSAGES)
-        src->warning("emit_from: msg='%s'", // dest=%i/%i obj=%p",
-                     s->message.c_str()
-//                      destloc.pos.x, destloc.pos.y,
-//                      dst);
-                     );
-#endif
-        if (GridObject *go = dynamic_cast<GridObject*>(src))
-            SendMessage (dst, Message (s->message, value, go->get_pos()));
-        else
-            SendMessage (dst, Message (s->message, value));
-    }
-
-    void emit_from (const SignalList &sl, Object *source, int value)
-    {
-        size_t size = sl.size();
-        for (unsigned i=0; i<size; ++i) {
-            if (sl[i].source == source)
-                emit_signal (&sl[i], value);
-        }
-//         // signals may have side effects. To minimize them
-//         //   1. collect all targets and then
-//         //   2. emit signals to targets
-
-//         vector<Object*> targets;
-
-//         for (unsigned i=0; i<size; ++i) {
-//             if (m_signals[i].get_source() == source)
-//                 target.push_back (m_signals[i]);
-
-//             for (unsigned i=0; i<size; ++i)
-//                 if (GetObject(m_signals[i].get_target_loc()) == targets[i])
-//                     m_signals[i].emit_from (source, value);
-//         }
-    }
-
-    bool emit_by_index (const SignalList &sl, Object *source, int signalidx, int value) 
-    {
-        size_t size      = sl.size();
-        int    signalcnt = 0;
-        for (unsigned i=0; i<size; ++i) {
-            if (sl[i].source == source) {
-                if (signalcnt == signalidx) {
-                    emit_signal (&sl[i], value);
-                    return true;
-                }
-                signalcnt += 1;
-            }
-        }
-        return false;
-    }
-
-    Object *find_single_destination (const SignalList &sl, Object *src)
-    {
-        Object *found = 0;
-        size_t  size  = sl.size();
-
-        for (unsigned i = 0; i<size; ++i) {
-            if (sl[i].source == src) {
-                if (Object *candidate = GetObject(sl[i].destloc)) {
-                    if (!found)
-                        found = candidate;
-                    else if (candidate != found)
-                        return 0;   // multiple targets
-                }
-            }
-        }
-        return found;
-    }
-}
-
-
 /* -------------------- RubberBandData -------------------- */
 
 RubberBandData::RubberBandData () {
@@ -1865,57 +1782,112 @@
 }
 
 
-/* -------------------- Signals -------------------- */
+/* -------------------- Signals, Messages, Actions -------------------- */
 
-void AddSignal (const GridLoc &srcloc, 
-                       const GridLoc &dstloc, 
-                       const string &msg)
-{
+void AddSignal (const GridLoc &srcloc, const GridLoc &dstloc, const string &msg) {
+    // this code is for Oxyd and Enigma < 1.1 compatibility only
 #if defined(VERBOSE_MESSAGES)
     fprintf(stderr, "AddSignal src=%i/%i dest=%i/%i msg='%s'\n",
             srcloc.pos.x, srcloc.pos.y, dstloc.pos.x, dstloc.pos.y, msg.c_str());
 #endif // VERBOSE_MESSAGES
 
-    if (Object *src = GetObject(srcloc)) {
-        src->set_attrib("action", "signal");
-        level->m_signals.push_back (Signal (src, dstloc, msg));
+    Object *src = GetObject(srcloc);
+    Object *dst = GetObject(dstloc);
+    
+    if (src == NULL) {
+        Log << ecl::strf("AddSignal: Invalid signal source: src=%i/%i-%d dest=%i/%i-%d msg='%s'\n",
+            srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
+        return;  // ignore signal
     }
-    else {
-        Log << "AddSignal: Invalid signal source\n";
+    
+    // key: Oxyd uses signals to define the destination of wormholes
+    if (src->getObjectType() == Object::ITEM) {
+        ItemID src_id = get_id(dynamic_cast<Item *>(src));
+        if (src_id >= it_wormhole_off && src_id <= it_wormhole_on) {
+//            Log << ecl::strf("AddSignal: Wormhole signal destination src=%i/%i-%d dest=%i/%i-%d msg='%s'\n",
+//                srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
+            src->set_attrib("destination", GetFloor(dstloc.pos));  // use floor to guarantee existence
+            return;
+        }
     }
-}
-
-bool HaveSignals (Object *src) 
-{
-    SignalList::const_iterator i=level->m_signals.begin(),
-        end = level->m_signals.end();
-    for (; i != end; ++i) 
-        if (i->source == src) 
-            return true;
-    return false;
-}
-
-
-bool EmitSignalByIndex (Object *src, int signalidx, int value) 
-{
-    return emit_by_index (level->m_signals, src, signalidx, value);
-}
-
-bool GetSignalTargetPos (Object *src, GridPos &pos, int signalidx) 
-{
-    SignalList::const_iterator i = level->m_signals.begin(),
-        end = level->m_signals.end();
-    int idx = 0;
-    for (; i != end; ++i) {
-        if (i->source == src) {
-            if (idx == signalidx) {
-                pos = i->destloc.pos;
-                return true;
+    if (src->getObjectType() == Object::ITEM) {
+        ItemID src_id = get_id(dynamic_cast<Item *>(src));
+        if (src_id >= it_vortex_open && src_id <= it_vortex_closed) {
+//            Log << ecl::strf("AddSignal: Vortex signal destination src=%i/%i-%d dest=%i/%i-%d msg='%s'\n",
+//                srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
+            TokenList tl = src->getAttr("destination");  // may be empty or may contain some tokens
+            tl.push_back(GetFloor(dstloc.pos));  // use floor to guarantee existence);
+            src->set_attrib("destination", tl);
+            return;
+        }
+    }
+    
+    
+    if (dst == NULL) {
+        Log << ecl::strf("AddSignal: Invalid signal destination src=%i/%i-%d dest=%i/%i-%d msg='%s'\n",
+            srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
+        return; // ignore signal
+    }
+//    Log << ecl::strf("AddSignal: Valid signal destination src=%i/%i-%d dest=%i/%i-%d msg='%s'\n",
+//        srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
+    
+    Value dstValue(dst);
+    
+    if (dst->is_kind("st-blocker") || dst->is_kind("st-blocker-growing") ||
+            dst->is_kind("it-blocker")) {
+        if (!dst->getAttr("name"))
+            NameObject(dst, ecl::strf("$!oxyd!blocker%d", dst->getId()));
+        dstValue = dst->getAttr("name");
+    }
+    
+    if (dst->is_kind("it-hill") || dst->is_kind("it-tinyhill") ||
+            dst->is_kind("it-hollow") || dst->is_kind("it-tinyhollow")) {
+        if (!dst->getAttr("name"))
+            NameObject(dst, ecl::strf("$!oxyd!hillhollow%d", dst->getId()));
+        dstValue = dst->getAttr("name");
+    }
+    
+    if (src->is_kind("st-actorimpulse")) {
+        Log << "AddSignal for st-actorimpulse\n";
+        ObjectList ol = src->getDefaultedAttr("$!oxyd!destinations", Value(Value::GROUP));
+        ol.push_back(dstValue);
+        src->set_attrib("$!oxyd!destinations", ol);
+        return;
+    }
+    
+    std::string target_key = "target";
+    std::string action_key = "action";
+    
+    // fourswitch: 4 subsequent AddSignal calls for state specific signals
+    if (src->getObjectType() == Object::STONE
+            && get_id(dynamic_cast<Stone *>(src)) == st_fourswitch) {
+        for (int i = 0;; i++) {
+            if (!src->getAttr(ecl::strf("target_%d", i))) {
+                target_key = ecl::strf("target_%d", i);
+                action_key = ecl::strf("action_%d", i);
+                break;
             }
-            idx += 1;
         }
     }
-    return false;
+    
+    // key: Oxyd uses signals from keys to key switches to determine which keys
+    // activate which key hole
+    if (src->getObjectType() == Object::ITEM) {
+        ItemID src_id = get_id(dynamic_cast<Item *>(src));
+        if (src_id >= it_key_a && src_id <= it_key_c && dst->is_kind("st-key")) {
+            dst->set_attrib("keycode", src->getAttr("keycode"));
+            return;
+        }
+    }
+    
+    // this function is supported for old API only - we can assume that target, action
+    // are not set by other means than this function:
+    TokenList targets = src->getDefaultedAttr(target_key, Value(Value::TOKENS));    
+    targets.push_back(dstValue);   // add this target to existing ones
+    src->set_attrib(target_key, Value(targets));
+    TokenList actions = src->getDefaultedAttr(action_key, Value(Value::TOKENS));    
+    actions.push_back(Value("signal"));   // add this target to existing ones
+    src->set_attrib(action_key, Value(actions));
 }
 
 
@@ -1992,6 +1964,7 @@
                 }
             }
             // else ignore this no longer valid target
+//            Log << "PerformAction target not valid\n";
         } else {
             // send message to all objects
             if (action == "") 
@@ -2008,11 +1981,6 @@
         
         if (ait != actions.end()) ++ait;
     }
-    
-    if ((targets.size() == 0) && (actions.size() == 1) && actions.front().to_string() == "signal") {
-        // pre 1.10 signal handling
-        emit_from(level->m_signals, obj, onoff);
-    }
 }
 
 

Modified: trunk/src/world.hh
===================================================================
--- trunk/src/world.hh	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/world.hh	2007-12-18 23:19:35 UTC (rev 945)
@@ -244,18 +244,9 @@
 
 /* -------------------- Signals & Messages -------------------- */
 
-    void    AddSignal (const GridLoc &src, 
-                       const GridLoc &dst, 
-                       const string &msg);
+    // just for Oxyd and old API compatibility
+    void AddSignal (const GridLoc &src, const GridLoc &dst, const string &msg);
 
-    bool    HaveSignals (Object *src);
-
-    /*! Return true if suitable signal was found. */
-    bool    EmitSignalByIndex (Object *src, int signalidx, int value=0);
-
-    /* Signal indices start at 0 */
-    bool GetSignalTargetPos (Object *src, GridPos &pos, int signalidx = 0);
-
     void BroadcastMessage (const std::string& msg, const Value& value, 
                            GridLayerBits grids);
 

Modified: trunk/src/world_internal.hh
===================================================================
--- trunk/src/world_internal.hh	2007-12-14 21:44:39 UTC (rev 944)
+++ trunk/src/world_internal.hh	2007-12-18 23:19:35 UTC (rev 945)
@@ -32,20 +32,6 @@
     typedef vector<Signal>       SignalList;
 
 
-/* -------------------- Signals -------------------- */
-
-    struct Signal {
-        // Variables
-        Object *source;
-        GridLoc destloc;
-        string message;
-
-        // Constructor
-        Signal (Object *src, GridLoc dstloc, const string &msg)
-        : source (src), destloc(dstloc), message(msg)
-        {}
-    };
-
 /* -------------------- RubberBand -------------------- */
     
     /*! Stores the physical information about a rubber band (to which
@@ -350,7 +336,7 @@
         Actor               *leftmost_actor;   // sorted double linked list of actors
         Actor               *rightmost_actor;  
         vector<RubberBand *> m_rubberbands;
-        SignalList           m_signals;
+//        SignalList           m_signals;
         MouseForce           m_mouseforce;
         ConstantForce        m_flatforce;
         int                  scrambleIntensity;



From ral at mail.berlios.de  Thu Dec 20 00:09:09 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Thu, 20 Dec 2007 00:09:09 +0100
Subject: [Enigma-game-svn] r946 - trunk/src
Message-ID: <200712192309.lBJN99vQ029766@sheep.berlios.de>

Author: ral
Date: 2007-12-20 00:09:08 +0100 (Thu, 20 Dec 2007)
New Revision: 946

Modified:
   trunk/src/enigma.cc
   trunk/src/lua.cc
   trunk/src/ox_oxyd1.cc
   trunk/src/st_switches.cc
Log:
Trunk 1.1: 
- fix r945: vortex with position as destination
- fix oxyd stone mapping
- fix fourswitch: signal,trigger react only on rising edge if not Enigma mode


Modified: trunk/src/enigma.cc
===================================================================
--- trunk/src/enigma.cc	2007-12-18 23:19:35 UTC (rev 945)
+++ trunk/src/enigma.cc	2007-12-19 23:09:08 UTC (rev 946)
@@ -410,8 +410,9 @@
 
 Value::operator ecl::V2() const {
     switch (type) {
-        case POSITION:
+        case POSITION: {
             return ecl::V2(val.dval[0], val.dval[1]);
+        }
         default:
             return ecl::V2(0, 0);
     }

Modified: trunk/src/lua.cc
===================================================================
--- trunk/src/lua.cc	2007-12-18 23:19:35 UTC (rev 945)
+++ trunk/src/lua.cc	2007-12-19 23:09:08 UTC (rev 946)
@@ -276,8 +276,8 @@
 static ecl::V2 toPosition(lua_State *L, int idx) {
     double x = 0;
     double y = 0;
-    if (is_position(L, -1)) {  // position
-        lua_getmetatable(L, -1);
+    if (is_position(L, idx)) {  // position
+        lua_getmetatable(L, idx);
         lua_rawgeti(L, -1, 1);
         lua_rawgeti(L, -2, 2);
         x = lua_tonumber(L, -2);

Modified: trunk/src/ox_oxyd1.cc
===================================================================
--- trunk/src/ox_oxyd1.cc	2007-12-18 23:19:35 UTC (rev 945)
+++ trunk/src/ox_oxyd1.cc	2007-12-19 23:09:08 UTC (rev 946)
@@ -171,7 +171,7 @@
     0,                          // Oxyd1 stone 0x00
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     "st-fakeoxyd",              // Oxyd1 stone 0x11
-    "st-plain_break",           // Oxyd1 stone 0x12
+    "st-door_c",                // Oxyd1 stone 0x12
     "st-bigbrick-es",           // Oxyd1 stone 0x13
     "st-bigbrick-sw",           // Oxyd1 stone 0x14
     "st-bigbrick-ne",           // Oxyd1 stone 0x15

Modified: trunk/src/st_switches.cc
===================================================================
--- trunk/src/st_switches.cc	2007-12-18 23:19:35 UTC (rev 945)
+++ trunk/src/st_switches.cc	2007-12-19 23:09:08 UTC (rev 946)
@@ -429,8 +429,10 @@
 
         virtual Value on_message(const Message &m)
         {
-            if (m.message == "signal" || m.message == "trigger")
-                turn();
+            if (m.message == "signal" || m.message == "trigger") {
+                if (server::GameCompatibility == enigma::GAMET_ENIGMA || m.value == 1)
+                    turn();
+            }
             return Value();
         }
 



From ral at mail.berlios.de  Fri Dec 21 17:38:14 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Fri, 21 Dec 2007 17:38:14 +0100
Subject: [Enigma-game-svn] r947 - trunk/src
Message-ID: <200712211638.lBLGcEap026407@sheep.berlios.de>

Author: ral
Date: 2007-12-21 17:38:13 +0100 (Fri, 21 Dec 2007)
New Revision: 947

Modified:
   trunk/src/stones.cc
   trunk/src/world.cc
Log:
Trunk 1.1: 
- fix r941: messages to Black/WhiteBallStone


Modified: trunk/src/stones.cc
===================================================================
--- trunk/src/stones.cc	2007-12-19 23:09:08 UTC (rev 946)
+++ trunk/src/stones.cc	2007-12-21 16:38:13 UTC (rev 947)
@@ -23,6 +23,7 @@
 #include "client.hh"
 #include "player.hh"
 #include "Inventory.hh"
+#include "main.hh"
 
 using namespace std;
 

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-19 23:09:08 UTC (rev 946)
+++ trunk/src/world.cc	2007-12-21 16:38:13 UTC (rev 947)
@@ -1971,9 +1971,9 @@
                 action = "toggle";
             for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
                 if (*oit != NULL) {
-                    if (GridObject *go = dynamic_cast<GridObject*>(*oit))
+                    if (GridObject *go = dynamic_cast<GridObject*>(obj)) {
                         SendMessage(*oit, Message(action, Value(onoff), go->get_pos()));
-                    else
+                    } else
                         SendMessage(*oit, Message(action, Value(onoff)));
                 }
             }



From ral at mail.berlios.de  Sat Dec 22 00:47:40 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sat, 22 Dec 2007 00:47:40 +0100
Subject: [Enigma-game-svn] r948 - trunk/src
Message-ID: <200712212347.lBLNlelJ001939@sheep.berlios.de>

Author: ral
Date: 2007-12-22 00:47:39 +0100 (Sat, 22 Dec 2007)
New Revision: 948

Modified:
   trunk/src/actors.cc
   trunk/src/items.cc
   trunk/src/main.hh
   trunk/src/stones_simple.cc
Log:
Trunk 1.1: it-vortex
- fix object kill issues
- add "autoclose" attribute: close after a warp
- add "scissor" attribute, defaults to true on new API, false on old
- perform action on actor passing - value false for source, true for dst.


Modified: trunk/src/actors.cc
===================================================================
--- trunk/src/actors.cc	2007-12-21 16:38:13 UTC (rev 947)
+++ trunk/src/actors.cc	2007-12-21 23:47:39 UTC (rev 948)
@@ -979,7 +979,7 @@
         if (Item *it = GetItem(get_gridpos())) {
             ItemID id = get_id(it);
             if (id == it_vortex_open || id == it_vortex_closed) 
-                SendMessage(it, "arrival"); // closes some vortex
+                SendMessage(it, "_passed"); // closes some vortex
         }
         change_state(JUMP_VORTEX);
         break;

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-21 16:38:13 UTC (rev 947)
+++ trunk/src/items.cc	2007-12-21 23:47:39 UTC (rev 948)
@@ -1795,16 +1795,7 @@
 
 They may be opened or closed. Is a vortex is closed, the actor cannot enter.
 
-\subsection vortexa Attributes
-- \b targetx:       X coordinate of the destination
-- \b targety:       Y coordinate of the destination
 
-\subsection vortexe Example
-\verbatim
-set_item("it-vortex-open", 1,1, {targetx=5.5, targety=10.5})
-set_item("it-vortex-closed", 3,1, {targetx=7.5, targety=10.5})
-\endverbatim
-
 \subsection vortexm Messages
 - \b open       opens the vortex
 - \b close      closes the vortex
@@ -1847,7 +1838,7 @@
         void openclose();
 
         void prepare_for_warp (Actor *actor);
-        void emit_actor();
+        void emit_actor(Vortex *destVortex);
 
         bool get_target_by_index (int idx, V2 &target);
         void perform_warp();    // warp swallowed actor(s)
@@ -1869,10 +1860,6 @@
         };
 
         State  state;
-        bool   close_after_warp;
-        Actor *m_actor_being_warped;
-        int    m_target_index;
-        Vortex *m_target_vortex;
     };
 
     ItemTraits Vortex::traits[2] = {
@@ -1883,17 +1870,20 @@
     const double Vortex::RANGE = 0.5/2;
 }
 
-Vortex::Vortex(bool opened)
-: state(opened ? OPEN : CLOSED),
-  close_after_warp(!opened),
-  m_actor_being_warped (0),
-  m_target_index (0),
-  m_target_vortex(0)
-{
+Vortex::Vortex(bool open) : state(open ? OPEN : CLOSED) {
+    set_attrib("autoclose", !open);
+    set_attrib("$dest_idx", 0);
+    set_attrib("$dest_vortex", (Object *)NULL);
+    set_attrib("$grabbed_actor", (Object *)NULL);
 }
 
 Vortex::~Vortex() {
     GameTimer.remove_alarm(this);
+    if (Actor *actor = dynamic_cast<Actor *>((Object *)getAttr("$grabbed_actor"))) {
+        // release an actor that is grabbed on behalf of this vortex - actor state FALLING_VORTEX
+        SendMessage(actor, "rise");
+    }
+    
 }
 
 void Vortex::on_removal(GridPos p) {
@@ -1902,19 +1892,17 @@
         XLevelRuntime, "Tried to kill a busy vortex. Please use another way.");
 }
 
-void Vortex::prepare_for_warp (Actor *actor)
-{
+void Vortex::prepare_for_warp (Actor *actor) {
     SendMessage(actor, "fallvortex");
-    m_target_index = 0;
-    m_actor_being_warped = actor;
+    set_attrib("$dest_idx", 0);
+    set_attrib("$grabbed_actor", actor);
     state = SWALLOWING;
 
     GameTimer.set_alarm(this, 0.4, false);
 }
 
 
-bool Vortex::actor_hit (Actor *actor)
-{
+bool Vortex::actor_hit (Actor *actor) {
     if (state == OPEN && near_center_p(actor) && actor->can_be_warped())
         prepare_for_warp (actor);
     return false;
@@ -1933,23 +1921,29 @@
         openclose();
     else if (msg == "open")
         open();
-    else if (msg == "close" || (msg == "arrival" && close_after_warp)) {
+    else if (msg == "close" || (msg == "_passed" && getAttr("autoclose").to_bool())) {
         close();
     }
+    
+    if (msg == "_passed")
+        PerformAction(this, true);
     return Value();
 }
 
 void Vortex::init_model() {
     switch(state) {
-    case WARPING:
-    case OPEN:
-    case EMITTING:
-    case SWALLOWING:
-        set_model("it-vortex-open");
-        break;
-    case CLOSED: set_model("it-vortex-closed"); break;
-    case OPENING: set_anim("it-vortex-opening"); break;
-    case CLOSING: set_anim("it-vortex-closing"); break;
+        case WARPING:
+        case OPEN:
+        case EMITTING:
+        case SWALLOWING:
+            set_model("it-vortex-open");
+            break;
+        case CLOSED: 
+            set_model("it-vortex-closed"); break;
+        case OPENING: 
+            set_anim("it-vortex-opening"); break;
+        case CLOSING: 
+            set_anim("it-vortex-closing"); break;
     }
 }
 
@@ -2028,7 +2022,7 @@
     if (state == WARPING) {
         perform_warp();
     } else if (state == EMITTING) {
-        emit_actor();
+        emit_actor(dynamic_cast<Vortex *>((Object *)getAttr("$dest_vortex")));
     } else if (state == SWALLOWING) {
         state = WARPING;
         sound_event ("hitfloor");
@@ -2037,39 +2031,59 @@
         ASSERT (0, XLevelRuntime, "Vortex: alarm called with inconsistent state");
 }
 
-void Vortex::emit_actor () {
-    V2 v(m_target_vortex->get_pos().center());
-    WarpActor (m_actor_being_warped, v[0], v[1], false);
-    SendMessage (m_actor_being_warped, "rise");
-    m_actor_being_warped = 0;
+void Vortex::emit_actor(Vortex *destVortex) {
+    if (destVortex == NULL)   // destination vortex got killed in meantime
+        destVortex = this;    // reemit from source vortex 
+    V2 v(destVortex->get_pos().center());
+    if (Actor *actor = dynamic_cast<Actor *>((Object *)getAttr("$grabbed_actor"))) {
+        WarpActor(actor, v[0], v[1], false);
+        SendMessage(actor, "rise");
+        if (destVortex != this) {
+            bool isScissor = to_bool(getDefaultedAttr("scissor", 
+                    (server::EnigmaCompatibility >= 1.10) || server::GameCompatibility != GAMET_ENIGMA));
+            if (isScissor)
+                KillRubberBands(actor);
+        }
+    }
+    set_attrib("$grabbed_actor", (Object *)NULL);
 
     state = OPEN;
-    if (this != m_target_vortex && close_after_warp)
+    if (this != destVortex && getAttr("autoclose").to_bool())  // do not close source vortex if destination is currently blocked
         close();
+    if (this != destVortex)
+        PerformAction(this, false);
 }
 
 void Vortex::warp_to(const V2 &target) {
     client::Msg_Sparkle (target);
-    WarpActor (m_actor_being_warped, target[0], target[1], false);
-    SendMessage (m_actor_being_warped, "appear");
-    m_actor_being_warped = 0;
+    if (Actor *actor = dynamic_cast<Actor *>((Object *)getAttr("$grabbed_actor"))) {
+        WarpActor(actor, target[0], target[1], false);
+        SendMessage(actor, "appear");
+        bool isScissor = to_bool(getDefaultedAttr("scissor", 
+                (server::EnigmaCompatibility >= 1.10) || server::GameCompatibility != GAMET_ENIGMA));
+        if (isScissor)
+            KillRubberBands(actor);
+    }
+    set_attrib("$grabbed_actor", (Object *)NULL);
+
     state = OPEN;
-    if (close_after_warp)
+    if (getAttr("autoclose").to_bool())
         close();
+    PerformAction(this, false);
 }
 
-void Vortex::perform_warp()
-{
-    if (!m_actor_being_warped)
+void Vortex::perform_warp() {
+    Actor *actor = dynamic_cast<Actor *>((Object *)getAttr("$grabbed_actor"));
+    if (actor == NULL)
         return;
 
-    ASSERT (state == WARPING, XLevelRuntime,
-        "Vortex: perform_warp called with inconsistent state");
+    ASSERT (state == WARPING, XLevelRuntime, "Vortex: perform_warp called with inconsistent state");
 
     V2 v_target;
 
     // is another target position defined?
-    if (get_target_by_index (m_target_index, v_target)) {
+    int dest_idx = getAttr("$dest_idx");
+    if (get_target_by_index(dest_idx, v_target)) {
         GridPos  p_target(v_target);
 
         Vortex *v = dynamic_cast<Vortex*>(GetItem(p_target));
@@ -2079,46 +2093,42 @@
 
             if (st && !st->is_floating()) {
                 // is destination vortex blocked? redirect
-                m_target_index += 1;
-                client::Msg_Sparkle (v_target);
-                WarpActor (m_actor_being_warped,
-                                  v_target[0], v_target[1], false);
+                set_attrib("$dest_idx", dest_idx + 1);
+                client::Msg_Sparkle(v_target);
+                WarpActor(actor, v_target[0], v_target[1], false);
                 GameTimer.set_alarm(this, 0.4, false);
             }
             else {
-                m_target_vortex = v;
-
                 switch (v->state) {
-                case OPEN:
-                case OPENING:
-                    // destination is open
-                    emit_actor();
-                    break;
-
-                case CLOSED:
-                case CLOSING:
-                    // destination is closed
-                    SendMessage(v, "open");
-                    state = EMITTING;
-                    GameTimer.set_alarm(this, 0.4, false);
-                    break;
-                case SWALLOWING:
-                case WARPING:
-                case EMITTING:
-                    // destination is busy -> don't warp actor, emit
-                    // it where it has started
-                    m_target_vortex = this;
-                    emit_actor();
+                    case OPEN:
+                    case OPENING:
+                        // destination is open
+                        emit_actor(v);
+                        break;
+    
+                    case CLOSED:
+                    case CLOSING:
+                        // destination is closed
+                        SendMessage(v, "open");
+                        set_attrib("$dest_vortex", v);
+                        state = EMITTING;
+                        GameTimer.set_alarm(this, 0.4, false);
+                        break;
+                    case SWALLOWING:
+                    case WARPING:
+                    case EMITTING:
+                        // destination is busy -> don't warp actor, emit
+                        // it where it has started
+                        emit_actor(this);
                 }
             }
         } else {
-            warp_to (v_target);
+            warp_to(v_target);
         }
     }
     else {
         // if no target defined, don't warp actor
-        m_target_vortex = this;
-        emit_actor();
+        emit_actor(this);
     }
 }
 

Modified: trunk/src/main.hh
===================================================================
--- trunk/src/main.hh	2007-12-21 16:38:13 UTC (rev 947)
+++ trunk/src/main.hh	2007-12-21 23:47:39 UTC (rev 948)
@@ -236,7 +236,7 @@
     /**
      * Flag to use in expensive asserts as first operand in a logical or
      * statement to allow the assertion to be blocked in favour of speed.
-     * F.e. <code>ASSERT(noAssert || long_lasting_check(), XLevelRuntime, "");<code>
+     * F.e. <code>ASSERT(noAssert || long_lasting_check(), XLevelRuntime, "");</code>
      */
     extern bool noAssert;
 

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-12-21 16:38:13 UTC (rev 947)
+++ trunk/src/stones_simple.cc	2007-12-21 23:47:39 UTC (rev 948)
@@ -1176,7 +1176,7 @@
 
             // The mode attribute "scissor" defines, if when touching an st-rubberband,
             // other rubberbands to the actor will be cut of or not, true means they will. true is default.
-            bool isScissor = to_bool(getDefaultedAttr("scissor","true"));
+            bool isScissor = to_bool(getDefaultedAttr("scissor", true));
 
             if (!HasRubberBand (sc.actor, this)) {
                 sound_event ("rubberband");



From ral at mail.berlios.de  Sat Dec 22 13:13:19 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sat, 22 Dec 2007 13:13:19 +0100
Subject: [Enigma-game-svn] r949 - trunk/src
Message-ID: <200712221213.lBMCDJu3023448@sheep.berlios.de>

Author: ral
Date: 2007-12-22 13:13:17 +0100 (Sat, 22 Dec 2007)
New Revision: 949

Modified:
   trunk/src/ox_oxyd1.cc
   trunk/src/stones_complex.cc
   trunk/src/stones_simple.cc
Log:
Trunk 1.1: 
- add thief as signla multiplier
- door_c destruction on dynamite, initially open type


Modified: trunk/src/ox_oxyd1.cc
===================================================================
--- trunk/src/ox_oxyd1.cc	2007-12-21 23:47:39 UTC (rev 948)
+++ trunk/src/ox_oxyd1.cc	2007-12-22 12:13:17 UTC (rev 949)
@@ -178,7 +178,7 @@
     "st-bigbrick-nw",           // Oxyd1 stone 0x16
     "st-plain_hole",            // Oxyd1 stone 0x17
     "st-oxyd-0x18",             // Oxyd1 stone 0x18
-    "st-glass1_hole",           // Oxyd1 stone 0x19
+    "st-door_c-open",           // Oxyd1 stone 0x19
     "st-grate1",                // Oxyd1 stone 0x1a
     "st-grate2",                // Oxyd1 stone 0x1b
     "st-bug",                   // Oxyd1 stone 0x1c

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2007-12-21 23:47:39 UTC (rev 948)
+++ trunk/src/stones_complex.cc	2007-12-22 12:13:17 UTC (rev 949)
@@ -1542,6 +1542,8 @@
         State get_state() const { return state; }
         void set_state(State st) { state=st; }
 
+        void change_state(State newstate) ;
+        virtual Value message(const string &m, const Value &);
     private:
         // DoorBase interface
         virtual string model_basename() { return get_kind(); }
@@ -1550,8 +1552,6 @@
         virtual string closing_sound() const { return ""; }
 
         // Private methods
-        void change_state(State newstate) ;
-        virtual Value message(const string &m, const Value &);
 
         StoneResponse collision_response(const StoneContact &sc);
 
@@ -1700,7 +1700,36 @@
         CLONEOBJ(Door_c);
     public:
         Door_c() : DoorBase("st-door_c") {}
+        Value message(const string &m, const Value &val) {
+            if (m == "ignite" && server::GameCompatibility == GAMET_OXYD1) {
+                KillStone(get_pos());  // TODO animation & sound
+                return Value();
+            } else {
+                return DoorBase::message(m, val);
+            }
+        }
     };
+    
+    class Door_c_open : public DoorBase {  // a hack for oxyd compatibility tests
+        CLONEOBJ(Door_c_open);
+    public:
+        Door_c_open() : DoorBase("st-door_c", OPEN) {}
+        Value message(const string &m, const Value &val) {
+            State newstate = state;
+        
+            if (m == "signal") {
+                newstate = val.to_bool() ? CLOSING : OPENING;  // inverted
+                if (newstate==OPENING && (state==CLOSED || state==CLOSING))
+                    change_state(OPENING);
+                else if (newstate==CLOSING && (state==OPEN || state==OPENING))
+                    change_state(CLOSING);
+                return Value();
+            } else {
+                return DoorBase::message(m, val);
+            }
+        }
+
+    };    
 }
 
 bool Door::is_transparent (Direction dir) const {
@@ -3178,6 +3207,7 @@
     Register(new Door_a);
     Register(new Door_b);
     Register(new Door_c);
+    Register("st-door_c-open", new Door_c_open);
 
     Register(new HollowStoneImpulseStone);
 

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-12-21 23:47:39 UTC (rev 948)
+++ trunk/src/stones_simple.cc	2007-12-22 12:13:17 UTC (rev 949)
@@ -1495,7 +1495,9 @@
 }
 
 Value ThiefStone::message(const string &msg, const Value &v) {
-    if(msg == "capture" && state == IDLE) {
+    if(msg == "signal" && server::GameCompatibility != GAMET_ENIGMA) {
+        PerformAction(this, v.to_bool());  // signal multiplier
+    } else if(msg == "capture" && state == IDLE) {
         state = CAPTURED;
         Item * it =  GetItem(get_pos());
         



From ral at mail.berlios.de  Sat Dec 22 14:49:38 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sat, 22 Dec 2007 14:49:38 +0100
Subject: [Enigma-game-svn] r950 - trunk/src
Message-ID: <200712221349.lBMDncVP002811@sheep.berlios.de>

Author: ral
Date: 2007-12-22 14:49:37 +0100 (Sat, 22 Dec 2007)
New Revision: 950

Modified:
   trunk/src/items.cc
   trunk/src/objects.cc
   trunk/src/objects.hh
   trunk/src/st_switches.cc
   trunk/src/stones_complex.cc
   trunk/src/stones_simple.cc
   trunk/src/world.cc
   trunk/src/world.hh
Log:
Trunk 1.1: 
- substitute global PerformAction() by Object::performAction(Value v) method
- vortex: action delivers passed actor instead of true/false
- doorknocking: new API is action, PerOxyd disabled, other signal to item
Note:
- actions can now take arbitrary values besides the classical bool onoff


Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/items.cc	2007-12-22 13:49:37 UTC (rev 950)
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -1321,7 +1322,7 @@
 
         virtual Value on_message (const Message &m) {
             if (m.message == "signal") {
-                PerformAction (this, to_double (m.value) != 0.0);
+                performAction(m.value.to_bool());  // convert 1/0 values to true/false
             }
             else if (m.message == "init") {
                 update_state();
@@ -1364,10 +1365,10 @@
         init_model();
         if (m_pressedp) {
             sound_event ("triggerdown");
-            PerformAction(this, true);
+            performAction(true);
         } else {
             sound_event ("triggerup");
-            PerformAction(this, false);
+            performAction(false);
         }
     }
 }
@@ -1517,7 +1518,7 @@
         if (st == 0) {
             warning("stone_change: Stone disappeared w/o sending me a proper message!");
             activated = false;
-            PerformAction(this, false);
+            performAction(false);
         }
     }
 }
@@ -1526,7 +1527,7 @@
     if (str == "noshogun") {
         if (activated) {
             activated = false;
-            PerformAction(this, false);
+            performAction(false);
         }
     }
     else {
@@ -1538,7 +1539,7 @@
 
         if (size_matches != activated) {
             activated = size_matches;
-            PerformAction(this, activated);
+            performAction(activated);
         }
     }
     return Value();
@@ -1926,7 +1927,7 @@
     }
     
     if (msg == "_passed")
-        PerformAction(this, true);
+        performAction(getAttr("$grabbed_actor"));
     return Value();
 }
 
@@ -2045,13 +2046,13 @@
                 KillRubberBands(actor);
         }
     }
-    set_attrib("$grabbed_actor", (Object *)NULL);
-
     state = OPEN;
     if (this != destVortex && getAttr("autoclose").to_bool())  // do not close source vortex if destination is currently blocked
         close();
     if (this != destVortex)
-        PerformAction(this, false);
+        performAction(getAttr("$grabbed_actor"));
+
+    set_attrib("$grabbed_actor", (Object *)NULL);
 }
 
 void Vortex::warp_to(const V2 &target) {
@@ -2064,12 +2065,12 @@
         if (isScissor)
             KillRubberBands(actor);
     }
-    set_attrib("$grabbed_actor", (Object *)NULL);
-
     state = OPEN;
     if (getAttr("autoclose").to_bool())
         close();
-    PerformAction(this, false);
+
+    performAction(getAttr("$grabbed_actor"));
+    set_attrib("$grabbed_actor", (Object *)NULL);
 }
 
 void Vortex::perform_warp() {
@@ -2892,7 +2893,7 @@
         Sensor() {}
 
         void actor_enter (Actor *) {
-            PerformAction (this, true);
+            performAction(true);
         }
     };
     DEF_TRAITSF(Sensor, "it-sensor", it_sensor, itf_static | itf_invisible);
@@ -2904,7 +2905,7 @@
         InverseSensor() {}
 
         void actor_enter (Actor *) {
-            PerformAction (this, false);
+            performAction (false);
         }
     };
     DEF_TRAITSF(InverseSensor, "it-inversesensor", it_inversesensor,
@@ -2928,7 +2929,7 @@
                 int value = to_int(val);
 //                 warning("received signal with value %i", value);
                 if (value)
-                    PerformAction(this, type != 0);
+                    performAction(type != 0);
             }
             return Value();
         }
@@ -3170,14 +3171,14 @@
         }
 
         void alarm() {
-            PerformAction (this, true);
+            performAction(true);
         }
 
         virtual Value on_message (const Message &m) {
             if (server::GameCompatibility == enigma::GAMET_PEROXYD) {
                 // Crosses can be used to invert signals in Per.Oxyd
                 if (m.message == "signal") {
-                    PerformAction (this, to_double (m.value) != 1.0);
+                    performAction(m.value.to_bool()); // convert 1/0 values to true/false
                 }
             } else if (enigma_server::GameCompatibility == GAMET_ENIGMA) {
                 if (m.message == "brush")
@@ -3474,7 +3475,7 @@
         DECL_TRAITS;
 
         virtual Value on_message (const Message &) {
-            PerformAction (this, true);
+            performAction(true);
             return Value();
         }
     public:

Modified: trunk/src/objects.cc
===================================================================
--- trunk/src/objects.cc	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/objects.cc	2007-12-22 13:49:37 UTC (rev 950)
@@ -20,6 +20,7 @@
 
 #include "errors.hh"
 #include "game.hh"
+#include "lua.hh"
 #include "sound.hh"
 #include "world.hh"
 
@@ -175,6 +176,50 @@
     return Value(Value::DEFAULT);
 }
 
+void Object::performAction (const Value& val) {
+    TokenList targets = getAttr("target");
+    TokenList actions = getAttr("action");
+    if (Value state = getAttr("state")) {
+        int s = state;
+        if (Value stateTargets = getAttr(ecl::strf("target_%d", s)))
+            targets = stateTargets;
+        if (Value actionTargets = getAttr(ecl::strf("action_%d", s)))
+            actions = actionTargets;
+    }
+    
+    TokenList::iterator ait = actions.begin();
+    std::string action;  // empty string as default
+    for (TokenList::iterator tit = targets.begin(); tit != targets.end(); ++tit) {
+        action = (ait != actions.end()) ? ait->to_string() : "";
+        
+        ObjectList ol = *tit;  // get all objects described by target token
+        if (ol.size() == 0 || (ol.size() == 1 && ol.front() == NULL)) {  // no target object
+            if ((action == "callback" || action == "") && (tit->getType() == Value::STRING) 
+                    && lua::IsFunc(lua::LevelState(), tit->get_string())) {
+                // it is an existing callback function
+                if (lua::CallFunc(lua::LevelState(), tit->get_string(), val, this) != lua::NO_LUAERROR) {
+                    throw XLevelRuntime(string("callback '") + tit->get_string() + "' failed:\n"+lua::LastError(lua::LevelState()));
+                }
+            }
+            // else ignore this no longer valid target
+//            Log << "PerformAction target not valid\n";
+        } else {
+            // send message to all objects
+            if (action == "") 
+                action = "toggle";
+            for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
+                if (*oit != NULL) {
+                    if (GridObject *go = dynamic_cast<GridObject*>(this)) {
+                        SendMessage(*oit, Message(action, val, go->get_pos()));
+                    } else
+                        SendMessage(*oit, Message(action, val));
+                }
+            }
+        }
+        
+        if (ait != actions.end()) ++ait;
+    }
+}
 
 /* Send an impulse to position 'dest' into direction dir.  If 'dest'
    contains a stone, on_impulse() is called for that stone */

Modified: trunk/src/objects.hh
===================================================================
--- trunk/src/objects.hh	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/objects.hh	2007-12-22 13:49:37 UTC (rev 950)
@@ -158,6 +158,12 @@
 
     protected:
         virtual Value getDefaultValue(const string &key) const;
+        /** This function is used by all triggers, switches etc. that
+         * perform some particular action when activated (like opening
+         * doors or switching lasers on and off). It interprets the
+         * "action" and "target" attributes of `o'. 
+         */
+        void performAction(const Value& val);
     private:
         friend void InitWorld();   // for bootFinished() access
         

Modified: trunk/src/st_switches.cc
===================================================================
--- trunk/src/st_switches.cc	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/st_switches.cc	2007-12-22 13:49:37 UTC (rev 950)
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -57,7 +58,7 @@
                     set_anim("st-switch-turnon");
                 else
                     set_anim("st-switch-turnoff");
-                PerformAction(this, newon);
+                performAction(newon);
             }
         }
 
@@ -101,7 +102,7 @@
                     set_anim("st-switch_black-turnon");
                 else
                     set_anim("st-switch_black-turnoff");
-                PerformAction(this, newon);
+                performAction(newon);
             }
         }
         void animcb() {
@@ -145,7 +146,7 @@
                     set_anim("st-switch_white-turnon");
                 else
                     set_anim("st-switch_white-turnoff");
-                PerformAction(this, newon);
+                performAction(newon);
             }
         }
         void animcb() {
@@ -211,11 +212,11 @@
 
     switch (newstate) {
     case ACTIVE:
-        PerformAction(this, true);
+        performAction(true);
         GameTimer.activate(this);
         break;
     case INACTIVE:
-        PerformAction(this, false);
+        performAction(false);
         GameTimer.deactivate(this);
         sound_event ("coinslotoff");
         break;
@@ -354,7 +355,7 @@
 
     if (toggle) {
         set_on (!is_on());
-        PerformAction (this, is_on());
+        performAction(is_on());
     }
 }
 
@@ -396,7 +397,7 @@
             bool isGlobalTarget = getAttr("target");
             
             if (!m_inactive_so_far && !isGlobalTarget) {
-                PerformAction(this, false);  // signal off for old direction state
+                performAction(false);  // signal off for old direction state
             } else
                 m_inactive_so_far = false;
 
@@ -406,9 +407,9 @@
             sound_event("fourswitch");
 
             if (isGlobalTarget) {
-                PerformAction(this, (server::EnigmaCompatibility < 1.10) ? is_on() : 3 - m_direction);
+                performAction((server::EnigmaCompatibility < 1.10) ? is_on() : 3 - m_direction);
             } else {
-                PerformAction(this, true);  // signal on for new direction state
+                performAction(true);  // signal on for new direction state
             }
         }
 
@@ -532,7 +533,7 @@
     if (state == IDLE) {
 //         sound_event ("st-switch");
         set_model(get_active_model());
-        PerformAction(this, !inverse());
+        performAction(!inverse());
         if (newstate == TOUCHED) {
             double delay = timer_delay();
             ASSERT(delay>0.0, XLevelRuntime, "LaserTimeSwitchBase: delay non-positive");
@@ -542,7 +543,7 @@
     else if (newstate == IDLE) {
 //         sound_event ("st-switch");
         set_model(get_inactive_model());
-        PerformAction(this, inverse());
+        performAction(inverse());
     }
     else {
         // it's not allowed to switch from LIGHTED to TOUCHED
@@ -672,13 +673,13 @@
             if (!inv->is_full()) {
                 inv->add_item (MakeItem("it-floppy"));
                 set_on(false);
-                PerformAction(this, is_on());
+                performAction(is_on());
             }
         }
         else if (player::WieldedItemIs (sc.actor, "it-floppy")) {
             DisposeObject (inv->yield_first());
             set_on(true);
-            PerformAction(this, is_on());
+            performAction(is_on());
         }
         player::RedrawInventory (inv);
     }

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/stones_complex.cc	2007-12-22 13:49:37 UTC (rev 950)
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/ or
  * modify it under the terms of the GNU General Public License
@@ -1676,8 +1677,13 @@
 
         void actor_hit(const StoneContact &)
         {
-            if (Item *it = GetItem (get_pos()))
-                PerformAction (it, true);
+            // door knocking
+            Item *it = GetItem(get_pos());
+            if (it != NULL && server::GameCompatibility != GAMET_PEROXYD 
+                    && (server::GameCompatibility != GAMET_ENIGMA || server::EnigmaCompatibility < 1.10 ))
+                SendMessage(it, "signal", 1);
+            else
+                performAction(true);
         }
 
         string model_basename() { return string("st-door")+get_type(); }
@@ -2464,7 +2470,7 @@
 	    rotate_arms(arms, clockwise);
         handleActorsAndItems(clockwise, impulse_sender);
 
-        PerformAction (this, clockwise == 0);
+        performAction(clockwise == 0);
         server::IncMoveCounter();
     }
     return can_rotate;

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/stones_simple.cc	2007-12-22 13:49:37 UTC (rev 950)
@@ -1127,7 +1127,7 @@
             sound_event("scissors");
             set_anim("st-scissors-snip");
             if (KillRubberBands (sc.actor))
-                PerformAction(this, false);
+                performAction(false);
         }
         void animcb() {
             set_model("st-scissors");
@@ -1288,7 +1288,7 @@
         void alarm() {
             if (is_on()) {
 //                 sound::PlaySound("st-timer");
-                PerformAction(this, m_signalvalue != 0);
+                performAction(m_signalvalue != 0);
                 m_signalvalue = 1-m_signalvalue;
                 if(!get_is_looped())
                     set_on(false); // Switch to "off"-model.
@@ -1496,7 +1496,7 @@
 
 Value ThiefStone::message(const string &msg, const Value &v) {
     if(msg == "signal" && server::GameCompatibility != GAMET_ENIGMA) {
-        PerformAction(this, v.to_bool());  // signal multiplier
+        performAction(v.to_bool());  // signal multiplier
     } else if(msg == "capture" && state == IDLE) {
         state = CAPTURED;
         Item * it =  GetItem(get_pos());

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/world.cc	2007-12-22 13:49:37 UTC (rev 950)
@@ -1938,50 +1938,6 @@
 }
 
 
-void PerformAction (Object *obj, bool onoff) {
-    TokenList targets = obj->getAttr("target");
-    TokenList actions = obj->getAttr("action");
-    if (Value state = obj->getAttr("state")) {
-        int s = state;
-        if (Value stateTargets = obj->getAttr(ecl::strf("target_%d", s)))
-            targets = stateTargets;
-        if (Value actionTargets = obj->getAttr(ecl::strf("action_%d", s)))
-            actions = actionTargets;
-    }
-    
-    TokenList::iterator ait = actions.begin();
-    std::string action;  // empty string as default
-    for (TokenList::iterator tit = targets.begin(); tit != targets.end(); ++tit) {
-        action = (ait != actions.end()) ? ait->to_string() : "";
-        
-        ObjectList ol = *tit;  // get all objects described by target token
-        if (ol.size() == 0 || (ol.size() == 1 && ol.front() == NULL)) {  // no target object
-            if ((action == "callback" || action == "") && (tit->getType() == Value::STRING) 
-                    && lua::IsFunc(lua::LevelState(), tit->get_string())) {
-                // it is an existing callback function
-                if (lua::CallFunc(lua::LevelState(), tit->get_string(), Value(onoff), obj) != lua::NO_LUAERROR) {
-                    throw XLevelRuntime(string("callback '") + tit->get_string() + "' failed:\n"+lua::LastError(lua::LevelState()));
-                }
-            }
-            // else ignore this no longer valid target
-//            Log << "PerformAction target not valid\n";
-        } else {
-            // send message to all objects
-            if (action == "") 
-                action = "toggle";
-            for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
-                if (*oit != NULL) {
-                    if (GridObject *go = dynamic_cast<GridObject*>(obj)) {
-                        SendMessage(*oit, Message(action, Value(onoff), go->get_pos()));
-                    } else
-                        SendMessage(*oit, Message(action, Value(onoff)));
-                }
-            }
-        }
-        
-        if (ait != actions.end()) ++ait;
-    }
-}
 
 
 namespace

Modified: trunk/src/world.hh
===================================================================
--- trunk/src/world.hh	2007-12-22 12:13:17 UTC (rev 949)
+++ trunk/src/world.hh	2007-12-22 13:49:37 UTC (rev 950)
@@ -254,11 +254,6 @@
     Value SendMessage (Object *o, const string &msg, const Value& value);
     Value SendMessage (Object *o, const Message &m);
 
-    /*! This function is used by all triggers, switches etc. that
-      perform some particular action when activated (like opening
-      doors or switching lasers on and off). It interprets the
-      "action" and "target" attributes of `o'. */
-    void PerformAction (Object *o, bool onoff);
 
 
 /* -------------------- Actors -------------------- */



From ral at mail.berlios.de  Sun Dec 23 23:32:59 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Sun, 23 Dec 2007 23:32:59 +0100
Subject: [Enigma-game-svn] r951 - in trunk/src: . stones
Message-ID: <200712232232.lBNMWxJ3003098@sheep.berlios.de>

Author: ral
Date: 2007-12-23 23:32:57 +0100 (Sun, 23 Dec 2007)
New Revision: 951

Modified:
   trunk/src/floors.cc
   trunk/src/floors.hh
   trunk/src/items.cc
   trunk/src/laser.cc
   trunk/src/objects.cc
   trunk/src/objects.hh
   trunk/src/ox_oxyd1.cc
   trunk/src/st_switches.cc
   trunk/src/stones.cc
   trunk/src/stones/OxydStone.cc
   trunk/src/stones/OxydStone.hh
   trunk/src/stones_complex.cc
   trunk/src/stones_internal.hh
   trunk/src/stones_simple.cc
   trunk/src/world.cc
   trunk/src/world.hh
Log:
Trunk 1.1: message reengineering
- unified message/on_message to message(const Message &m)
- all objects pass unhandled messages to superclasses
- message gridpos replaced by sender object reference
  (this allows sending backmessages)
- eliminated global CurrentCollisionActor
- thief as inverting message multiplier
- oxyd Ox5f as it-sensor
- charge stone fowards signals


Modified: trunk/src/floors.cc
===================================================================
--- trunk/src/floors.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/floors.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -56,26 +56,26 @@
     delete this;
 }
 
-Value Floor::message(const string &msg, const Value &val) {
+Value Floor::message(const Message &m) {
     // "init"     : Start burning, if "initfire" is set.
     // "heat"     : Heat the item, heat-transform floor
     //                 or maybe set fire to it (if burnable).
     // "setfire"  : Just try to make fire (if burnable).
     // "forcefire": Force fire, even on unburnable floor.
     // "stopfire" : Stop fire, put ash but don't transform floor.
-    if(msg == "init" && has_firetype(flft_initfire))
+    if (m.message == "init" && has_firetype(flft_initfire))
         return force_fire();
-    if(msg == "heat")
+    if (m.message == "heat")
         return try_heating(NODIR, flhf_message);
-    if((msg == "ignite" || msg == "expl") && has_firetype(flft_ignitable))
+    if ((m.message == "ignite" || m.message == "expl") && has_firetype(flft_ignitable))
         return try_ignite(NODIR, flhf_message);
-    if(msg == "setfire")
+    if (m.message == "setfire")
         return try_ignite(NODIR, flhf_message);
-    if(msg == "forcefire")
+    if (m.message == "forcefire")
         return force_fire();
-    if(msg == "stopfire")
+    if (m.message == "stopfire")
         return stop_fire(true);
-    return Object::message(msg, val);
+    return Object::message(m);
 }
 
 ecl::V2 Floor::process_mouseforce (Actor *a, ecl::V2 force) {
@@ -705,7 +705,7 @@
         CLONEOBJ(Bridge);
     public:
         Bridge(bool open=true);
-        virtual Value message(const string &m, const Value &);
+        virtual Value message(const Message &m);
     private:
         enum State {
             OPEN, CLOSED, OPENING, CLOSING, // normal states
@@ -748,41 +748,44 @@
     }
 }
 
-Value Bridge::message(const string &m, const Value &)
+Value Bridge::message(const Message &m)
 {
-    if (m == "open" && (state==CLOSED || state==CLOSING))
+    if (m.message == "open" && (state==CLOSED || state==CLOSING)) {
         change_state(OPENING);
-    else if (m=="close")
+        return Value();
+    } else if (m.message == "close") {
         switch (state) {
-        case OPEN:
-        case OPENING:
-        case CLOSING_BYSTONE:
-            change_state(CLOSING);
-            break;
-        case CLOSED_BYSTONE:
-            change_state(CLOSED);
-            break;
-        case CLOSED:
-        case CLOSING:
-            break; // already closed
-
+            case OPEN:
+            case OPENING:
+            case CLOSING_BYSTONE:
+                change_state(CLOSING);
+                break;
+            case CLOSED_BYSTONE:
+                change_state(CLOSED);
+                break;
+            case CLOSED:
+            case CLOSING:
+                break; // already closed
         }
-    else if (m=="openclose" || m=="signal")
+        return Value();
+    } else if (m.message == "openclose" || m.message == "signal") {
         switch (state) {
-        case OPEN:
-        case OPENING:
-        case CLOSING_BYSTONE:
-            change_state(CLOSING);
-            break;
-        case CLOSED_BYSTONE:
-            change_state(CLOSED);
-            break;
-        case CLOSED:
-        case CLOSING:
-            change_state(OPENING);
-            break;
+            case OPEN:
+            case OPENING:
+            case CLOSING_BYSTONE:
+                change_state(CLOSING);
+                break;
+            case CLOSED_BYSTONE:
+                change_state(CLOSED);
+                break;
+            case CLOSED:
+            case CLOSING:
+                change_state(OPENING);
+                break;
         }
-    return Value();
+        return Value();
+    }
+    return Floor::message(m);
 }
 
 void Bridge::init_model()
@@ -862,7 +865,7 @@
         void actor_enter(Actor* a);
         void animcb();
         void steal();
-        virtual Value message(const string &msg, const Value &v);        
+        virtual Value message(const Message &m);        
     };
 }
 
@@ -952,8 +955,8 @@
         sound_event("thief");
 }
 
-Value Thief::message(const string &msg, const Value &v) {
-    if(msg == "capture" && state == IDLE) {
+Value Thief::message(const Message &m) {
+    if(m.message == "capture" && state == IDLE) {
         state = CAPTURED;
         Item * it =  GetItem(get_pos());
         
@@ -967,8 +970,8 @@
         bag = NULL;
         set_anim(get_modelname() + string("-captured"));
         return Value(1);
-    } else
-        return Floor::message(msg, v);
+    }
+    return Floor::message(m);
 }
 
 //----------------------------------------

Modified: trunk/src/floors.hh
===================================================================
--- trunk/src/floors.hh	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/floors.hh	2007-12-23 22:32:57 UTC (rev 951)
@@ -94,7 +94,7 @@
         // Object interface
         Floor *clone();
         void dispose();
-        virtual Value message(const string& msg, const Value &val);
+        virtual Value message(const Message &m);
         virtual void set_attrib (const string& key, const Value &val);
 
         // Floor interface

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/items.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -195,16 +195,21 @@
             }
         }
 
-        virtual Value message(const string &m, const Value &val) {
-            if (m=="onoff")
+        virtual Value message(const Message &m) {
+            if (m.message == "onoff") {
                 set_on(!is_on());
-            else if (m=="signal")
-                set_on (to_int(val) != 0);
-            else if (m == "on")
+                return Value();
+            } else if (m.message == "signal") {
+                set_on (m.value != 0);
+                return Value();
+            } else if (m.message == "on") {
                 set_on(true);
-            else if (m=="off")
+                return Value();
+            } else if (m.message == "off") {
                 set_on(false);
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
 
         // OnOffItem interface
@@ -272,12 +277,14 @@
         CLONEOBJ(Squashed);
         DECL_TRAITS;
 
-        virtual Value on_message (const Message &m) {
+        virtual Value message (const Message &m) {
             if (enigma_server::GameCompatibility == GAMET_ENIGMA) {
-                if (m.message == "brush")
+                if (m.message == "brush") {
                     KillItem(this->get_pos());
+                    return Value();
+                }
             }
-            return Value();
+            return Object::message(m);
         }
 
 
@@ -499,12 +506,14 @@
             return false;
         }
 
-        virtual Value on_message (const Message &m) {
+        virtual Value message (const Message &m) {
             if (enigma_server::GameCompatibility == GAMET_ENIGMA) {
-                if (m.message == "brush")
+                if (m.message == "brush") {
                     KillItem(this->get_pos());
+                    return Value();
+                }
             }
-            return Value();
+            return Object::message(m);
         }
 
     public:
@@ -614,7 +623,7 @@
     class HillHollow : public Item {
     public:
         // Object interface.
-        virtual Value message(const string &m, const Value &);
+        virtual Value message(const Message &m);
     protected:
         enum Type { HILL, HOLLOW, TINYHILL, TINYHOLLOW };
 
@@ -727,26 +736,26 @@
     }
 }
 
-Value HillHollow::message(const string &m, const Value &val)
+Value HillHollow::message(const Message &m)
 {
-    if (m=="trigger") {
+    if (m.message == "trigger") {
         Type flippedkind[] = {HOLLOW,HILL, TINYHOLLOW,TINYHILL};
         transmute(flippedkind[m_type]);
-    }
-    else if (m == "signal") {
-        if (val != 0) {
+        return Value();
+    } else if (m.message == "signal") {
+        if (m.value != 0) {
             Type flippedkind[] = {HILL,HILL, TINYHILL,TINYHILL};
             transmute(flippedkind[m_type]);
         } else {
             Type flippedkind[] = {HOLLOW,HOLLOW, TINYHOLLOW,TINYHOLLOW};
             transmute(flippedkind[m_type]);
         }
-    }
-    else if (m=="shovel")
+        return Value();
+    } else if (m.message == "shovel") {
         shovel();
-    else
-        Item::message (m, val);
-    return Value();
+        return Value();
+    } 
+    return Object::message(m);
 }
 
 V2 HillHollow::vec_to_center (V2 v)
@@ -1066,15 +1075,17 @@
             }
             return ITEM_KILL;	       // remove from inventory
         }
-        virtual Value message(const string &msg, const Value &/*val*/) {
+        virtual Value message(const Message &m) {
             bool explode = false;
 
-            if (msg == "ignite") {
+            if (m.message == "ignite") {
                 // dynamite does not blow up Documents in Oxyd1
                 explode = server::GameCompatibility != GAMET_OXYD1;
+            } else if (m.message == "expl" || m.message == "bombstone") {
+                explode = true;
+            } else {
+                return Object::message(m);
             }
-            else if (msg == "expl" || msg == "bombstone")
-                explode = true;
 
             if (explode)
                 replace (it_explosion1);
@@ -1130,16 +1141,18 @@
             }
         }
 
-        virtual Value message(const string &msg, const Value &/*val*/) {
-            if (msg == "ignite" || msg == "expl" || msg == "bombstone")
+        virtual Value message(const Message &m) {
+            if (m.message == "ignite" || m.message == "expl" || m.message == "bombstone") {
                 change_state(BURNING);
-            else if (msg == "explode") // currently unused in c++ code
+                return Value();
+            } else if (m.message == "explode") { // currently unused in c++ code
                 explode();
-            else if (msg == "heat") {  // used by fire-system
+                return Value();
+            } else if (m.message == "heat") {  // used by fire-system
                 change_state(BURNING);
                 return Value(1.0);  // caught message -> no fire!
             }
-            return Value();
+            return Object::message(m);
         }
         void animcb() { explode(); }
         void on_laserhit(Direction) {
@@ -1171,16 +1184,18 @@
         {}
 
     protected:
-        virtual Value message(const string &msg, const Value &) {
-            if (msg == "ignite"  || msg == "expl")
+        virtual Value message(const Message &m) {
+            if (m.message == "ignite"  || m.message == "expl") {
                 burn();
-            else if (msg == "explode" )
+                return Value();
+            } else if (m.message == "explode" ) {
                 explode();
-            else if (msg == "heat") {  // used by fire-system
+                return Value();
+            } else if (m.message == "heat") {  // used by fire-system
                 burn();
                 return Value(1.0);  // caught message -> no fire!
             }
-            return Value();
+            return Object::message(m);
         }
 
     private:
@@ -1320,14 +1335,15 @@
         void actor_leave(Actor *) { m_actorcount -= 1; update_state(); }
         void stone_change(Stone *) { update_state(); }
 
-        virtual Value on_message (const Message &m) {
+        virtual Value message (const Message &m) {
             if (m.message == "signal") {
                 performAction(m.value.to_bool());  // convert 1/0 values to true/false
+                return Value();                
+            } else if (m.message == "init") {
+                update_state();                
+                return Value();
             }
-            else if (m.message == "init") {
-                update_state();
-            }
-            return Value();
+            return Object::message(m);
         }
     };
 
@@ -1389,11 +1405,12 @@
         void on_stonehit (Stone *) {start_growing();}
         void on_laserhit (Direction) {start_growing();}
 
-        virtual Value message(const string &msg, const Value &) {
-            if (msg == "grow" || msg == "signal") {
+        virtual Value message(const Message &m) {
+            if (m.message == "grow" || m.message == "signal") {
                 start_growing();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         void start_growing() {
@@ -1493,7 +1510,7 @@
         enum SubType { SMALL, MEDIUM, LARGE };
         ShogunDot(SubType size);
 
-        virtual Value message(const string &str, const Value &v);
+        virtual Value message(const Message &m);
         void stone_change(Stone *st);
 
         // Variables.
@@ -1523,15 +1540,15 @@
     }
 }
 
-Value ShogunDot::message(const string &str, const Value &/*v*/) {
-    if (str == "noshogun") {
+Value ShogunDot::message(const Message &m) {
+    if (m.message == "noshogun") {
         if (activated) {
             activated = false;
             performAction(false);
         }
-    }
-    else {
-        const char *s = str.c_str();
+        return Value();
+    } else {
+        const char *s = m.message.c_str();
         bool size_matches =
             (strncmp(s, "shogun", 6) == 0)    &&
             ((s[6]-'1')              == subtype) &&
@@ -1540,9 +1557,10 @@
         if (size_matches != activated) {
             activated = size_matches;
             performAction(activated);
+            return Value();
         }
     }
-    return Value();
+    return Object::message(m);
 }
 
 
@@ -1820,7 +1838,7 @@
         bool actor_hit(Actor*);
         void init_model();
         void animcb();
-        virtual Value message(const string &msg, const Value &val);
+        virtual Value message(const Message &m);
 
         // TimeHandler interface
         void alarm();
@@ -1909,26 +1927,28 @@
     return false;
 }
 
-Value Vortex::message(const string &msg, const Value &val)
+Value Vortex::message(const Message &m)
 {
-    if (msg == "signal") {
-        int ival = to_int(val);
+    if (m.message == "signal") {
+        int ival = m.value;
         if (ival != 0)
             open();
         else
             close();
-    }
-    else if (msg == "openclose" || msg == "trigger")
+        return Value();
+    } else if (m.message == "openclose" || m.message == "trigger") {
         openclose();
-    else if (msg == "open")
+        return Value();
+    } else if (m.message == "open") {
         open();
-    else if (msg == "close" || (msg == "_passed" && getAttr("autoclose").to_bool())) {
+        return Value();
+    } else if (m.message == "close" || (m.message == "_passed" && getAttr("autoclose").to_bool())) {
         close();
+        if (m.message == "_passed")
+            performAction(getAttr("$grabbed_actor"));
+        return Value();
     }
-    
-    if (msg == "_passed")
-        performAction(getAttr("$grabbed_actor"));
-    return Value();
+    return Object::message(m);
 }
 
 void Vortex::init_model() {
@@ -2194,10 +2214,12 @@
         DECL_TRAITS_ARRAY(10, subtype);
 
         Pipe(int stype) : subtype(stype) {}
-        virtual Value message(const string &msg, const Value &) {
-            if (msg == "expl")
+        virtual Value message(const Message &m) {
+            if (m.message == "expl") {
                 replace (it_explosion1);
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
     public:
         static void setup() {
@@ -2374,21 +2396,21 @@
                 SendMessage(a, "fall");
             return false;
         }
-        virtual Value message(const string &msg, const Value &val) {
-            if (msg == "crack" && state==IDLE && !is_fixed()) {
+        virtual Value message(const Message &m) {
+            if (m.message == "crack" && state==IDLE && !is_fixed()) {
                 int type = get_type();
                 if ((type == 0 && do_crack()) || (type > 0)) {
                     set_attrib("type", Value((int)getAttr("type") + 1));
                     sound_event ("crack");
                     init_model();
+                return Value();
                 }
-            }
-            if (msg == "heat") {
+            } else if (m.message == "heat") {
                 sound_event ("crack");
                 replace(it_debris);
                 return Value(1.0);
             }
-            return Value();
+            return Object::message(m);
         }
 
         bool do_crack() {
@@ -2458,7 +2480,7 @@
         }
         State state;
 
-        virtual Value message (const string &msg, const Value &v);
+        virtual Value message(const Message &m);
         void animcb();
         bool actor_hit(Actor *a);
         void init_model();
@@ -2478,18 +2500,19 @@
     };
 }
 
-Value Burnable::message(const string &msg, const Value &v)
-{
-    if (msg == "extinguish") {   // stop / never start burning
+Value Burnable::message(const Message &m) {
+    if (m.message == "extinguish") {   // stop / never start burning
         state = FIREPROOF;
         init_model();
-    } else if (msg == "brush" && (state == ASH || state == FIREPROOF)) {
-        kill();                 // The brush cleans the floor
+        return Value();
+    } else if (m.message == "brush" && (state == ASH || state == FIREPROOF)) {
+        kill();   // The brush cleans the floor
+        return Value();
     } else if (Floor *fl = GetFloor(get_pos())) {
-        if (msg == "trigger" || msg == "ignite" || msg == "expl")
+        if (m.message == "trigger" || m.message == "ignite" || m.message == "expl")
             return SendMessage(fl, "ignite");
     }
-    return Item::message(msg, v);
+    return Object::message(m);
 }
 
 void Burnable::animcb() {
@@ -2652,7 +2675,7 @@
         void change_state(State new_state);
         void on_creation (GridPos p);
         void on_removal (GridPos p);
-        virtual Value message(const string &msg, const Value &val);
+        virtual Value message(const Message &m);
         void stone_change(Stone *st);
         void grow();
         void alarm();
@@ -2716,34 +2739,36 @@
 }
 
 
-Value Blocker::message(const string &msg, const Value &val)
+Value Blocker::message(const Message &m)
 {
-    if (msg == "trigger" || msg == "openclose") {
+    if (m.message == "trigger" || m.message == "openclose") {
         switch (state) {
-        case IDLE:
-        case SHRINKED:
-            grow(); // if no stone on top -> grow
-            break;
-
-            // if stone on top -> toggle state (has no effect until stone leaves)
-        case BOLDERED:
-            change_state(COVERED);
-            break;
-        case COVERED:
-            change_state(BOLDERED);
-            break;
+            case IDLE:
+            case SHRINKED:
+                grow(); // if no stone on top -> grow
+                break;
+    
+                // if stone on top -> toggle state (has no effect until stone leaves)
+            case BOLDERED:
+                change_state(COVERED);
+                break;
+            case COVERED:
+                change_state(BOLDERED);
+                break;
         }
-    }
-    else {
+        return Value();
+    } else {
         int open = -1;
 
-        if (msg == "signal") {
-            open = val;
+        if (m.message == "signal") {
+            open = m.value;
         }
-        else if (msg == "open")
+        else if (m.message == "open")
             open = 1;
-        else if (msg == "close")
+        else if (m.message == "close")
             open = 0;
+        else
+            return Object::message(m);
 
         if (open == 1)  { // shrink
             if (state == COVERED)
@@ -2768,7 +2793,6 @@
             }
         }
     }
-    return Value();
 }
 
 void Blocker::stone_change(Stone *st)
@@ -2846,16 +2870,17 @@
         CLONEOBJ(OxydBridge);
         DECL_TRAITS;
 
-        virtual Value message(const string& msg, const Value &val) {
-            if (msg == "signal") {
-                int ival = to_int (val);
+        virtual Value message(const Message &m) {
+            if (m.message == "signal") {
+                int ival = m.value;
                 Floor *floor = GetFloor (get_pos());
                 if (ival > 0)
                     SendMessage (floor, "close");
                 else
                     SendMessage (floor, "open");
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
     public:
         OxydBridge() {}
@@ -2895,6 +2920,18 @@
         void actor_enter (Actor *) {
             performAction(true);
         }
+        
+        virtual Value message(const Message &m) {
+            if (m.message == "hit") {   // door knocking forward to black/whitballstone
+                set_attrib("$hitactor", m.value);
+                performAction(true);
+                set_attrib("$hitactor", (Object *)NULL);
+                return Value();
+            } else if (m.message == "_hitactor") {
+                return getAttr("$hitactor");
+            }
+            return Object::message(m);
+        }
     };
     DEF_TRAITSF(Sensor, "it-sensor", it_sensor, itf_static | itf_invisible);
 
@@ -2924,14 +2961,15 @@
             ASSERT(type >= 0 && type <= 1, XLevelRuntime, "SignalFilterItem: type unknown");
         }
 
-        virtual Value message(const string& m, const Value& val) {
-            if (m == "signal") {
-                int value = to_int(val);
+        virtual Value message(const Message &m) {
+            if (m.message == "signal") {
+                int value = m.value;
 //                 warning("received signal with value %i", value);
                 if (value)
                     performAction(type != 0);
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         // type of signal filter
@@ -2975,7 +3013,7 @@
         CLONEOBJ(EasyKillStone);
         DECL_TRAITS;
 
-        virtual Value on_message (const Message &);
+        virtual Value message(const Message &m);
     public:
         EasyKillStone() {}
     };
@@ -2983,7 +3021,7 @@
                 it_easykillstone, itf_invisible | itf_fireproof);
 }
 
-Value EasyKillStone::on_message (const Message &m )
+Value EasyKillStone::message(const Message &m)
 {
     if (m.message == "init") {
         // does not work in on_creation() because items are created
@@ -3001,8 +3039,9 @@
             }
         }
         kill();
+        return Value();
     }
-    return Value();
+    return Object::message(m);
 }
 
 /* -------------------- EasyKeepStone -------------------- */
@@ -3012,15 +3051,16 @@
         CLONEOBJ(EasyKeepStone);
         DECL_TRAITS;
 
-        virtual Value message(const string& m, const Value& ) {
-            if (m == "init") {
+        virtual Value message(const Message &m) {
+            if (m.message == "init") {
                 // does not work in on_creation() because items are created
                 // before stones are created.
                 if (server::GetDifficulty() == DIFFICULTY_HARD)
                     KillStone(get_pos());
                 kill();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
     public:
         EasyKeepStone() {}
@@ -3036,13 +3076,14 @@
         CLONEOBJ (OnePKillStone);
         DECL_TRAITS;
 
-        virtual Value on_message (const Message &m) {
+        virtual Value message (const Message &m) {
             if (m.message == "init") {
                 if (server::SingleComputerGame)
                     KillStone (get_pos());
                 kill();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
     public:
         OnePKillStone () {}
@@ -3054,13 +3095,14 @@
         CLONEOBJ (TwoPKillStone);
         DECL_TRAITS;
 
-        virtual Value on_message (const Message &m) {
+        virtual Value message (const Message &m) {
             if (m.message == "init") {
                 if (!server::SingleComputerGame)
                     KillStone (get_pos());
                 kill();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
     public:
         TwoPKillStone () {}
@@ -3174,17 +3216,20 @@
             performAction(true);
         }
 
-        virtual Value on_message (const Message &m) {
+        virtual Value message(const Message &m) {
             if (server::GameCompatibility == enigma::GAMET_PEROXYD) {
                 // Crosses can be used to invert signals in Per.Oxyd
                 if (m.message == "signal") {
-                    performAction(m.value.to_bool()); // convert 1/0 values to true/false
+                    performAction(!m.value.to_bool()); // convert 1/0 values to true/false
+                    return Value();
                 }
             } else if (enigma_server::GameCompatibility == GAMET_ENIGMA) {
-                if (m.message == "brush")
+                if (m.message == "brush") {
                     KillItem(this->get_pos());
+                    return Value();
+                }
             }
-            return Value();
+            return Object::message(m);
         }
 
     public:
@@ -3474,9 +3519,12 @@
         CLONEOBJ(Oxyd5fItem);
         DECL_TRAITS;
 
-        virtual Value on_message (const Message &) {
-            performAction(true);
-            return Value();
+        virtual Value message(const Message &m) {
+            if (m.message == "init") {
+                performAction(true);
+                return Value();
+            }
+            return Object::message(m);
         }
     public:
         Oxyd5fItem()

Modified: trunk/src/laser.cc
===================================================================
--- trunk/src/laser.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/laser.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -439,7 +439,7 @@
     set_model(mname);
 }
 
-
+
 /* -------------------- MirrorStone -------------------- */
 namespace
 {
@@ -470,7 +470,7 @@
         StoneTraits traits;
 
 	// Object interface.
-        virtual Value message(const string &m, const Value &);
+        virtual Value message(const Message &m);
 
         // LaserEmitter interface
         DirectionBits emission_directions() const {
@@ -519,36 +519,42 @@
     set_model(mname);
 }
 
-Value MirrorStone::message(const string &m, const Value &val) {
-    if (m == "trigger" || m=="turn") {
+Value MirrorStone::message(const Message &m) {
+    if (m.message == "trigger" || m.message == "turn") {
         rotate_right();
+        return Value();
     }
-    else if (m == "signal") {
-        if (to_double(val) != 0) {
+    else if (m.message == "signal") {
+        if (to_double(m.value) != 0) {
             rotate_right();
         }
+        return Value();
     }
-    else if (m == "mirror-north") {
+    else if (m.message == "mirror-north") {
         set_orientation(3);
         init_model();
         MaybeRecalcLight(get_pos());
+        return Value();
     }
-    else if (m == "mirror-east") {
+    else if (m.message == "mirror-east") {
         set_orientation(4);
         init_model();
         MaybeRecalcLight(get_pos());
+        return Value();
     }
-    else if (m == "mirror-south") {
+    else if (m.message == "mirror-south") {
         set_orientation(1);
         init_model();
         MaybeRecalcLight(get_pos());
+        return Value();
     }
-    else if (m == "mirror-west") {
+    else if (m.message == "mirror-west") {
         set_orientation(2);
         init_model();
         MaybeRecalcLight(get_pos());
+        return Value();
     }
-    return Value();
+    return Object::message(m);
 }
 
 void MirrorStone::actor_hit(const StoneContact &sc)

Modified: trunk/src/objects.cc
===================================================================
--- trunk/src/objects.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/objects.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -108,13 +108,7 @@
     return id;
 }
 
-Value Object::on_message (const Message &m)
-{
-    return message (m.message, m.value);
-}
-
-Value Object::message(const string& /*msg*/, const Value &/*val*/)
-{
+Value Object::message(const Message &m) {
     return Value();
 }
 
@@ -209,10 +203,7 @@
                 action = "toggle";
             for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
                 if (*oit != NULL) {
-                    if (GridObject *go = dynamic_cast<GridObject*>(this)) {
-                        SendMessage(*oit, Message(action, val, go->get_pos()));
-                    } else
-                        SendMessage(*oit, Message(action, val));
+                    SendMessage(*oit, Message(action, val, this));                    
                 }
             }
         }

Modified: trunk/src/objects.hh
===================================================================
--- trunk/src/objects.hh	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/objects.hh	2007-12-23 22:32:57 UTC (rev 951)
@@ -119,8 +119,11 @@
 
         virtual const char *get_kind() const;
 
-        virtual Value on_message (const Message &m);
-        virtual Value message(const string& msg, const Value &val);
+        /**
+         * 
+         */
+        virtual Value message(const Message &m);
+        
         virtual void set_attrib(const string& key, const Value &val);
         
         /**

Modified: trunk/src/ox_oxyd1.cc
===================================================================
--- trunk/src/ox_oxyd1.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/ox_oxyd1.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -406,7 +406,7 @@
     ITEMSPEC(it_UNUSED),                  // 0x5c
     ITEMSPEC(it_UNUSED),                  // 0x5d
     ITEMSPEC(it_UNUSED),                  // 0x5e
-    ITEMSPEC(it_oxyd5f),                  // 0x5f
-    ITEMSPEC(it_drop),                  // 0x60    drop (turns actor into rotor)
+    ITEMSPEC(it_sensor),                  // 0x5f
+    ITEMSPEC(it_drop),                    // 0x60    drop (turns actor into rotor)
     // codes >= 0x61 are unused
 };

Modified: trunk/src/st_switches.cc
===================================================================
--- trunk/src/st_switches.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/st_switches.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -428,13 +428,14 @@
             turn();
         }
 
-        virtual Value on_message(const Message &m)
+        virtual Value message(const Message &m)
         {
             if (m.message == "signal" || m.message == "trigger") {
                 if (server::GameCompatibility == enigma::GAMET_ENIGMA || m.value == 1)
                     turn();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         const char *collision_sound() { return "metal"; }

Modified: trunk/src/stones/OxydStone.cc
===================================================================
--- trunk/src/stones/OxydStone.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/stones/OxydStone.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -854,23 +854,28 @@
         delete this;
     }
     
-    Value OxydStone::message(const string &m, const Value &val) {
-        if (m=="closeall") {
+    Value OxydStone::message(const Message &m) {
+        if (m.message == "closeall") {
             closeAllStandardOxyds();
+            return Value();
         }
-        else if (m=="shuffle") {
+        else if (m.message == "shuffle") {
             shuffleColors();
+            return Value();
         }
-        else if (m=="trigger" || m=="spitter") {
+        else if (m.message == "trigger" || m.message == "spitter") {
             tryOpen();
+            return Value();
         }
-        else if (m=="signal" && to_int(val) != 0) {
+        else if (m.message == "signal" && m.value != 0) {
             tryOpen();
+            return Value();
         }
-        else if (m=="init") {
+        else if (m.message == "init") {
             initColors();
+            return Value();
         }
-        return Value();
+        return Object::message(m);
     }
     
     void OxydStone::set_attrib(const string& key, const Value &val) {

Modified: trunk/src/stones/OxydStone.hh
===================================================================
--- trunk/src/stones/OxydStone.hh	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/stones/OxydStone.hh	2007-12-23 22:32:57 UTC (rev 951)
@@ -83,7 +83,7 @@
         // Object interface
         virtual OxydStone * clone();
         virtual void dispose();
-        virtual Value message(const string &m, const Value &);
+        virtual Value message(const Message &m);
         virtual void set_attrib(const string& key, const Value &val);
         virtual Value getAttr(const string &key) const;
 

Modified: trunk/src/stones.cc
===================================================================
--- trunk/src/stones.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/stones.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -362,6 +362,13 @@
         {
             set_attrib("charge", charge);
         }
+        virtual Value message(const Message &m) {
+            if (server::GameCompatibility == enigma::GAMET_PEROXYD && m.message == "signal") {
+                performAction(m.value);
+                return Value();
+            }
+            return Object::message(m);
+        }
     private:
         double get_charge() {
             double q = getAttr("charge");
@@ -659,11 +666,12 @@
 
         const char *collision_sound() {return "stone";}
 
-        virtual Value message (const string &msg, const Value &) {
-            if (msg == "trigger" || msg == "signal") {
+        virtual Value message(const Message &m) {
+            if (m.message == "trigger" || m.message == "signal") {
                 ReplaceStone(get_pos(), MakeStone("st-plain_hole"));
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
         void actor_hit (const StoneContact &sc) {
             if (player::WieldedItemIs (sc.actor, "it-pencil")) {
@@ -689,11 +697,12 @@
         CLONEOBJ(PlainStone_Hollow);
         DECL_TRAITS;
 
-        virtual Value message (const string &msg, const Value &) {
-            if (msg == "trigger" || msg == "signal") {
+        virtual Value message(const Message &m) {
+            if (m.message == "trigger" || m.message == "signal") {
                 ReplaceStone(get_pos(), MakeStone("st-plain"));
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         StoneResponse collision_response(const StoneContact &) 
@@ -737,10 +746,12 @@
         void on_laserhit (Direction) {
             break_me();
         }
-        virtual Value message (const string &msg, const Value &) {
-            if (msg =="ignite" || msg == "expl" || msg == "bombstone")
+        virtual Value message(const Message &m) {
+            if (m.message =="ignite" || m.message == "expl" || m.message == "bombstone") {
                 break_me();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
         void actor_hit (const StoneContact &sc) {
             if (player::WieldedItemIs (sc.actor, "it-hammer")) {
@@ -776,10 +787,12 @@
             }
         }
 
-        virtual Value message (const string &msg, const Value &) {
-            if (msg =="ignite" || msg == "expl" || msg == "bombstone")
+        virtual Value message(const Message &m) {
+            if (m.message =="ignite" || m.message == "expl" || m.message == "bombstone") {
                 break_me();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
         const char *collision_sound() {return "metal";}
     public:
@@ -816,10 +829,12 @@
             sound_event ("stonedestroy");
             ReplaceStone(get_pos(), MakeStone ("st-plain_breaking"));
         }
-        virtual Value message (const string &msg, const Value &) {
-            if (msg =="ignite" || msg == "expl" || msg == "bombstone")
+        virtual Value message(const Message &m) {
+            if (m.message =="ignite" || m.message == "expl" || m.message == "bombstone") {
                 break_me();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
         void on_move() {
             Stone::on_move();
@@ -865,25 +880,36 @@
     class BlackBallsStone : public Stone {
         CLONEOBJ(BlackBallsStone);
 
-        virtual Value on_message (const Message &m)
+        virtual Value message(const Message &m)
         {
-            GridPos p = get_pos();
-            Actor *a = CurrentCollisionActor;
-            if (a && get_id(a) == ac_blackball) {
-                if (p.y == m.gridpos.y) {
-                    SendMessage (GetStone (move (p, EAST)),  "signal", 1.0);
-                    SendMessage (GetStone (move (p, WEST)),  "signal", 1.0);
-                    SendMessage (GetStone (move (p, NORTH)), "signal", 0.0);
-                    SendMessage (GetStone (move (p, SOUTH)), "signal", 0.0);
+            if (m.message == "signal" || m.message == "hit") {
+                if (GridObject *sender = dynamic_cast<GridObject*>(m.sender)) {
+                    GridPos p = get_pos();
+                    Object *o;
+                    if (m.message == "hit")
+                        o = m.value;
+                    else
+                        o= SendMessage(m.sender, "_hitactor");
+                    
+                    Actor *a = dynamic_cast<Actor *>(o);
+                    if (a && get_id(a) == ac_blackball) {
+                        if (p.y == sender->get_pos().y) {
+                            SendMessage (GetStone (move (p, EAST)),  "signal", 1.0);
+                            SendMessage (GetStone (move (p, WEST)),  "signal", 1.0);
+                            SendMessage (GetStone (move (p, NORTH)), "signal", 0.0);
+                            SendMessage (GetStone (move (p, SOUTH)), "signal", 0.0);
+                        }
+                        else {
+                            SendMessage (GetStone (move (p, EAST)),  "signal", 0.0);
+                            SendMessage (GetStone (move (p, WEST)),  "signal", 0.0);
+                            SendMessage (GetStone (move (p, NORTH)), "signal", 1.0);
+                            SendMessage (GetStone (move (p, SOUTH)), "signal", 1.0);
+                        }
+                        return Value();
+                    }
                 }
-                else {
-                    SendMessage (GetStone (move (p, EAST)),  "signal", 0.0);
-                    SendMessage (GetStone (move (p, WEST)),  "signal", 0.0);
-                    SendMessage (GetStone (move (p, NORTH)), "signal", 1.0);
-                    SendMessage (GetStone (move (p, SOUTH)), "signal", 1.0);
-                }
             }
-            return Value();
+            return Object::message(m);
         }
     public:
         BlackBallsStone() : Stone ("st-blackballs") {
@@ -893,25 +919,36 @@
     class WhiteBallsStone : public Stone {
         CLONEOBJ(WhiteBallsStone);
 
-        virtual Value on_message (const Message &m)
+        virtual Value message(const Message &m)
         {
-            GridPos p = get_pos();
-            Actor *a = CurrentCollisionActor;
-            if (a && get_id(a) == ac_whiteball) {
-                if (p.y == m.gridpos.y) {
-                    SendMessage (GetStone (move (p, EAST)),  "signal", 1.0);
-                    SendMessage (GetStone (move (p, WEST)),  "signal", 1.0);
-                    SendMessage (GetStone (move (p, NORTH)), "signal", 0.0);
-                    SendMessage (GetStone (move (p, SOUTH)), "signal", 0.0);
+            if (m.message == "signal" || m.message == "hit") {
+                if (GridObject *sender = dynamic_cast<GridObject*>(m.sender)) {
+                    GridPos p = get_pos();
+                    Object *o;
+                    if (m.message == "hit")
+                        o = m.value;
+                    else
+                        o = SendMessage(m.sender, "_hitactor");
+                        
+                    Actor *a = dynamic_cast<Actor *>(o);
+                    if (a && get_id(a) == ac_whiteball) {
+                        if (p.y == sender->get_pos().y) {
+                            SendMessage (GetStone (move (p, EAST)),  "signal", 1.0);
+                            SendMessage (GetStone (move (p, WEST)),  "signal", 1.0);
+                            SendMessage (GetStone (move (p, NORTH)), "signal", 0.0);
+                            SendMessage (GetStone (move (p, SOUTH)), "signal", 0.0);
+                        }
+                        else {
+                            SendMessage (GetStone (move (p, EAST)),  "signal", 0.0);
+                            SendMessage (GetStone (move (p, WEST)),  "signal", 0.0);
+                            SendMessage (GetStone (move (p, NORTH)), "signal", 1.0);
+                            SendMessage (GetStone (move (p, SOUTH)), "signal", 1.0);
+                        }
+                        return Value();
+                    }
                 }
-                else {
-                    SendMessage (GetStone (move (p, EAST)),  "signal", 0.0);
-                    SendMessage (GetStone (move (p, WEST)),  "signal", 0.0);
-                    SendMessage (GetStone (move (p, NORTH)), "signal", 1.0);
-                    SendMessage (GetStone (move (p, SOUTH)), "signal", 1.0);
-                }
             }
-            return Value();
+            return Object::message(m);
         }
 
     public:

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/stones_complex.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -352,7 +352,7 @@
         OneWayBase(Direction dir);
 
         void init_model();
-        virtual Value message(const string& msg, const Value &val);
+        virtual Value message(const Message &m);
 
         void actor_hit (const StoneContact&);
         StoneResponse collision_response(const StoneContact &sc);
@@ -423,17 +423,19 @@
     set_model (mname);
 }
 
-Value OneWayBase::message(const string& msg, const Value &val) {
-    if (msg == "direction" && val.getType() == Value::DOUBLE) {
-        set_orientation(to_direction(val));
+Value OneWayBase::message(const Message &m) {
+    if (m.message == "direction" && m.value.getType() == Value::DOUBLE) {
+        set_orientation(to_direction(m.value));
         init_model();
+        return Value();
     }
-    else if (msg == "signal" || msg == "flip") {
+    else if (m.message == "signal" || m.message == "flip") {
         Direction dir = get_orientation();
         set_orientation(reverse(dir));
         init_model();
+        return Value();
     }
-    return Value();
+    return Object::message(m);
 }
 
 void OneWayBase::actor_hit(const StoneContact &sc) {
@@ -598,12 +600,13 @@
                 trigger_obstacle(impulse.dir);
         }
 
-        virtual Value message(const string& msg, const Value &val) {
-            if (msg == "direction" && state != FALLING) {
-                set_dir (to_direction(val));
+        virtual Value message(const Message &m) {
+            if (m.message == "direction" && state != FALLING) {
+                set_dir(to_direction(m.value));
                 init_model();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
     };
     DEF_TRAITSM(BolderStone, "st-bolder", st_bolder, MOVABLE_IRREGULAR);
@@ -688,17 +691,18 @@
             }
         }
 
-        virtual Value message(const string &msg, const Value &val) {
-            if (msg == "trigger" || msg == "openclose") {
+        virtual Value message(const Message &m) {
+            if (m.message == "trigger" || m.message == "openclose") {
                 if (state == SHRINKING) {
                     change_state(GROWING);
                 }
                 else {
                     change_state(SHRINKING);
                 }
+                return Value();
             }
-            else if (msg == "signal") {
-                int value = to_int(val);
+            else if (m.message == "signal") {
+                int value = m.value;
 //                 warning("received signal (value=%i)", value);
                 if (value) {    // value == 1 -> shrink
                     if (state != SHRINKING)
@@ -708,16 +712,19 @@
                     if (state == SHRINKING)
                         change_state(GROWING);
                 }
+                return Value();
             }
-            else if (msg == "open") { // aka "shrink"
+            else if (m.message == "open") { // aka "shrink"
                 if (state != SHRINKING)
                     change_state(SHRINKING);
+                return Value();
             }
-            else if (msg == "close") { // aka "grow"
+            else if (m.message == "close") { // aka "grow"
                 if (state == SHRINKING)
                     change_state(GROWING);
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         void actor_contact(Actor *a) {
@@ -774,14 +781,15 @@
             }
         }
 
-        virtual Value message(const string &msg, const Value &) {
-            if (msg == "trigger") {
+        virtual Value message(const Message &m) {
+            if (m.message == "trigger") {
                 if (state == INACTIVE) {
                     state = ACTIVE;
                     init_model();
                 }
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         void spread( GridPos p) {
@@ -977,7 +985,7 @@
 
         /* ---------- Stone interface ---------- */
 
-        virtual Value message(const string& msg, const Value &val);
+        virtual Value message(const Message &m);
 
         void on_creation (GridPos p);
         void on_removal (GridPos p);
@@ -1298,8 +1306,8 @@
     explode();
 }
 
-Value PuzzleStone::message(const string& msg, const Value &val) {
-    if (msg == "scramble") {
+Value PuzzleStone::message(const Message &m) {
+    if (m.message == "scramble") {
         // oxyd levels contain explicit information on how to
         // scramble puzzle stones. According to that information
         // a "scramble" message is send to specific puzzle stones
@@ -1308,7 +1316,7 @@
         // enigma levels may create scramble messages using
         // AddScramble() and SetScrambleIntensity()
 
-        Direction dir = to_direction(val);
+        Direction dir = to_direction(m.value);
         Cluster   c;
         find_row_or_column_cluster(c, get_pos(), dir, oxyd1_compatible());
 
@@ -1324,8 +1332,9 @@
         else {
             warning("useless scramble (cluster size=%i)", size);
         }
+        return Value();
     }
-    return Value();
+    return Object::message(m);
 }
 
 void PuzzleStone::on_impulse(const Impulse& impulse) 
@@ -1521,7 +1530,7 @@
 void PuzzleStone::actor_contact (Actor *a)
 {
     if (state == EXPLODING)
-        SendMessage (a, "shatter");
+        SendMessage(a, "shatter");
 }
 
 
@@ -1544,7 +1553,7 @@
         void set_state(State st) { state=st; }
 
         void change_state(State newstate) ;
-        virtual Value message(const string &m, const Value &);
+        virtual Value message(const Message &m);
     private:
         // DoorBase interface
         virtual string model_basename() { return get_kind(); }
@@ -1570,18 +1579,21 @@
     };
 }
 
-Value DoorBase::message(const string &m, const Value &val) {
+Value DoorBase::message(const Message &m) {
     State newstate = state;
 
-    if (m == "open")
+    if (m.message == "open") {
         newstate = OPENING;
-    else if (m == "close")
+    } else if (m.message == "close") {
         newstate = CLOSING;
-    else if (m == "openclose")
+    } else if (m.message == "openclose") {
         newstate = (state==OPEN || state==OPENING) ? CLOSING : OPENING;
-    else if (m == "signal")
-        newstate = val.to_bool() ? OPENING : CLOSING;
-
+    } else if (m.message == "signal") {
+        newstate = m.value.to_bool() ? OPENING : CLOSING;
+    } else {
+        return Object::message(m);
+    }
+    
     if (newstate==OPENING && (state==CLOSED || state==CLOSING))
         change_state(OPENING);
     else if (newstate==CLOSING && (state==OPEN || state==OPENING))
@@ -1675,15 +1687,16 @@
             return true;        // don't let door press buttons
         }
 
-        void actor_hit(const StoneContact &)
+        void actor_hit(const StoneContact &sc)
         {
+            Log << "door knocking\n";
             // door knocking
             Item *it = GetItem(get_pos());
             if (it != NULL && server::GameCompatibility != GAMET_PEROXYD 
                     && (server::GameCompatibility != GAMET_ENIGMA || server::EnigmaCompatibility < 1.10 ))
-                SendMessage(it, "signal", 1);
+                SendMessage(it, "hit", sc.actor);
             else
-                performAction(true);
+                performAction(sc.actor);
         }
 
         string model_basename() { return string("st-door")+get_type(); }
@@ -1706,12 +1719,12 @@
         CLONEOBJ(Door_c);
     public:
         Door_c() : DoorBase("st-door_c") {}
-        Value message(const string &m, const Value &val) {
-            if (m == "ignite" && server::GameCompatibility == GAMET_OXYD1) {
+        Value message(const Message &m) {
+            if (m.message == "ignite" && server::GameCompatibility == GAMET_OXYD1) {
                 KillStone(get_pos());  // TODO animation & sound
                 return Value();
             } else {
-                return DoorBase::message(m, val);
+                return DoorBase::message(m);
             }
         }
     };
@@ -1720,21 +1733,6 @@
         CLONEOBJ(Door_c_open);
     public:
         Door_c_open() : DoorBase("st-door_c", OPEN) {}
-        Value message(const string &m, const Value &val) {
-            State newstate = state;
-        
-            if (m == "signal") {
-                newstate = val.to_bool() ? CLOSING : OPENING;  // inverted
-                if (newstate==OPENING && (state==CLOSED || state==CLOSING))
-                    change_state(OPENING);
-                else if (newstate==CLOSING && (state==OPEN || state==OPENING))
-                    change_state(CLOSING);
-                return Value();
-            } else {
-                return DoorBase::message(m, val);
-            }
-        }
-
     };    
 }
 
@@ -1786,11 +1784,12 @@
         Holes get_holes() const;
         void notify_item();
 
-        virtual Value message(const string &m, const Value &) {
-            if (m == "init") { // request from ShogunDot (if set _after_ ShogunStone)
+        virtual Value message(const Message &m) {
+            if (m.message == "init") { // request from ShogunDot (if set _after_ ShogunStone)
                 notify_item();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         void add_hole(Holes h) {
@@ -1943,19 +1942,21 @@
 
         virtual void notify_state(State st) = 0;
 
-        virtual Value message(const string &m, const Value &value) {
-            if (m=="trigger") {
-                incoming = (value.getType() == Value::DOUBLE)
-                    ? Direction( static_cast<int> (value.get_double()+0.1))
+        virtual Value message(const Message &m) {
+            if (m.message == "trigger") {
+                incoming = (m.value.getType() == Value::DOUBLE)
+                    ? Direction( static_cast<int> (m.value.get_double()+0.1))
                     : NODIR;
 
                 change_state(PULSING);
+                return Value();
             }
-            else if (m == "signal" && to_double (value) != 0) {
+            else if (m.message == "signal" && to_double(m.value) != 0) {
                 incoming = NODIR;
                 change_state (PULSING);
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         void animcb() {
@@ -2185,7 +2186,7 @@
 
     private:
         // Object interface
-        virtual Value on_message (const Message &m);
+        virtual Value message(const Message &m);
         virtual void animcb();
 
         // Private methods
@@ -2329,16 +2330,17 @@
     active = false;
 }
 
-Value Turnstile_Pivot_Base::on_message (const Message &m)
+Value Turnstile_Pivot_Base::message(const Message &m)
 {
     if (m.message == "signal") {
-        int val = to_int (m.value);
+        int val = m.value;
         if (val == 1)
             rotate(false, 0);
         else
             rotate(true, 0);
+        return Value();
     }
-    return Value();
+    return Object::message(m);
 }
 
 
@@ -2749,7 +2751,7 @@
         void init_model();
         void animcb();
         void set_attrib(const string& key, const Value &val);
-        virtual Value message(const string &msg, const Value &v);
+        virtual Value message(const Message &m);
         void actor_hit(const StoneContact &sc);
         void on_impulse(const Impulse& impulse) {}
         void alarm();
@@ -2917,31 +2919,34 @@
         }
     }
 
-    Value ChessStone::message(const string &msg, const Value &v) {
-        if(msg == "capture") {
-            if(state == IDLE && v.to_string() != get_model_name())
+    Value ChessStone::message(const Message &m) {
+        if(m.message == "capture") {
+            if(state == IDLE && m.value.to_string() != get_model_name())
                 if(try_state(CAPTURED)) {
                     set_anim(get_model_name() + "-captured");
                     return Value(1);
                 }
             return Value();
-        } else if(msg == "move_nne") { return message_move(NORTH, EAST); }
-        else   if(msg == "move_een") { return message_move(EAST, NORTH); }
-        else   if(msg == "move_ees") { return message_move(EAST, SOUTH); }
-        else   if(msg == "move_sse") { return message_move(SOUTH, EAST); }
-        else   if(msg == "move_ssw") { return message_move(SOUTH, WEST); }
-        else   if(msg == "move_wws") { return message_move(WEST, SOUTH); }
-        else   if(msg == "move_wwn") { return message_move(WEST, NORTH); }
-        else   if(msg == "move_nnw") { return message_move(NORTH, WEST); }
-        else   if(msg == "move") {
+        } else if(m.message == "move_nne") { return message_move(NORTH, EAST); }
+        else   if(m.message == "move_een") { return message_move(EAST, NORTH); }
+        else   if(m.message == "move_ees") { return message_move(EAST, SOUTH); }
+        else   if(m.message == "move_sse") { return message_move(SOUTH, EAST); }
+        else   if(m.message == "move_ssw") { return message_move(SOUTH, WEST); }
+        else   if(m.message == "move_wws") { return message_move(WEST, SOUTH); }
+        else   if(m.message == "move_wwn") { return message_move(WEST, NORTH); }
+        else   if(m.message == "move_nnw") { return message_move(NORTH, WEST); }
+        else   if(m.message == "move") {
             Direction dir1 = to_direction(getAttr("direction1"));
             Direction dir2 = to_direction(getAttr("direction2"));
             return message_move(dir1, dir2);
-        } else if(msg == "signal") { set_color(to_int(v)); }
-        else   if(msg == "flip") { set_color(1 - (int)getAttr("color")); }
-        else
-            return Stone::message(msg, v);
-        return Value();
+        } else if(m.message == "signal") {
+            set_color(to_int(m.value));
+            return Value();
+        } else if(m.message == "flip") {
+            set_color(1 - (int)getAttr("color"));
+            return Value();
+        }
+        return Object::message(m);
     }
 
     Value ChessStone::message_move(Direction dir1, Direction dir2) {
@@ -3119,13 +3124,24 @@
             }
         }
 
-        virtual Value message (const string &msg, const Value &v) {
-            if      (msg == "onoff")   set_on(state == INACTIVE);
-            else if (msg == "signal")  set_on(to_int(v) != 0);
-            else if (msg == "on")      set_on(true);
-            else if (msg == "off")     set_on(false);
-            else if (msg == "trigger") set_on(state == INACTIVE);
-            return Value();
+        virtual Value message (const Message &m) {
+            if (m.message == "onoff") {
+                set_on(state == INACTIVE);
+                return Value();
+            } else if (m.message == "signal") {
+                set_on(to_int(m.value) != 0);
+                return Value();
+            } else if (m.message == "on") {
+                set_on(true);
+                return Value();
+            } else if (m.message == "off") {
+                set_on(false);
+                return Value();
+            } else if (m.message == "trigger") {
+                set_on(state == INACTIVE);
+                return Value();
+            }
+            return Object::message(m);
         }
 
         void alarm() {

Modified: trunk/src/stones_internal.hh
===================================================================
--- trunk/src/stones_internal.hh	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/stones_internal.hh	2007-12-23 22:32:57 UTC (rev 951)
@@ -102,18 +102,23 @@
 
         virtual void notify_onoff(bool /*on*/) {}
 
-        virtual Value on_message(const Message &msg)
+        virtual Value on_message(const Message &m)
         {
-            const std::string &m = msg.message;
-            if (m=="onoff")
+            const std::string &msg = m.message;
+            if (m.message == "onoff") {
                 set_on(!is_on());
-            else if (m=="signal")
-                set_on (to_int(msg.value) != 0);
-            else if (m == "on")
+                return Value(); 
+            } else if (m.message == "signal") {
+                set_on (to_int(m.value) != 0);
+                return Value(); 
+            } else if (m.message == "on") {
                 set_on(true);
-            else if (m=="off")
+                return Value(); 
+            } else if (m.message == "off") {
                 set_on(false);
-            return Value();
+                return Value();
+            }
+            return Object::message(m); 
         }
     };
 

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/stones_simple.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -130,7 +130,7 @@
             return Stone::is_transparent(dir);
         }
 
-        virtual Value on_message (const Message &m)
+        virtual Value message(const Message &m)
         {
             if (traits->hollow && m.message == "glasses") {
                 if (to_int(m.value)) {
@@ -145,8 +145,9 @@
                         set_model (this->get_kind());
                     }
                 }
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         const SimpleStoneTraits *traits; // owned by simple_stone_traits
@@ -154,7 +155,7 @@
     };
 }
 
-
+
 /* -------------------- SimpleStoneMovable -------------------- */
 
 namespace
@@ -267,16 +268,17 @@
         CLONEOBJ(EasyModeStone);
         DECL_TRAITS;
 
-        virtual Value message(const std::string &msg, const Value&) {
-            if (msg == "init") {
+        virtual Value message(const Message &m) {
+            if (m.message == "init") {
                 if (server::GetDifficulty() == DIFFICULTY_EASY) {
                     SetFloor (get_pos(), MakeFloor ("fl-normal"));
                 } else {
                     KillItem (get_pos());
                 }
                 KillStone (get_pos());
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
     public:
         EasyModeStone() 
@@ -285,7 +287,7 @@
     DEF_TRAITSM(EasyModeStone, "st-easymode", st_easymode, MOVABLE_BREAKABLE);
 }
 
-
+
 /* -------------------- Grates -------------------- */
 
 namespace
@@ -565,10 +567,12 @@
         void animcb() {
             KillStone(get_pos());
         }
-        virtual Value message(const string &msg, const Value &) {
-            if (msg =="ignite" || msg == "expl" || msg == "bombstone")
+        virtual Value message(const Message &m) {
+            if (m.message =="ignite" || m.message == "expl" || m.message == "bombstone") {
                 break_me();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
 
         virtual string get_break_anim() const  {
@@ -658,10 +662,12 @@
         bool may_be_broken_by(Actor *a) const {
             return player::WieldedItemIs (a, "it-hammer");
         }
-        virtual Value message(const string &msg, const Value &) {
-            if (msg == "trigger")
+        virtual Value message(const Message &m) {
+            if (m.message == "trigger") {
                 break_me();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
     };
     DEF_TRAITSM(Break_bolder, "st-break_bolder", st_break_bolder, MOVABLE_BREAKABLE);
@@ -1001,15 +1007,17 @@
             }
         }
 
-        virtual Value message (const string &msg, const Value &) {
-            if (msg == "fire" && !blockfire) {
+        virtual Value message(const Message &m) {
+            if (m.message == "fire" && !blockfire) {
                 KillStone(get_pos());
                 return Value(1.0);  // allow fire to spread
-            } else if (msg == "heat" && blockfire) {
+            } else if (m.message == "heat" && blockfire) {
                 return Value(1.0);  // block fire
-            } else if (msg == "fall")
+            } else if (m.message == "fall") {
                 maybe_fall_or_stopfire();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
 
         // in oxyd1 only fall when moving
@@ -1059,7 +1067,7 @@
         void animcb() {
             Stone *st = MakeStone ("st-wood");
             ReplaceStone (get_pos(), st);
-            SendMessage (st, "fall"); // instantly builds a bridge on fl-swamp etc
+            SendMessage(st, "fall"); // instantly builds a bridge on fl-swamp etc
         }
         void actor_contact(Actor *a) {SendMessage(a, "shatter");}
         void actor_inside(Actor *a) {SendMessage(a, "shatter");}
@@ -1336,7 +1344,7 @@
         void change_state(State newstate);
         void animcb();
         void actor_hit(const StoneContact &sc);
-        virtual Value message(const string &m, const Value &val);
+        virtual Value message(const Message &m);
 
         void on_laserhit(Direction) {
             change_state(BREAKING);
@@ -1394,20 +1402,22 @@
     else
         change_state(FARTING);
 }
-Value FartStone::message (const string &m, const Value &val) 
+Value FartStone::message(const Message &m) 
 {
-    if (m == "signal" && to_int(val) != 0)
+    if (m.message == "signal" && m.value != 0) {
         change_state(FARTING);
-    else if (m=="trigger")
+        return Value();
+    } else if (m.message == "trigger") {
         change_state(FARTING);
-    else if (m == "ignite" || m == "expl") 
+        return Value();
+    } else if (m.message == "ignite" || m.message == "expl") { 
         change_state(BREAKING);
-    return Value();
+        return Value();
+    }
+    return Object::message(m);
 }
 
 
-
-
 /* -------------------- Thief -------------------- */
 namespace
 {
@@ -1429,7 +1439,7 @@
         // even a slight touch should steal from the actor: 
         void actor_touch(const StoneContact &sc) { actor_hit(sc); }
         void animcb();
-        virtual Value message(const string &msg, const Value &v);        
+        virtual Value message(const Message &m);        
 
         const char *collision_sound() { return "cloth"; }
         int affected_player;
@@ -1494,10 +1504,11 @@
     }
 }
 
-Value ThiefStone::message(const string &msg, const Value &v) {
-    if(msg == "signal" && server::GameCompatibility != GAMET_ENIGMA) {
-        performAction(v.to_bool());  // signal multiplier
-    } else if(msg == "capture" && state == IDLE) {
+Value ThiefStone::message(const Message &m) {
+    if(m.message == "signal" && server::GameCompatibility != GAMET_ENIGMA) {
+        performAction(!m.value.to_bool());  // inverse signal multiplier
+        return Value();
+    } else if (m.message == "capture" && state == IDLE) {
         state = CAPTURED;
         Item * it =  GetItem(get_pos());
         
@@ -1511,8 +1522,8 @@
         bag = NULL;
         set_anim(string(get_kind()) + "-captured");
         return Value(1);
-    } else
-        return Stone::message(msg, v);
+    }
+    return Object::message(m);
 }
 
 // -------------------------
@@ -1567,15 +1578,16 @@
 
         int signalidx;
 
-        virtual Value message (const string &msg, const Value &) {
+        virtual Value message(const Message &m) {
             if(server::GameCompatibility != GAMET_ENIGMA) {
                 // Oxyd* usage of ActorImpulseStone as a signal multiplier
                 ObjectList ol = getAttr("$!oxyd!destinations");
                 
-                if (msg == "init" && ol.size() > 0) {
+                if (m.message == "init" && ol.size() > 0) {
                     signalidx = 0;
                     SendMessage(ol.front(), "signal", 1);
-                } else if (msg == "signal") {
+                    return Value();
+                } else if (m.message == "signal") {
                     int i = 0;
                     bool didBreak = false;
                     for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit, i++) {
@@ -1592,9 +1604,10 @@
                         signalidx = 0;                        
                     } else
                         signalidx++;
+                    return Value();
                 }
             } // GameCompatibility != GAMET_ENIGMA
-            return Value();
+            return Object::message(m);
         }
 
     public:
@@ -1684,13 +1697,14 @@
             }
         }
 
-        virtual Value on_message (const Message &m) {
+        virtual Value message(const Message &m) {
             if (m.message == "signal" || m.message == "trigger") {
                 // toggle between black and white stone
                 m_type = (m_type + 4) % 8;
                 init_model();
+                return Value();
             }
-            return Value();
+            return Object::message(m);
         }
 
         bool is_floating() const { return true; }
@@ -1802,7 +1816,7 @@
         void actor_hit (const StoneContact &sc);
         void change_state (State newstate);
         void animcb();
-        virtual Value message (const string &msg, const Value &);
+        virtual Value message(const Message &m);
     };
 }
 DEF_TRAITSM(BombStone, "INVALID", st_INVALID, MOVABLE_BREAKABLE);
@@ -1829,11 +1843,13 @@
         SetItem(p, it_explosion1);
 }
 
-Value BombStone::message(const string &msg, const Value &) 
+Value BombStone::message(const Message &m) 
 {
-    if (msg =="expl" || msg =="bombstone")
+    if (m.message =="expl" || m.message =="bombstone") {
         change_state(BREAK);
-    return Value();
+        return Value();
+    }
+    return Object::message(m);
 }
 
 void BombStone::actor_hit(const StoneContact &sc) 
@@ -1847,7 +1863,7 @@
     }
 }
 
-
+
 /* -------------------- MagicStone -------------------- */
 namespace
 {
@@ -1933,9 +1949,9 @@
             set_visible_model();
         }
 
-        virtual Value message(const string& msg, const Value &val) {
-            if (msg == "glasses") {
-                if (to_int(val)) {
+        virtual Value message(const Message &m) {
+            if (m.message == "glasses") {
+                if (to_int(m.value)) {
                     if (!visible) {
                         visible = true;
                         set_visible_model();
@@ -1947,8 +1963,9 @@
                         set_visible_model();
                     }
                 }
+                return Value();
             }
-            return Value();
+            Object::message(m);
         }
     public:
         DeathStoneInvisible() : visible(false) {}
@@ -2009,11 +2026,12 @@
             explode();
         }
 
-        virtual Value message(const string &msg, const Value &) {
-            if (msg == "expl") {
+        virtual Value message(const Message &m) {
+            if (m.message == "expl") {
                 explode();
+                return Value();
             }
-            return Value();
+            Object::message(m);
         }
 
         bool is_sticky(const Actor *) const 
@@ -2050,19 +2068,22 @@
     private:
         bool is_floating() const { return true; }
 
-        virtual Value message(const string &msg, const Value &val) {
-            if (msg == "signal") {
-                int ival = to_int (val);
+        virtual Value message(const Message &m) {
+            if (m.message == "signal") {
+                int ival = m.value;
                 if (ival > 0)
                     lighten();
                 else
                     darken();
-            }
-            else if (msg == "lighten")
+                return Value();
+            } else if (m.message == "lighten") {
                 lighten();
-            else if (msg == "darken")
+                return Value();
+            } else if (m.message == "darken") {
                 darken();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
     };
     class DiscoLight : public DiscoStone {
@@ -2198,12 +2219,12 @@
             ReplaceStone(get_pos(), MakeStone("st-plain_breaking"));
         }
 
-        virtual Value message (const string &msg, const Value &) {
-            if (msg =="heat" || msg == "fire") {
+        virtual Value message(const Message &m) {
+            if (m.message =="heat" || m.message == "fire") {
                 break_me();
                 return Value(1.0);
             }
-            return Value();
+            return Object::message(m);
         }
 
         void actor_hit(const StoneContact &sc) {
@@ -2229,10 +2250,12 @@
             ReplaceStone(get_pos(), MakeStone("st-plain_breaking"));
         }
 
-        virtual Value message (const string &msg, const Value &) {
-            if (msg =="fire")
+        virtual Value message(const Message &m) {
+            if (m.message =="fire") {
                 break_me();
-            return Value();
+                return Value();
+            }
+            return Object::message(m);
         }
 
         void actor_hit(const StoneContact &sc) {

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/world.cc	2007-12-23 22:32:57 UTC (rev 951)
@@ -85,17 +85,11 @@
 
 /* -------------------- Messages -------------------- */
 
-Message::Message ()
-{
+Message::Message () : sender (NULL) {
 }
  
-Message::Message (const std::string &message_,
-                  const Value &value_,
-                  GridPos from_)
-: message (message_),
-  value (value_),
-  gridpos (from_)
-{
+Message::Message (const std::string &theMessage, const Value &theValue, Object * theSender) : 
+        message (theMessage), value (theValue), sender (theSender) {
 }
 
 /* -------------------- RubberBandData -------------------- */
@@ -255,7 +249,6 @@
 
 enigma::Timer  GameTimer;
 bool           TrackMessages;
-Actor         *CurrentCollisionActor = 0;
 
 
 
@@ -1094,10 +1087,8 @@
             if (!has_nearby_contact(ai.last_contacts, ai.last_contacts_count, 
                     contact)) {
                 if (Stone *stone = GetStone(sc.stonepos)) {
-                    CurrentCollisionActor = a;
                     if (slow_collision) stone->actor_touch(sc);
                     else stone->actor_hit(sc);
-                    CurrentCollisionActor = 0;
 
                     if (!slow_collision) {
                         client::Msg_Sparkle (sc.contact_point);
@@ -1568,7 +1559,6 @@
 void WorldPrepareLevel ()
 {
     GameTimer.clear();
-    CurrentCollisionActor = 0;
     Resize (20, 13);
 }
 
@@ -1828,8 +1818,8 @@
             srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
         return; // ignore signal
     }
-//    Log << ecl::strf("AddSignal: Valid signal destination src=%i/%i-%d dest=%i/%i-%d msg='%s'\n",
-//        srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
+//    Log << ecl::strf("AddSignal: Valid signal destination src=%i/%i-%d (%s) dest=%i/%i-%d (%s) msg='%s'\n",
+//        srcloc.pos.x, srcloc.pos.y, srcloc.layer, src->get_kind(), dstloc.pos.x, dstloc.pos.y, dstloc.layer, dst->get_kind(), msg.c_str());
     
     Value dstValue(dst);
     
@@ -1891,22 +1881,17 @@
 }
 
 
-Value SendMessage(Object *o, const std::string &msg) 
+Value SendMessage(Object *obj, const std::string &msg, const Value& value, Object *sender)
 {
-    return SendMessage (o, Message (msg, Value()));
+    return SendMessage (obj, Message (msg, value, sender));
 }
 
-Value SendMessage(Object *o, const std::string &msg, const Value& value)
+Value SendMessage (Object *obj, const Message &m)
 {
-    return SendMessage (o, Message (msg, value));
-}
-
-Value SendMessage (Object *o, const Message &m)
-{
-    if (o) {
+    if (obj) {
         if (TrackMessages)
-            o->warning("will be sent message '%s' (with Value)", m.message.c_str());
-        return o->on_message(m);
+            obj->warning("will be sent message '%s' (with Value)", m.message.c_str());
+        return obj->message(m);
     }
     else if (TrackMessages) {
         fprintf(stderr, "Sending message '%s' to NULL-object\n", m.message.c_str());

Modified: trunk/src/world.hh
===================================================================
--- trunk/src/world.hh	2007-12-22 13:49:37 UTC (rev 950)
+++ trunk/src/world.hh	2007-12-23 22:32:57 UTC (rev 951)
@@ -55,16 +55,13 @@
 
     struct Message {
         // Variables
-        std::string    message;
-        Value  value;
-        GridPos        gridpos;
+        std::string message;
+        Value value;
+        Object *sender;
 
         // Constructors
         Message ();
-        Message (const std::string &message,
-                 const Value &value,
-                 GridPos gridpos = GridPos());
-
+        Message (const std::string &message, const Value &value, Object *sender);
     };
 
 
@@ -250,9 +247,8 @@
     void BroadcastMessage (const std::string& msg, const Value& value, 
                            GridLayerBits grids);
 
-    Value SendMessage (Object *o, const string &msg);
-    Value SendMessage (Object *o, const string &msg, const Value& value);
-    Value SendMessage (Object *o, const Message &m);
+    Value SendMessage (Object *obj, const string &msg, const Value& value = Value(), Object *sender = NULL);
+    Value SendMessage (Object *obj, const Message &m);
 
 
 



From ral at mail.berlios.de  Mon Dec 24 11:26:20 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Mon, 24 Dec 2007 11:26:20 +0100
Subject: [Enigma-game-svn] r952 - trunk/src
Message-ID: <200712241026.lBOAQKbD007974@sheep.berlios.de>

Author: ral
Date: 2007-12-24 11:26:18 +0100 (Mon, 24 Dec 2007)
New Revision: 952

Modified:
   trunk/src/actors.cc
   trunk/src/actors.hh
   trunk/src/world.cc
Log:
Trunk 1.1: 
- fix r951: add forgotten actor message reengineering


Modified: trunk/src/actors.cc
===================================================================
--- trunk/src/actors.cc	2007-12-23 22:32:57 UTC (rev 951)
+++ trunk/src/actors.cc	2007-12-24 10:26:18 UTC (rev 952)
@@ -89,7 +89,6 @@
         const ActorTraits &get_traits() const { return traits; } \
 
 
-
 /* -------------------- Actor -------------------- */
 
 Actor::Actor (const ActorTraits &tr)
@@ -264,11 +263,12 @@
     return true;
 }
 
-Value Actor::message(const string &m, const Value &) {
-    if (m == "init") {
+Value Actor::message(const Message &m) {
+    if (m.message == "init") {
         startingpos = get_pos();
+        return Value();
     }
-    return Value();
+    return Object::message(m);
 }
 
 bool Actor::sound_event (const char *name, double vol) {
@@ -285,8 +285,6 @@
 }
 
 
-
-
 /* -------------------- RotorBase -------------------- */
 
 namespace
@@ -390,7 +388,7 @@
     Actor::think(dtime);
 }
 
-
+
 /* -------------------- Rotor -------------------- */
 namespace
 {
@@ -412,7 +410,7 @@
     0.8f                        // mass
 };
 
-
+
 /* -------------------- Spinning top -------------------- */
 namespace
 {
@@ -434,7 +432,6 @@
     0.8f                        // mass
 };
 
-
 /* -------------------- Bug -------------------- */
 
 namespace
@@ -459,7 +456,6 @@
 };
 
 
-
 /* -------------------- Horse -------------------- */
 
 namespace
@@ -547,7 +543,6 @@
 
 
 
-
 /* -------------------- CannonBall -------------------- */
 
 namespace
@@ -610,7 +605,6 @@
 }
 
 
-
 /* -------------------- BasicBall -------------------- */
 namespace
 {
@@ -677,7 +671,7 @@
         bool can_be_warped() const { return state==NORMAL; }
 
         // Object interface.
-        virtual Value message(const string &m, const Value &);
+        virtual Value message(const Message &m);
 
         // ModelCallback interface.
         void animcb();
@@ -766,60 +760,102 @@
         change_state(newstate);
 }
 
-Value BasicBall::message(const string &m, const Value &v) 
+Value BasicBall::message(const Message &m) 
 {
+    bool handled = false;
     switch (state) {
-    case NORMAL:
-        if (m == "shatter")         change_state_noshield(SHATTERING);
-        else if (m == "suicide")    change_state(SHATTERING);
-        else if (m == "laserhit")   change_state_noshield(SHATTERING);
-        else if (m == "drown")      change_state_noshield(DROWNING);
-        else if (m == "fall")       change_state_noshield(FALLING);
-        else if (m == "fallvortex") change_state(FALLING_VORTEX);
-        else if (m == "jump")       change_state(JUMPING);
-        else if (m == "appear")     change_state(APPEARING);
-        else if (m == "disappear")  change_state(DISAPPEARING);
-        break;
-    case JUMPING:
-        if (m == "shatter")         change_state_noshield(SHATTERING);
-        else if (m == "disappear")  change_state(DISAPPEARING);
-        break;
-    case DEAD:
-        if (m == "resurrect")       change_state(RESURRECTED);
-        break;
-    case FALLING_VORTEX:
-        if (m == "rise")            change_state(RISING_VORTEX); // vortex->vortex teleportation
-        else if (m == "appear")     change_state(APPEARING); // vortex->non-vortex teleportation
-        break;
-    case JUMP_VORTEX:
-        if (m == "laserhit")        change_state(SHATTERING);
-        break;
-    case APPEARING:
-        // ugly hack
-        if (m == "init")
-            Actor::message (m, v);
-        else if (m == "shatter")    change_state (SHATTERING);
-	break;
-    default:
-        break;
+        case NORMAL:
+            if (m.message == "shatter") {
+                change_state_noshield(SHATTERING);
+                handled = true;
+            } else if (m.message == "suicide") {
+                change_state(SHATTERING);
+                handled = true;
+            } else if (m.message == "laserhit") {
+                change_state_noshield(SHATTERING);
+                handled = true;
+            } else if (m.message == "drown") {
+                change_state_noshield(DROWNING);
+                handled = true;
+            } else if (m.message == "fall") {
+                change_state_noshield(FALLING);
+                handled = true;
+            } else if (m.message == "fallvortex") {
+                change_state(FALLING_VORTEX);
+                handled = true;
+            } else if (m.message == "jump") {
+                change_state(JUMPING);
+                handled = true;
+            } else if (m.message == "appear") {
+                change_state(APPEARING);
+                handled = true;
+            } else if (m.message == "disappear") {
+                change_state(DISAPPEARING);
+                handled = true;
+            }
+            break;
+        case JUMPING:
+            if (m.message == "shatter") {
+                change_state_noshield(SHATTERING);
+                handled = true;
+            } else if (m.message == "disappear") {
+                change_state(DISAPPEARING);
+                handled = true;
+            }
+            break;
+        case DEAD:
+            if (m.message == "resurrect") {
+                change_state(RESURRECTED);
+                handled = true;
+            }
+            break;
+        case FALLING_VORTEX:
+            if (m.message == "rise") {
+                change_state(RISING_VORTEX); // vortex->vortex teleportation
+            } else if (m.message == "appear") {
+                change_state(APPEARING); // vortex->non-vortex teleportation
+                handled = true;
+            }
+            break;
+        case JUMP_VORTEX:
+            if (m.message == "laserhit") {
+                change_state(SHATTERING);
+                handled = true;
+            }
+            break;
+        case APPEARING:
+            // ugly hack
+            if (m.message == "init") {
+                Actor::message (m);
+                handled = true;
+            } else if (m.message == "shatter") {
+                change_state (SHATTERING);
+                handled = true;
+            }
+    	    break;
+        default:
+            break;
     }
 
-
     // Shield, booze and invisibility can be activated in all states except DEAD
 
     if (state != DEAD) {
-        if (m == "shield") {
+        if (m.message == "shield") {
             m_shield_rest_time += SHIELD_TIME;
             update_halo();
+            handled = true;
         }
-        else if (m == "invisibility") {
+        else if (m.message == "invisibility") {
             m_invisible_rest_time += 8.0;
+            handled = true;
         }
-        else if (m == "booze") {
+        else if (m.message == "booze") {
             m_drunk_rest_time += 5.0; // Drunken for 5 more seconds
+            handled = true;
         }
     }
-    return Value();
+
+    return handled ? Value() : Actor::message(m);
 }
 
 void BasicBall::set_sink_model(const string &m)

Modified: trunk/src/actors.hh
===================================================================
--- trunk/src/actors.hh	2007-12-23 22:32:57 UTC (rev 951)
+++ trunk/src/actors.hh	2007-12-24 10:26:18 UTC (rev 952)
@@ -115,7 +115,7 @@
 
         /* ---------- Object interface ---------- */
         Actor *clone() = 0;
-        virtual Value   message (const string &m, const Value &);
+        virtual Value message(const Message &m);
         void   set_attrib (const string& key, const Value &val);
 
         /* ---------- Actor interface ---------- */

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-23 22:32:57 UTC (rev 951)
+++ trunk/src/world.cc	2007-12-24 10:26:18 UTC (rev 952)
@@ -1576,7 +1576,7 @@
     {
         Actor *a = *i;
         a->on_creation(a->get_actorinfo()->pos);
-        a->message ("init", Value());
+        SendMessage(a, "init", Value());
 
         if (Value v = a->getAttr("player")) {
             int iplayer = v;



From ral at mail.berlios.de  Thu Dec 27 16:33:58 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Thu, 27 Dec 2007 16:33:58 +0100
Subject: [Enigma-game-svn] r953 - trunk/src
Message-ID: <200712271533.lBRFXwoo030353@sheep.berlios.de>

Author: ral
Date: 2007-12-27 16:33:57 +0100 (Thu, 27 Dec 2007)
New Revision: 953

Modified:
   trunk/src/items.cc
   trunk/src/stones_internal.hh
   trunk/src/world.cc
Log:
Trunk 1.1: 
- fix r951: add forgotten internal-onoff stone message reengineering


Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-24 10:26:18 UTC (rev 952)
+++ trunk/src/items.cc	2007-12-27 15:33:57 UTC (rev 953)
@@ -3521,7 +3521,7 @@
 
         virtual Value message(const Message &m) {
             if (m.message == "init") {
-                performAction(true);
+//                performAction(true);
                 return Value();
             }
             return Object::message(m);

Modified: trunk/src/stones_internal.hh
===================================================================
--- trunk/src/stones_internal.hh	2007-12-24 10:26:18 UTC (rev 952)
+++ trunk/src/stones_internal.hh	2007-12-27 15:33:57 UTC (rev 953)
@@ -102,7 +102,7 @@
 
         virtual void notify_onoff(bool /*on*/) {}
 
-        virtual Value on_message(const Message &m)
+        virtual Value message(const Message &m)
         {
             const std::string &msg = m.message;
             if (m.message == "onoff") {

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-24 10:26:18 UTC (rev 952)
+++ trunk/src/world.cc	2007-12-27 15:33:57 UTC (rev 953)
@@ -1818,8 +1818,8 @@
             srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
         return; // ignore signal
     }
-//    Log << ecl::strf("AddSignal: Valid signal destination src=%i/%i-%d (%s) dest=%i/%i-%d (%s) msg='%s'\n",
-//        srcloc.pos.x, srcloc.pos.y, srcloc.layer, src->get_kind(), dstloc.pos.x, dstloc.pos.y, dstloc.layer, dst->get_kind(), msg.c_str());
+    Log << ecl::strf("AddSignal: Valid signal destination src=%i/%i-%d (%s) dest=%i/%i-%d (%s) msg='%s'\n",
+        srcloc.pos.x, srcloc.pos.y, srcloc.layer, src->get_kind(), dstloc.pos.x, dstloc.pos.y, dstloc.layer, dst->get_kind(), msg.c_str());
     
     Value dstValue(dst);
     



From ral at mail.berlios.de  Thu Dec 27 21:12:58 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Thu, 27 Dec 2007 21:12:58 +0100
Subject: [Enigma-game-svn] r954 - trunk/src
Message-ID: <200712272012.lBRKCwkM032443@sheep.berlios.de>

Author: ral
Date: 2007-12-27 21:12:57 +0100 (Thu, 27 Dec 2007)
New Revision: 954

Modified:
   trunk/src/items.cc
   trunk/src/items.hh
   trunk/src/ox_magnum.cc
   trunk/src/world.cc
Log:
Trunk 1.1: 
- remove of item oxyd5f


Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-27 15:33:57 UTC (rev 953)
+++ trunk/src/items.cc	2007-12-27 20:12:57 UTC (rev 954)
@@ -3515,25 +3515,7 @@
     DEF_TRAITSF(ChangeFloorItem, "it-changefloor", it_changefloor,
                 itf_static | itf_invisible);
 
-    class Oxyd5fItem : public Item {
-        CLONEOBJ(Oxyd5fItem);
-        DECL_TRAITS;
 
-        virtual Value message(const Message &m) {
-            if (m.message == "init") {
-//                performAction(true);
-                return Value();
-            }
-            return Object::message(m);
-        }
-    public:
-        Oxyd5fItem()
-        {}
-    };
-    DEF_TRAITSF(Oxyd5fItem, "it-oxyd5f", it_oxyd5f,
-                itf_static | itf_invisible | itf_fireproof);
-}
-
 /* -------------------- Drop -------------------- */
 
 namespace

Modified: trunk/src/items.hh
===================================================================
--- trunk/src/items.hh	2007-12-27 15:33:57 UTC (rev 953)
+++ trunk/src/items.hh	2007-12-27 20:12:57 UTC (rev 954)
@@ -93,7 +93,6 @@
         it_magnet_off,
         it_magnet_on,
         it_odometer,
-        it_oxyd5f,
         it_pencil,
         it_pin,
         it_pipe_e, it_pipe_w, it_pipe_s, it_pipe_n,

Modified: trunk/src/ox_magnum.cc
===================================================================
--- trunk/src/ox_magnum.cc	2007-12-27 15:33:57 UTC (rev 953)
+++ trunk/src/ox_magnum.cc	2007-12-27 20:12:57 UTC (rev 954)
@@ -391,7 +391,7 @@
     ITEMSPEC(it_UNUSED),        // OxydMagnum item 0x5c
     ITEMSPEC(it_UNUSED),        // OxydMagnum item 0x5d
     ITEMSPEC(it_UNUSED),        // OxydMagnum item 0x5e
-    ITEMSPEC(it_oxyd5f),        // OxydMagnum item 0x5f
+    ITEMSPEC(it_signalfilter1), // OxydMagnum item 0x5f
     ITEMSPEC(it_drop),          // OxydMagnum item 0x60 (drunk)
     ITEMSPEC(it_UNUSED),        // OxydMagnum item 0x61 (rev. breaking area)
     ITEMSPEC(it_UNUSED),        // OxydMagnum item 0x62 (player exchange)

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2007-12-27 15:33:57 UTC (rev 953)
+++ trunk/src/world.cc	2007-12-27 20:12:57 UTC (rev 954)
@@ -1818,8 +1818,8 @@
             srcloc.pos.x, srcloc.pos.y, srcloc.layer, dstloc.pos.x, dstloc.pos.y, dstloc.layer, msg.c_str());
         return; // ignore signal
     }
-    Log << ecl::strf("AddSignal: Valid signal destination src=%i/%i-%d (%s) dest=%i/%i-%d (%s) msg='%s'\n",
-        srcloc.pos.x, srcloc.pos.y, srcloc.layer, src->get_kind(), dstloc.pos.x, dstloc.pos.y, dstloc.layer, dst->get_kind(), msg.c_str());
+//    Log << ecl::strf("AddSignal: Valid signal destination src=%i/%i-%d (%s) dest=%i/%i-%d (%s) msg='%s'\n",
+//        srcloc.pos.x, srcloc.pos.y, srcloc.layer, src->get_kind(), dstloc.pos.x, dstloc.pos.y, dstloc.layer, dst->get_kind(), msg.c_str());
     
     Value dstValue(dst);
     



From ral at mail.berlios.de  Thu Dec 27 22:17:17 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Thu, 27 Dec 2007 22:17:17 +0100
Subject: [Enigma-game-svn] r955 - trunk/src
Message-ID: <200712272117.lBRLHHOm003350@sheep.berlios.de>

Author: ral
Date: 2007-12-27 22:17:16 +0100 (Thu, 27 Dec 2007)
New Revision: 955

Modified:
   trunk/src/items.cc
Log:
Trunk 1.1: 
- fix r954 (remove of item oxyd5f)


Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-12-27 20:12:57 UTC (rev 954)
+++ trunk/src/items.cc	2007-12-27 21:17:16 UTC (rev 955)
@@ -3514,8 +3514,8 @@
     };
     DEF_TRAITSF(ChangeFloorItem, "it-changefloor", it_changefloor,
                 itf_static | itf_invisible);
+}
 
-
 /* -------------------- Drop -------------------- */
 
 namespace
@@ -3718,7 +3718,6 @@
     RegisterItem (new OnePKillStone);
     RegisterItem (new OxydBridge);
     RegisterItem (new OxydBridgeActive);
-    RegisterItem (new Oxyd5fItem);
     RegisterItem (new Pencil);
     RegisterItem (new Pin);
     Pipe::setup();



From ral at mail.berlios.de  Fri Dec 28 21:48:40 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Fri, 28 Dec 2007 21:48:40 +0100
Subject: [Enigma-game-svn] r956 - trunk/src
Message-ID: <200712282048.lBSKmeZf020958@sheep.berlios.de>

Author: ral
Date: 2007-12-28 21:48:38 +0100 (Fri, 28 Dec 2007)
New Revision: 956

Added:
   trunk/src/GridObject.cc
   trunk/src/GridObject.hh
   trunk/src/Object.cc
   trunk/src/Object.hh
   trunk/src/Value.cc
   trunk/src/Value.hh
Removed:
   trunk/src/objects.cc
   trunk/src/objects.hh
Modified:
   trunk/src/Makefile.am
   trunk/src/WorldProxy.hh
   trunk/src/actors.hh
   trunk/src/enigma.cc
   trunk/src/enigma.hh
   trunk/src/items.hh
   trunk/src/laser.hh
   trunk/src/lua.hh
   trunk/src/ox_oxyd1.cc
   trunk/src/ox_peroxyd.cc
   trunk/src/player.hh
   trunk/src/stones.hh
   trunk/src/world.hh
Log:
Trunk 1.1: reengineering
- extract classes Value, Object, GridObject to own files
- remove files objects.hh/cc
Note:
- autogen necessary


Added: trunk/src/GridObject.cc
===================================================================
--- trunk/src/GridObject.cc	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/GridObject.cc	2007-12-28 20:48:38 UTC (rev 956)
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2002,2003,2004,2005 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "GridObject.hh"
+
+#include "errors.hh"
+#include "game.hh"
+#include "lua.hh"
+#include "sound.hh"
+#include "world.hh"
+
+#include "ecl_util.hh"
+#include "ecl_dict.hh"
+
+#include <algorithm>
+#include <string>
+#include <cstdlib>
+#include <cstdarg>
+#include <iostream>
+#include <iomanip>
+
+
+using namespace std;
+
+namespace enigma {
+
+// remove comment from define below to switch on verbose messaging
+// note: VERBOSE_MESSAGES is defined in multiple source files!
+// #define VERBOSE_MESSAGES
+
+
+/* -------------------- GridObject implementation -------------------- */
+
+    void GridObject::setOwner(int player) {
+        ASSERT(pos.x < 0, XLevelRuntime,
+            "GridObject: attempt to add object to owner inventory that is still on grid");
+        pos.x = -1;
+        pos.y = player;
+    }
+    
+    Value GridObject::getOwner() {
+        if (pos.x == -1 && pos.y != -1)
+            return Value(pos.y);
+        else
+            return Value();
+    }
+    
+    void GridObject::setOwnerPos(GridPos po) {
+        ASSERT(pos.x < 0, XLevelRuntime,
+            "GridObject: attempt to add object to owner inventory that is still on grid");
+        if (po.x >= 0) {
+            pos.x = -2 - po.x;
+            pos.y = -2 - po.y;
+        } else {
+            pos.x = po.x;
+            pos.y = po.y;
+        }
+    }
+    
+    GridPos GridObject::getOwnerPos() {
+        if (pos.x <= -2)
+            return GridPos(-2 - pos.x, -2 - pos.y);
+        else 
+            return pos;
+    }
+    
+    display::Model *GridObject::set_anim (const std::string &mname) 
+    {
+        set_model (mname);
+        display::Model *m = get_model();
+        m->set_callback(this);
+        return m;
+    }
+    
+    bool GridObject::sound_event (const char *name, double vol)
+    {
+        return sound::EmitSoundEvent (name, get_pos().center(), getVolume(name, this, vol));
+    }
+    
+    void GridObject::warning(const char *format, ...) const 
+    {
+        va_list        arg_ptr;
+        const GridPos& position = get_pos();
+    
+        va_start(arg_ptr, format);
+    
+        fprintf(stderr, "%p \"%s\" at %i/%i: ", this, get_kind(), position.x, position.y);
+        vfprintf(stderr, format, arg_ptr);
+        fputc('\n', stderr);
+    
+        va_end(arg_ptr);
+    }
+    
+} // namespace enigma


Property changes on: trunk/src/GridObject.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/GridObject.hh
===================================================================
--- trunk/src/GridObject.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/GridObject.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+#ifndef GRIDOBJECT_HH
+#define GRIDOBJECT_HH
+
+#include "Object.hh"
+
+#include "display.hh"
+#include "ecl_alist.hh"
+#include <map>
+
+namespace enigma { 
+
+    using std::string;
+    
+
+/* -------------------- GridObject -------------------- */
+    class Actor;
+
+    /** 
+     * GridObject is the base class for everything that can only be
+     * placed on "The Grid", i.e., for floor tiles, items, and
+     * stones. 
+     */
+    class GridObject : public Object, public display::ModelCallback {
+    public:
+        GridObject() : pos (GridPos(-1, -1)) {}
+        GridObject(const char * kind) : Object(kind), pos (GridPos(-1, -1)) {}
+
+        void creation(GridPos p) {
+            pos = p;
+            on_creation (p);
+        }
+        void removal(GridPos p) { 
+            on_removal(p);
+            pos.x = -1;
+            pos.y = -1;
+        }
+        GridPos get_pos() const {return pos;}
+        
+        virtual void setOwner(int player);
+        
+        /**
+         * Get the player number who is owning the object.
+         * @return  integer value of player number or nil if not owned by a player
+         */
+        Value getOwner();
+        
+        /**
+         * Set the location of the GridObject to a given world or mirrored owner
+         * position.
+         */
+        virtual void setOwnerPos(GridPos po);
+         
+        /**
+         * Get the position of object within the world. Only objects owned by
+         * players will return positions outside of the world. 
+         */
+        GridPos getOwnerPos();
+
+        // GridObject interface
+        virtual void on_laserhit (Direction) {}
+        virtual void actor_enter (Actor *) {}
+        virtual void actor_leave (Actor *) {}
+
+
+        void warning(const char *format, ...) const;
+
+        // Helper functions
+        bool sound_event (const char *name, double vol = 1.0);
+        display::Model *set_anim (const std::string &mname);
+
+    protected:
+        // GridObject interface
+        virtual void set_model (const std::string &mname) = 0;
+        virtual display::Model *get_model () = 0;
+        virtual void kill_model (GridPos p) = 0;
+
+        virtual void init_model() {
+            set_model(get_kind());
+        }
+
+        virtual void on_creation (GridPos) {
+            init_model();
+        }
+
+        virtual void on_removal (GridPos p) {
+            kill_model (p);
+        }
+
+    private:
+        // ModelCallback interface.
+        void animcb() {}
+
+
+        /**
+         * The location of the GridObject. An object that is set on one of the world's
+         * layers will store the x and y coordinates with values greater equal 0. An
+         * object that is not a direct part of the world has a pos.x < 0. Objects that
+         * are owned by other objects that are part of a world layer will store the
+         * position of the owner mirrored at point -1, -1. This results in pos.x <= -2.
+         * All other GridObjects will have pos.x = -1. In this case pos.y >= 0 identifies
+         * the player that owns the object in his inventory. Objects that are neiter set
+         * in the world nor owned by anyone have pos.x = pos.y = -1. 
+         */
+        GridPos pos;
+    };
+
+} // namespace enigma
+
+#endif


Property changes on: trunk/src/GridObject.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/Makefile.am	2007-12-28 20:48:38 UTC (rev 956)
@@ -53,6 +53,8 @@
 	fwd.hh			\
 	game.cc			\
 	game.hh			\
+	GridObject.cc 		\
+	GridObject.hh 		\
 	Inventory.cc		\
 	Inventory.hh		\
 	ItemHolder.hh		\
@@ -82,8 +84,8 @@
 	network.hh		\
 	nls.cc 			\
 	nls.hh			\
-	objects.cc 		\
-	objects.hh 		\
+	Object.cc 		\
+	Object.hh 		\
 	oxyd.cc			\
 	oxyd.hh 		\
 	oxyd_internal.hh	\
@@ -119,10 +121,12 @@
 	util.hh			\
 	utilXML.cc		\
 	utilXML.hh		\
+	Value.cc		\
+	Value.hh		\
 	video.cc 		\
 	video.hh		\
-	WorldProxy.cc	\
-	WorldProxy.hh	\
+	WorldProxy.cc		\
+	WorldProxy.hh		\
 	world.cc 		\
 	world.hh 		\
 	world_internal.hh	\

Added: trunk/src/Object.cc
===================================================================
--- trunk/src/Object.cc	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/Object.cc	2007-12-28 20:48:38 UTC (rev 956)
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2002,2003,2004,2005 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "Object.hh"
+
+#include "errors.hh"
+#include "game.hh"
+#include "lua.hh"
+#include "sound.hh"
+#include "world.hh"
+
+#include "ecl_util.hh"
+#include "ecl_dict.hh"
+
+#include <algorithm>
+#include <string>
+#include <cstdlib>
+#include <cstdarg>
+#include <iostream>
+#include <iomanip>
+
+
+using namespace std;
+
+namespace enigma {
+
+// remove comment from define below to switch on verbose messaging
+// note: VERBOSE_MESSAGES is defined in multiple source files!
+// #define VERBOSE_MESSAGES
+
+/* -------------------- Object implementation -------------------- */
+
+    int Object::next_id = 1;
+    std::map<int, Object *> Object::objects;
+    
+    int Object::getNextId(Object *obj, bool bootFinished) {
+        static bool isBooting = true;
+        static int nextIdBoot = 1;
+        static std::map<int, Object *> objectsBoot;
+        
+        if (isBooting) {
+            if (bootFinished) {
+                isBooting = false;
+                next_id = nextIdBoot;
+                objects = objectsBoot;
+                return 0;
+            } else {
+                objectsBoot[nextIdBoot] = obj;
+                return nextIdBoot++;
+            }
+        } else {
+            objects[next_id] = obj;
+            return next_id++;
+        }
+    }
+    
+    void Object::bootFinished() {
+        getNextId(NULL, true);
+    }
+    
+    void Object::freeId(int id) {
+        objects.erase(id);
+    }
+    
+    Object * Object::getObject(int id) {
+        std::map<int, Object *>::iterator it = objects.find(id);
+        if (it == objects.end())
+            return NULL;
+        else
+            return it->second;
+    }
+    
+    Object::Object() {
+        id = getNextId(this, false);
+    }
+    
+    Object::Object(const char *kind) {
+        set_attrib("kind", Value(kind));
+        id = getNextId(this, false);
+    }
+    
+    Object::Object(const Object &src_obj) {
+        id = getNextId(this, false);
+        attribs = src_obj.attribs;
+    }
+    
+    Object::~Object() {
+        freeId(id);
+    //cerr << "obj del " << id << " - " << this->get_kind() <<"\n";
+    }
+    
+    int Object::getId() const {
+        return id;
+    }
+    
+    Value Object::message(const Message &m) {
+        return Value();
+    }
+    
+    void Object::on_levelinit() {
+    }
+    
+    
+    const char * Object::get_kind() const {      // To be made pure virtual
+        const Value *v = get_attrib("kind");
+        ASSERT(v && v->getType() == Value::STRING, XLevelRuntime,
+            "Object: attribute kind is not of type string (found in get_kind)");
+        return v->get_string();
+    }
+    
+    // check kind of object
+    // kind_templ may contain wildcards ( ? and * )
+    bool Object::is_kind(const char *kind_templ) const {
+        return ecl::string_match(get_kind(), kind_templ);
+    }
+    
+    bool Object::is_kind(const string& kind_templ) const {
+        return ecl::string_match(get_kind(), kind_templ.c_str());
+    }
+    
+    void Object::set_attrib(const string& key, const Value& val) {
+        if (val)         // only set non-default values
+            attribs[key] = val;  //.insert (key, val);
+    }
+    
+    const Value* Object::get_attrib(const string& key) const { // To be delete as soon as
+                                                               // get_kind() has no need of it
+        AttribMap::const_iterator i = attribs.find(key);
+        if (i == attribs.end())
+            return 0;
+        else
+            return &i->second;
+    }
+    
+    Value Object::getAttr(const string& key) const {
+        AttribMap::const_iterator i = attribs.find(key);
+        if (i == attribs.end())
+            return Value(Value::DEFAULT);
+        else
+            return i->second;
+    }
+    
+    Value Object::getDefaultedAttr(const string& key, Value defaultValue) const {
+        if (Value v = getAttr(key))
+            return v;
+        else
+            return defaultValue;
+    }
+    
+    Value Object::getValue(const string& key) const {
+        return getAttr(key);       // TODO write template method
+    }
+    
+    Value Object::getDefaultValue(const string &key) const {
+        return Value(Value::DEFAULT);
+    }
+    
+    void Object::performAction (const Value& val) {
+        TokenList targets = getAttr("target");
+        TokenList actions = getAttr("action");
+        if (Value state = getAttr("state")) {
+            int s = state;
+            if (Value stateTargets = getAttr(ecl::strf("target_%d", s)))
+                targets = stateTargets;
+            if (Value actionTargets = getAttr(ecl::strf("action_%d", s)))
+                actions = actionTargets;
+        }
+        
+        TokenList::iterator ait = actions.begin();
+        std::string action;  // empty string as default
+        for (TokenList::iterator tit = targets.begin(); tit != targets.end(); ++tit) {
+            action = (ait != actions.end()) ? ait->to_string() : "";
+            
+            ObjectList ol = *tit;  // get all objects described by target token
+            if (ol.size() == 0 || (ol.size() == 1 && ol.front() == NULL)) {  // no target object
+                if ((action == "callback" || action == "") && (tit->getType() == Value::STRING) 
+                        && lua::IsFunc(lua::LevelState(), tit->get_string())) {
+                    // it is an existing callback function
+                    if (lua::CallFunc(lua::LevelState(), tit->get_string(), val, this) != lua::NO_LUAERROR) {
+                        throw XLevelRuntime(string("callback '") + tit->get_string() + "' failed:\n"+lua::LastError(lua::LevelState()));
+                    }
+                }
+                // else ignore this no longer valid target
+    //            Log << "PerformAction target not valid\n";
+            } else {
+                // send message to all objects
+                if (action == "") 
+                    action = "toggle";
+                for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
+                    if (*oit != NULL) {
+                        SendMessage(*oit, Message(action, val, this));                    
+                    }
+                }
+            }
+            
+            if (ait != actions.end()) ++ait;
+        }
+    }
+    
+    /* Send an impulse to position 'dest' into direction dir.  If 'dest'
+       contains a stone, on_impulse() is called for that stone */
+    void Object::send_impulse(const GridPos& dest, Direction dir) 
+    {
+        if (Stone *st = GetStone(dest)) {
+            Impulse impulse(this, dest, dir);
+            st->on_impulse(impulse);
+        }
+    }
+    
+    /* Like variant above, but the _result_ of the impulse is delayed.
+     */
+    
+    void
+    Object::send_impulse(const GridPos& dest, Direction dir, double delay)
+    {
+        if (Stone *st = GetStone(dest)) {
+            addDelayedImpulse(Impulse(this, dest, dir), delay, st);
+        }
+    }
+    
+    void Object::warning(const char *format, ...) const {
+        va_list arg_ptr;
+    
+        va_start(arg_ptr, format);
+    
+        fprintf(stderr, "%p non-grid-\"%s\": ", this, get_kind());
+        vfprintf(stderr, format, arg_ptr);
+        fputc('\n', stderr);
+    
+        va_end(arg_ptr);
+    }
+    
+    Object::ObjectType Object::getObjectType() const {
+        return OTHER;
+    }
+    
+} // namespace enigma


Property changes on: trunk/src/Object.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/Object.hh
===================================================================
--- trunk/src/Object.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/Object.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+#ifndef OBJECT_HH
+#define OBJECT_HH
+
+#include "display.hh"
+#include "ecl_alist.hh"
+#include "Value.hh"
+#include <map>
+
+namespace enigma { 
+
+    using std::string;
+    
+    struct Message;
+    class Value;
+
+    /**
+     *  Object is the base class for all ``objects'' in the world.
+     * The most important facilities this class provides are:
+     *
+     * (1) A way to clone() and dispose() objects.  This is mainly used
+     *     in function MakeObject() to create new objects of a given
+     *     type.
+     * 
+     * (2) A way to pass messages between unrelated objects via message().
+     *     This allows us to send messages to objects from Lua and to
+     *     decouple objects types as much as possible.
+     * 
+     * (3) A way to get and set attributes.  These attributes are quite
+     *     similar to instance variables, but they can be easily modified
+     *     from Lua.  This makes it possible to modify certain object
+     *     parameters (such as the text on a piece of paper or the color
+     *     of an oxyd stone) in level descriptions.
+     * 
+     * The various Object subclasses instances need to register a template
+     * instance for each object name. To avoid the inclusion of every
+     * subclass declaration file into the registry for registry driven forward
+     * initialization we make use of the static file based initialization
+     * that occurs prior to the main application startup. To be independent of
+     * the undefined sequence in which the files are initialized we store the
+     * template instances, object names and id's in function local static caches.
+     * These caches are copied to the final runtime data structures on the main
+     * application startup. We call this feature "boot"-initialization. The macros
+     * BOOT_REGISTER_START and BOOT_REGISTER_END will be used once at the end of
+     * every subclass file. They embrace the BootRegister() function calls that
+     * register the templates.
+     */
+    class Object {
+
+    public:
+        enum ObjectType { 
+            OTHER,
+            STONE,
+            FLOOR,
+            ITEM,
+            ACTOR
+        };
+            
+        Object();
+        Object(const char *kind);
+        Object(const Object &src_obj); 
+        virtual ~Object();
+
+        static Object * getObject(int id);
+        int getId() const;
+        
+        /* ---------- Attributes ---------- */
+
+        typedef ecl::AssocList<std::string, Value> AttribMap;
+
+        bool is_kind(const char *kind) const;
+        bool is_kind(const string& kind) const;
+
+        const AttribMap &get_attribs() const { return attribs; }
+        
+        /**
+         * Get an attribute or a special given default value. This method
+         * gets attributes like the simple argumented getAttr method but
+         * returns the given default value instead of a DEFAULT value if
+         * no explicit attribute exists.
+         */
+        Value getDefaultedAttr(const string &key, Value defaultValue) const;
+
+
+        /* ---------- Helper routines ---------- */
+
+        void send_impulse(const GridPos& dest, Direction dir);
+        void send_impulse(const GridPos& dest, Direction dir, double delay);
+
+        /* ---------- Object interface ---------- */
+
+        virtual const char *get_kind() const;
+
+        /**
+         * 
+         */
+        virtual Value message(const Message &m);
+        
+        virtual void set_attrib(const string& key, const Value &val);
+        
+        /**
+         * Get an attribute that has been set or that stands as a proxy for a
+         * trait or ivar. Object itself will just return attribute values
+         * that are stored in its attribute map. For not existing attributes
+         * a value of type DEFAULT is returned.
+         * 
+         * Subclasses may override this method to supply values of traits or
+         * ivars. This way levels can gain read access to attributes that can
+         * not to be stored in the attribute map due to performance reasons.
+         */
+        virtual Value getAttr(const string &key) const;
+        
+        /**
+         * Get the attribute, traits, ivar or default value for a given key.
+         * This is the main access method for object values that returns
+         * the best available value known for a key. It resolves attributes,
+         * uses proxy values for ivars and traits, uses class defaults,
+         * world defaults or system defaults.
+         * 
+         * This is a template method. Subclass have to override the method
+         * <code>getDefaultValue()</code> to supply proper class defaults.
+         * All other defaults are resolved by this method
+         */
+        Value getValue(const string &key) const;
+
+        virtual Object *clone()=0;
+        virtual void dispose()=0;
+
+        virtual void on_levelinit();
+
+        virtual void warning(const char *format, ...) const;
+        virtual ObjectType getObjectType() const;
+
+    protected:
+        virtual Value getDefaultValue(const string &key) const;
+        /** This function is used by all triggers, switches etc. that
+         * perform some particular action when activated (like opening
+         * doors or switching lasers on and off). It interprets the
+         * "action" and "target" attributes of `o'. 
+         */
+        void performAction(const Value& val);
+    private:
+        friend void InitWorld();   // for bootFinished() access
+        
+        static int next_id;
+        static std::map<int, Object *> objects;
+        int id;
+        AttribMap attribs;
+        static int getNextId(Object *obj, bool bootFinished);
+        static void bootFinished();
+        static void freeId(int id);
+        const Value* get_attrib(const string& key) const;
+    };
+
+
+} // namespace enigma
+
+
+#define BOOT_REGISTER_START        \
+        namespace {                \
+            bool do_boot_register() {
+
+#define BOOT_REGISTER_END          \
+                return true;       \
+            }                      \
+            static bool boot_registered = do_boot_register(); \
+        } 
+
+#define CLONEOBJ(TYPE)                                  \
+        TYPE* clone() { return new TYPE(*this); }       \
+        void dispose() { delete this; }
+
+#define CLONEACTOR(TYPE)                                                \
+        TYPE* clone() { TYPE *o=new TYPE(*this); o->init(); return o; } \
+        void dispose() { delete this; }
+
+#define INSTANCELISTOBJ(TYPE)                                                   \
+        typedef std::vector<TYPE*> InstanceList;                                \
+        static InstanceList instances;                                          \
+        TYPE *clone() { TYPE *o = new TYPE(*this); instances.push_back(o); return o;}  \
+        void dispose() {                                                        \
+            instances.erase(find(instances.begin(), instances.end(), this));    \
+            delete this;                                                        \
+        }
+
+#endif


Property changes on: trunk/src/Object.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/Value.cc
===================================================================
--- trunk/src/Value.cc	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/Value.cc	2007-12-28 20:48:38 UTC (rev 956)
@@ -0,0 +1,434 @@
+/*
+ * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include "Value.hh"
+
+#include "errors.hh"
+#include "enigma.hh"
+#include "ecl.hh"
+#include "main.hh"
+#include "Object.hh"
+#include "world.hh"
+
+#include <set>
+#include <vector>
+
+using namespace std;
+using namespace ecl;
+
+namespace enigma {
+    
+/* -------------------- Value implementation -------------------- */
+
+    Value::Value() : type (NIL) {
+    }
+    
+    Value::Value(const char* str) : type (STRING) {
+        val.str = new char[strlen(str)+1];
+        strcpy(val.str, str);
+    }
+    
+    Value::Value(double d) : type (DOUBLE) {
+         val.dval[0] = d;
+    }
+    
+    Value::Value(int i) : type (DOUBLE) {
+         val.dval[0] = i;
+    }
+    
+    Value::Value(bool b) : type (BOOL) {
+         val.dval[0] = b;
+    }
+    
+    Value::Value(Object *obj) : type (OBJECT) {
+         if (obj != NULL)
+             val.dval[0] = obj->getId();
+         else
+             val.dval[0] = 0;
+    }
+    
+    Value::Value(ObjectList aList) : type (GROUP) {
+        std::string descriptor;
+        ObjectList::iterator it;
+        for (it = aList.begin(); it != aList.end(); ++it) {
+            if (*it == NULL)
+                descriptor.append("#0,");
+            else {
+                Value v = (*it)->getAttr("name");
+                if (v && v.type == STRING && strcmp(v.val.str, "") != 0) {
+                    descriptor.append(v);
+                    descriptor.append(",");
+                } else {
+                    descriptor.append(ecl::strf("#%d,", (*it)->getId()));
+                }   
+            }
+        }
+        val.str =  new char[descriptor.size() + 1];
+        strcpy(val.str, descriptor.c_str());
+    //    Log << "Value ObjectList '" << descriptor << "'\n";
+    }
+    
+    Value::Value(TokenList aList) : type (TOKENS) {
+        std::string descriptor;
+        TokenList::iterator it;
+        for (it = aList.begin(); it != aList.end(); ++it) {
+            switch ((*it).type) {
+                case STRING :
+                    ASSERT((*it).val.str[0] != 0, XLevelRuntime, "TokenList: illegal empty string value");                
+                    descriptor.append((*it).val.str);
+                    break;
+                case OBJECT :
+                    descriptor.append(ecl::strf("#%d", (int)((*it).val.dval[0])));
+                    break;
+                case GROUP :
+                    descriptor.append("%");
+                    descriptor.append((*it).val.str);
+                    break;
+                default :
+                    ASSERT(false, XLevelRuntime, "TokenList: illegal value type");
+                    break;
+            }
+            descriptor.append(";");
+        }
+        val.str =  new char[descriptor.size() + 1];
+        strcpy(val.str, descriptor.c_str());
+     
+    //    Log << "Value TokenList '" << descriptor << "'\n";
+    }
+    
+    Value::Value(ecl::V2 pos) : type (POSITION) {
+         val.dval[0] = pos[0];
+         val.dval[1] = pos[1];
+    }
+    
+    Value::Value(GridPos gpos) : type (POSITION) {
+         val.dval[0] = gpos.x;
+         val.dval[1] = gpos.y;
+    }
+    
+    Value::Value(Type t) : type (t) {
+        switch (t) {
+            case POSITION :
+                val.dval[1] = 0;
+                // fall thorough
+            case DOUBLE :
+                val.dval[0] = 0;
+                break;
+            case STRING :
+            case GROUP :
+            case TOKENS :
+                val.str = new char[1];
+                val.str[0] = 0;
+                break;
+            case BOOL :
+                val.dval[0] = false;
+                break;
+            case OBJECT :
+                val.dval[0] = (double) NULL;
+                break;
+        }
+    }
+    
+    Value::~Value() { 
+        clear(); 
+    }
+    
+    
+    Value::Value(const string& str) : type(STRING) {
+        val.str = new char[str.length()+1];
+        strcpy(val.str, str.c_str());
+    }
+    
+    Value::Value (const Value& other) : type(NIL) {
+        this->operator=(other);
+    }
+    
+    Value& Value::operator= (const Value& other) {
+        if (this != &other) {
+            switch (other.type) {
+                case STRING:
+                    assign(other.val.str);
+                    break;
+                case GROUP:
+                    assign(other.val.str);
+                    type = GROUP;
+                    break;
+                default:
+                    clear();
+                    type = other.type;
+                    val = other.val;
+            }
+        }
+        return *this;
+    }
+    
+    bool Value::operator==(const Value& other) const {
+        if (type != other.type)
+            return false;
+        else
+            switch (type) {
+                case DOUBLE :
+                case BOOL :
+                case OBJECT :
+                    return val.dval[0] == other.val.dval[0];
+                case STRING :
+                case GROUP :
+                case TOKENS :
+                    return strcmp(val.str, other.val.str) == 0;
+                case POSITION :
+                    return (val.dval[0] == other.val.dval[0]) && (val.dval[1] == other.val.dval[1]);
+            }
+        return true;
+    }
+    
+    bool Value::operator!=(const Value& other) const {
+        return ! (*this == other);
+    }
+    
+    bool Value::operator==(int i) const {
+        return (int) *this == i;
+    }
+    
+    bool Value::operator!=(int i) const {
+        return (int) *this != i;
+    }
+    
+    Value::operator bool() const {
+        if (isDefault())
+            return false;
+        else
+            return true;
+    }
+    
+    Value::operator double() const {
+        switch (type) {
+            case DOUBLE: 
+                return val.dval[0];
+            case BOOL: 
+                return (val.dval[0] != 0) ? 1 : 0;
+            case STRING:
+                return atof(val.str);  // TODO use strtod and eval remaining part of string
+            default:
+                return 0.0;
+        }
+    }
+    
+    Value::operator int() const {
+        switch (type) {
+            case DOUBLE:
+                return round_nearest<int>(val.dval[0]);
+            case BOOL: 
+                return (val.dval[0] != 0) ? 1 : 0;
+            case STRING: 
+                return atoi(val.str);  //TODO use strtol and eval remaining part of string
+            default: return 0;
+        }
+    }
+    
+    Value::operator Object *() const {
+        switch (type) {
+            case OBJECT:
+                return Object::getObject(round_nearest<int>(val.dval[0]));
+            case STRING:
+                return GetNamedObject(val.str);            
+            default: 
+                return NULL;
+        }
+    }
+    
+    Value::operator ObjectList() const {
+        ObjectList result;
+        switch (type) {
+            case STRING:
+                if (std::string(val.str).find_first_of("*?") != std::string::npos) {
+                    // wildcards in object name - we need to add all objects
+                    result = GetNamedGroup(val.str);
+                    break;
+                }
+                // else it is a single object name - fall through
+            case OBJECT:
+                result.push_back(*this);
+                break;
+            case GROUP:
+                std::vector<std::string> vs;
+                ecl::split_copy(std::string(val.str), ',', back_inserter(vs));
+                for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
+                    if (it->size() > 0) {
+                        if ((*it)[0] == '#') {
+                            result.push_back(Object::getObject(atoi((*it).c_str() + 1)));
+                        } else {
+                            result.push_back(GetNamedObject(*it));
+                        }
+                    }
+                }
+                break;
+        }
+        return result;
+    }
+    
+    Value::operator TokenList() const {
+        TokenList result;
+        switch (type) {
+            case OBJECT:
+            case STRING:
+            case GROUP:
+                result.push_back(*this);
+                break;
+            case TOKENS:
+                std::vector<std::string> vs;
+                ecl::split_copy(std::string(val.str), ';', back_inserter(vs));
+                for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
+                    if (it->size() > 0) {
+                        if ((*it)[0] == '#') {
+                            // an object id
+                            Value v(OBJECT);
+                            v.val.dval[0] = atoi((*it).c_str() + 1);
+                            result.push_back(v);
+                        } else if ((*it)[0] == '%'){
+                            // a group
+                            Value v(NIL);
+                            v.assign((*it).c_str() + 1);
+                            v.type = GROUP;
+                            result.push_back(v);
+                        } else {
+                            // a string
+                            result.push_back(Value(*it));
+                        }
+                    }
+                }
+                break;
+        }
+        return result;
+    }
+    
+    Value::operator ecl::V2() const {
+        switch (type) {
+            case POSITION: {
+                return ecl::V2(val.dval[0], val.dval[1]);
+            }
+            default:
+                return ecl::V2(0, 0);
+        }
+    }
+    
+    Value::operator GridPos() const {
+        switch (type) {
+            case POSITION:
+                return GridPos(round_down<int>(val.dval[0]), round_down<int>(val.dval[1]));
+            default:
+                return GridPos(0, 0);
+        }
+    }
+    
+    Value::operator const char*() const {
+        static std::string s;
+        switch (type) {
+            case Value::DOUBLE:
+                s = ecl::strf("%g", val.dval[0]);  // need drop of trailing zeros and point for int
+                return s.c_str();
+            case Value::STRING: 
+                return val.str;
+            case Value::NIL:
+            case Value::DEFAULT:
+            default: 
+                s.clear();
+                return s.c_str();
+        }
+    }
+    
+    void Value::assign(const char* s) {
+        clear();
+        type = STRING;
+        val.str = new char[strlen(s)+1];
+        strcpy(val.str, s);
+    }
+    
+    void Value::assign(double d) { 
+        clear(); type=DOUBLE; val.dval[0]=d; 
+    }
+    
+    void Value::clear() {
+        switch (type) {
+            case STRING:
+            case GROUP:
+               delete[] val.str;
+               break;
+        }
+        type = NIL;
+    }
+    
+    Value::Type Value::getType() const {
+        return type;
+    }
+    
+    double Value::get_double() const throw(){
+        ASSERT(type == DOUBLE, XLevelRuntime, "get_double: type not double");
+        return val.dval[0];
+    }
+    
+    const char* Value::get_string() const throw() {
+        ASSERT(type == STRING, XLevelRuntime, "get_string: type not string");
+        return val.str;
+    }
+    
+    bool Value::isDefault() const {
+        return type == DEFAULT;
+    }
+    
+    std::string Value::to_string() const{
+        return std::string(*this);
+    }
+    
+    bool Value::to_bool() const {
+        switch (type) {
+            case BOOL :
+            case DOUBLE :
+                return val.dval[0] != 0;
+            case NIL :
+            case DEFAULT :
+                return false;
+            default :
+                return true;
+        }
+    }
+    
+    
+    int to_int(const Value &v) {
+        return v;
+    }
+    
+    bool to_bool(const Value &v) {
+        return v.to_bool();
+    }
+    
+    double to_double(const Value &v) {
+        return v;
+    }
+    
+    std::string to_string(const Value &v) {
+        return v.to_string();
+    }
+    
+    Direction to_direction (const Value &v) {
+        int val = Clamp(to_int(v), 0, 3);
+        return static_cast<Direction>(val);
+    }
+    
+} // namespace enigma


Property changes on: trunk/src/Value.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/Value.hh
===================================================================
--- trunk/src/Value.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/Value.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2002,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+#ifndef VALUE_HH
+#define VALUE_HH
+
+/*
+ * This file contains declarations for facilities used by several
+ * different parts of the program, like common types and constants,
+ * and routines for resource management.
+ */
+
+#include "enigma.hh"
+
+namespace enigma { 
+
+    class Object;
+    class Value;
+   
+    typedef std::list<Object *> ObjectList;
+    typedef std::list<Value> TokenList;
+
+    /**
+     * A flexible container for various types of data. This class is one
+     * of the central Enigma concepts. It is used for Object attributes,
+     * for passing arguments and return values in messages and for exchanging
+     * values with LUA code.
+     * 
+     * Object attributes besides the common floor, item, stone, actor traits
+     * are usually very specific and only few objects will be aware of
+     * them. The Value provides a common container, that allows all objects
+     * and the world to pass these attributes without any further knowledge.
+     * 
+     * Instances of Value can be passed to and from the type free LUA language.
+     * Objects can be configured in their attributes and questioned about states
+     * via attributes.
+     * 
+     * Value are converted to required types as far as possible and in a
+     * LUA compatible manner.
+     * 
+     * Bool Values can not be assigned directly to a bool variable. Use the
+     * to_bool() method for retrieving proper bool values.
+     * 
+     * A special Value type called "DEFAULT" exists within the C++ engine. It
+     * describes a not explicitly set Value. The receiver of this Value should use
+     * or request the default behaviour. "DEFAULT" Values are the only Values
+     * that are converted to bool "false". All other Values convert to bool 
+     * "true". Thus a value can be checked for existance by evaluating it as a
+     * bool. This remains true even for Values that contain bool content! A
+     * common pattern for handling Values is:
+     * 
+     * <pre>
+     * if (Value v = getAttr("key")) {   // proceed only if attribute exists
+     *     int i = v;                    // assign value to an int
+     *     std::string s(v);             // create a string out of a value
+     *     x = (double)v * 2;            // cast v to a desired type
+     *     double d = getAttr("x", 2);   // get a value with a default of 2.0
+     * }
+     * </pre>
+     */
+    class Value {
+    public:
+        /**
+         * Specifier for the current type of the value content.
+         */
+        enum Type { 
+            DEFAULT,  ///< Pseudotype for a not existing attribute that should
+                      ///< cause the default behaviour of the object
+            NIL,      ///< Value that is equivalent to Lua "nil". It represents
+                      ///< an invalid value
+            BOOL,     ///< Value that represents bool values "true" and "false".
+            DOUBLE,   ///< Value is numerical and can take a "double". It is used
+                      ///< for other numericals values like "int", too.
+            STRING,   ///< Value is a string. Such a string may encode another
+                      ///< type that has no native representation in Value
+            OBJECT,   ///< Value is an object id. The id is a persistent object
+                      ///< identifier.
+            GROUP,    ///< Value is a group of objects.
+            POSITION, ///< Value is a position
+            TOKENS    ///< Value is a list of token values
+        };
+
+        Value();                       ///< Constructor for NIL value that 
+                                       ///< represents an invalid value
+        Value(double d);               ///< Constructor for DOUBLE value
+        Value(const char* str);        ///< Constructor for STRING value. The
+                                       ///< given string is duplicated
+        Value(const std::string& str); ///< Constructor for STRING value. The
+                                       ///< given string is duplicated
+        Value(int i);                  ///< Constructor for DOUBLE value
+        Value(bool b);                 ///< Constructor for BOOL value
+        Value(Object *obj);            ///< Constructor for OBJECT value that properly
+                                       ///< represents a persistent reference to an object
+        Value(ObjectList aList);       ///< Constructor for OBJECT value that properly
+                                       ///< represents a set of objects
+        Value(TokenList aList);        ///< Constructor for TOKENS value that properly
+                                       ///< represents a list of tokens
+        Value(ecl::V2 pos);            ///< Constructor for POSITION value
+        Value(GridPos gpos);           ///< Constructor for POSITION value
+        Value(Type t);                 ///< Constructor for a given type. The
+                                       ///< value defaults to 0.0 or ""
+        ~Value();
+
+        Value(const Value& v);                 ///< Explicit copy constructor that
+                                               ///< performs a deep copy
+        Value& operator=(const Value& v);      ///< Explicit copy assignment that
+                                               ///< performs a deep copy
+        /**
+         * Compare values in type and value. This compare is a LUA like
+         * compare of values. Note that a DOUBLE value of 1.0 does not equal
+         * a STRING value of "1.0" even though both values are seamless casted
+         * to the same double and result in the same numerical calculation results.
+         * 
+         * If you want to compare two values that express numerical data independent
+         * of their value type use the pattern:
+         * <pre>
+         *     (double) value1 == (double) value2
+         * </pre>
+         */
+        bool operator==(const Value& v) const;
+        bool operator!=(const Value& v) const; ///< Compare values in type and value
+        bool operator==(int i) const;          ///< Compare value with int without casting.
+                                               ///< f.e <code>if (v == 2)</code>
+        bool operator!=(int i) const;          ///< Compare value with int without casting
+        
+        /**
+         * Test of a value for explicit existence besides a default.
+         * This conversion returns "false" if the value is of type DEFAULT.
+         * This happens when a "getAttr()" call did not find a concrete value.
+         * All other value types that represent explicit given values return "true".
+         * The main usage is the common pattern <code>if (Value v = getAttr("key"))</code>.
+         * 
+         * Note: this conversion does not return the result of a boolean stored
+         * in the value. If a concrete value contains a boolean this test
+         * returns always "true", even if the boolean is "false" and the value
+         * is of type NIL.
+         */
+        operator bool() const;
+        
+        /**
+         * Conversion of a value to a double. String values are interpreted as
+         * a double like it is done by LUA. All other values default to a double
+         * value of 0.0.
+         */
+        operator double() const;
+         
+        /**
+         * Conversion of a value to a int. String values are interpreted as
+         * a int like it is done by LUA. All other values default to a int
+         * value of 0.
+         */
+        operator int() const;
+        
+        /**
+         * Conversion of a value to an object reference. All values besides valid
+         * object values default to a NULL reference.
+         */
+        operator Object *() const;
+        
+        /**
+         * Conversion of a value to an object set.
+         */
+        operator ObjectList() const;
+        
+        /**
+         * Conversion of a value to a list of tokens.
+         */
+        operator TokenList() const;
+        
+        /**
+         * Conversion of a value to a position vector.
+         */
+        operator ecl::V2() const;
+        
+        /**
+         * Conversion of a value to a grid position.
+         */
+        operator GridPos() const;
+        
+        /**
+         * Conversion of a value to a <code>char *</code> just for initialization
+         * of a std::string. Numerical values are converted to a string like it
+         * id done by LUA. All other values default to an empty string.
+         * 
+         * Note that the returned pointer may be volatile and
+         * cannot be used for any further usage besides immediate initialization of
+         * a string object. For all other purposes use the <code>to_string()</code> method to
+         * receive a non-volatile copy of the string.
+         */
+        operator const char*() const;
+
+        void assign(double d);       ///< Reset value to a DOUBLE
+        void assign(const char* s);  ///< Reset value to a STRING with a copy of
+                                     ///< the given string
+
+        Type    getType() const;               ///< Returns the current value type
+        double  get_double() const throw();     ///< Returns the current double value without
+                                                ///< any conversion if it is a DOUBLE.
+                                                ///< On type mismatch a XLevelRuntime is thrown
+        const char* get_string() const throw(); ///< Returns the current string value without
+                                                ///< any conversion if it is a STRING.
+                                                ///< On type mismatch a XLevelRuntime is thrown
+        bool isDefault() const;                 ///< Returns true if type is DEFAULT
+        
+        /**
+         * Returns a std::string with convertion of numerical values. All other
+         * values default to an empty string.
+         */
+        std::string to_string() const;
+        
+        /**
+         * Returns the LUA compatible boolean representation of the value.
+         * <code>false</code> is returned for a NIL value and <code>true</code>
+         * for any other value.
+         */
+        bool to_bool() const;
+    private:
+        void clear();      ///< Release resources and assign type NIL
+
+        // Variables
+        Type type;
+        union {
+            double dval[2];
+            char* str;
+        } val;
+    };
+
+
+    bool        to_bool(const Value &v);        ///< Synonym for v.to_bool()
+    int         to_int(const Value &v);         ///< Synonym for (int)v
+    double      to_double(const Value &v);      ///< Synonym for (double)v
+    std::string to_string(const Value &v);      ///< Synonym for v.to_string()
+    Direction   to_direction (const Value &v);  ///< Casting of value to Direction
+
+} // namespace enigma
+
+#endif


Property changes on: trunk/src/Value.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/WorldProxy.hh
===================================================================
--- trunk/src/WorldProxy.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/WorldProxy.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -19,7 +19,7 @@
 #ifndef WORLDPROXY_HH_INCLUDED
 #define WORLDPROXY_HH_INCLUDED
 
-#include "objects.hh"
+#include "Object.hh"
 
 namespace enigma {
 

Modified: trunk/src/actors.hh
===================================================================
--- trunk/src/actors.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/actors.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -19,7 +19,7 @@
 #ifndef ACTORS_HH_INCLUDED
 #define ACTORS_HH_INCLUDED
 
-#include "objects.hh"
+#include "Object.hh"
 
 namespace enigma {
 

Modified: trunk/src/enigma.cc
===================================================================
--- trunk/src/enigma.cc	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/enigma.cc	2007-12-28 20:48:38 UTC (rev 956)
@@ -22,7 +22,7 @@
 #include "enigma.hh"
 #include "ecl.hh"
 #include "main.hh"
-#include "objects.hh"
+#include "Object.hh"
 #include "server.hh"
 #include "world.hh"
 
@@ -125,402 +125,6 @@
 }
 
 
-/* -------------------- Value implementation -------------------- */
-
-Value::Value() : type (NIL) {
-}
-
-Value::Value(const char* str) : type (STRING) {
-    val.str = new char[strlen(str)+1];
-    strcpy(val.str, str);
-}
-
-Value::Value(double d) : type (DOUBLE) {
-     val.dval[0] = d;
-}
-
-Value::Value(int i) : type (DOUBLE) {
-     val.dval[0] = i;
-}
-
-Value::Value(bool b) : type (BOOL) {
-     val.dval[0] = b;
-}
-
-Value::Value(Object *obj) : type (OBJECT) {
-     if (obj != NULL)
-         val.dval[0] = obj->getId();
-     else
-         val.dval[0] = 0;
-}
-
-Value::Value(ObjectList aList) : type (GROUP) {
-    std::string descriptor;
-    ObjectList::iterator it;
-    for (it = aList.begin(); it != aList.end(); ++it) {
-        if (*it == NULL)
-            descriptor.append("#0,");
-        else {
-            Value v = (*it)->getAttr("name");
-            if (v && v.type == STRING && strcmp(v.val.str, "") != 0) {
-                descriptor.append(v);
-                descriptor.append(",");
-            } else {
-                descriptor.append(ecl::strf("#%d,", (*it)->getId()));
-            }   
-        }
-    }
-    val.str =  new char[descriptor.size() + 1];
-    strcpy(val.str, descriptor.c_str());
-//    Log << "Value ObjectList '" << descriptor << "'\n";
-}
-
-Value::Value(TokenList aList) : type (TOKENS) {
-    std::string descriptor;
-    TokenList::iterator it;
-    for (it = aList.begin(); it != aList.end(); ++it) {
-        switch ((*it).type) {
-            case STRING :
-                ASSERT((*it).val.str[0] != 0, XLevelRuntime, "TokenList: illegal empty string value");                
-                descriptor.append((*it).val.str);
-                break;
-            case OBJECT :
-                descriptor.append(ecl::strf("#%d", (int)((*it).val.dval[0])));
-                break;
-            case GROUP :
-                descriptor.append("%");
-                descriptor.append((*it).val.str);
-                break;
-            default :
-                ASSERT(false, XLevelRuntime, "TokenList: illegal value type");
-                break;
-        }
-        descriptor.append(";");
-    }
-    val.str =  new char[descriptor.size() + 1];
-    strcpy(val.str, descriptor.c_str());
- 
-//    Log << "Value TokenList '" << descriptor << "'\n";
-}
-
-Value::Value(ecl::V2 pos) : type (POSITION) {
-     val.dval[0] = pos[0];
-     val.dval[1] = pos[1];
-}
-
-Value::Value(GridPos gpos) : type (POSITION) {
-     val.dval[0] = gpos.x;
-     val.dval[1] = gpos.y;
-}
-
-Value::Value(Type t) : type (t) {
-    switch (t) {
-        case POSITION :
-            val.dval[1] = 0;
-            // fall thorough
-        case DOUBLE :
-            val.dval[0] = 0;
-            break;
-        case STRING :
-        case GROUP :
-        case TOKENS :
-            val.str = new char[1];
-            val.str[0] = 0;
-            break;
-        case BOOL :
-            val.dval[0] = false;
-            break;
-        case OBJECT :
-            val.dval[0] = (double) NULL;
-            break;
-    }
-}
-
-Value::~Value() { 
-    clear(); 
-}
-
-
-Value::Value(const string& str) : type(STRING) {
-    val.str = new char[str.length()+1];
-    strcpy(val.str, str.c_str());
-}
-
-Value::Value (const Value& other) : type(NIL) {
-    this->operator=(other);
-}
-
-Value& Value::operator= (const Value& other) {
-    if (this != &other) {
-        switch (other.type) {
-            case STRING:
-                assign(other.val.str);
-                break;
-            case GROUP:
-                assign(other.val.str);
-                type = GROUP;
-                break;
-            default:
-                clear();
-                type = other.type;
-                val = other.val;
-        }
-    }
-    return *this;
-}
-
-bool Value::operator==(const Value& other) const {
-    if (type != other.type)
-        return false;
-    else
-        switch (type) {
-            case DOUBLE :
-            case BOOL :
-            case OBJECT :
-                return val.dval[0] == other.val.dval[0];
-            case STRING :
-            case GROUP :
-            case TOKENS :
-                return strcmp(val.str, other.val.str) == 0;
-            case POSITION :
-                return (val.dval[0] == other.val.dval[0]) && (val.dval[1] == other.val.dval[1]);
-        }
-    return true;
-}
-
-bool Value::operator!=(const Value& other) const {
-    return ! (*this == other);
-}
-
-bool Value::operator==(int i) const {
-    return (int) *this == i;
-}
-
-bool Value::operator!=(int i) const {
-    return (int) *this != i;
-}
-
-Value::operator bool() const {
-    if (isDefault())
-        return false;
-    else
-        return true;
-}
-
-Value::operator double() const {
-    switch (type) {
-        case DOUBLE: 
-            return val.dval[0];
-        case BOOL: 
-            return (val.dval[0] != 0) ? 1 : 0;
-        case STRING:
-            return atof(val.str);  // TODO use strtod and eval remaining part of string
-        default:
-            return 0.0;
-    }
-}
-
-Value::operator int() const {
-    switch (type) {
-        case DOUBLE:
-            return round_nearest<int>(val.dval[0]);
-        case BOOL: 
-            return (val.dval[0] != 0) ? 1 : 0;
-        case STRING: 
-            return atoi(val.str);  //TODO use strtol and eval remaining part of string
-        default: return 0;
-    }
-}
-
-Value::operator Object *() const {
-    switch (type) {
-        case OBJECT:
-            return Object::getObject(round_nearest<int>(val.dval[0]));
-        case STRING:
-            return GetNamedObject(val.str);            
-        default: 
-            return NULL;
-    }
-}
-
-Value::operator ObjectList() const {
-    ObjectList result;
-    switch (type) {
-        case STRING:
-            if (std::string(val.str).find_first_of("*?") != std::string::npos) {
-                // wildcards in object name - we need to add all objects
-                result = GetNamedGroup(val.str);
-                break;
-            }
-            // else it is a single object name - fall through
-        case OBJECT:
-            result.push_back(*this);
-            break;
-        case GROUP:
-            std::vector<std::string> vs;
-            ecl::split_copy(std::string(val.str), ',', back_inserter(vs));
-            for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
-                if (it->size() > 0) {
-                    if ((*it)[0] == '#') {
-                        result.push_back(Object::getObject(atoi((*it).c_str() + 1)));
-                    } else {
-                        result.push_back(GetNamedObject(*it));
-                    }
-                }
-            }
-            break;
-    }
-    return result;
-}
-
-Value::operator TokenList() const {
-    TokenList result;
-    switch (type) {
-        case OBJECT:
-        case STRING:
-        case GROUP:
-            result.push_back(*this);
-            break;
-        case TOKENS:
-            std::vector<std::string> vs;
-            ecl::split_copy(std::string(val.str), ';', back_inserter(vs));
-            for (std::vector<std::string>::iterator it = vs.begin(); it != vs.end(); ++it) {
-                if (it->size() > 0) {
-                    if ((*it)[0] == '#') {
-                        // an object id
-                        Value v(OBJECT);
-                        v.val.dval[0] = atoi((*it).c_str() + 1);
-                        result.push_back(v);
-                    } else if ((*it)[0] == '%'){
-                        // a group
-                        Value v(NIL);
-                        v.assign((*it).c_str() + 1);
-                        v.type = GROUP;
-                        result.push_back(v);
-                    } else {
-                        // a string
-                        result.push_back(Value(*it));
-                    }
-                }
-            }
-            break;
-    }
-    return result;
-}
-
-Value::operator ecl::V2() const {
-    switch (type) {
-        case POSITION: {
-            return ecl::V2(val.dval[0], val.dval[1]);
-        }
-        default:
-            return ecl::V2(0, 0);
-    }
-}
-
-Value::operator GridPos() const {
-    switch (type) {
-        case POSITION:
-            return GridPos(round_down<int>(val.dval[0]), round_down<int>(val.dval[1]));
-        default:
-            return GridPos(0, 0);
-    }
-}
-
-Value::operator const char*() const {
-    static std::string s;
-    switch (type) {
-        case Value::DOUBLE:
-            s = ecl::strf("%g", val.dval[0]);  // need drop of trailing zeros and point for int
-            return s.c_str();
-        case Value::STRING: 
-            return val.str;
-        case Value::NIL:
-        case Value::DEFAULT:
-        default: 
-            s.clear();
-            return s.c_str();
-    }
-}
-
-void Value::assign(const char* s) {
-    clear();
-    type = STRING;
-    val.str = new char[strlen(s)+1];
-    strcpy(val.str, s);
-}
-
-void Value::assign(double d) { 
-    clear(); type=DOUBLE; val.dval[0]=d; 
-}
-
-void Value::clear() {
-    switch (type) {
-        case STRING:
-        case GROUP:
-    	   delete[] val.str;
-           break;
-    }
-    type = NIL;
-}
-
-Value::Type Value::getType() const {
-    return type;
-}
-
-double Value::get_double() const throw(){
-    ASSERT(type == DOUBLE, XLevelRuntime, "get_double: type not double");
-    return val.dval[0];
-}
-
-const char* Value::get_string() const throw() {
-    ASSERT(type == STRING, XLevelRuntime, "get_string: type not string");
-    return val.str;
-}
-
-bool Value::isDefault() const {
-    return type == DEFAULT;
-}
-
-std::string Value::to_string() const{
-    return std::string(*this);
-}
-
-bool Value::to_bool() const {
-    switch (type) {
-        case BOOL :
-        case DOUBLE :
-            return val.dval[0] != 0;
-        case NIL :
-        case DEFAULT :
-            return false;
-        default :
-            return true;
-    }
-}
-
-
-int to_int(const Value &v) {
-    return v;
-}
-
-bool to_bool(const Value &v) {
-    return v.to_bool();
-}
-
-double to_double(const Value &v) {
-    return v;
-}
-
-std::string to_string(const Value &v) {
-    return v.to_string();
-}
-
-Direction to_direction (const Value &v) {
-    int val = Clamp(to_int(v), 0, 3);
-    return static_cast<Direction>(val);
-}
-
 /* -------------------- GridPos -------------------- */
 
 GridPos::GridPos(const ecl::V2& p) 

Modified: trunk/src/enigma.hh
===================================================================
--- trunk/src/enigma.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/enigma.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -38,9 +38,6 @@
 #define NUMENTRIES(array) (sizeof(array)/sizeof(*array))
 
 namespace enigma { 
-
-    class Object;
-    class Value;
     
 /* -------------------- Various types -------------------- */
 
@@ -189,224 +186,6 @@
       structures. */
     bool to_gridloc (const char *str, GridLoc &loc);
 
-
-/* -------------------- Value -------------------- */
-
-    typedef std::list<Object *> ObjectList;
-    typedef std::list<Value> TokenList;
-
-    /**
-     * A flexible container for various types of data. This class is one
-     * of the central Enigma concepts. It is used for Object attributes,
-     * for passing arguments and return values in messages and for exchanging
-     * values with LUA code.
-     * 
-     * Object attributes besides the common floor, item, stone, actor traits
-     * are usually very specific and only few objects will be aware of
-     * them. The Value provides a common container, that allows all objects
-     * and the world to pass these attributes without any further knowledge.
-     * 
-     * Instances of Value can be passed to and from the type free LUA language.
-     * Objects can be configured in their attributes and questioned about states
-     * via attributes.
-     * 
-     * Value are converted to required types as far as possible and in a
-     * LUA compatible manner.
-     * 
-     * Bool Values can not be assigned directly to a bool variable. Use the
-     * to_bool() method for retrieving proper bool values.
-     * 
-     * A special Value type called "DEFAULT" exists within the C++ engine. It
-     * describes a not explicitly set Value. The receiver of this Value should use
-     * or request the default behaviour. "DEFAULT" Values are the only Values
-     * that are converted to bool "false". All other Values convert to bool 
-     * "true". Thus a value can be checked for existance by evaluating it as a
-     * bool. This remains true even for Values that contain bool content! A
-     * common pattern for handling Values is:
-     * 
-     * <pre>
-     * if (Value v = getAttr("key")) {   // proceed only if attribute exists
-     *     int i = v;                    // assign value to an int
-     *     std::string s(v);             // create a string out of a value
-     *     x = (double)v * 2;            // cast v to a desired type
-     *     double d = getAttr("x", 2);   // get a value with a default of 2.0
-     * }
-     * </pre>
-     */
-    class Value {
-    public:
-        /**
-         * Specifier for the current type of the value content.
-         */
-        enum Type { 
-            DEFAULT,  ///< Pseudotype for a not existing attribute that should
-                      ///< cause the default behaviour of the object
-            NIL,      ///< Value that is equivalent to Lua "nil". It represents
-                      ///< an invalid value
-            BOOL,     ///< Value that represents bool values "true" and "false".
-            DOUBLE,   ///< Value is numerical and can take a "double". It is used
-                      ///< for other numericals values like "int", too.
-            STRING,   ///< Value is a string. Such a string may encode another
-                      ///< type that has no native representation in Value
-            OBJECT,   ///< Value is an object id. The id is a persistent object
-                      ///< identifier.
-            GROUP,    ///< Value is a group of objects.
-            POSITION, ///< Value is a position
-            TOKENS    ///< Value is a list of token values
-        };
-
-        Value();                       ///< Constructor for NIL value that 
-                                       ///< represents an invalid value
-        Value(double d);               ///< Constructor for DOUBLE value
-        Value(const char* str);        ///< Constructor for STRING value. The
-                                       ///< given string is duplicated
-        Value(const std::string& str); ///< Constructor for STRING value. The
-                                       ///< given string is duplicated
-        Value(int i);                  ///< Constructor for DOUBLE value
-        Value(bool b);                 ///< Constructor for BOOL value
-        Value(Object *obj);            ///< Constructor for OBJECT value that properly
-                                       ///< represents a persistent reference to an object
-        Value(ObjectList aList);       ///< Constructor for OBJECT value that properly
-                                       ///< represents a set of objects
-        Value(TokenList aList);        ///< Constructor for TOKENS value that properly
-                                       ///< represents a list of tokens
-        Value(ecl::V2 pos);            ///< Constructor for POSITION value
-        Value(GridPos gpos);           ///< Constructor for POSITION value
-        Value(Type t);                 ///< Constructor for a given type. The
-                                       ///< value defaults to 0.0 or ""
-        ~Value();
-
-        Value(const Value& v);                 ///< Explicit copy constructor that
-                                               ///< performs a deep copy
-        Value& operator=(const Value& v);      ///< Explicit copy assignment that
-                                               ///< performs a deep copy
-        /**
-         * Compare values in type and value. This compare is a LUA like
-         * compare of values. Note that a DOUBLE value of 1.0 does not equal
-         * a STRING value of "1.0" even though both values are seamless casted
-         * to the same double and result in the same numerical calculation results.
-         * 
-         * If you want to compare two values that express numerical data independent
-         * of their value type use the pattern:
-         * <pre>
-         *     (double) value1 == (double) value2
-         * </pre>
-         */
-        bool operator==(const Value& v) const;
-        bool operator!=(const Value& v) const; ///< Compare values in type and value
-        bool operator==(int i) const;          ///< Compare value with int without casting.
-                                               ///< f.e <code>if (v == 2)</code>
-        bool operator!=(int i) const;          ///< Compare value with int without casting
-        
-        /**
-         * Test of a value for explicit existence besides a default.
-         * This conversion returns "false" if the value is of type DEFAULT.
-         * This happens when a "getAttr()" call did not find a concrete value.
-         * All other value types that represent explicit given values return "true".
-         * The main usage is the common pattern <code>if (Value v = getAttr("key"))</code>.
-         * 
-         * Note: this conversion does not return the result of a boolean stored
-         * in the value. If a concrete value contains a boolean this test
-         * returns always "true", even if the boolean is "false" and the value
-         * is of type NIL.
-         */
-        operator bool() const;
-        
-        /**
-         * Conversion of a value to a double. String values are interpreted as
-         * a double like it is done by LUA. All other values default to a double
-         * value of 0.0.
-         */
-        operator double() const;
-         
-        /**
-         * Conversion of a value to a int. String values are interpreted as
-         * a int like it is done by LUA. All other values default to a int
-         * value of 0.
-         */
-        operator int() const;
-        
-        /**
-         * Conversion of a value to an object reference. All values besides valid
-         * object values default to a NULL reference.
-         */
-        operator Object *() const;
-        
-        /**
-         * Conversion of a value to an object set.
-         */
-        operator ObjectList() const;
-        
-        /**
-         * Conversion of a value to a list of tokens.
-         */
-        operator TokenList() const;
-        
-        /**
-         * Conversion of a value to a position vector.
-         */
-        operator ecl::V2() const;
-        
-        /**
-         * Conversion of a value to a grid position.
-         */
-        operator GridPos() const;
-        
-        /**
-         * Conversion of a value to a <code>char *</code> just for initialization
-         * of a std::string. Numerical values are converted to a string like it
-         * id done by LUA. All other values default to an empty string.
-         * 
-         * Note that the returned pointer may be volatile and
-         * cannot be used for any further usage besides immediate initialization of
-         * a string object. For all other purposes use the <code>to_string()</code> method to
-         * receive a non-volatile copy of the string.
-         */
-        operator const char*() const;
-
-        void assign(double d);       ///< Reset value to a DOUBLE
-        void assign(const char* s);  ///< Reset value to a STRING with a copy of
-                                     ///< the given string
-
-        Type    getType() const;               ///< Returns the current value type
-        double  get_double() const throw();     ///< Returns the current double value without
-                                                ///< any conversion if it is a DOUBLE.
-                                                ///< On type mismatch a XLevelRuntime is thrown
-        const char* get_string() const throw(); ///< Returns the current string value without
-                                                ///< any conversion if it is a STRING.
-                                                ///< On type mismatch a XLevelRuntime is thrown
-        bool isDefault() const;                 ///< Returns true if type is DEFAULT
-        
-        /**
-         * Returns a std::string with convertion of numerical values. All other
-         * values default to an empty string.
-         */
-        std::string to_string() const;
-        
-        /**
-         * Returns the LUA compatible boolean representation of the value.
-         * <code>false</code> is returned for a NIL value and <code>true</code>
-         * for any other value.
-         */
-        bool to_bool() const;
-    private:
-        void clear();      ///< Release resources and assign type NIL
-
-        // Variables
-        Type type;
-        union {
-            double dval[2];
-            char* str;
-        } val;
-    };
-
-
-    bool        to_bool(const Value &v);        ///< Synonym for v.to_bool()
-    int         to_int(const Value &v);         ///< Synonym for (int)v
-    double      to_double(const Value &v);      ///< Synonym for (double)v
-    std::string to_string(const Value &v);      ///< Synonym for v.to_string()
-    Direction   to_direction (const Value &v);  ///< Casting of value to Direction
-
 /* -------------------- Timers -------------------- */
 
     /* Interface for time event handlers. */

Modified: trunk/src/items.hh
===================================================================
--- trunk/src/items.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/items.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -19,7 +19,7 @@
 #ifndef ITEMS_HH_INCLUDED
 #define ITEMS_HH_INCLUDED
 
-#include "objects.hh"
+#include "GridObject.hh"
 
 namespace enigma {
     

Modified: trunk/src/laser.hh
===================================================================
--- trunk/src/laser.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/laser.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -22,7 +22,7 @@
 /* This file contains the declarations for (almost) everything that
    has to do with lasers. */
 
-#include "objects.hh"
+#include "GridObject.hh"
 #include "stones.hh"
 
 namespace enigma {

Modified: trunk/src/lua.hh
===================================================================
--- trunk/src/lua.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/lua.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -21,7 +21,7 @@
 
 #include "enigma.hh"
 #include "ecl_geom.hh"
-#include "objects.hh"
+#include "GridObject.hh"
 #include <map>
 
 #ifdef CXXLUA

Deleted: trunk/src/objects.cc
===================================================================
--- trunk/src/objects.cc	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/objects.cc	2007-12-28 20:48:38 UTC (rev 956)
@@ -1,313 +0,0 @@
-/*
- * Copyright (C) 2002,2003,2004,2005 Daniel Heck
- * Copyright (C) 2007 Ronald Lamprecht
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- */
-
-#include "errors.hh"
-#include "game.hh"
-#include "lua.hh"
-#include "sound.hh"
-#include "world.hh"
-
-#include "ecl_util.hh"
-#include "ecl_dict.hh"
-
-#include <algorithm>
-#include <string>
-#include <cstdlib>
-#include <cstdarg>
-#include <iostream>
-#include <iomanip>
-
-
-using namespace std;
-
-namespace enigma {
-
-// remove comment from define below to switch on verbose messaging
-// note: VERBOSE_MESSAGES is defined in multiple source files!
-// #define VERBOSE_MESSAGES
-
-/* -------------------- Object implementation -------------------- */
-
-int Object::next_id = 1;
-std::map<int, Object *> Object::objects;
-
-int Object::getNextId(Object *obj, bool bootFinished) {
-    static bool isBooting = true;
-    static int nextIdBoot = 1;
-    static std::map<int, Object *> objectsBoot;
-    
-    if (isBooting) {
-        if (bootFinished) {
-            isBooting = false;
-            next_id = nextIdBoot;
-            objects = objectsBoot;
-            return 0;
-        } else {
-            objectsBoot[nextIdBoot] = obj;
-            return nextIdBoot++;
-        }
-    } else {
-        objects[next_id] = obj;
-        return next_id++;
-    }
-}
-
-void Object::bootFinished() {
-    getNextId(NULL, true);
-}
-
-void Object::freeId(int id) {
-    objects.erase(id);
-}
-
-Object * Object::getObject(int id) {
-    std::map<int, Object *>::iterator it = objects.find(id);
-    if (it == objects.end())
-        return NULL;
-    else
-        return it->second;
-}
-
-Object::Object() {
-    id = getNextId(this, false);
-}
-
-Object::Object(const char *kind) {
-    set_attrib("kind", Value(kind));
-    id = getNextId(this, false);
-}
-
-Object::Object(const Object &src_obj) {
-    id = getNextId(this, false);
-    attribs = src_obj.attribs;
-}
-
-Object::~Object() {
-    freeId(id);
-//cerr << "obj del " << id << " - " << this->get_kind() <<"\n";
-}
-
-int Object::getId() const {
-    return id;
-}
-
-Value Object::message(const Message &m) {
-    return Value();
-}
-
-void Object::on_levelinit() {
-}
-
-
-const char * Object::get_kind() const {      // To be made pure virtual
-    const Value *v = get_attrib("kind");
-    ASSERT(v && v->getType() == Value::STRING, XLevelRuntime,
-        "Object: attribute kind is not of type string (found in get_kind)");
-    return v->get_string();
-}
-
-// check kind of object
-// kind_templ may contain wildcards ( ? and * )
-bool Object::is_kind(const char *kind_templ) const {
-    return ecl::string_match(get_kind(), kind_templ);
-}
-
-bool Object::is_kind(const string& kind_templ) const {
-    return ecl::string_match(get_kind(), kind_templ.c_str());
-}
-
-void Object::set_attrib(const string& key, const Value& val) {
-    if (val)         // only set non-default values
-        attribs[key] = val;  //.insert (key, val);
-}
-
-const Value* Object::get_attrib(const string& key) const { // To be delete as soon as
-                                                           // get_kind() has no need of it
-    AttribMap::const_iterator i = attribs.find(key);
-    if (i == attribs.end())
-        return 0;
-    else
-        return &i->second;
-}
-
-Value Object::getAttr(const string& key) const {
-    AttribMap::const_iterator i = attribs.find(key);
-    if (i == attribs.end())
-        return Value(Value::DEFAULT);
-    else
-        return i->second;
-}
-
-Value Object::getDefaultedAttr(const string& key, Value defaultValue) const {
-    if (Value v = getAttr(key))
-        return v;
-    else
-        return defaultValue;
-}
-
-Value Object::getValue(const string& key) const {
-    return getAttr(key);       // TODO write template method
-}
-
-Value Object::getDefaultValue(const string &key) const {
-    return Value(Value::DEFAULT);
-}
-
-void Object::performAction (const Value& val) {
-    TokenList targets = getAttr("target");
-    TokenList actions = getAttr("action");
-    if (Value state = getAttr("state")) {
-        int s = state;
-        if (Value stateTargets = getAttr(ecl::strf("target_%d", s)))
-            targets = stateTargets;
-        if (Value actionTargets = getAttr(ecl::strf("action_%d", s)))
-            actions = actionTargets;
-    }
-    
-    TokenList::iterator ait = actions.begin();
-    std::string action;  // empty string as default
-    for (TokenList::iterator tit = targets.begin(); tit != targets.end(); ++tit) {
-        action = (ait != actions.end()) ? ait->to_string() : "";
-        
-        ObjectList ol = *tit;  // get all objects described by target token
-        if (ol.size() == 0 || (ol.size() == 1 && ol.front() == NULL)) {  // no target object
-            if ((action == "callback" || action == "") && (tit->getType() == Value::STRING) 
-                    && lua::IsFunc(lua::LevelState(), tit->get_string())) {
-                // it is an existing callback function
-                if (lua::CallFunc(lua::LevelState(), tit->get_string(), val, this) != lua::NO_LUAERROR) {
-                    throw XLevelRuntime(string("callback '") + tit->get_string() + "' failed:\n"+lua::LastError(lua::LevelState()));
-                }
-            }
-            // else ignore this no longer valid target
-//            Log << "PerformAction target not valid\n";
-        } else {
-            // send message to all objects
-            if (action == "") 
-                action = "toggle";
-            for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
-                if (*oit != NULL) {
-                    SendMessage(*oit, Message(action, val, this));                    
-                }
-            }
-        }
-        
-        if (ait != actions.end()) ++ait;
-    }
-}
-
-/* Send an impulse to position 'dest' into direction dir.  If 'dest'
-   contains a stone, on_impulse() is called for that stone */
-void Object::send_impulse(const GridPos& dest, Direction dir) 
-{
-    if (Stone *st = GetStone(dest)) {
-        Impulse impulse(this, dest, dir);
-        st->on_impulse(impulse);
-    }
-}
-
-/* Like variant above, but the _result_ of the impulse is delayed.
- */
-
-void
-Object::send_impulse(const GridPos& dest, Direction dir, double delay)
-{
-    if (Stone *st = GetStone(dest)) {
-        addDelayedImpulse(Impulse(this, dest, dir), delay, st);
-    }
-}
-
-void Object::warning(const char *format, ...) const {
-    va_list arg_ptr;
-
-    va_start(arg_ptr, format);
-
-    fprintf(stderr, "%p non-grid-\"%s\": ", this, get_kind());
-    vfprintf(stderr, format, arg_ptr);
-    fputc('\n', stderr);
-
-    va_end(arg_ptr);
-}
-
-Object::ObjectType Object::getObjectType() const {
-    return OTHER;
-}
-/* -------------------- GridObject implementation -------------------- */
-
-void GridObject::setOwner(int player) {
-    ASSERT(pos.x < 0, XLevelRuntime,
-        "GridObject: attempt to add object to owner inventory that is still on grid");
-    pos.x = -1;
-    pos.y = player;
-}
-
-Value GridObject::getOwner() {
-    if (pos.x == -1 && pos.y != -1)
-        return Value(pos.y);
-    else
-        return Value();
-}
-
-void GridObject::setOwnerPos(GridPos po) {
-    ASSERT(pos.x < 0, XLevelRuntime,
-        "GridObject: attempt to add object to owner inventory that is still on grid");
-    if (po.x >= 0) {
-        pos.x = -2 - po.x;
-        pos.y = -2 - po.y;
-    } else {
-        pos.x = po.x;
-        pos.y = po.y;
-    }
-}
-
-GridPos GridObject::getOwnerPos() {
-    if (pos.x <= -2)
-        return GridPos(-2 - pos.x, -2 - pos.y);
-    else 
-        return pos;
-}
-
-display::Model *GridObject::set_anim (const std::string &mname) 
-{
-    set_model (mname);
-    display::Model *m = get_model();
-    m->set_callback(this);
-    return m;
-}
-
-bool GridObject::sound_event (const char *name, double vol)
-{
-    return sound::EmitSoundEvent (name, get_pos().center(), getVolume(name, this, vol));
-}
-
-void GridObject::warning(const char *format, ...) const 
-{
-    va_list        arg_ptr;
-    const GridPos& position = get_pos();
-
-    va_start(arg_ptr, format);
-
-    fprintf(stderr, "%p \"%s\" at %i/%i: ", this, get_kind(), position.x, position.y);
-    vfprintf(stderr, format, arg_ptr);
-    fputc('\n', stderr);
-
-    va_end(arg_ptr);
-}
-
-} // namespace enigma

Deleted: trunk/src/objects.hh
===================================================================
--- trunk/src/objects.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/objects.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -1,301 +0,0 @@
-/*
- * Copyright (C) 2002,2003,2004 Daniel Heck
- * Copyright (C) 2007 Ronald Lamprecht
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- */
-#ifndef OBJECTS_HH
-#define OBJECTS_HH
-
-#define BOOT_REGISTER_START        \
-        namespace {                \
-            bool do_boot_register() {
-
-#define BOOT_REGISTER_END          \
-                return true;       \
-            }                      \
-            static bool boot_registered = do_boot_register(); \
-        } 
-
-#include "display.hh"
-#include "ecl_alist.hh"
-#include <map>
-
-namespace enigma { 
-
-    using std::string;
-    
-    struct Message;
-
-/* -------------------- Objects -------------------- */
-
-    /**
-     *  Object is the base class for all ``objects'' in the world.
-     * The most important facilities this class provides are:
-     *
-     * (1) A way to clone() and dispose() objects.  This is mainly used
-     *     in function MakeObject() to create new objects of a given
-     *     type.
-     * 
-     * (2) A way to pass messages between unrelated objects via message().
-     *     This allows us to send messages to objects from Lua and to
-     *     decouple objects types as much as possible.
-     * 
-     * (3) A way to get and set attributes.  These attributes are quite
-     *     similar to instance variables, but they can be easily modified
-     *     from Lua.  This makes it possible to modify certain object
-     *     parameters (such as the text on a piece of paper or the color
-     *     of an oxyd stone) in level descriptions.
-     * 
-     * The various Object subclasses instances need to register a template
-     * instance for each object name. To avoid the inclusion of every
-     * subclass declaration file into the registry for registry driven forward
-     * initialization we make use of the static file based initialization
-     * that occurs prior to the main application startup. To be independent of
-     * the undefined sequence in which the files are initialized we store the
-     * template instances, object names and id's in function local static caches.
-     * These caches are copied to the final runtime data structures on the main
-     * application startup. We call this feature "boot"-initialization. The macros
-     * BOOT_REGISTER_START and BOOT_REGISTER_END will be used once at the end of
-     * every subclass file. They embrace the BootRegister() function calls that
-     * register the templates.
-     */
-    class Object {
-
-    public:
-        enum ObjectType { 
-            OTHER,
-            STONE,
-            FLOOR,
-            ITEM,
-            ACTOR
-        };
-            
-        Object();
-        Object(const char *kind);
-        Object(const Object &src_obj); 
-        virtual ~Object();
-
-        static Object * getObject(int id);
-        int getId() const;
-        
-        /* ---------- Attributes ---------- */
-
-        typedef ecl::AssocList<std::string, Value> AttribMap;
-
-        bool is_kind(const char *kind) const;
-        bool is_kind(const string& kind) const;
-
-        const AttribMap &get_attribs() const { return attribs; }
-        
-        /**
-         * Get an attribute or a special given default value. This method
-         * gets attributes like the simple argumented getAttr method but
-         * returns the given default value instead of a DEFAULT value if
-         * no explicit attribute exists.
-         */
-        Value getDefaultedAttr(const string &key, Value defaultValue) const;
-
-
-        /* ---------- Helper routines ---------- */
-
-        void send_impulse(const GridPos& dest, Direction dir);
-        void send_impulse(const GridPos& dest, Direction dir, double delay);
-
-        /* ---------- Object interface ---------- */
-
-        virtual const char *get_kind() const;
-
-        /**
-         * 
-         */
-        virtual Value message(const Message &m);
-        
-        virtual void set_attrib(const string& key, const Value &val);
-        
-        /**
-         * Get an attribute that has been set or that stands as a proxy for a
-         * trait or ivar. Object itself will just return attribute values
-         * that are stored in its attribute map. For not existing attributes
-         * a value of type DEFAULT is returned.
-         * 
-         * Subclasses may override this method to supply values of traits or
-         * ivars. This way levels can gain read access to attributes that can
-         * not to be stored in the attribute map due to performance reasons.
-         */
-        virtual Value getAttr(const string &key) const;
-        
-        /**
-         * Get the attribute, traits, ivar or default value for a given key.
-         * This is the main access method for object values that returns
-         * the best available value known for a key. It resolves attributes,
-         * uses proxy values for ivars and traits, uses class defaults,
-         * world defaults or system defaults.
-         * 
-         * This is a template method. Subclass have to override the method
-         * <code>getDefaultValue()</code> to supply proper class defaults.
-         * All other defaults are resolved by this method
-         */
-        Value getValue(const string &key) const;
-
-        virtual Object *clone()=0;
-        virtual void dispose()=0;
-
-        virtual void on_levelinit();
-
-        virtual void warning(const char *format, ...) const;
-        virtual ObjectType getObjectType() const;
-
-    protected:
-        virtual Value getDefaultValue(const string &key) const;
-        /** This function is used by all triggers, switches etc. that
-         * perform some particular action when activated (like opening
-         * doors or switching lasers on and off). It interprets the
-         * "action" and "target" attributes of `o'. 
-         */
-        void performAction(const Value& val);
-    private:
-        friend void InitWorld();   // for bootFinished() access
-        
-        static int next_id;
-        static std::map<int, Object *> objects;
-        int id;
-        AttribMap attribs;
-        static int getNextId(Object *obj, bool bootFinished);
-        static void bootFinished();
-        static void freeId(int id);
-        const Value* get_attrib(const string& key) const;
-    };
-
-/* -------------------- GridObject -------------------- */
-    class Actor;
-
-    /** 
-     * GridObject is the base class for everything that can only be
-     * placed on "The Grid", i.e., for floor tiles, items, and
-     * stones. 
-     */
-    class GridObject : public Object, public display::ModelCallback {
-    public:
-        GridObject() : pos (GridPos(-1, -1)) {}
-        GridObject(const char * kind) : Object(kind), pos (GridPos(-1, -1)) {}
-
-        void creation(GridPos p) {
-            pos = p;
-            on_creation (p);
-        }
-        void removal(GridPos p) { 
-            on_removal(p);
-            pos.x = -1;
-            pos.y = -1;
-        }
-        GridPos get_pos() const {return pos;}
-        
-        virtual void setOwner(int player);
-        
-        /**
-         * Get the player number who is owning the object.
-         * @return  integer value of player number or nil if not owned by a player
-         */
-        Value getOwner();
-        
-        /**
-         * Set the location of the GridObject to a given world or mirrored owner
-         * position.
-         */
-        virtual void setOwnerPos(GridPos po);
-         
-        /**
-         * Get the position of object within the world. Only objects owned by
-         * players will return positions outside of the world. 
-         */
-        GridPos getOwnerPos();
-
-        // GridObject interface
-        virtual void on_laserhit (Direction) {}
-        virtual void actor_enter (Actor *) {}
-        virtual void actor_leave (Actor *) {}
-
-
-        void warning(const char *format, ...) const;
-
-        // Helper functions
-        bool sound_event (const char *name, double vol = 1.0);
-        display::Model *set_anim (const std::string &mname);
-
-    protected:
-        // GridObject interface
-        virtual void set_model (const std::string &mname) = 0;
-        virtual display::Model *get_model () = 0;
-        virtual void kill_model (GridPos p) = 0;
-
-        virtual void init_model() {
-            set_model(get_kind());
-        }
-
-        virtual void on_creation (GridPos) {
-            init_model();
-        }
-
-        virtual void on_removal (GridPos p) {
-            kill_model (p);
-        }
-
-    private:
-        // ModelCallback interface.
-        void animcb() {}
-
-
-        /**
-         * The location of the GridObject. An object that is set on one of the world's
-         * layers will store the x and y coordinates with values greater equal 0. An
-         * object that is not a direct part of the world has a pos.x < 0. Objects that
-         * are owned by other objects that are part of a world layer will store the
-         * position of the owner mirrored at point -1, -1. This results in pos.x <= -2.
-         * All other GridObjects will have pos.x = -1. In this case pos.y >= 0 identifies
-         * the player that owns the object in his inventory. Objects that are neiter set
-         * in the world nor owned by anyone have pos.x = pos.y = -1. 
-         */
-        GridPos pos;
-    };
-
-} // namespace enigma
-
-
-#define CLONEOBJ(TYPE)                                  \
-        TYPE* clone() { return new TYPE(*this); }       \
-        void dispose() { delete this; }
-
-#define CLONEACTOR(TYPE)                                                \
-        TYPE* clone() { TYPE *o=new TYPE(*this); o->init(); return o; } \
-        void dispose() { delete this; }
-
-
-// #define SINGLETONOBJ(TYPE)                    \
-//         TYPE* clone() { return this; }        \
-//         void dispose() {}
-
-
-#define INSTANCELISTOBJ(TYPE)                                                   \
-        typedef std::vector<TYPE*> InstanceList;                                \
-        static InstanceList instances;                                          \
-        TYPE *clone() { TYPE *o = new TYPE(*this); instances.push_back(o); return o;}  \
-        void dispose() {                                                        \
-            instances.erase(find(instances.begin(), instances.end(), this));    \
-            delete this;                                                        \
-        }
-
-#endif

Modified: trunk/src/ox_oxyd1.cc
===================================================================
--- trunk/src/ox_oxyd1.cc	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/ox_oxyd1.cc	2007-12-28 20:48:38 UTC (rev 956)
@@ -32,7 +32,6 @@
 #define ITEMSPEC(i) i
 #define ITEMMAPTYPE ItemID
 
-#include "objects.hh"
 #include "server.hh"
 #include "oxyd_internal.hh"
 

Modified: trunk/src/ox_peroxyd.cc
===================================================================
--- trunk/src/ox_peroxyd.cc	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/ox_peroxyd.cc	2007-12-28 20:48:38 UTC (rev 956)
@@ -33,7 +33,6 @@
 #define ITEMSPEC(i) i
 #define ITEMMAPTYPE enigma::ItemID
 
-#include "objects.hh"
 #include "server.hh"
 #include "oxyd_internal.hh"
 

Modified: trunk/src/player.hh
===================================================================
--- trunk/src/player.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/player.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -27,7 +27,6 @@
  * (currently always 1 or 2).
  */
 
-#include "objects.hh"
 #include "items.hh"
 #include "actors.hh"
 

Modified: trunk/src/stones.hh
===================================================================
--- trunk/src/stones.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/stones.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -19,7 +19,7 @@
 #ifndef STONES_HH_INCLUDED
 #define STONES_HH_INCLUDED
 
-#include "objects.hh"
+#include "GridObject.hh"
 
 namespace enigma {
     

Modified: trunk/src/world.hh
===================================================================
--- trunk/src/world.hh	2007-12-27 21:17:16 UTC (rev 955)
+++ trunk/src/world.hh	2007-12-28 20:48:38 UTC (rev 956)
@@ -20,7 +20,8 @@
 #define WORLD_HH_INCLUDED
 
 #include "enigma.hh"
-#include "objects.hh"
+#include "Object.hh"
+#include "GridObject.hh"
 #include "actors.hh"
 #include "floors.hh"
 #include "items.hh"



From andreasl at mail.berlios.de  Fri Dec 28 22:48:03 2007
From: andreasl at mail.berlios.de (andreasl at BerliOS)
Date: Fri, 28 Dec 2007 22:48:03 +0100
Subject: [Enigma-game-svn] r957 - trunk/src
Message-ID: <200712282148.lBSLm3I0024188@sheep.berlios.de>

Author: andreasl
Date: 2007-12-28 22:48:03 +0100 (Fri, 28 Dec 2007)
New Revision: 957

Modified:
   trunk/src/floors.cc
   trunk/src/floors.hh
Log:
Trunk:
 - Switching the return type of the internal
   methods of fire from "Value" to "bool".


Modified: trunk/src/floors.cc
===================================================================
--- trunk/src/floors.cc	2007-12-28 20:48:38 UTC (rev 956)
+++ trunk/src/floors.cc	2007-12-28 21:48:03 UTC (rev 957)
@@ -212,18 +212,18 @@
     return fire_countdown;
 }
 
-Value Floor::force_fire() {
+bool Floor::force_fire() {
     SetItem(get_pos(), it_burnable_ignited);
     fire_countdown = 0;
-    return Value(1.0);
+    return true;
 }
 
-Value Floor::try_ignite(Direction sourcedir, FloorHeatFlags flhf) {
+bool Floor::try_ignite(Direction sourcedir, FloorHeatFlags flhf) {
     GridPos p = get_pos();
 
     // Don't disturb heating-transformation
     if(heating_animation)
-        return Value();
+        return false;
 
     // No or floating stone -> Burn items and replicate.
     // Movable stone && enigma-mode -> Burn items and replicate.
@@ -236,7 +236,7 @@
         if (st->is_movable())
             no_closing_stone = false;
         else if(!st->is_floating())
-            return Value();
+            return false;
     }
 
     if(server::GameCompatibility == GAMET_ENIGMA) {
@@ -284,10 +284,10 @@
             }
         }
     }
-    return Value();  // meaning: no fire
+    return false;  // meaning: no fire
 }
 
-Value Floor::try_heating(Direction sourcedir, FloorHeatFlags flhf) {
+bool Floor::try_heating(Direction sourcedir, FloorHeatFlags flhf) {
     // First of all: How are we allowed to react at all?
     // There are four branches of heating:
     //
@@ -329,7 +329,7 @@
     if(doIgnite && !reaction_happened)
         return this->try_ignite(sourcedir, flhf);
     // Else: return reaction_happened from item or heat-transform
-    return reaction_happened ? Value(1.0) : Value();
+    return reaction_happened;
 }
 
 bool Floor::on_heattransform(Direction sourcedir, FloorHeatFlags flhf) {
@@ -350,7 +350,7 @@
     }
 }
 
-Value Floor::stop_fire(bool is_message) {
+bool Floor::stop_fire(bool is_message) {
     // stop burning
     //   -> kill burnable-item
     //   -> transform floor?
@@ -364,9 +364,9 @@
         if(Item *it = GetItem(p)) {
             ItemID id = get_id(it);
             if(id != it_burnable_burning && id != it_burnable_ignited)
-                return Value();  // no fire
+                return false;  // no fire
         } else
-            return Value(); // no item == no fire
+            return false; // no item == no fire
 
     KillItem(p);
     fire_countdown = 1;
@@ -375,7 +375,7 @@
     // Remember, at this point "this" may be destroyed.
     if(!GetFloor(p)->has_firetype(flft_noash))
         SetItem(p, it_burnable_ash);
-    return Value(1.0); // fire extinguished  
+    return true; // fire extinguished  
 }
 
 void Floor::on_burnable_animcb(bool justIgnited) {

Modified: trunk/src/floors.hh
===================================================================
--- trunk/src/floors.hh	2007-12-28 20:48:38 UTC (rev 956)
+++ trunk/src/floors.hh	2007-12-28 21:48:03 UTC (rev 957)
@@ -135,10 +135,10 @@
     private:
         virtual void on_actorhit(Actor * /*a*/) {}
         // Fire logic
-        Value try_heating(Direction sourcedir, FloorHeatFlags flhf);
-        Value try_ignite(Direction sourcedir, FloorHeatFlags flhf);
-        Value force_fire();
-        Value stop_fire(bool is_message);
+        bool try_heating(Direction sourcedir, FloorHeatFlags flhf);
+        bool try_ignite(Direction sourcedir, FloorHeatFlags flhf);
+        bool force_fire();
+        bool stop_fire(bool is_message);
 
         // Traits and variables
         FloorTraits traits;



From ral at mail.berlios.de  Fri Dec 28 23:46:53 2007
From: ral at mail.berlios.de (ral at BerliOS)
Date: Fri, 28 Dec 2007 23:46:53 +0100
Subject: [Enigma-game-svn] r958 - trunk/src
Message-ID: <200712282246.lBSMkrtL028824@sheep.berlios.de>

Author: ral
Date: 2007-12-28 23:46:53 +0100 (Fri, 28 Dec 2007)
New Revision: 958

Modified:
   trunk/src/Object.cc
   trunk/src/st_switches.cc
Log:
Trunk 1.1: reengineering bool attribute "inverse"
- switched "inverse" in engine from 1/0 to true/false
- made "inverse" a general attribute for all objects that return a bool value
  on performAction
- new API "inverse" attribute is a Lua 5.0 boolean
- old API "inverse" attribute is 1/0 int
Note:
- no existing level does use "inverse" attribute


Modified: trunk/src/Object.cc
===================================================================
--- trunk/src/Object.cc	2007-12-28 21:48:03 UTC (rev 957)
+++ trunk/src/Object.cc	2007-12-28 22:46:53 UTC (rev 958)
@@ -22,6 +22,7 @@
 
 #include "errors.hh"
 #include "game.hh"
+#include "main.hh"
 #include "lua.hh"
 #include "sound.hh"
 #include "world.hh"
@@ -172,7 +173,12 @@
         return Value(Value::DEFAULT);
     }
     
-    void Object::performAction (const Value& val) {
+    void Object::performAction(const Value& val) {
+        Value messageValue = val;
+        if (messageValue.getType() == Value::BOOL)   // bool values may be inverted
+            if (getDefaultedAttr("inverse", false).to_bool())
+                messageValue = !messageValue.to_bool();  // invert value
+
         TokenList targets = getAttr("target");
         TokenList actions = getAttr("action");
         if (Value state = getAttr("state")) {
@@ -193,7 +199,7 @@
                 if ((action == "callback" || action == "") && (tit->getType() == Value::STRING) 
                         && lua::IsFunc(lua::LevelState(), tit->get_string())) {
                     // it is an existing callback function
-                    if (lua::CallFunc(lua::LevelState(), tit->get_string(), val, this) != lua::NO_LUAERROR) {
+                    if (lua::CallFunc(lua::LevelState(), tit->get_string(), messageValue, this) != lua::NO_LUAERROR) {
                         throw XLevelRuntime(string("callback '") + tit->get_string() + "' failed:\n"+lua::LastError(lua::LevelState()));
                     }
                 }
@@ -205,7 +211,7 @@
                     action = "toggle";
                 for (ObjectList::iterator oit = ol.begin(); oit != ol.end(); ++oit) {
                     if (*oit != NULL) {
-                        SendMessage(*oit, Message(action, val, this));                    
+                        SendMessage(*oit, Message(action, messageValue, this));                    
                     }
                 }
             }

Modified: trunk/src/st_switches.cc
===================================================================
--- trunk/src/st_switches.cc	2007-12-28 21:48:03 UTC (rev 957)
+++ trunk/src/st_switches.cc	2007-12-28 22:46:53 UTC (rev 958)
@@ -459,8 +459,6 @@
         virtual const char *get_inactive_model() const = 0;
         virtual double timer_delay() const;
 
-        bool inverse() { return getAttr("inverse") == 1; }
-
         // Stone interface
         void on_creation (GridPos p);
         void on_removal (GridPos p);
@@ -534,7 +532,7 @@
     if (state == IDLE) {
 //         sound_event ("st-switch");
         set_model(get_active_model());
-        performAction(!inverse());
+        performAction(true);
         if (newstate == TOUCHED) {
             double delay = timer_delay();
             ASSERT(delay>0.0, XLevelRuntime, "LaserTimeSwitchBase: delay non-positive");
@@ -544,7 +542,7 @@
     else if (newstate == IDLE) {
 //         sound_event ("st-switch");
         set_model(get_inactive_model());
-        performAction(inverse());
+        performAction(false);
     }
     else {
         // it's not allowed to switch from LIGHTED to TOUCHED



