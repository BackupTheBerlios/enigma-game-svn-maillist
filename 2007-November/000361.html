<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r929 - in trunk/src: . stones
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r929%20-%20in%20trunk/src%3A%20.%20stones&In-Reply-To=%3C200711272308.lARN8Kse016716%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000360.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r929 - in trunk/src: . stones</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r929%20-%20in%20trunk/src%3A%20.%20stones&In-Reply-To=%3C200711272308.lARN8Kse016716%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r929 - in trunk/src: . stones">ral at mail.berlios.de
       </A><BR>
    <I>Wed Nov 28 00:08:20 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000360.html">[Enigma-game-svn] r928 - homepage/input/news
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#361">[ date ]</a>
              <a href="thread.html#361">[ thread ]</a>
              <a href="subject.html#361">[ subject ]</a>
              <a href="author.html#361">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2007-11-28 00:08:19 +0100 (Wed, 28 Nov 2007)
New Revision: 929

Removed:
   trunk/src/objects_decl.hh
Modified:
   trunk/src/Makefile.am
   trunk/src/WorldProxy.hh
   trunk/src/actors.hh
   trunk/src/enigma.cc
   trunk/src/floors.cc
   trunk/src/floors.hh
   trunk/src/items.cc
   trunk/src/items.hh
   trunk/src/laser.hh
   trunk/src/lua.hh
   trunk/src/objects.cc
   trunk/src/objects.hh
   trunk/src/player.hh
   trunk/src/stones.cc
   trunk/src/stones.hh
   trunk/src/stones/OxydStone.cc
   trunk/src/stones/OxydStone.hh
   trunk/src/stones_complex.cc
   trunk/src/stones_simple.cc
   trunk/src/world.hh
Log:
Trunk 1.1:
- rename Object::getAttr(name, value) to getDefaultedAttr(,) to allow
  overriding of single argument method getAttr(name) in subclasses
- remove objects_decl.hh by copying its content to objects.hh


Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/Makefile.am	2007-11-27 23:08:19 UTC (rev 929)
@@ -84,7 +84,6 @@
 	nls.hh			\
 	objects.cc 		\
 	objects.hh 		\
-	objects_decl.hh 	\
 	oxyd.cc			\
 	oxyd.hh 		\
 	oxyd_internal.hh	\

Modified: trunk/src/WorldProxy.hh
===================================================================
--- trunk/src/WorldProxy.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/WorldProxy.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -19,7 +19,7 @@
 #ifndef WORLDPROXY_HH_INCLUDED
 #define WORLDPROXY_HH_INCLUDED
 
-#include &quot;objects_decl.hh&quot;
+#include &quot;objects.hh&quot;
 
 namespace enigma {
 

Modified: trunk/src/actors.hh
===================================================================
--- trunk/src/actors.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/actors.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -19,7 +19,7 @@
 #ifndef ACTORS_HH_INCLUDED
 #define ACTORS_HH_INCLUDED
 
-#include &quot;objects_decl.hh&quot;
+#include &quot;objects.hh&quot;
 
 namespace enigma {
 

Modified: trunk/src/enigma.cc
===================================================================
--- trunk/src/enigma.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/enigma.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -22,7 +22,7 @@
 #include &quot;enigma.hh&quot;
 #include &quot;ecl.hh&quot;
 #include &quot;main.hh&quot;
-#include &quot;objects_decl.hh&quot;
+#include &quot;objects.hh&quot;
 #include &quot;world.hh&quot;
 
 #include &lt;iostream&gt;

Modified: trunk/src/floors.cc
===================================================================
--- trunk/src/floors.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/floors.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -428,19 +428,19 @@
     // In non-Enigma-modes, without items on them, all floors behave the same:
     switch (selector) {
         case flft_burnable :
-            return getAttr(&quot;burnable&quot;, dflt).to_bool();
+            return getDefaultedAttr(&quot;burnable&quot;, dflt).to_bool();
         case flft_ignitable :
-            return getAttr(&quot;ignitable&quot;, dflt).to_bool();
+            return getDefaultedAttr(&quot;ignitable&quot;, dflt).to_bool();
         case flft_secure :
-            return getAttr(&quot;secure&quot;, dflt).to_bool();
+            return getDefaultedAttr(&quot;secure&quot;, dflt).to_bool();
         case flft_eternal :
-            return getAttr(&quot;eternal&quot;, dflt).to_bool();
+            return getDefaultedAttr(&quot;eternal&quot;, dflt).to_bool();
         case flft_noash :
-            return getAttr(&quot;noash&quot;, dflt).to_bool();
+            return getDefaultedAttr(&quot;noash&quot;, dflt).to_bool();
         case flft_fastfire :
-            return getAttr(&quot;fastfire&quot;, dflt).to_bool();
+            return getDefaultedAttr(&quot;fastfire&quot;, dflt).to_bool();
         case flft_initfire :
-            return getAttr(&quot;initfire&quot;, dflt).to_bool();
+            return getDefaultedAttr(&quot;initfire&quot;, dflt).to_bool();
     }
     return dflt;
 }

Modified: trunk/src/floors.hh
===================================================================
--- trunk/src/floors.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/floors.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -19,6 +19,8 @@
 #ifndef FLOORS_HH_INCLUDED
 #define FLOORS_HH_INCLUDED
 
+#include &quot;items.hh&quot;
+
 namespace enigma {
 
     class Actor;

Modified: trunk/src/items.cc
===================================================================
--- trunk/src/items.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/items.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -1596,8 +1596,8 @@
         }
     private:
         void on_creation (GridPos p) {
-            double range = getAttr(&quot;range&quot;, server::MagnetRange);
-            double strength = getAttr(&quot;strength&quot;, server::MagnetForce);
+            double range = getDefaultedAttr(&quot;range&quot;, server::MagnetRange);
+            double strength = getDefaultedAttr(&quot;strength&quot;, server::MagnetForce);
 
             ff.m_active = is_on();
             ff.set_pos (p);
@@ -1703,10 +1703,10 @@
         void set_forcefield() {
             if (is_on()) {
                 ff.set_pos(get_pos());
-                double range = getAttr(&quot;range&quot;, server::WormholeRange);
+                double range = getDefaultedAttr(&quot;range&quot;, server::WormholeRange);
                 ff.set_range (range);
 
-                double s = getAttr(&quot;strength&quot;, server::WormholeForce);
+                double s = getDefaultedAttr(&quot;strength&quot;, server::WormholeForce);
                 ff.set_strength (s);
 
                 AddForceField(&amp;ff);
@@ -2384,7 +2384,7 @@
 
         bool do_crack() {
             if (!is_fixed()) {
-                double brittleness = getAttr(&quot;brittleness&quot;, server::Brittleness);
+                double brittleness = getDefaultedAttr(&quot;brittleness&quot;, server::Brittleness);
                 double rnd = DoubleRand(0, 1);
                 return rnd &lt; brittleness;
     	    } else
@@ -3577,9 +3577,9 @@
 
         ItemAction activate(Actor *a, GridPos p) {
             // Default values for the rubberband:
-            double strength = getAttr(&quot;strength&quot;, 10.0);
-            double length = getAttr(&quot;length&quot;, 1.0);
-            double minlength = getAttr(&quot;minlength&quot;, 0.0);
+            double strength = getDefaultedAttr(&quot;strength&quot;, 10.0);
+            double length = getDefaultedAttr(&quot;length&quot;, 1.0);
+            double minlength = getDefaultedAttr(&quot;minlength&quot;, 0.0);
 
             RubberBandData rbd;
             rbd.strength = strength;

Modified: trunk/src/items.hh
===================================================================
--- trunk/src/items.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/items.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -19,7 +19,7 @@
 #ifndef ITEMS_HH_INCLUDED
 #define ITEMS_HH_INCLUDED
 
-#include &quot;objects_decl.hh&quot;
+#include &quot;objects.hh&quot;
 
 namespace enigma {
     

Modified: trunk/src/laser.hh
===================================================================
--- trunk/src/laser.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/laser.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -23,6 +23,7 @@
    has to do with lasers. */
 
 #include &quot;objects.hh&quot;
+#include &quot;stones.hh&quot;
 
 namespace enigma {
     /**

Modified: trunk/src/lua.hh
===================================================================
--- trunk/src/lua.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/lua.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -21,7 +21,7 @@
 
 #include &quot;enigma.hh&quot;
 #include &quot;ecl_geom.hh&quot;
-#include &quot;objects_decl.hh&quot;
+#include &quot;objects.hh&quot;
 #include &lt;map&gt;
 
 #ifdef CXXLUA

Modified: trunk/src/objects.cc
===================================================================
--- trunk/src/objects.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/objects.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -160,7 +160,7 @@
         return i-&gt;second;
 }
 
-Value Object::getAttr(const string&amp; key, Value defaultValue) const {
+Value Object::getDefaultedAttr(const string&amp; key, Value defaultValue) const {
     if (Value v = getAttr(key))
         return v;
     else

Modified: trunk/src/objects.hh
===================================================================
--- trunk/src/objects.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/objects.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2007 Ronald Lamprecht
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,11 +20,273 @@
 #ifndef OBJECTS_HH
 #define OBJECTS_HH
 
-#include &quot;objects_decl.hh&quot;
-#include &quot;items.hh&quot;
-#include &quot;floors.hh&quot;
-#include &quot;stones.hh&quot;
-#include &quot;actors.hh&quot;
+#define BOOT_REGISTER_START        \
+        namespace {                \
+            bool do_boot_register() {
 
+#define BOOT_REGISTER_END          \
+                return true;       \
+            }                      \
+            static bool boot_registered = do_boot_register(); \
+        } 
 
+#include &quot;display.hh&quot;
+#include &quot;ecl_alist.hh&quot;
+#include &lt;map&gt;
+
+namespace enigma { 
+
+    using std::string;
+    
+    struct Message;
+
+/* -------------------- Objects -------------------- */
+
+    /**
+     *  Object is the base class for all ``objects'' in the world.
+     * The most important facilities this class provides are:
+     *
+     * (1) A way to clone() and dispose() objects.  This is mainly used
+     *     in function MakeObject() to create new objects of a given
+     *     type.
+     * 
+     * (2) A way to pass messages between unrelated objects via message().
+     *     This allows us to send messages to objects from Lua and to
+     *     decouple objects types as much as possible.
+     * 
+     * (3) A way to get and set attributes.  These attributes are quite
+     *     similar to instance variables, but they can be easily modified
+     *     from Lua.  This makes it possible to modify certain object
+     *     parameters (such as the text on a piece of paper or the color
+     *     of an oxyd stone) in level descriptions.
+     * 
+     * The various Object subclasses instances need to register a template
+     * instance for each object name. To avoid the inclusion of every
+     * subclass declaration file into the registry for registry driven forward
+     * initialization we make use of the static file based initialization
+     * that occurs prior to the main application startup. To be independent of
+     * the undefined sequence in which the files are initialized we store the
+     * template instances, object names and id's in function local static caches.
+     * These caches are copied to the final runtime data structures on the main
+     * application startup. We call this feature &quot;boot&quot;-initialization. The macros
+     * BOOT_REGISTER_START and BOOT_REGISTER_END will be used once at the end of
+     * every subclass file. They embrace the BootRegister() function calls that
+     * register the templates.
+     */
+    class Object {
+
+    public:
+        enum ObjectType { 
+            OTHER,
+            STONE,
+            FLOOR,
+            ITEM,
+            ACTOR
+        };
+            
+        Object();
+        Object(const char *kind);
+        Object(const Object &amp;src_obj); 
+        virtual ~Object();
+
+        static Object * getObject(int id);
+        int getId() const;
+        
+        /* ---------- Attributes ---------- */
+
+        typedef ecl::AssocList&lt;std::string, Value&gt; AttribMap;
+
+        bool is_kind(const char *kind) const;
+        bool is_kind(const string&amp; kind) const;
+
+        const AttribMap &amp;get_attribs() const { return attribs; }
+        
+        /**
+         * Get an attribute or a special given default value. This method
+         * gets attributes like the simple argumented getAttr method but
+         * returns the given default value instead of a DEFAULT value if
+         * no explicit attribute exists.
+         */
+        Value getDefaultedAttr(const string &amp;key, Value defaultValue) const;
+
+
+        /* ---------- Helper routines ---------- */
+
+        void send_impulse(const GridPos&amp; dest, Direction dir);
+        void send_impulse(const GridPos&amp; dest, Direction dir, double delay);
+
+        /* ---------- Object interface ---------- */
+
+        virtual const char *get_kind() const;
+
+        virtual Value on_message (const Message &amp;m);
+        virtual Value message(const string&amp; msg, const Value &amp;val);
+        virtual void set_attrib(const string&amp; key, const Value &amp;val);
+        
+        /**
+         * Get an attribute that has been set or that stands as a proxy for a
+         * trait or ivar. Object itself will just return attribute values
+         * that are stored in its attribute map. For not existing attributes
+         * a value of type DEFAULT is returned.
+         * 
+         * Subclasses may override this method to supply values of traits or
+         * ivars. This way levels can gain read access to attributes that can
+         * not to be stored in the attribute map due to performance reasons.
+         */
+        virtual Value getAttr(const string &amp;key) const;
+        
+        /**
+         * Get the attribute, traits, ivar or default value for a given key.
+         * This is the main access method for object values that returns
+         * the best available value known for a key. It resolves attributes,
+         * uses proxy values for ivars and traits, uses class defaults,
+         * world defaults or system defaults.
+         * 
+         * This is a template method. Subclass have to override the method
+         * &lt;code&gt;getDefaultValue()&lt;/code&gt; to supply proper class defaults.
+         * All other defaults are resolved by this method
+         */
+        Value getValue(const string &amp;key) const;
+
+        virtual Object *clone()=0;
+        virtual void dispose()=0;
+
+        virtual void on_levelinit();
+
+        virtual void warning(const char *format, ...) const;
+        virtual ObjectType getObjectType() const;
+
+    protected:
+        virtual Value getDefaultValue(const string &amp;key) const;
+    private:
+        friend void InitWorld();   // for bootFinished() access
+        
+        static int next_id;
+        static std::map&lt;int, Object *&gt; objects;
+        int id;
+        AttribMap attribs;
+        static int getNextId(Object *obj, bool bootFinished);
+        static void bootFinished();
+        static void freeId(int id);
+        const Value* get_attrib(const string&amp; key) const;
+    };
+
+/* -------------------- GridObject -------------------- */
+    class Actor;
+
+    /** 
+     * GridObject is the base class for everything that can only be
+     * placed on &quot;The Grid&quot;, i.e., for floor tiles, items, and
+     * stones. 
+     */
+    class GridObject : public Object, public display::ModelCallback {
+    public:
+        GridObject() : pos (GridPos(-1, -1)) {}
+        GridObject(const char * kind) : Object(kind), pos (GridPos(-1, -1)) {}
+
+        void creation(GridPos p) {
+            pos = p;
+            on_creation (p);
+        }
+        void removal(GridPos p) { 
+            on_removal(p);
+            pos.x = -1;
+            pos.y = -1;
+        }
+        GridPos get_pos() const {return pos;}
+        
+        virtual void setOwner(int player);
+        
+        /**
+         * Get the player number who is owning the object.
+         * @return  integer value of player number or nil if not owned by a player
+         */
+        Value getOwner();
+        
+        /**
+         * Set the location of the GridObject to a given world or mirrored owner
+         * position.
+         */
+        virtual void setOwnerPos(GridPos po);
+         
+        /**
+         * Get the position of object within the world. Only objects owned by
+         * players will return positions outside of the world. 
+         */
+        GridPos getOwnerPos();
+
+        // GridObject interface
+        virtual void on_laserhit (Direction) {}
+        virtual void actor_enter (Actor *) {}
+        virtual void actor_leave (Actor *) {}
+
+
+        void warning(const char *format, ...) const;
+
+        // Helper functions
+        bool sound_event (const char *name, double vol = 1.0);
+        display::Model *set_anim (const std::string &amp;mname);
+
+    protected:
+        // GridObject interface
+        virtual void set_model (const std::string &amp;mname) = 0;
+        virtual display::Model *get_model () = 0;
+        virtual void kill_model (GridPos p) = 0;
+
+        virtual void init_model() {
+            set_model(get_kind());
+        }
+
+        virtual void on_creation (GridPos) {
+            init_model();
+        }
+
+        virtual void on_removal (GridPos p) {
+            kill_model (p);
+        }
+
+    private:
+        // ModelCallback interface.
+        void animcb() {}
+
+
+        /**
+         * The location of the GridObject. An object that is set on one of the world's
+         * layers will store the x and y coordinates with values greater equal 0. An
+         * object that is not a direct part of the world has a pos.x &lt; 0. Objects that
+         * are owned by other objects that are part of a world layer will store the
+         * position of the owner mirrored at point -1, -1. This results in pos.x &lt;= -2.
+         * All other GridObjects will have pos.x = -1. In this case pos.y &gt;= 0 identifies
+         * the player that owns the object in his inventory. Objects that are neiter set
+         * in the world nor owned by anyone have pos.x = pos.y = -1. 
+         */
+        GridPos pos;
+    };
+
+} // namespace enigma
+
+
+#define CLONEOBJ(TYPE)                                  \
+        TYPE* clone() { return new TYPE(*this); }       \
+        void dispose() { delete this; }
+
+#define CLONEACTOR(TYPE)                                                \
+        TYPE* clone() { TYPE *o=new TYPE(*this); o-&gt;init(); return o; } \
+        void dispose() { delete this; }
+
+
+// #define SINGLETONOBJ(TYPE)                    \
+//         TYPE* clone() { return this; }        \
+//         void dispose() {}
+
+
+#define INSTANCELISTOBJ(TYPE)                                                   \
+        typedef std::vector&lt;TYPE*&gt; InstanceList;                                \
+        static InstanceList instances;                                          \
+        TYPE *clone() { TYPE *o = new TYPE(*this); instances.push_back(o); return o;}  \
+        void dispose() {                                                        \
+            instances.erase(find(instances.begin(), instances.end(), this));    \
+            delete this;                                                        \
+        }
+
 #endif

Deleted: trunk/src/objects_decl.hh
===================================================================
--- trunk/src/objects_decl.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/objects_decl.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -1,292 +0,0 @@
-/*
- * Copyright (C) 2002,2003,2004 Daniel Heck
- * Copyright (C) 2007 Ronald Lamprecht
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- */
-#ifndef OBJECTS_DECL_HH
-#define OBJECTS_DECL_HH
-
-#define BOOT_REGISTER_START        \
-        namespace {                \
-            bool do_boot_register() {
-
-#define BOOT_REGISTER_END          \
-                return true;       \
-            }                      \
-            static bool boot_registered = do_boot_register(); \
-        } 
-
-#include &quot;display.hh&quot;
-#include &quot;ecl_alist.hh&quot;
-#include &lt;map&gt;
-
-namespace enigma { 
-
-    using std::string;
-    
-    struct Message;
-
-/* -------------------- Objects -------------------- */
-
-    /**
-     *  Object is the base class for all ``objects'' in the world.
-     * The most important facilities this class provides are:
-     *
-     * (1) A way to clone() and dispose() objects.  This is mainly used
-     *     in function MakeObject() to create new objects of a given
-     *     type.
-     * 
-     * (2) A way to pass messages between unrelated objects via message().
-     *     This allows us to send messages to objects from Lua and to
-     *     decouple objects types as much as possible.
-     * 
-     * (3) A way to get and set attributes.  These attributes are quite
-     *     similar to instance variables, but they can be easily modified
-     *     from Lua.  This makes it possible to modify certain object
-     *     parameters (such as the text on a piece of paper or the color
-     *     of an oxyd stone) in level descriptions.
-     * 
-     * The various Object subclasses instances need to register a template
-     * instance for each object name. To avoid the inclusion of every
-     * subclass declaration file into the registry for registry driven forward
-     * initialization we make use of the static file based initialization
-     * that occurs prior to the main application startup. To be independent of
-     * the undefined sequence in which the files are initialized we store the
-     * template instances, object names and id's in function local static caches.
-     * These caches are copied to the final runtime data structures on the main
-     * application startup. We call this feature &quot;boot&quot;-initialization. The macros
-     * BOOT_REGISTER_START and BOOT_REGISTER_END will be used once at the end of
-     * every subclass file. They embrace the BootRegister() function calls that
-     * register the templates.
-     */
-    class Object {
-
-    public:
-        enum ObjectType { 
-            OTHER,
-            STONE,
-            FLOOR,
-            ITEM,
-            ACTOR
-        };
-            
-        Object();
-        Object(const char *kind);
-        Object(const Object &amp;src_obj); 
-        virtual ~Object();
-
-        static Object * getObject(int id);
-        int getId() const;
-        
-        /* ---------- Attributes ---------- */
-
-        typedef ecl::AssocList&lt;std::string, Value&gt; AttribMap;
-
-        bool is_kind(const char *kind) const;
-        bool is_kind(const string&amp; kind) const;
-
-        const AttribMap &amp;get_attribs() const { return attribs; }
-        
-        /**
-         * Get an attribute or a special given default value. This method
-         * gets attributes like the simple argumented getAttr method but
-         * returns the given default value instead of a DEFAULT value if
-         * no explicit attribute exists.
-         */
-        Value getAttr(const string &amp;key, Value defaultValue) const;
-
-
-        /* ---------- Helper routines ---------- */
-
-        void send_impulse(const GridPos&amp; dest, Direction dir);
-        void send_impulse(const GridPos&amp; dest, Direction dir, double delay);
-
-        /* ---------- Object interface ---------- */
-
-        virtual const char *get_kind() const;
-
-        virtual Value on_message (const Message &amp;m);
-        virtual Value message(const string&amp; msg, const Value &amp;val);
-        virtual void set_attrib(const string&amp; key, const Value &amp;val);
-        
-        /**
-         * Get an attribute that has been set or that stands as a proxy for a
-         * trait or ivar. Object itself will just return attribute values
-         * that are stored in its attribute map. For not existing attributes
-         * a value of type DEFAULT is returned.
-         * 
-         * Subclasses may override this method to supply values of traits or
-         * ivars. This way levels can gain read access to attributes that can
-         * not to be stored in the attribute map due to performance reasons.
-         */
-        virtual Value getAttr(const string &amp;key) const;
-        
-        /**
-         * Get the attribute, traits, ivar or default value for a given key.
-         * This is the main access method for object values that returns
-         * the best available value known for a key. It resolves attributes,
-         * uses proxy values for ivars and traits, uses class defaults,
-         * world defaults or system defaults.
-         * 
-         * This is a template method. Subclass have to override the method
-         * &lt;code&gt;getDefaultValue()&lt;/code&gt; to supply proper class defaults.
-         * All other defaults are resolved by this method
-         */
-        Value getValue(const string &amp;key) const;
-
-        virtual Object *clone()=0;
-        virtual void dispose()=0;
-
-        virtual void on_levelinit();
-
-        virtual void warning(const char *format, ...) const;
-        virtual ObjectType getObjectType() const;
-
-    protected:
-        virtual Value getDefaultValue(const string &amp;key) const;
-    private:
-        friend void InitWorld();   // for bootFinished() access
-        
-        static int next_id;
-        static std::map&lt;int, Object *&gt; objects;
-        int id;
-        AttribMap attribs;
-        static int getNextId(Object *obj, bool bootFinished);
-        static void bootFinished();
-        static void freeId(int id);
-        const Value* get_attrib(const string&amp; key) const;
-    };
-
-/* -------------------- GridObject -------------------- */
-    class Actor;
-
-    /** 
-     * GridObject is the base class for everything that can only be
-     * placed on &quot;The Grid&quot;, i.e., for floor tiles, items, and
-     * stones. 
-     */
-    class GridObject : public Object, public display::ModelCallback {
-    public:
-        GridObject() : pos (GridPos(-1, -1)) {}
-        GridObject(const char * kind) : Object(kind), pos (GridPos(-1, -1)) {}
-
-        void creation(GridPos p) {
-            pos = p;
-            on_creation (p);
-        }
-        void removal(GridPos p) { 
-            on_removal(p);
-            pos.x = -1;
-            pos.y = -1;
-        }
-        GridPos get_pos() const {return pos;}
-        
-        virtual void setOwner(int player);
-        
-        /**
-         * Get the player number who is owning the object.
-         * @return  integer value of player number or nil if not owned by a player
-         */
-        Value getOwner();
-        
-        /**
-         * Set the location of the GridObject to a given world or mirrored owner
-         * position.
-         */
-        virtual void setOwnerPos(GridPos po);
-         
-        /**
-         * Get the position of object within the world. Only objects owned by
-         * players will return positions outside of the world. 
-         */
-        GridPos getOwnerPos();
-
-        // GridObject interface
-        virtual void on_laserhit (Direction) {}
-        virtual void actor_enter (Actor *) {}
-        virtual void actor_leave (Actor *) {}
-
-
-        void warning(const char *format, ...) const;
-
-        // Helper functions
-        bool sound_event (const char *name, double vol = 1.0);
-        display::Model *set_anim (const std::string &amp;mname);
-
-    protected:
-        // GridObject interface
-        virtual void set_model (const std::string &amp;mname) = 0;
-        virtual display::Model *get_model () = 0;
-        virtual void kill_model (GridPos p) = 0;
-
-        virtual void init_model() {
-            set_model(get_kind());
-        }
-
-        virtual void on_creation (GridPos) {
-            init_model();
-        }
-
-        virtual void on_removal (GridPos p) {
-            kill_model (p);
-        }
-
-    private:
-        // ModelCallback interface.
-        void animcb() {}
-
-
-        /**
-         * The location of the GridObject. An object that is set on one of the world's
-         * layers will store the x and y coordinates with values greater equal 0. An
-         * object that is not a direct part of the world has a pos.x &lt; 0. Objects that
-         * are owned by other objects that are part of a world layer will store the
-         * position of the owner mirrored at point -1, -1. This results in pos.x &lt;= -2.
-         * All other GridObjects will have pos.x = -1. In this case pos.y &gt;= 0 identifies
-         * the player that owns the object in his inventory. Objects that are neiter set
-         * in the world nor owned by anyone have pos.x = pos.y = -1. 
-         */
-        GridPos pos;
-    };
-
-} // namespace enigma
-
-
-#define CLONEOBJ(TYPE)                                  \
-        TYPE* clone() { return new TYPE(*this); }       \
-        void dispose() { delete this; }
-
-#define CLONEACTOR(TYPE)                                                \
-        TYPE* clone() { TYPE *o=new TYPE(*this); o-&gt;init(); return o; } \
-        void dispose() { delete this; }
-
-
-// #define SINGLETONOBJ(TYPE)                    \
-//         TYPE* clone() { return this; }        \
-//         void dispose() {}
-
-
-#define INSTANCELISTOBJ(TYPE)                                                   \
-        typedef std::vector&lt;TYPE*&gt; InstanceList;                                \
-        static InstanceList instances;                                          \
-        TYPE *clone() { TYPE *o = new TYPE(*this); instances.push_back(o); return o;}  \
-        void dispose() {                                                        \
-            instances.erase(find(instances.begin(), instances.end(), this));    \
-            delete this;                                                        \
-        }
-
-#endif

Modified: trunk/src/player.hh
===================================================================
--- trunk/src/player.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/player.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -28,6 +28,8 @@
  */
 
 #include &quot;objects.hh&quot;
+#include &quot;items.hh&quot;
+#include &quot;actors.hh&quot;
 
 namespace enigma
 {

Modified: trunk/src/stones/OxydStone.cc
===================================================================
--- trunk/src/stones/OxydStone.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/stones/OxydStone.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -886,10 +886,10 @@
             set_model(string(&quot;st-oxyd&quot;)+(std::string)val);
     }
     
-//    Value OxydStone::getAttr(const string &amp;key) const {
-//        // TODO &quot;state&quot; 0=CLOSE || CLOSING; 1 = other iState values
-//        return Object::getAttr(key);
-//    }
+    Value OxydStone::getAttr(const string &amp;key) const {
+        // TODO &quot;state&quot; 0=CLOSE || CLOSING; 1 = other iState values
+        return Object::getAttr(key);
+    }
     
     void OxydStone::actor_hit(const StoneContact &amp;/*sc*/) {
         tryOpen();
@@ -911,7 +911,7 @@
     }
     
     void OxydStone::on_creation (GridPos) {
-        string flavor(getAttr(&quot;flavor&quot;, &quot;a&quot;));
+        string flavor(getDefaultedAttr(&quot;flavor&quot;, &quot;a&quot;));
         set_model(string(&quot;st-oxyd&quot;) + flavor);
         photo_activate();
     }
@@ -991,8 +991,8 @@
     }
     
     void OxydStone::set_iState(State newState) {
-        string flavor(getAttr(&quot;flavor&quot;,&quot;a&quot;));
-        string color(getAttr(&quot;color&quot;, 0));
+        string flavor(getDefaultedAttr(&quot;flavor&quot;,&quot;a&quot;));
+        string color(getDefaultedAttr(&quot;color&quot;, 0));
     
         string basemodelname = string(&quot;st-oxyd&quot;) + flavor;
         string modelname = basemodelname + color;

Modified: trunk/src/stones/OxydStone.hh
===================================================================
--- trunk/src/stones/OxydStone.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/stones/OxydStone.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -85,7 +85,7 @@
         virtual void dispose();
         virtual Value message(const string &amp;m, const Value &amp;);
         virtual void set_attrib(const string&amp; key, const Value &amp;val);
-//        virtual Value getAttr(const string &amp;key) const;
+        virtual Value getAttr(const string &amp;key) const;
 
         // Stone interface
         virtual void actor_hit(const StoneContact &amp;sc);

Modified: trunk/src/stones.cc
===================================================================
--- trunk/src/stones.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/stones.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -194,11 +194,11 @@
    default matrix, resp. defaultfactor as hit_factor. */
 ecl::V2 Stone::distortedVelocity (ecl::V2 vel, double defaultfactor = 1.0) {
     ecl::V2 newvel;
-    double factor = this-&gt;getAttr(&quot;hit_factor&quot;, defaultfactor);
-    newvel[0] = (double)(this-&gt;getAttr(&quot;hit_distortion_xx&quot;, 1)) * vel[0]
+    double factor = this-&gt;getDefaultedAttr(&quot;hit_factor&quot;, defaultfactor);
+    newvel[0] = (double)(this-&gt;getDefaultedAttr(&quot;hit_distortion_xx&quot;, 1)) * vel[0]
                 + (double)(this-&gt;getAttr(&quot;hit_distortion_xy&quot;)) * vel[1];
     newvel[1] = (double)(this-&gt;getAttr(&quot;hit_distortion_yx&quot;)) * vel[0]
-                + (double)(this-&gt;getAttr(&quot;hit_distortion_yy&quot;, 1)) * vel[1];
+                + (double)(this-&gt;getDefaultedAttr(&quot;hit_distortion_yy&quot;, 1)) * vel[1];
     return newvel * factor;
 }
 

Modified: trunk/src/stones.hh
===================================================================
--- trunk/src/stones.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/stones.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -19,7 +19,7 @@
 #ifndef STONES_HH_INCLUDED
 #define STONES_HH_INCLUDED
 
-#include &quot;objects_decl.hh&quot;
+#include &quot;objects.hh&quot;
 
 namespace enigma {
     

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/stones_complex.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -1666,7 +1666,7 @@
         virtual string closing_sound() const { return &quot;doorclose&quot;; }
         virtual const char *collision_sound() { return &quot;electric&quot;; }
         string get_type() const {
-            string type(getAttr(&quot;type&quot;, &quot;h&quot;));
+            string type(getDefaultedAttr(&quot;type&quot;, &quot;h&quot;));
             return type;
         }
 
@@ -3057,7 +3057,7 @@
                 the force resulting from floor-&gt;add_force. &quot;baseinterval&quot;
                 is 50 ms or the interval given in &quot;interval&quot;.
             */
-            double base = getAttr(&quot;interval&quot;, 0.05);
+            double base = getDefaultedAttr(&quot;interval&quot;, 0.05);
             if (Value f = getAttr(&quot;friction_factor&quot;))
                 base *= 1.0 + (double)f * GetFloor(get_pos())-&gt;get_friction();
             if (Value g = getAttr(&quot;gradient_factor&quot;))

Modified: trunk/src/stones_simple.cc
===================================================================
--- trunk/src/stones_simple.cc	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/stones_simple.cc	2007-11-27 23:08:19 UTC (rev 929)
@@ -1164,8 +1164,8 @@
         DECL_TRAITS;
 
         void actor_hit(const StoneContact &amp;sc) {
-            double strength = getAttr(&quot;strength&quot;, 10.0);
-            double length = getAttr(&quot;length&quot;, 1.0);
+            double strength = getDefaultedAttr(&quot;strength&quot;, 10.0);
+            double length = getDefaultedAttr(&quot;length&quot;, 1.0);
             double minlength = getAttr(&quot;minlength&quot;);
 
             RubberBandData rbd;
@@ -1175,7 +1175,7 @@
 
             // The mode attribute &quot;scissor&quot; defines, if when touching an st-rubberband,
             // other rubberbands to the actor will be cut of or not, true means they will. true is default.
-            bool isScissor = to_bool(getAttr(&quot;scissor&quot;,&quot;true&quot;));
+            bool isScissor = to_bool(getDefaultedAttr(&quot;scissor&quot;,&quot;true&quot;));
 
             if (!HasRubberBand (sc.actor, this)) {
                 sound_event (&quot;rubberband&quot;);
@@ -1258,7 +1258,7 @@
         int m_signalvalue;
 
         double get_interval() const {
-            return getAttr(&quot;interval&quot;, 100);
+            return getDefaultedAttr(&quot;interval&quot;, 100);
         }
 
         bool get_is_looped() const {
@@ -1450,7 +1450,7 @@
         set_anim(&quot;st-thief-emerge&quot;);
         state = EMERGING;
         m_affected_actor = sc.actor;
-        affected_player = m_affected_actor-&gt;getAttr(&quot;player&quot;, -1);
+        affected_player = m_affected_actor-&gt;getDefaultedAttr(&quot;player&quot;, -1);
     }
 }
 
@@ -1530,7 +1530,7 @@
                 // actor_hit is called before reflect, but the force added below
                 // is applied to actor after the reflection.
 
-                double forcefac = getAttr(&quot;force&quot;, server::BumperForce);
+                double forcefac = getDefaultedAttr(&quot;force&quot;, server::BumperForce);
 
                 V2 vec = normalize(sc.actor-&gt;get_pos() - get_pos().center());
                 sc.actor-&gt;add_force (distortedVelocity(vec, forcefac));                

Modified: trunk/src/world.hh
===================================================================
--- trunk/src/world.hh	2007-11-22 18:49:58 UTC (rev 928)
+++ trunk/src/world.hh	2007-11-27 23:08:19 UTC (rev 929)
@@ -21,6 +21,10 @@
 
 #include &quot;enigma.hh&quot;
 #include &quot;objects.hh&quot;
+#include &quot;actors.hh&quot;
+#include &quot;floors.hh&quot;
+#include &quot;items.hh&quot;
+#include &quot;stones.hh&quot;
 #include &quot;util.hh&quot;
 
 namespace enigma {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000360.html">[Enigma-game-svn] r928 - homepage/input/news
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#361">[ date ]</a>
              <a href="thread.html#361">[ thread ]</a>
              <a href="subject.html#361">[ subject ]</a>
              <a href="author.html#361">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
