<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1327 - in trunk: data data/gfx32 data/gfx40	data/gfx48 src/stones
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1327%20-%20in%20trunk%3A%20data%20data/gfx32%20data/gfx40%0A%09data/gfx48%20src/stones&In-Reply-To=%3C200809150003.m8F037IC018149%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000756.html">
   <LINK REL="Next"  HREF="000758.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1327 - in trunk: data data/gfx32 data/gfx40	data/gfx48 src/stones</H1>
    <B>raoul at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1327%20-%20in%20trunk%3A%20data%20data/gfx32%20data/gfx40%0A%09data/gfx48%20src/stones&In-Reply-To=%3C200809150003.m8F037IC018149%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1327 - in trunk: data data/gfx32 data/gfx40	data/gfx48 src/stones">raoul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 02:03:07 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000756.html">[Enigma-game-svn] r1326 - team_levelpacks/team_test_new_api
</A></li>
        <LI>Next message: <A HREF="000758.html">[Enigma-game-svn] r1328 - feature_branches/hp_lotm/input/lotm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#757">[ date ]</a>
              <a href="thread.html#757">[ thread ]</a>
              <a href="subject.html#757">[ subject ]</a>
              <a href="author.html#757">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: raoul
Date: 2008-09-15 02:02:58 +0200 (Mon, 15 Sep 2008)
New Revision: 1327

Added:
   trunk/data/gfx32/st_puzzle.png
   trunk/data/gfx40/st_puzzle.png
   trunk/data/gfx48/st_puzzle.png
Removed:
   trunk/data/gfx32/it-hstrip.png
   trunk/data/gfx32/it-vstrip.png
   trunk/data/gfx40/it-hstrip.png
   trunk/data/gfx40/it-vstrip.png
   trunk/data/gfx48/it-hstrip.png
   trunk/data/gfx48/it-vstrip.png
   trunk/data/gfx48/st-puzzle.png
Modified:
   trunk/data/models-2d.lua
   trunk/src/stones/PuzzleStone.cc
Log:
-&gt; New gfx for new puzzle pieces
-&gt; Old gfx (st-puzzle.png) for gfx{32,40} not yet removed
-&gt; Removed unused stripitem images



Deleted: trunk/data/gfx32/it-hstrip.png
===================================================================
(Binary files differ)

Deleted: trunk/data/gfx32/it-vstrip.png
===================================================================
(Binary files differ)

Added: trunk/data/gfx32/st_puzzle.png
===================================================================
(Binary files differ)


Property changes on: trunk/data/gfx32/st_puzzle.png
___________________________________________________________________
Name: svn:mime-type
   + image/png

Deleted: trunk/data/gfx40/it-hstrip.png
===================================================================
(Binary files differ)

Deleted: trunk/data/gfx40/it-vstrip.png
===================================================================
(Binary files differ)

Added: trunk/data/gfx40/st_puzzle.png
===================================================================
(Binary files differ)


Property changes on: trunk/data/gfx40/st_puzzle.png
___________________________________________________________________
Name: svn:mime-type
   + image/png

Deleted: trunk/data/gfx48/it-hstrip.png
===================================================================
(Binary files differ)

Deleted: trunk/data/gfx48/it-vstrip.png
===================================================================
(Binary files differ)

Deleted: trunk/data/gfx48/st-puzzle.png
===================================================================
(Binary files differ)

Added: trunk/data/gfx48/st_puzzle.png
===================================================================
(Binary files differ)


Property changes on: trunk/data/gfx48/st_puzzle.png
___________________________________________________________________
Name: svn:mime-type
   + image/png

Modified: trunk/data/models-2d.lua
===================================================================
--- trunk/data/models-2d.lua	2008-09-15 00:01:17 UTC (rev 1326)
+++ trunk/data/models-2d.lua	2008-09-15 00:02:58 UTC (rev 1327)
@@ -1033,11 +1033,11 @@
 
 -- st-puzzle* --
 do
-    DefSubimages(&quot;st-puzzle&quot;, {modelname=&quot;st-puzzlex&quot;,w=8,h=4})
-    for i=2,16  do DefSolidStone(&quot;st-puzzle&quot;..i, &quot;st-puzzlex&quot;..i) end
-    for i=18,32 do DefSolidStone(&quot;st-puzzle&quot;..i, &quot;st-puzzlex&quot;..i) end
-    DefShModel(&quot;st-puzzle1&quot;, &quot;st-puzzlex1&quot;, &quot;sh-puzzle1&quot;)
-    DefShModel(&quot;st-puzzle17&quot;, &quot;st-puzzlex17&quot;, &quot;sh-puzzle1&quot;)
+    DefSubimages(&quot;st_puzzle&quot;, {modelname=&quot;st_puzzlex&quot;,w=16,h=4,startindex=0})
+    -- Full puzzels
+    for i=0,31  do DefSolidStone(&quot;st_puzzle&quot;..i, &quot;st_puzzlex&quot;..i) end
+    -- Hollow puzzels
+    for i=32,63  do DefShModel(&quot;st_puzzle&quot;..i, &quot;st_puzzlex&quot;..i, &quot;sh-puzzle1&quot;) end
 end
 
 -- st-rock3-break --
@@ -1366,7 +1366,7 @@
         local fadein = &quot;oxyd&quot;..flavor..&quot;-fadein&quot;
         local fadeout= &quot;oxyd&quot;..flavor..&quot;-fadeout&quot;
         local spotcolor = color
-        
+
         if (color &gt;= 0) then
             spotcolor = color + 1 -- oxyd color 0..num_colors-1, file 1.., frames 1..
         else

Modified: trunk/src/stones/PuzzleStone.cc
===================================================================
--- trunk/src/stones/PuzzleStone.cc	2008-09-15 00:01:17 UTC (rev 1326)
+++ trunk/src/stones/PuzzleStone.cc	2008-09-15 00:02:58 UTC (rev 1327)
@@ -6,7 +6,7 @@
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- *  
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@@ -31,15 +31,15 @@
         setAttr(&quot;connections&quot;, connections);
         setAttr(&quot;hollow&quot;, hollow);
     }
-    
+
     PuzzleStone::~PuzzleStone() {
         GameTimer.remove_alarm (this);
     }
-    
+
     std::string PuzzleStone::getClass() const {
         return &quot;st_puzzle&quot;;
     }
-    
+
     void PuzzleStone::setAttr(const string&amp; key, const Value &amp;val) {
         if (key == &quot;hollow&quot;) {
             if (val.to_bool() != (bool)(objFlags &amp; OBJBIT_HOLLOW)) {
@@ -72,13 +72,13 @@
             //
             // enigma levels may create scramble messages using
             // AddScramble() and SetScrambleIntensity()
-    
+
             Direction dir = to_direction(m.value);
             PuzzleList c;
             int size = findLine(c, dir, (int)getAttr(&quot;color&quot;));
-    
+
             // warning(&quot;received 'scramble'. dir=%s size=%i&quot;, to_suffix(dir).c_str(), size);
-    
+
             if (size &gt;= 2) {
                 int count = IntegerRand(0, static_cast&lt;int&gt; (size-1));
                 while (count--)
@@ -105,28 +105,22 @@
         }
         return Stone::message(m);
     }
-    
+
     void PuzzleStone::setState(int extState) {
         // block all write attempts
     }
-    
+
     void PuzzleStone::init_model() {
         if (state == EXPLODING) {
             set_anim(&quot;st-explosion&quot;);
             return;
         }
-        int m = getConnections() + 1;
-        if (m == 1)
-            set_model(&quot;st-metal&quot;);
-        else {    
-            if ((objFlags &amp; OBJBIT_HOLLOW) &amp;&amp; m == 16)
-                m = 1;
-            if (getAttr(&quot;color&quot;) == YELLOW)
-                m += 16;
-            set_model(ecl::strf(&quot;st-puzzle%d&quot;, m));
-        }
+        int m = getConnections();
+        if (getAttr(&quot;color&quot;) == YELLOW) { m += 16; }
+        if ((objFlags &amp; OBJBIT_HOLLOW)) { m += 32; }
+        set_model(ecl::strf(&quot;st_puzzle%d&quot;, m));
     }
-    
+
     void PuzzleStone::on_creation(GridPos p) {
         if (!(objFlags &amp; OBJBIT_INIT)) {
             autoJoinCluster();
@@ -135,7 +129,7 @@
         activatePhoto();
         Stone::on_creation(p);
     }
-    
+
     void PuzzleStone::lightDirChanged(DirectionBits oldDirs, DirectionBits newDirs) {
         if (state == IDLE &amp;&amp; !(objFlags &amp; OBJBIT_HOLLOW)) {
             DirectionBits addDirs = added_dirs(oldDirs, newDirs);
@@ -151,15 +145,15 @@
     void PuzzleStone::animcb() {
         KillStone(get_pos());
     }
-    
+
     bool PuzzleStone::is_transparent(Direction d) const {
         return objFlags &amp; OBJBIT_HOLLOW;
     }
-    
+
     bool PuzzleStone::is_sticky(const Actor *a) const {
         return !(objFlags &amp; OBJBIT_HOLLOW);
     }
-    
+
     bool PuzzleStone::allowsSpreading(Direction dir) const {
         return objFlags &amp; OBJBIT_HOLLOW;
     }
@@ -167,11 +161,11 @@
     bool PuzzleStone::is_removable() const {
         return state == IDLE;
     }
-    
+
     bool PuzzleStone::isConnectable(Stone *other) const {
         return Stone::isConnectable(other) &amp;&amp; (other-&gt;getAttr(&quot;color&quot;) == getAttr(&quot;color&quot;));
     }
-    
+
     StoneResponse PuzzleStone::collision_response(const StoneContact &amp;sc) {
         if ((objFlags &amp; OBJBIT_HOLLOW) || state == EXPLODING)
             return STONE_PASS;
@@ -181,17 +175,17 @@
     void PuzzleStone::actor_hit(const StoneContact &amp;sc) {
         if (objFlags &amp; OBJBIT_HOLLOW)
             return;                 // Puzzle stone is hollow
-    
+
         if (state != IDLE)
             return;
-    
+
         Direction rotate_dir = reverse(contact_face(sc));
         Direction move_dir = get_push_direction(sc);
-    
+
         if (getAttr(&quot;color&quot;) == YELLOW) {
             if (explodeCluster())
                 return;
-    
+
             // 1) If unconnected puzzle stones -&gt; try to move it
             if ((objFlags &amp; OBJBIT_SINGLE) &amp;&amp; move_dir != NODIR) {
                 // if cluster contains single stone
@@ -204,75 +198,75 @@
                     sound_event (&quot;movesmall&quot;);
                 } else
                     rotateLine(rotate_dir);
-            } 
-            // 2) If more than one stone, 
-            else 
+            }
+            // 2) If more than one stone,
+            else
                 rotateLine(rotate_dir);
         }
         else {
             // BLUE
             bool has_magic_wand = player::WieldedItemIs (sc.actor, &quot;it_magicwand&quot;);
-    
+
             // 1) Try to start explosion of complete cluster
             if (has_magic_wand &amp;&amp; explodeCluster())
                 return;
-    
+
             // 2) Failed? Try to move the cluster
             if (move_dir != NODIR &amp;&amp; moveCluster(true, move_dir, true)) {
                 sc.actor-&gt;send_impulse(get_pos(), move_dir);
                 return;
             }
-    
-            // 3) Last chance: try to rotate the row or column 
+
+            // 3) Last chance: try to rotate the row or column
             if (has_magic_wand) {
                 rotateLine(rotate_dir);
             }
         }
     }
-    
+
     void PuzzleStone::actor_contact (Actor *a) {
         if (state == EXPLODING || state == IGNITED)
             SendMessage(a, &quot;shatter&quot;);
     }
-    
+
     void PuzzleStone::on_impulse(const Impulse&amp; impulse) {
         if (state == IDLE) {
             bool    actor_with_wand = false;
-            if (Actor *ac = dynamic_cast&lt;Actor*&gt;(impulse.sender)) 
+            if (Actor *ac = dynamic_cast&lt;Actor*&gt;(impulse.sender))
                 actor_with_wand = player::WieldedItemIs(ac, &quot;it_magicwand&quot;);
-    
+
             moveCluster(!actor_with_wand, impulse.dir);
         }
     }
 
     void PuzzleStone::on_move() {
-        if (!(objFlags &amp; OBJBIT_HOLLOW)) 
+        if (!(objFlags &amp; OBJBIT_HOLLOW))
             ShatterActorsInsideField (get_pos());
     }
-    
+
     void PuzzleStone::alarm() {
         explodeStone();
     }
-    
+
     void PuzzleStone::markPuzzle(bool visited) {
         if (visited != (bool)(objFlags &amp; OBJBIT_VISITED))
             objFlags ^= OBJBIT_VISITED;
     }
-    
+
     void PuzzleStone::markList(PuzzleList &amp;list, bool visited) {
         for (PuzzleList::iterator itr = list.begin(); itr != list.end(); ++itr)
             (*itr)-&gt;markPuzzle(visited);
     }
-    
+
     bool PuzzleStone::checkConnected(PuzzleList &amp;todo, PuzzleStone * source, Direction dir, int color) {
         GridPos newpos = move(source-&gt;get_pos(), dir);
         PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(newpos));
-    
+
         if ((pz ==  NULL) || (pz-&gt;getAttr(&quot;color&quot;) != color))
             return false;
-    
+
         DirectionBits cfaces = pz-&gt;getConnections();
-    
+
         if (has_dir(cfaces, reverse(dir))) {
             // Puzzle stone at newpos is connected to stone at curpos
             if (!(pz-&gt;objFlags &amp; OBJBIT_VISITED)) {
@@ -285,25 +279,25 @@
             return false;
         }
     }
-    
+
     bool PuzzleStone::findFragment(PuzzleList &amp;cluster, bool keepMarked) {
         // Use a depth first search to determine the group of all stones that
-        //   are connected to the current stone.  Returns true if the cluster is
-        //``complete'' in the sense defined above.
+        // are connected to the current stone.  Returns true if the cluster is
+        // ``complete'' in the sense defined above.
 
         bool is_complete = true;
         PuzzleList todo;
         todo.push_back(this);
         markPuzzle(true);
         int color = getAttr(&quot;color&quot;);
-    
+
         while (!todo.empty()) {
             PuzzleStone *pz = todo.back();
             todo.pop_back();
-        
+
             cluster.push_back(pz);
             DirectionBits cfaces = pz-&gt;getConnections();
-    
+
             if (has_dir(cfaces, NORTH))
                 is_complete &amp;= checkConnected(todo, pz, NORTH, color);
             if (has_dir(cfaces, EAST))
@@ -313,7 +307,7 @@
             if (has_dir(cfaces, WEST))
                 is_complete &amp;= checkConnected(todo, pz, WEST, color);
         }
-        
+
         if (!keepMarked)
             markList(cluster, false);
         return is_complete;
@@ -328,17 +322,17 @@
             }
         }
     }
-    
-    bool PuzzleStone::findAdjacents(PuzzleList &amp;huddle) {    
+
+    bool PuzzleStone::findAdjacents(PuzzleList &amp;huddle) {
         PuzzleList todo;
         todo.push_back(this);
         markPuzzle(true);
         int color = getAttr(&quot;color&quot;);
-    
+
         while (!todo.empty()) {
             PuzzleStone *pz = todo.back();
             todo.pop_back();
-    
+
             huddle.push_back(pz);
             checkNeighbor(todo, pz, NORTH, color);
             checkNeighbor(todo, pz, SOUTH, color);
@@ -347,11 +341,11 @@
         }
         markList(huddle, false);
     }
-        
+
     int PuzzleStone::findLine(PuzzleList &amp;line, Direction dir, int color) {
         ASSERT(dir != NODIR, XLevelRuntime,
             &quot;PuzzleStone: no direction in find_row_or_column_cluster&quot;);
-        
+
         int size = 0;
         GridPos p = get_pos();
         while (PuzzleStone *puzz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(p))) {
@@ -367,7 +361,7 @@
     bool PuzzleStone::moveCluster(bool waterSink, Direction dir, bool checkOnly) {
         PuzzleList cluster;
         bool isComplete = findFragment(cluster, true);
-        
+
         // Now check whether all stones can be placed at their new position
         bool move_ok = true;
         for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
@@ -381,21 +375,21 @@
                 }
             }
         }
-        
+
         markList(cluster, false);
         if (checkOnly || !move_ok) {
             return move_ok;
         }
-        
+
         // If the floor at a complete cluster's new position consists
         // exclusively of abyss or water, create a bridge instead of
         // moving the cluster.
         //
         // For partial clusters build bridges only on water and if the
         // wielded item is NOT the magic wand.
-    
+
         bool createBridge = true;
-    
+
         for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
             if (Floor *fl = GetFloor(move((*itr)-&gt;get_pos(), dir))) {
                 if (!((fl-&gt;is_kind(&quot;fl-abyss&quot;) &amp;&amp; isComplete) || (fl-&gt;is_kind(&quot;fl-water&quot;) &amp;&amp; (isComplete || waterSink)))) {
@@ -404,23 +398,23 @@
                 }
             }
         }
-        
+
         // Finally, either move the whole cluster or create a bridge
         sound_event(&quot;movebig&quot;);
         int size = cluster.size();
-        
+
         if (createBridge) {
             for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
                 SetFloor(move((*itr)-&gt;get_pos(), dir), MakeFloor(&quot;fl-gray&quot;));
                 KillStone((*itr)-&gt;get_pos());
             }
-        } 
+        }
         else {
             for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
                (*itr)-&gt;sourcePos = (*itr)-&gt;get_pos();
                YieldStone((*itr)-&gt;sourcePos);
             }
-    
+
             for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
                 SetStone(move((*itr)-&gt;sourcePos, dir), *itr);
                 (*itr)-&gt;on_move();
@@ -429,7 +423,7 @@
         server::IncMoveCounter(size);
         return true;
     }
-    
+
     bool PuzzleStone::explodeCluster() {
         bool exploded = false;
 
@@ -437,7 +431,7 @@
         if (findFragment(cluster)) {
             PuzzleList huddle;
             findAdjacents(huddle);
-    
+
             // If all adjacent stones build one complete cluster explode it
 //            Log &lt;&lt; &quot;Huddle &quot; &lt;&lt; huddle.size() &lt;&lt; &quot; Cluster &quot;&lt;&lt; cluster.size() &lt;&lt; &quot;\n&quot;;
             if (huddle.size() == cluster.size()) {
@@ -446,7 +440,7 @@
             else {
                 if (getAttr(&quot;color&quot;) == BLUE) {
                     // check if 'huddle' is made up of complete clusters :
-    
+
                     while (!huddle.empty()) {
                         // remove one complete cluster from 'huddle'
                         markList(cluster, true);
@@ -459,12 +453,12 @@
                             } else
                                ++itr;
                         }
-                            
+
                         if (huddle.empty()) { // none left -&gt; all were complete
                             exploded = true;
                             break;
                         }
-    
+
                         // look for next complete cluster :
                         cluster.clear();
                         PuzzleStone *pz = huddle.front();
@@ -475,7 +469,7 @@
                 }
             }
         }
-        
+
         if (exploded) {
             if (getAttr(&quot;color&quot;) == BLUE)
                 findAdjacents(cluster);
@@ -490,19 +484,19 @@
             else
                 objFlags &amp;= ~OBJBIT_SINGLE;
         }
-        
+
         return exploded;
     }
-    
+
     void PuzzleStone::explodeStone() {
         GridPos p = get_pos();
         int color = getAttr(&quot;color&quot;);
-    
+
         // exchange puzzle stone with explosion
         sound_event(&quot;stonedestroy&quot;);
         state = EXPLODING;
         init_model();
-    
+
         // trigger all adjacent puzzle stones :
         const double DEFAULT_DELAY = 0.2;
         triggerExplosion(move(p, NORTH), DEFAULT_DELAY, color);
@@ -510,7 +504,7 @@
         triggerExplosion(move(p, EAST),  DEFAULT_DELAY, color);
         triggerExplosion(move(p, WEST),  DEFAULT_DELAY, color);
     }
-    
+
     void PuzzleStone::triggerExplosion(GridPos p, double delay, int color) {
         PuzzleStone *puzz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(p));
         if (puzz &amp;&amp; puzz-&gt;state == PENDING &amp;&amp; puzz-&gt;getAttr(&quot;color&quot;) == color ) {
@@ -518,14 +512,14 @@
             puzz-&gt;ignite(delay);
         }
     }
-    
+
     void PuzzleStone::ignite(double delay) {
         if (state == PENDING) {
             state = IGNITED;
             GameTimer.set_alarm(this, delay, false);
         }
     }
-    
+
     void PuzzleStone::rotateLine(PuzzleList &amp;line, bool forward) {
         PuzzleList::iterator itr = line.begin();
         PuzzleStone *pz1 = *itr;
@@ -539,19 +533,19 @@
                     GridPos p2 = pz2-&gt;get_pos();
                     YieldStone(p2);
                     SetStone(p2, pz1);
-                    pz1 = pz2; 
+                    pz1 = pz2;
                 } else {
                     PuzzleStone *pz2 = *itr;
                     GridPos p2 = pz2-&gt;get_pos();
                     YieldStone(p2);
                     SetStone(p1, pz2);
-                    p1 = p2; 
+                    p1 = p2;
                 }
             }
             SetStone(p1, pz1);
         }
     }
-    
+
     void PuzzleStone::rotateLine(Direction dir, bool forward) {
         if (dir != NODIR) {
             PuzzleList line;
@@ -563,7 +557,7 @@
     }
 
     DEF_TRAITSM(PuzzleStone, &quot;st_puzzle&quot;, st_puzzle, MOVABLE_IRREGULAR);
-    
+
     BOOT_REGISTER_START
         BootRegister(new PuzzleStone(BLUE, &quot;&quot;), &quot;st_puzzle&quot;);
         BootRegister(new PuzzleStone(BLUE, &quot;&quot;), &quot;st_puzzle_blue&quot;);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000756.html">[Enigma-game-svn] r1326 - team_levelpacks/team_test_new_api
</A></li>
	<LI>Next message: <A HREF="000758.html">[Enigma-game-svn] r1328 - feature_branches/hp_lotm/input/lotm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#757">[ date ]</a>
              <a href="thread.html#757">[ thread ]</a>
              <a href="subject.html#757">[ subject ]</a>
              <a href="author.html#757">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
