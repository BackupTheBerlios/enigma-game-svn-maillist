<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1317 - in trunk: data data/schemas src src/stones
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1317%20-%20in%20trunk%3A%20data%20data/schemas%20src%20src/stones&In-Reply-To=%3C200809131451.m8DEpYRS004117%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000746.html">
   <LINK REL="Next"  HREF="000748.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1317 - in trunk: data data/schemas src src/stones</H1>
    <B>ral at BerliOS</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1317%20-%20in%20trunk%3A%20data%20data/schemas%20src%20src/stones&In-Reply-To=%3C200809131451.m8DEpYRS004117%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1317 - in trunk: data data/schemas src src/stones">ral at mail.berlios.de
       </A><BR>
    <I>Sat Sep 13 16:51:34 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000746.html">[Enigma-game-svn] r1316 - in trunk: doc src src/floors src/items
</A></li>
        <LI>Next message: <A HREF="000748.html">[Enigma-game-svn] r1318 - team_levelpacks/team_test_new_api
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#747">[ date ]</a>
              <a href="thread.html#747">[ thread ]</a>
              <a href="subject.html#747">[ subject ]</a>
              <a href="author.html#747">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ral
Date: 2008-09-13 16:51:32 +0200 (Sat, 13 Sep 2008)
New Revision: 1317

Added:
   trunk/src/stones/PuzzleStone.cc
   trunk/src/stones/PuzzleStone.hh
Removed:
   trunk/src/stones/ConnectiveStone.cc
   trunk/src/stones/ConnectiveStone.hh
Modified:
   trunk/data/api1init.lua
   trunk/data/api2init.lua
   trunk/data/schemas/objects.xml
   trunk/src/Makefile.am
   trunk/src/enigma.hh
   trunk/src/ox_magnum.cc
   trunk/src/ox_oxyd1.cc
   trunk/src/ox_peroxyd.cc
   trunk/src/stones.cc
   trunk/src/stones.hh
   trunk/src/stones/ClusterStone.cc
   trunk/src/stones/ClusterStone.hh
   trunk/src/stones_complex.cc
   trunk/src/world.cc
Log:
Trunk 1.1: new API reengineering
- puzzle part 1:
  - rename to &quot;st_puzzle&quot;,&quot;st_puzzle_blue&quot;, &quot;st_puzzle_yellow&quot;
  - attribute &quot;color&quot;, values BLUE, YELLOW
  - attribute &quot;connections&quot; like Clusterstones - substring of &quot;nesw&quot; 
  - attribute &quot;hollow&quot;: true, false
  - hollow puzzles exist only with &quot;nesw&quot;, connection attribute is set
  - keep identity of stones on rotation
  - fix laser light bugs on rotation of hollow, switched off light,...
  - improve algorithms - linear ones only
  - disable all operations on a cluster on pending explosions
  - add autocluster feature
- unused class ConnectiveStone eliminated


Modified: trunk/data/api1init.lua
===================================================================
--- trunk/data/api1init.lua	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/data/api1init.lua	2008-09-13 14:51:32 UTC (rev 1317)
@@ -219,6 +219,38 @@
     st_panel = &quot;st-wood_001&quot;,
     st_polarswitch = &quot;st-polarswitch&quot;,
     st_pull = &quot;st-pull&quot;,
+    st_puzzle = &quot;st-puzzle&quot;,
+    st_puzzle_blue_w = &quot;st-puzzle-w&quot;,
+    st_puzzle_blue_s = &quot;st-puzzle-s&quot;,
+    st_puzzle_blue_sw = &quot;st-puzzle-sw&quot;,
+    st_puzzle_blue_e = &quot;st-puzzle-e&quot;,
+    st_puzzle_blue_ew = &quot;st-puzzle-ew&quot;,
+    st_puzzle_blue_es = &quot;st-puzzle-es&quot;,
+    st_puzzle_blue_esw = &quot;st-puzzle-esw&quot;,
+    st_puzzle_blue_n = &quot;st-puzzle-n&quot;,
+    st_puzzle_blue_nw = &quot;st-puzzle-nw&quot;,
+    st_puzzle_blue_ns = &quot;st-puzzle-ns&quot;,
+    st_puzzle_blue_nsw = &quot;st-puzzle-nsw&quot;,
+    st_puzzle_blue_ne = &quot;st-puzzle-ne&quot;,
+    st_puzzle_blue_new = &quot;st-puzzle-new&quot;,
+    st_puzzle_blue_nes = &quot;st-puzzle-nes&quot;,
+    st_puzzle_blue_nesw = &quot;st-puzzle-nesw&quot;,
+    st_puzzle_blue_hollow = &quot;st-puzzle-hollow&quot;,
+    st_puzzle_yellow_w = &quot;st-puzzle2-w&quot;,
+    st_puzzle_yellow_s = &quot;st-puzzle2-s&quot;,
+    st_puzzle_yellow_sw = &quot;st-puzzle2-sw&quot;,
+    st_puzzle_yellow_e = &quot;st-puzzle2-e&quot;,
+    st_puzzle_yellow_ew = &quot;st-puzzle2-ew&quot;,
+    st_puzzle_yellow_es = &quot;st-puzzle2-es&quot;,
+    st_puzzle_yellow_esw = &quot;st-puzzle2-esw&quot;,
+    st_puzzle_yellow_n = &quot;st-puzzle2-n&quot;,
+    st_puzzle_yellow_nw = &quot;st-puzzle2-nw&quot;,
+    st_puzzle_yellow_ns = &quot;st-puzzle2-ns&quot;,
+    st_puzzle_yellow_nsw = &quot;st-puzzle2-nsw&quot;,
+    st_puzzle_yellow_ne = &quot;st-puzzle2-ne&quot;,
+    st_puzzle_yellow_new = &quot;st-puzzle2-new&quot;,
+    st_puzzle_yellow_nes = &quot;st-puzzle2-nes&quot;,
+    st_puzzle_yellow_nesw_hollow = &quot;st-puzzle2-hollow&quot;,
     st_rotator_cw = &quot;st-rotator-right&quot;,
     st_rotator_ccw = &quot;st-rotator-left&quot;,
     st_rotator_cw_movable = &quot;st-rotator_move-right&quot;,
@@ -409,6 +441,9 @@
             return &quot;st-door_&quot; .. flavor
         end
     end
+    if _newname == &quot;st_puzzle&quot; then
+        return &quot;st-puzzle&quot;
+    end
     if _newname == &quot;it_sensor&quot; then
         local code = enigma._GetAttrib(obj, &quot;inverse&quot;)
         if code == false then
@@ -441,9 +476,8 @@
              _key = &quot;oxydcolor&quot;
 	 end
      end
-     if key == &quot;connections&quot; and _obj_name ~= &quot;st-puzzle&quot; then
-         if val == 1 then _val = &quot;&quot;
-         elseif  val == 2  then _val = &quot;w&quot;
+     if key == &quot;connections&quot; then
+         if  val == 2  then _val = &quot;w&quot;
          elseif  val == 3  then _val = &quot;s&quot;
          elseif  val == 4  then _val = &quot;sw&quot;
          elseif  val == 5  then _val = &quot;e&quot;
@@ -458,8 +492,16 @@
          elseif  val == 14 then _val = &quot;new&quot;
          elseif  val == 15 then _val = &quot;nes&quot;
          elseif  val == 16 then _val = &quot;nesw&quot;
+         elseif  val == 1 and _obj_name ~= &quot;st-puzzle&quot; then _val = &quot;&quot;
+         elseif  val == 1 and _obj_name == &quot;st-puzzle&quot; then
+             _key = &quot;hollow&quot;
+             _val = true
          end
      end
+     if key == &quot;oxyd&quot; then
+        _key = &quot;color&quot;
+        if val == 0 then _val = 2 else _val = 3 end
+     end
      if key == &quot;keycode&quot; then
          _key = &quot;code&quot;
      end
@@ -611,6 +653,11 @@
          else return &quot;a&quot;
          end
      end
+     if key == &quot;oxyd&quot; and _obj_name == &quot;st-puzzle&quot; then
+         local color = enigma._GetAttrib(obj, &quot;color&quot;)
+         if color == 2 then val = 0 else val = 1 end
+         return val
+     end
 
      local val = enigma._GetAttrib(obj, _key)
      
@@ -620,7 +667,7 @@
      if key == &quot;whiteball&quot; then
         if val == 1 then val = 1 else val = 0 end
      end
-     if key == &quot;connections&quot; and _obj_name ~= &quot;st-puzzle&quot; then
+     if key == &quot;connections&quot; then
          if val == &quot;&quot; then val = 1
          elseif  val == &quot;w&quot;    then val = 2
          elseif  val == &quot;s&quot;    then val = 3

Modified: trunk/data/api2init.lua
===================================================================
--- trunk/data/api2init.lua	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/data/api2init.lua	2008-09-13 14:51:32 UTC (rev 1317)
@@ -71,8 +71,10 @@
 OXYDPAIR = 2
 
 -- color
-BLACK = 0
-WHITE = 1
+BLACK  = 0
+WHITE  = 1
+BLUE   = 2
+YELLOW = 3
 NOCOLOR = nil
 
 -- rotation direction

Modified: trunk/data/schemas/objects.xml
===================================================================
--- trunk/data/schemas/objects.xml	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/data/schemas/objects.xml	2008-09-13 14:51:32 UTC (rev 1317)
@@ -6,7 +6,7 @@
     &lt;attr name=&quot;anchor1&quot; type=&quot;tokens&quot; default=&quot;nil&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;anchor2&quot; type=&quot;tokens&quot; default=&quot;nil&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;autoclose&quot; type=&quot;bool&quot; default=&quot;false&quot; rw=&quot;rw&quot;/&gt;
-    &lt;attr name=&quot;cluster&quot; type=&quot;int&quot; default=&quot;nil&quot; min=&quot;0&quot; max=&quot;1&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;cluster&quot; type=&quot;int&quot; default=&quot;nil&quot; min=&quot;0&quot; max=&quot;9&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;code&quot; type=&quot;int&quot; default=&quot;1&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;coin_value&quot; type=&quot;double&quot; default=&quot;1&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;color&quot; type=&quot;int&quot; default=&quot;nil&quot; min=&quot;0&quot; max=&quot;1&quot; rw=&quot;rw&quot;/&gt;
@@ -26,6 +26,7 @@
     &lt;attr name=&quot;hit_distortion_xy&quot; type=&quot;double&quot; default=&quot;0&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;hit_distortion_yx&quot; type=&quot;double&quot; default=&quot;0&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;hit_distortion_yy&quot; type=&quot;double&quot; default=&quot;1&quot; rw=&quot;rw&quot;/&gt;
+    &lt;attr name=&quot;hollow&quot; type=&quot;bool&quot; default=&quot;false&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;instant&quot; type=&quot;bool&quot; default=&quot;false&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;interval&quot; type=&quot;double&quot; default=&quot;1&quot; rw=&quot;rw&quot;/&gt;
     &lt;attr name=&quot;interval_s&quot; type=&quot;double&quot; default=&quot;3&quot; rw=&quot;rw&quot;/&gt;
@@ -63,6 +64,7 @@
     &lt;msg name=&quot;closeall&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;disconnect&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;flip&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;get_adjacents&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;grow&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;hit&quot; type=&quot;object&quot;/&gt;
     &lt;msg name=&quot;ignite&quot; type=&quot;nil&quot;/&gt;
@@ -73,6 +75,8 @@
     &lt;msg name=&quot;on&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;open&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;orientate&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;pull_rotate&quot; type=&quot;int&quot;/&gt;
+    &lt;msg name=&quot;push_rotate&quot; type=&quot;int&quot;/&gt;
     &lt;msg name=&quot;shuffle&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;shovel&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;signal&quot; type=&quot;int&quot; min=&quot;0&quot; max=&quot;1&quot;/&gt;
@@ -92,6 +96,7 @@
     &lt;msg name=&quot;_passed&quot; type=&quot;nil&quot;/&gt;            &lt;!-- check type--&gt;
     &lt;msg name=&quot;_performaction&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;_revive&quot; type=&quot;nil&quot;/&gt;
+    &lt;msg name=&quot;_scramble&quot; type=&quot;int&quot;/&gt;
     &lt;msg name=&quot;_shogun&quot; type=&quot;int&quot;/&gt;
     &lt;msg name=&quot;_spitter&quot; type=&quot;nil&quot;/&gt;
     &lt;msg name=&quot;_start&quot; type=&quot;nil&quot;/&gt;
@@ -819,6 +824,23 @@
       &lt;msg name=&quot;_freeze&quot;/&gt;
       &lt;msg name=&quot;_revive&quot;/&gt;
     &lt;/object&gt;
+    &lt;object name=&quot;st_puzzle&quot;&gt;
+      &lt;attr name=&quot;connections&quot;/&gt;
+      &lt;attr name=&quot;cluster&quot;/&gt;
+      &lt;attr name=&quot;color&quot; min=&quot;2&quot; max=&quot;3&quot;/&gt;
+      &lt;attr name=&quot;hollow&quot;/&gt;
+      &lt;attr name=&quot;state&quot; rw=&quot;r&quot;/&gt;
+      &lt;msg name=&quot;get_adjacents&quot;/&gt;
+      &lt;msg name=&quot;pull_rotate&quot;/&gt;
+      &lt;msg name=&quot;push_rotate&quot;/&gt;
+      &lt;msg name=&quot;_scramble&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_puzzle_blue&quot;&gt;
+      &lt;attr name=&quot;color&quot; value=&quot;2&quot;/&gt;
+    &lt;/object&gt;
+    &lt;object name=&quot;st_puzzle_yellow&quot;&gt;
+      &lt;attr name=&quot;color&quot; value=&quot;3&quot;/&gt;
+   &lt;/object&gt;
     &lt;object name=&quot;st_rotator&quot;&gt;
       &lt;attr name=&quot;counterclock&quot;/&gt;
       &lt;attr name=&quot;movable&quot; rw=&quot;rw&quot;/&gt;

Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/Makefile.am	2008-09-13 14:51:32 UTC (rev 1317)
@@ -247,8 +247,6 @@
 	stones/ClusterStone.hh	\
 	stones/CoinSlot.cc	\
 	stones/CoinSlot.hh	\
-	stones/ConnectiveStone.cc	\
-	stones/ConnectiveStone.hh	\
 	stones/DeathStone.cc	\
 	stones/DeathStone.hh	\
 	stones/Door.cc		\
@@ -283,6 +281,8 @@
 	stones/PolarSwitchStone.hh	\
 	stones/PullStone.cc	\
 	stones/PullStone.hh	\
+	stones/PuzzleStone.cc	\
+	stones/PuzzleStone.hh	\
 	stones/RotatorStone.cc	\
 	stones/RotatorStone.hh	\
 	stones/RubberbandStone.cc	\

Modified: trunk/src/enigma.hh
===================================================================
--- trunk/src/enigma.hh	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/enigma.hh	2008-09-13 14:51:32 UTC (rev 1317)
@@ -41,7 +41,9 @@
     
     enum Color {
         BLACK = 0,
-        WHITE = 1
+        WHITE = 1,
+        BLUE  = 2,
+        YELLOW = 3
     };
     
 /* -------------------- Various types -------------------- */

Modified: trunk/src/ox_magnum.cc
===================================================================
--- trunk/src/ox_magnum.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/ox_magnum.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -203,17 +203,17 @@
     &quot;st_mirror_triangle_nc&quot;,    // OxydMagnum stone 0x54
     &quot;st_mirror_triangle_wc&quot;,    // OxydMagnum stone 0x55
     &quot;st_mirror_triangle_sc&quot;,    // OxydMagnum stone 0x56
-    &quot;st-puzzle2-es&quot;,            // Oxyd1 stone 0x57
-    &quot;st-puzzle2-sw&quot;,            // Oxyd1 stone 0x58
-    &quot;st-puzzle2-nw&quot;,            // Oxyd1 stone 0x59
-    &quot;st-puzzle2-ne&quot;,            // Oxyd1 stone 0x5a
-    &quot;st-puzzle2-ew&quot;,            // Oxyd1 stone 0x5b
-    &quot;st-puzzle2-ns&quot;,            // Oxyd1 stone 0x5c
-    &quot;st-puzzle2-n&quot;,             // Oxyd1 stone 0x5d
-    &quot;st-puzzle2-s&quot;,             // Oxyd1 stone 0x5e
-    &quot;st-puzzle2-w&quot;,             // Oxyd1 stone 0x5f
-    &quot;st-puzzle2-e&quot;,             // Oxyd1 stone 0x60
-    &quot;st-puzzle2-nesw&quot;,          // Oxyd1 stone 0x61
+    &quot;st_puzzle_yellow_es&quot;,      // Oxyd1 stone 0x57
+    &quot;st_puzzle_yellow_ew&quot;,      // Oxyd1 stone 0x58
+    &quot;st_puzzle_yellow_nw&quot;,      // Oxyd1 stone 0x59
+    &quot;st_puzzle_yellow_ne&quot;,      // Oxyd1 stone 0x5a
+    &quot;st_puzzle_yellow_ew&quot;,      // Oxyd1 stone 0x5b
+    &quot;st_puzzle_yellow_ns&quot;,      // Oxyd1 stone 0x5c
+    &quot;st_puzzle_yellow_n&quot;,       // Oxyd1 stone 0x5d
+    &quot;st_puzzle_yellow_s&quot;,       // Oxyd1 stone 0x5e
+    &quot;st_puzzle_yellow_w&quot;,       // Oxyd1 stone 0x5f
+    &quot;st_puzzle_yellow_e&quot;,       // Oxyd1 stone 0x60
+    &quot;st_puzzle_yellow_nesw&quot;,    // Oxyd1 stone 0x61
     &quot;st-metal_hole&quot;,            // OxydMagnum stone 0x62  (st-explosive: like st-metal, but explodes when touched ...)
     &quot;st-plain_break&quot;,           // OxydMagnum stone 0x63
     &quot;st-fakeoxyda&quot;,             // OxydMagnum stone 0x64

Modified: trunk/src/ox_oxyd1.cc
===================================================================
--- trunk/src/ox_oxyd1.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/ox_oxyd1.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -235,17 +235,17 @@
     &quot;st_mirror_triangle_nc&quot;,    // Oxyd1 stone 0x54
     &quot;st_mirror_triangle_wc&quot;,    // Oxyd1 stone 0x55
     &quot;st_mirror_triangle_sc&quot;,    // Oxyd1 stone 0x56
-    &quot;st-puzzle2-es&quot;,            // Oxyd1 stone 0x57
-    &quot;st-puzzle2-sw&quot;,            // Oxyd1 stone 0x58
-    &quot;st-puzzle2-nw&quot;,            // Oxyd1 stone 0x59
-    &quot;st-puzzle2-ne&quot;,            // Oxyd1 stone 0x5a
-    &quot;st-puzzle2-ew&quot;,            // Oxyd1 stone 0x5b
-    &quot;st-puzzle2-ns&quot;,            // Oxyd1 stone 0x5c
-    &quot;st-puzzle2-n&quot;,             // Oxyd1 stone 0x5d
-    &quot;st-puzzle2-s&quot;,             // Oxyd1 stone 0x5e
-    &quot;st-puzzle2-w&quot;,             // Oxyd1 stone 0x5f
-    &quot;st-puzzle2-e&quot;,             // Oxyd1 stone 0x60
-    &quot;st-puzzle2-nesw&quot;,          // Oxyd1 stone 0x61
+    &quot;st_puzzle_yellow_es&quot;,      // Oxyd1 stone 0x57
+    &quot;st_puzzle_yellow_sw&quot;,      // Oxyd1 stone 0x58
+    &quot;st_puzzle_yellow_nw&quot;,      // Oxyd1 stone 0x59
+    &quot;st_puzzle_yellow_ne&quot;,      // Oxyd1 stone 0x5a
+    &quot;st_puzzle_yellow_ew&quot;,      // Oxyd1 stone 0x5b
+    &quot;st_puzzle_yellow_ns&quot;,      // Oxyd1 stone 0x5c
+    &quot;st_puzzle_yellow_n&quot;,       // Oxyd1 stone 0x5d
+    &quot;st_puzzle_yellow_s&quot;,       // Oxyd1 stone 0x5e
+    &quot;st_puzzle_yellow_w&quot;,       // Oxyd1 stone 0x5f
+    &quot;st_puzzle_yellow_e&quot;,       // Oxyd1 stone 0x60
+    &quot;st_puzzle_yellow_nesw&quot;,    // Oxyd1 stone 0x61
     &quot;st-metal_hole&quot;,            // Oxyd1 stone 0x62
     &quot;st-laserbreak&quot;,            // Oxyd1 stone 0x63
     &quot;st-fakeoxyda&quot;,             // Oxyd1 stone 0x64

Modified: trunk/src/ox_peroxyd.cc
===================================================================
--- trunk/src/ox_peroxyd.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/ox_peroxyd.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -269,18 +269,18 @@
     &quot;st_mirror_triangle_nc&quot;,    // PerOxyd stone 0x4e
     &quot;st_mirror_triangle_wc&quot;,    // PerOxyd stone 0x4f
     &quot;st_mirror_triangle_sc&quot;,    // PerOxyd stone 0x50
-    &quot;st-puzzle-es&quot;,             // PerOxyd stone 0x51
-    &quot;st-puzzle-sw&quot;,             // PerOxyd stone 0x52
-    &quot;st-puzzle-nw&quot;,             // PerOxyd stone 0x53
-    &quot;st-puzzle-ne&quot;,             // PerOxyd stone 0x54
-    &quot;st-puzzle-ew&quot;,             // PerOxyd stone 0x55
-    &quot;st-puzzle-ns&quot;,             // PerOxyd stone 0x56
-    &quot;st-puzzle-n&quot;,              // PerOxyd stone 0x57
-    &quot;st-puzzle-s&quot;,              // PerOxyd stone 0x58
-    &quot;st-puzzle-w&quot;,              // PerOxyd stone 0x59
-    &quot;st-puzzle-e&quot;,              // PerOxyd stone 0x5a
-    &quot;st-puzzle-nesw&quot;,           // PerOxyd stone 0x5b
-    &quot;st-puzzle-hollow&quot;,         // PerOxyd stone 0x5c
+    &quot;st_puzzle_blue_es&quot;,        // PerOxyd stone 0x51
+    &quot;st_puzzle_blue_sw&quot;,        // PerOxyd stone 0x52
+    &quot;st_puzzle_blue_nw&quot;,        // PerOxyd stone 0x53
+    &quot;st_puzzle_blue_ne&quot;,        // PerOxyd stone 0x54
+    &quot;st_puzzle_blue_ew&quot;,        // PerOxyd stone 0x55
+    &quot;st_puzzle_blue_ns&quot;,        // PerOxyd stone 0x56
+    &quot;st_puzzle_blue_n&quot;,         // PerOxyd stone 0x57
+    &quot;st_puzzle_blue_s&quot;,         // PerOxyd stone 0x58
+    &quot;st_puzzle_blue_w&quot;,         // PerOxyd stone 0x59
+    &quot;st_puzzle_blue_e&quot;,         // PerOxyd stone 0x5a
+    &quot;st_puzzle_blue_nesw&quot;,      // PerOxyd stone 0x5b
+    &quot;st_puzzle_blue_nesw_hollow&quot;, // PerOxyd stone 0x5c
     &quot;st-laserbreak&quot;,            // PerOxyd stone 0x5d
     &quot;st-coffee&quot;,                // PerOxyd stone 0x5e
     &quot;st_shogun&quot;,                // PerOxyd stone 0x5f (oxyd with a hole, movable ... strange stone! st-shogun as workaround, only link level 74)

Modified: trunk/src/stones/ClusterStone.cc
===================================================================
--- trunk/src/stones/ClusterStone.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones/ClusterStone.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -70,48 +70,7 @@
     bool ClusterStone::is_removable() const {
         return getFaces() == ALL_DIRECTIONS;
     }
-    
-    void ClusterStone::autoJoinCluster() {
-        GridPos p = get_pos();
-        Value myCluster = getAttr(&quot;cluster&quot;);
-        for (int i = WEST; i &lt;= NORTH; i++) {
-            Direction d = (Direction) i;
-            Stone *neighbour = GetStone(move(p, d));
-            if (neighbour != NULL &amp;&amp; std::string(neighbour-&gt;getClass()) == getClass()) {
-                Value neighbourCluster = neighbour-&gt;getAttr(&quot;cluster&quot;);
-                if (myCluster) {
-                    if (myCluster == neighbourCluster) {
-                        setAttr(&quot;$connections&quot;, getConnections() | to_bits(d));
-                        neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() | to_bits(reverse(d)));
-                    } else if (!neighbourCluster &amp;&amp; neighbour-&gt;getConnections() &amp; to_bits(reverse(d))) {
-                        setAttr(&quot;$connections&quot;, getConnections() | to_bits(d));
-                    } else {
-                        setAttr(&quot;$connections&quot;, getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(d))); // clear connection
-                    }
-                } else if (neighbourCluster)  {// I have fixed connections -&gt; adapt neighbour
-                    if (getConnections() &amp; to_bits(d))
-                        neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() | to_bits(reverse(d)));
-                    else
-                        neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(reverse(d))));
-                }
-            } else if (myCluster) { // no neighbour -&gt; no connection
-                setAttr(&quot;$connections&quot;, getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(d))); // clear connection
-            }
-        }
-    }
-    
-    void ClusterStone::autoLeaveCluster() {
-        GridPos p = get_pos();
-        for (int i = WEST; i &lt;= NORTH; i++) {
-            Direction d = (Direction) i;
-            Stone *neighbour = GetStone(move(p, d));
-            if (neighbour != NULL &amp;&amp; std::string(neighbour-&gt;getClass()) == getClass() 
-                    &amp;&amp; neighbour-&gt;getAttr(&quot;cluster&quot;)) {
-                neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(reverse(d))));
-            }
-        }
-    }
-    
+        
     BOOT_REGISTER_START
         BootRegister(new ClusterStone(&quot;st_panel&quot;, &quot;&quot;), &quot;st_panel&quot;);
         BootRegister(new ClusterStone(&quot;st_panel&quot;, &quot;w&quot;), &quot;st_panel_w&quot;);

Modified: trunk/src/stones/ClusterStone.hh
===================================================================
--- trunk/src/stones/ClusterStone.hh	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones/ClusterStone.hh	2008-09-13 14:51:32 UTC (rev 1317)
@@ -45,11 +45,7 @@
         virtual std::string getModelName() const;
         
         // Stone interface
-        virtual bool is_removable() const;
-        
-    private:
-        void autoJoinCluster();
-        void autoLeaveCluster();
+        virtual bool is_removable() const;        
     };
 
 } // namespace enigma

Deleted: trunk/src/stones/ConnectiveStone.cc
===================================================================
--- trunk/src/stones/ConnectiveStone.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones/ConnectiveStone.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2002,2003,2004 Daniel Heck
- * Copyright (C) 2007 Ronald Lamprecht
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *  
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- */
-
-#include &quot;stones/ConnectiveStone.hh&quot;
-
-namespace enigma {
-} // namespace enigma

Deleted: trunk/src/stones/ConnectiveStone.hh
===================================================================
--- trunk/src/stones/ConnectiveStone.hh	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones/ConnectiveStone.hh	2008-09-13 14:51:32 UTC (rev 1317)
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2002,2003,2004 Daniel Heck
- * Copyright (C) 2007 Ronald Lamprecht
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *  
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- *
- */
-#ifndef CONNECTIVESTONE_HH_INCLUDED
-#define CONNECTIVESTONE_HH_INCLUDED
-
-#include &quot;stones.hh&quot;
-
-/* -------------------- ConnectiveStone -------------------- */
-
-// base class for PuzzleStone and BigBrick
-
-namespace enigma {
-    
-    class ConnectiveStone : public Stone {
-    public:
-        ConnectiveStone(const char *kind, int connections): Stone(kind) {
-            setAttr(&quot;connections&quot;, connections);
-        }
-        ConnectiveStone(int connections) {
-            setAttr(&quot;connections&quot;, connections);
-        }
-
-        DirectionBits get_connections() const {
-            int conn = (int)getAttr(&quot;connections&quot;) - 1;
-            if (conn &gt;=0 &amp;&amp; conn &lt;16)
-                return DirectionBits(conn);
-            else
-                return NODIRBIT;
-        }
-
-        // temp. workarounds until this class gets eliminated
-        virtual void setAttr(const string&amp; key, const Value &amp;val) {
-            if (key == &quot;connections&quot;)
-                Object::setAttr(key, val);  // bypass GridObject
-            else
-                Stone::setAttr(key, val);
-        }
-        
-        virtual Value getAttr(const string &amp;key) const {
-            if (key == &quot;connections&quot;)
-                return Object::getAttr(key);
-            else
-                return Stone::getAttr(key);
-        }
-
-
-    protected:
-        virtual void init_model() {
-            set_model(get_kind()+ecl::strf(&quot;%d&quot;, get_modelno()));
-        }
-
-        virtual int get_modelno() const {
-            return getAttr(&quot;connections&quot;);
-        }
-    };
-
-} // namespace enigma
-
-#endif

Added: trunk/src/stones/PuzzleStone.cc
===================================================================
--- trunk/src/stones/PuzzleStone.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones/PuzzleStone.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -0,0 +1,605 @@
+/*
+ * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+
+#include &quot;stones/PuzzleStone.hh&quot;
+#include &quot;errors.hh&quot;
+#include &quot;main.hh&quot;
+#include &quot;player.hh&quot;
+#include &quot;world.hh&quot;
+#include &lt;algorithm&gt;
+
+namespace enigma {
+    PuzzleStone::PuzzleStone(int color, std::string connections, bool hollow) : Stone() {
+        setAttr(&quot;color&quot;, color);
+        setAttr(&quot;connections&quot;, connections);
+        setAttr(&quot;hollow&quot;, hollow);
+    }
+    
+    PuzzleStone::~PuzzleStone() {
+        GameTimer.remove_alarm (this);
+    }
+    
+    std::string PuzzleStone::getClass() const {
+        return &quot;st_puzzle&quot;;
+    }
+    
+    void PuzzleStone::setAttr(const string&amp; key, const Value &amp;val) {
+        if (key == &quot;hollow&quot;) {
+            if (val.to_bool() != (bool)(objFlags &amp; OBJBIT_HOLLOW)) {
+                objFlags ^= OBJBIT_HOLLOW;
+                if (objFlags &amp; OBJBIT_HOLLOW)
+                    Stone::setAttr(&quot;connections&quot;, &quot;nesw&quot;);
+                else if (isDisplayable())
+                    init_model();
+            }
+            return;
+        } else if (key == &quot;connections&quot; &amp;&amp; !(objFlags &amp; OBJBIT_HOLLOW)) {
+            Stone::setAttr(key, val);
+        }
+        Stone::setAttr(key, val);
+    }
+
+    Value PuzzleStone::getAttr(const std::string &amp;key) const {
+        if (key == &quot;hollow&quot;) {
+            return (bool)(objFlags &amp; OBJBIT_HOLLOW);
+        }
+        return Stone::getAttr(key);
+    }
+
+    Value PuzzleStone::message(const Message &amp;m) {
+        if (m.message == &quot;_scramble&quot;) {
+            // oxyd levels contain explicit information on how to
+            // scramble puzzle stones. According to that information
+            // a &quot;scramble&quot; message is send to specific puzzle stones
+            // together with information about the direction.
+            //
+            // enigma levels may create scramble messages using
+            // AddScramble() and SetScrambleIntensity()
+    
+            Direction dir = to_direction(m.value);
+            PuzzleList c;
+            int size = findLine(c, dir, (int)getAttr(&quot;color&quot;));
+    
+            // warning(&quot;received 'scramble'. dir=%s size=%i&quot;, to_suffix(dir).c_str(), size);
+    
+            if (size &gt;= 2) {
+                int count = IntegerRand(0, static_cast&lt;int&gt; (size-1));
+                while (count--)
+                    rotateLine(c);
+            }
+            else {
+                warning(&quot;useless scramble (line size=%i)&quot;, size);
+            }
+            return Value();
+        } else if (m.message == &quot;get_adjacents&quot;) {
+            // need a message instead of getAttr as we write mark puzzles what contradicts &quot;const&quot;
+            PuzzleList huddle;
+            findAdjacents(huddle);
+            ObjectList adj;
+            for (PuzzleList::iterator itr = huddle.begin(); itr != huddle.end(); ++itr)
+                adj.push_back(*itr);
+            return adj;
+        } else if (m.message == &quot;pull_rotate&quot;) {
+            rotateLine(to_direction(m.value), false);
+            return Value();
+        } else if (m.message == &quot;push_rotate&quot;) {
+            rotateLine(to_direction(m.value), true);
+            return Value();
+        }
+        return Stone::message(m);
+    }
+    
+    void PuzzleStone::setState(int extState) {
+        // block all write attempts
+    }
+    
+    void PuzzleStone::init_model() {
+        if (state == EXPLODING) {
+            set_anim(&quot;st-explosion&quot;);
+            return;
+        }
+        int m = getConnections() + 1;
+        if (m == 1)
+            set_model(&quot;st-metal&quot;);
+        else {    
+            if ((objFlags &amp; OBJBIT_HOLLOW) &amp;&amp; m == 16)
+                m = 1;
+            if (getAttr(&quot;color&quot;) == YELLOW)
+                m += 16;
+            set_model(ecl::strf(&quot;st-puzzle%d&quot;, m));
+        }
+    }
+    
+    void PuzzleStone::on_creation(GridPos p) {
+        if (!(objFlags &amp; OBJBIT_INIT)) {
+            autoJoinCluster();
+             objFlags |= OBJBIT_INIT;
+        }
+        activatePhoto();
+        Stone::on_creation(p);
+    }
+    
+    void PuzzleStone::lightDirChanged(DirectionBits oldDirs, DirectionBits newDirs) {
+        if (state == IDLE &amp;&amp; !(objFlags &amp; OBJBIT_HOLLOW)) {
+            DirectionBits addDirs = added_dirs(oldDirs, newDirs);
+            if (addDirs != NODIRBIT &amp;&amp; !explodeCluster() &amp;&amp; getAttr(&quot;color&quot;) == BLUE) {
+                if (addDirs &amp; SOUTHBIT) rotateLine(SOUTH);
+                if (addDirs &amp; NORTHBIT) rotateLine(NORTH);
+                if (addDirs &amp; WESTBIT)  rotateLine(WEST);
+                if (addDirs &amp; EASTBIT)  rotateLine(EAST);
+            }
+        }
+    }
+
+    void PuzzleStone::animcb() {
+        KillStone(get_pos());
+    }
+    
+    bool PuzzleStone::is_transparent(Direction d) const {
+        return objFlags &amp; OBJBIT_HOLLOW;
+    }
+    
+    bool PuzzleStone::is_sticky(const Actor *a) const {
+        return !(objFlags &amp; OBJBIT_HOLLOW);
+    }
+    
+    bool PuzzleStone::allowsSpreading(Direction dir) const {
+        return objFlags &amp; OBJBIT_HOLLOW;
+    }
+
+    bool PuzzleStone::is_removable() const {
+        return state == IDLE;
+    }
+    
+    bool PuzzleStone::isConnectable(Stone *other) const {
+        return Stone::isConnectable(other) &amp;&amp; (other-&gt;getAttr(&quot;color&quot;) == getAttr(&quot;color&quot;));
+    }
+    
+    StoneResponse PuzzleStone::collision_response(const StoneContact &amp;sc) {
+        if ((objFlags &amp; OBJBIT_HOLLOW) || state == EXPLODING)
+            return STONE_PASS;
+        return STONE_REBOUND;
+    }
+
+    void PuzzleStone::actor_hit(const StoneContact &amp;sc) {
+        if (objFlags &amp; OBJBIT_HOLLOW)
+            return;                 // Puzzle stone is hollow
+    
+        if (state != IDLE)
+            return;
+    
+        Direction rotate_dir = reverse(contact_face(sc));
+        Direction move_dir = get_push_direction(sc);
+    
+        if (getAttr(&quot;color&quot;) == YELLOW) {
+            if (explodeCluster())
+                return;
+    
+            // 1) If unconnected puzzle stones -&gt; try to move it
+            if ((objFlags &amp; OBJBIT_SINGLE) &amp;&amp; move_dir != NODIR) {
+                // if cluster contains single stone
+                // -&gt; move it if dest pos is free
+                GridPos dest = move(get_pos(), move_dir);
+                if (GetStone(dest) == NULL) {
+                    Stone *puzz = YieldStone(get_pos());
+                    SetStone(dest, puzz);
+                    puzz-&gt;on_move();
+                    sound_event (&quot;movesmall&quot;);
+                } else
+                    rotateLine(rotate_dir);
+            } 
+            // 2) If more than one stone, 
+            else 
+                rotateLine(rotate_dir);
+        }
+        else {
+            // BLUE
+            bool has_magic_wand = player::WieldedItemIs (sc.actor, &quot;it_magicwand&quot;);
+    
+            // 1) Try to start explosion of complete cluster
+            if (has_magic_wand &amp;&amp; explodeCluster())
+                return;
+    
+            // 2) Failed? Try to move the cluster
+            if (move_dir != NODIR &amp;&amp; moveCluster(true, move_dir, true)) {
+                sc.actor-&gt;send_impulse(get_pos(), move_dir);
+                return;
+            }
+    
+            // 3) Last chance: try to rotate the row or column 
+            if (has_magic_wand) {
+                rotateLine(rotate_dir);
+            }
+        }
+    }
+    
+    void PuzzleStone::actor_contact (Actor *a) {
+        if (state == EXPLODING || state == IGNITED)
+            SendMessage(a, &quot;shatter&quot;);
+    }
+    
+    void PuzzleStone::on_impulse(const Impulse&amp; impulse) {
+        if (state == IDLE) {
+            bool    actor_with_wand = false;
+            if (Actor *ac = dynamic_cast&lt;Actor*&gt;(impulse.sender)) 
+                actor_with_wand = player::WieldedItemIs(ac, &quot;it_magicwand&quot;);
+    
+            moveCluster(!actor_with_wand, impulse.dir);
+        }
+    }
+
+    void PuzzleStone::on_move() {
+        if (!(objFlags &amp; OBJBIT_HOLLOW)) 
+            ShatterActorsInsideField (get_pos());
+    }
+    
+    void PuzzleStone::alarm() {
+        explodeStone();
+    }
+    
+    void PuzzleStone::markPuzzle(bool visited) {
+        if (visited != (bool)(objFlags &amp; OBJBIT_VISITED))
+            objFlags ^= OBJBIT_VISITED;
+    }
+    
+    void PuzzleStone::markList(PuzzleList &amp;list, bool visited) {
+        for (PuzzleList::iterator itr = list.begin(); itr != list.end(); ++itr)
+            (*itr)-&gt;markPuzzle(visited);
+    }
+    
+    bool PuzzleStone::checkConnected(PuzzleList &amp;todo, PuzzleStone * source, Direction dir, int color) {
+        GridPos newpos = move(source-&gt;get_pos(), dir);
+        PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(newpos));
+    
+        if ((pz ==  NULL) || (pz-&gt;getAttr(&quot;color&quot;) != color))
+            return false;
+    
+        DirectionBits cfaces = pz-&gt;getConnections();
+    
+        if (has_dir(cfaces, reverse(dir))) {
+            // Puzzle stone at newpos is connected to stone at curpos
+            if (!(pz-&gt;objFlags &amp; OBJBIT_VISITED)) {
+                pz-&gt;markPuzzle(true);
+                todo.push_back(pz);
+            }
+            return true;
+        } else {
+            // The two stones are adjacent but not connected
+            return false;
+        }
+    }
+    
+    bool PuzzleStone::findFragment(PuzzleList &amp;cluster, bool keepMarked) {
+        // Use a depth first search to determine the group of all stones that
+        //   are connected to the current stone.  Returns true if the cluster is
+        //``complete'' in the sense defined above.
+
+        bool is_complete = true;
+        PuzzleList todo;
+        todo.push_back(this);
+        markPuzzle(true);
+        int color = getAttr(&quot;color&quot;);
+    
+        while (!todo.empty()) {
+            PuzzleStone *pz = todo.back();
+            todo.pop_back();
+        
+            cluster.push_back(pz);
+            DirectionBits cfaces = pz-&gt;getConnections();
+    
+            if (has_dir(cfaces, NORTH))
+                is_complete &amp;= checkConnected(todo, pz, NORTH, color);
+            if (has_dir(cfaces, EAST))
+                is_complete &amp;= checkConnected(todo, pz, EAST, color);
+            if (has_dir(cfaces, SOUTH))
+                is_complete &amp;= checkConnected(todo, pz, SOUTH, color);
+            if (has_dir(cfaces, WEST))
+                is_complete &amp;= checkConnected(todo, pz, WEST, color);
+        }
+        
+        if (!keepMarked)
+            markList(cluster, false);
+        return is_complete;
+    }
+
+    bool PuzzleStone::checkNeighbor(PuzzleList &amp;todo, PuzzleStone *source, Direction dir, int color) {
+        GridPos newpos = move(source-&gt;get_pos(), dir);
+        if (PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(newpos))) {
+            if (!(pz-&gt;objFlags &amp; OBJBIT_VISITED) &amp;&amp; (pz-&gt;getAttr(&quot;color&quot;) == color)) {
+                pz-&gt;markPuzzle(true);
+                todo.push_back(pz);
+            }
+        }
+    }
+    
+    bool PuzzleStone::findAdjacents(PuzzleList &amp;huddle) {    
+        PuzzleList todo;
+        todo.push_back(this);
+        markPuzzle(true);
+        int color = getAttr(&quot;color&quot;);
+    
+        while (!todo.empty()) {
+            PuzzleStone *pz = todo.back();
+            todo.pop_back();
+    
+            huddle.push_back(pz);
+            checkNeighbor(todo, pz, NORTH, color);
+            checkNeighbor(todo, pz, SOUTH, color);
+            checkNeighbor(todo, pz, EAST, color);
+            checkNeighbor(todo, pz, WEST, color);
+        }
+        markList(huddle, false);
+    }
+        
+    int PuzzleStone::findLine(PuzzleList &amp;line, Direction dir, int color) {
+        ASSERT(dir != NODIR, XLevelRuntime,
+            &quot;PuzzleStone: no direction in find_row_or_column_cluster&quot;);
+        
+        int size = 0;
+        GridPos p = get_pos();
+        while (PuzzleStone *puzz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(p))) {
+            if (puzz-&gt;getAttr(&quot;color&quot;) != color)
+                break; // stop when an unrequested puzzle stone type is readed
+            line.push_back(puzz);
+            p.move(dir);
+            size += 1;
+        }
+        return size;
+    }
+
+    bool PuzzleStone::moveCluster(bool waterSink, Direction dir, bool checkOnly) {
+        PuzzleList cluster;
+        bool isComplete = findFragment(cluster, true);
+        
+        // Now check whether all stones can be placed at their new position
+        bool move_ok = true;
+        for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
+            Stone *st = GetStone(move((*itr)-&gt;get_pos(), dir));
+            if (st != NULL) {
+                // check if is the stone at destination a part of the cluster
+                PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(st);
+                if ((pz == NULL) || !(pz-&gt;objFlags &amp; OBJBIT_VISITED)) {
+                    move_ok = false;
+                    break;
+                }
+            }
+        }
+        
+        markList(cluster, false);
+        if (checkOnly || !move_ok) {
+            return move_ok;
+        }
+        
+        // If the floor at a complete cluster's new position consists
+        // exclusively of abyss or water, create a bridge instead of
+        // moving the cluster.
+        //
+        // For partial clusters build bridges only on water and if the
+        // wielded item is NOT the magic wand.
+    
+        bool createBridge = true;
+    
+        for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
+            if (Floor *fl = GetFloor(move((*itr)-&gt;get_pos(), dir))) {
+                if (!((fl-&gt;is_kind(&quot;fl-abyss&quot;) &amp;&amp; isComplete) || (fl-&gt;is_kind(&quot;fl-water&quot;) &amp;&amp; (isComplete || waterSink)))) {
+                    createBridge = false;
+                    break;
+                }
+            }
+        }
+        
+        // Finally, either move the whole cluster or create a bridge
+        sound_event(&quot;movebig&quot;);
+        int size = cluster.size();
+        
+        if (createBridge) {
+            for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
+                SetFloor(move((*itr)-&gt;get_pos(), dir), MakeFloor(&quot;fl-gray&quot;));
+                KillStone((*itr)-&gt;get_pos());
+            }
+        } 
+        else {
+            for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
+               (*itr)-&gt;sourcePos = (*itr)-&gt;get_pos();
+               YieldStone((*itr)-&gt;sourcePos);
+            }
+    
+            for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr) {
+                SetStone(move((*itr)-&gt;sourcePos, dir), *itr);
+                (*itr)-&gt;on_move();
+            }
+        }
+        server::IncMoveCounter(size);
+        return true;
+    }
+    
+    bool PuzzleStone::explodeCluster() {
+        bool exploded = false;
+
+        PuzzleList cluster;
+        if (findFragment(cluster)) {
+            PuzzleList huddle;
+            findAdjacents(huddle);
+    
+            // If all adjacent stones build one complete cluster explode it
+//            Log &lt;&lt; &quot;Huddle &quot; &lt;&lt; huddle.size() &lt;&lt; &quot; Cluster &quot;&lt;&lt; cluster.size() &lt;&lt; &quot;\n&quot;;
+            if (huddle.size() == cluster.size()) {
+                exploded = true;
+            }
+            else {
+                if (getAttr(&quot;color&quot;) == BLUE) {
+                    // check if 'huddle' is made up of complete clusters :
+    
+                    while (!huddle.empty()) {
+                        // remove one complete cluster from 'huddle'
+                        markList(cluster, true);
+                        for (PuzzleList::iterator itr = huddle.begin(); itr != huddle.end(); ) {
+                            if ((*itr)-&gt;objFlags &amp; OBJBIT_VISITED) {
+                                (*itr)-&gt;objFlags &amp;= ~OBJBIT_VISITED;
+                                PuzzleList::iterator ditr = itr;
+                                ++itr;
+                                huddle.erase(ditr);
+                            } else
+                               ++itr;
+                        }
+                            
+                        if (huddle.empty()) { // none left -&gt; all were complete
+                            exploded = true;
+                            break;
+                        }
+    
+                        // look for next complete cluster :
+                        cluster.clear();
+                        PuzzleStone *pz = huddle.front();
+                        if (!pz-&gt;findFragment(cluster)) {
+                            break; // incomplete cluster found -&gt; don't explode
+                        }
+                    }
+                }
+            }
+        }
+        
+        if (exploded) {
+            if (getAttr(&quot;color&quot;) == BLUE)
+                findAdjacents(cluster);
+            else
+                findFragment(cluster);
+            for (PuzzleList::iterator itr = cluster.begin(); itr != cluster.end(); ++itr)
+                (*itr)-&gt;state = PENDING;
+            explodeStone();
+        } else if (getAttr(&quot;color&quot;) == YELLOW){
+            if (cluster.size() == 1)
+                objFlags |= OBJBIT_SINGLE;
+            else
+                objFlags &amp;= ~OBJBIT_SINGLE;
+        }
+        
+        return exploded;
+    }
+    
+    void PuzzleStone::explodeStone() {
+        GridPos p = get_pos();
+        int color = getAttr(&quot;color&quot;);
+    
+        // exchange puzzle stone with explosion
+        sound_event(&quot;stonedestroy&quot;);
+        state = EXPLODING;
+        init_model();
+    
+        // trigger all adjacent puzzle stones :
+        const double DEFAULT_DELAY = 0.2;
+        triggerExplosion(move(p, NORTH), DEFAULT_DELAY, color);
+        triggerExplosion(move(p, SOUTH), DEFAULT_DELAY, color);
+        triggerExplosion(move(p, EAST),  DEFAULT_DELAY, color);
+        triggerExplosion(move(p, WEST),  DEFAULT_DELAY, color);
+    }
+    
+    void PuzzleStone::triggerExplosion(GridPos p, double delay, int color) {
+        PuzzleStone *puzz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(p));
+        if (puzz &amp;&amp; puzz-&gt;state == PENDING &amp;&amp; puzz-&gt;getAttr(&quot;color&quot;) == color ) {
+            // explode adjacent puzzle stones of same type
+            puzz-&gt;ignite(delay);
+        }
+    }
+    
+    void PuzzleStone::ignite(double delay) {
+        if (state == PENDING) {
+            state = IGNITED;
+            GameTimer.set_alarm(this, delay, false);
+        }
+    }
+    
+    void PuzzleStone::rotateLine(PuzzleList &amp;line, bool forward) {
+        PuzzleList::iterator itr = line.begin();
+        PuzzleStone *pz1 = *itr;
+        ++itr;
+        if (itr != line.end()) {
+            GridPos p1 = pz1-&gt;get_pos();
+            YieldStone(p1);
+            for (; itr != line.end(); ++itr) {
+                if (forward) {
+                    PuzzleStone *pz2 = *itr;
+                    GridPos p2 = pz2-&gt;get_pos();
+                    YieldStone(p2);
+                    SetStone(p2, pz1);
+                    pz1 = pz2; 
+                } else {
+                    PuzzleStone *pz2 = *itr;
+                    GridPos p2 = pz2-&gt;get_pos();
+                    YieldStone(p2);
+                    SetStone(p1, pz2);
+                    p1 = p2; 
+                }
+            }
+            SetStone(p1, pz1);
+        }
+    }
+    
+    void PuzzleStone::rotateLine(Direction dir, bool forward) {
+        if (dir != NODIR) {
+            PuzzleList line;
+            int size = findLine(line, dir, (int)getAttr(&quot;color&quot;));
+            if (size &gt;= 2) {
+                rotateLine(line, forward);
+            }
+        }
+    }
+
+    DEF_TRAITSM(PuzzleStone, &quot;st_puzzle&quot;, st_puzzle, MOVABLE_IRREGULAR);
+    
+    BOOT_REGISTER_START
+        BootRegister(new PuzzleStone(BLUE, &quot;&quot;), &quot;st_puzzle&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;&quot;), &quot;st_puzzle_blue&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;&quot;), &quot;st_puzzle_yellow&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;w&quot;),   &quot;st_puzzle_blue_w&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;s&quot;),   &quot;st_puzzle_blue_s&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;sw&quot;),  &quot;st_puzzle_blue_sw&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;e&quot;),   &quot;st_puzzle_blue_e&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;ew&quot;),  &quot;st_puzzle_blue_ew&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;es&quot;),  &quot;st_puzzle_blue_es&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;esw&quot;), &quot;st_puzzle_blue_esw&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;n&quot;),   &quot;st_puzzle_blue_n&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;nw&quot;),  &quot;st_puzzle_blue_nw&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;ns&quot;),  &quot;st_puzzle_blue_ns&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;nsw&quot;), &quot;st_puzzle_blue_nsw&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;ne&quot;),  &quot;st_puzzle_blue_ne&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;new&quot;), &quot;st_puzzle_blue_new&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;nes&quot;), &quot;st_puzzle_blue_nes&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;nesw&quot;), &quot;st_puzzle_blue_nesw&quot;);
+        BootRegister(new PuzzleStone(BLUE, &quot;nesw&quot;, true), &quot;st_puzzle_blue_nesw_hollow&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;w&quot;),   &quot;st_puzzle_yellow_w&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;s&quot;),   &quot;st_puzzle_yellow_s&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;sw&quot;),  &quot;st_puzzle_yellow_sw&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;e&quot;),   &quot;st_puzzle_yellow_e&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;ew&quot;),  &quot;st_puzzle_yellow_ew&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;es&quot;),  &quot;st_puzzle_yellow_es&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;esw&quot;), &quot;st_puzzle_yellow_esw&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;n&quot;),   &quot;st_puzzle_yellow_n&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;nw&quot;),  &quot;st_puzzle_yellow_nw&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;ns&quot;),  &quot;st_puzzle_yellow_ns&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;nsw&quot;), &quot;st_puzzle_yellow_nsw&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;ne&quot;),  &quot;st_puzzle_yellow_ne&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;new&quot;), &quot;st_puzzle_yellow_new&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;nes&quot;), &quot;st_puzzle_yellow_nes&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;nesw&quot;), &quot;st_puzzle_yellow_nesw&quot;);
+        BootRegister(new PuzzleStone(YELLOW, &quot;nesw&quot;, true), &quot;st_puzzle_yellow_nesw_hollow&quot;);
+    BOOT_REGISTER_END
+
+} // namespace enigma


Property changes on: trunk/src/stones/PuzzleStone.cc
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/stones/PuzzleStone.hh
===================================================================
--- trunk/src/stones/PuzzleStone.hh	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones/PuzzleStone.hh	2008-09-13 14:51:32 UTC (rev 1317)
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2002,2003,2004 Daniel Heck
+ * Copyright (C) 2008 Ronald Lamprecht
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ */
+#ifndef PUZZLESTONE_HH
+#define PUZZLESTONE_HH
+
+#include &quot;stones.hh&quot;
+
+#include &quot;stones_internal.hh&quot;
+
+namespace enigma {
+
+    /** 
+     *  Puzzle stones can be connected to other stones of the same type.  Any
+     *  of the four faces of the stone can have ``socket''.  If the adjoining
+     *  faces of two neighboring stones both have a socket, the two stones
+     *  link up and henceforth move as group.
+     *  
+     *  A cluster of puzzle stones may for example look like this:
+     *  
+     *  +---+---+---+---+
+     *  |   |   |   |   |
+     *  | --+-+-+---+-+ |
+     *  |   | | |   | | |
+     *  +---+-+-+---+-+-+
+     *      | | |   | | |
+     *      | | |   | | |
+     *      |   |   |   |
+     *      +---+   +---+
+     *  
+     *  This example actually presents the special case of a ``complete''
+     *  cluster.  A cluster is complete if none of its stones has an
+     *  unconnected socket.
+     *  
+     *  When touched with a magic wand the puzzle stones rotate
+     *  row- or columnwise.
+     *   
+     * fragment = connected
+     * cluster = connected and complete
+     * huddle  = adjacent
+     */
+    class PuzzleStone : public Stone, public TimeHandler {
+        CLONEOBJ(PuzzleStone);
+        DECL_TRAITS;
+        
+    private:
+        enum iState {
+            IDLE,       ///&lt;
+            PENDING,    ///&lt;  a cluster gets locked on a pending explosion to avoid further actions
+            IGNITED,    ///&lt; 
+            EXPLODING   ///&lt; 
+        };
+
+        enum ObjectPrivatFlagsBits {
+            OBJBIT_INIT     =   1&lt;&lt;24,   ///&lt; we cluster just on first grid set and mark initialization
+            OBJBIT_HOLLOW   =   1&lt;&lt;25,   ///&lt; 
+            OBJBIT_VISITED  =   1&lt;&lt;26,   ///&lt; 
+            OBJBIT_SINGLE   =   1&lt;&lt;27    ///&lt; a single, unconnected stone - flag is continuously not updated! 
+        };
+        
+        typedef std::list&lt;PuzzleStone *&gt; PuzzleList;
+
+    public:
+        PuzzleStone(int color, std::string connections, bool hollow = false);
+        virtual ~PuzzleStone();
+        
+        // Object interface
+        virtual std::string getClass() const;
+        virtual void setAttr(const string&amp; key, const Value &amp;val);
+        virtual Value getAttr(const std::string &amp;key) const;
+        virtual Value message(const Message &amp;m);
+        
+        // StateObject interface
+//        virtual int externalState() const;
+        virtual void setState(int extState);
+//        virtual void toggleState();
+
+        // GridObject interface
+        virtual void on_creation(GridPos p);
+        virtual void init_model();
+        virtual void lightDirChanged(DirectionBits oldDirs, DirectionBits newDirs);
+        
+        // ModelCallback interface  - Animation callback
+        virtual void animcb();
+
+        // Stone interface
+        virtual bool isConnectable(Stone *other) const;
+        virtual void on_impulse(const Impulse&amp; impulse);
+        virtual void on_move();
+        virtual bool is_sticky(const Actor *a) const;
+        virtual bool is_transparent(Direction d) const;
+        virtual bool allowsSpreading(Direction dir) const;
+        virtual bool is_removable() const;        
+        virtual StoneResponse collision_response(const StoneContact &amp;sc);
+        virtual void actor_hit(const StoneContact &amp;sc);
+        virtual void actor_contact(Actor *a);
+        
+        // TimeHandler interface
+        virtual void alarm();
+        
+    private:
+        void markPuzzle(bool visited);
+        void markList(PuzzleList &amp;list, bool visited);
+        bool checkConnected(PuzzleList &amp;todo, PuzzleStone *source, Direction dir, int color);
+        bool findFragment(PuzzleList &amp;cluster, bool keepMarked = false);
+        bool checkNeighbor(PuzzleList &amp;todo, PuzzleStone *source, Direction dir, int color);
+        bool findAdjacents(PuzzleList &amp;huddle);
+        int  findLine(PuzzleList &amp;line, Direction dir, int color);
+        
+        bool moveCluster(bool waterSink, Direction dir, bool checkOnly = false);
+        bool explodeCluster();
+        void explodeStone();
+        void triggerExplosion(GridPos p, double delay, int color);
+        void ignite(double delay);
+        void rotateLine(PuzzleList &amp;line, bool forward = true);
+        void rotateLine(Direction dir, bool forward = true);
+        
+        // volatile:
+        GridPos sourcePos;   // source position on move
+    };
+
+} // namespace enigma
+
+#endif


Property changes on: trunk/src/stones/PuzzleStone.hh
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/stones.cc
===================================================================
--- trunk/src/stones.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -174,6 +174,47 @@
     return newvel * factor;
 }
 
+/* -------------------- Cluster routines -------------------- */
+    void Stone::autoJoinCluster() {
+        GridPos p = get_pos();
+        Value myCluster = getAttr(&quot;cluster&quot;);
+        for (int i = WEST; i &lt;= NORTH; i++) {
+            Direction d = (Direction) i;
+            Stone *neighbour = GetStone(move(p, d));
+            if (isConnectable(neighbour)) {
+                Value neighbourCluster = neighbour-&gt;getAttr(&quot;cluster&quot;);
+                if (myCluster) {
+                    if (myCluster == neighbourCluster) {
+                        setAttr(&quot;$connections&quot;, getConnections() | to_bits(d));
+                        neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() | to_bits(reverse(d)));
+                    } else if (!neighbourCluster &amp;&amp; neighbour-&gt;getConnections() &amp; to_bits(reverse(d))) {
+                        setAttr(&quot;$connections&quot;, getConnections() | to_bits(d));
+                    } else {
+                        setAttr(&quot;$connections&quot;, getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(d))); // clear connection
+                    }
+                } else if (neighbourCluster)  {// I have fixed connections -&gt; adapt neighbour
+                    if (getConnections() &amp; to_bits(d))
+                        neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() | to_bits(reverse(d)));
+                    else
+                        neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(reverse(d))));
+                }
+            } else if (myCluster) { // no neighbour -&gt; no connection
+                setAttr(&quot;$connections&quot;, getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(d))); // clear connection
+            }
+        }
+    }
+    
+    void Stone::autoLeaveCluster() {
+        GridPos p = get_pos();
+        for (int i = WEST; i &lt;= NORTH; i++) {
+            Direction d = (Direction) i;
+            Stone *neighbour = GetStone(move(p, d));
+            if (isConnectable(neighbour) &amp;&amp; neighbour-&gt;getAttr(&quot;cluster&quot;)) {
+                neighbour-&gt;setAttr(&quot;$connections&quot;, neighbour-&gt;getConnections() &amp; (ALL_DIRECTIONS ^ to_bits(reverse(d))));
+            }
+        }
+    }
+
 /* -------------------- Freeze check routines -------------------- */
 
 FreezeStatusBits Stone::get_freeze_bits() {

Modified: trunk/src/stones.hh
===================================================================
--- trunk/src/stones.hh	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones.hh	2008-09-13 14:51:32 UTC (rev 1317)
@@ -209,6 +209,10 @@
         virtual bool allowsSpreading(Direction dir) const {
             return is_floating();
         }
+        
+        virtual bool isConnectable(Stone *other) const {
+            return other != NULL &amp;&amp; std::string(other-&gt;getClass()) == getClass();
+        }
 
         /* ---------- Stone interface (events) ---------- */
 
@@ -230,6 +234,11 @@
         bool move_stone(GridPos newPos, const char *soundevent);
         bool move_stone(Direction dir);
         ecl::V2 distortedVelocity (ecl::V2 vel, double defaultfactor);
+        
+        // Cluster support
+        void autoJoinCluster();
+        void autoLeaveCluster();
+        
 
     protected:
         // GridObject interface

Modified: trunk/src/stones_complex.cc
===================================================================
--- trunk/src/stones_complex.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/stones_complex.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -25,7 +25,6 @@
 #include &quot;player.hh&quot;
 #include &quot;Inventory.hh&quot;
 #include &quot;stones_internal.hh&quot;
-#include &quot;stones/ConnectiveStone.hh&quot;
 #include &quot;actors.hh&quot;
 #include &quot;main.hh&quot;
 #include &quot;Value.hh&quot;
@@ -39,669 +38,6 @@
 
 namespace enigma { 
 
-
-///* -------------------- Puzzle stones -------------------- */ 
-
-/** \page st-puzzle Puzzle Stone
-
-Puzzle stones can be connected to other stones of the same type.  Any
-of the four faces of the stone can have ``socket''.  If the adjoining
-faces of two neighboring stones both have a socket, the two stones
-link up and henceforth move as group.
-
-A cluster of puzzle stones may for example look like this:
-
-\verbatim
-+---+---+---+---+
-|   |   |   |   |
-| --+-+-+---+-+ |
-|   | | |   | | |
-+---+-+-+---+-+-+
-    | | |   | | |
-    | | |   | | |
-    |   |   |   |
-    +---+   +---+
-\endverbatim
-
-This example actually presents the special case of a ``complete''
-cluster.  A cluster is complete if none of its stones has an
-unconnected socket.
-
-When touched with a magic wand the puzzle stones rotate
-row- or columnwise.  
-
-\subsection puzzlea Attributes
-
-- \b connections
-   number between 1 an 16.  Each bit in (connections-1) corresponds to
-   a socket on one of the four faces.  You will normally simply use
-   one of the Lua constants \c PUZ_0000 to \c PUZ_1111.
-
-- \b oxyd
-   If 1 then the puzzle stones act oxyd-compatible: Complete clusters
-   explode, when they get touched. All other puzzle stones rotate row-
-   or columnwise. Groups of oxyd-compatible puzzle stones are shuffled
-   randomly at level startup.
-
-\subsection puzzlee Example
-&lt;table&gt;
-&lt;tr&gt;
-&lt;td&gt; \image html st-puzzletempl_0001.png &quot;PUZ_0000&quot;
-&lt;td&gt; \image html st-puzzletempl_0002.png &quot;PUZ_0001&quot;
-&lt;td&gt; \image html st-puzzletempl_0003.png &quot;PUZ_0010&quot;
-&lt;td&gt; \image html st-puzzletempl_0004.png &quot;PUZ_0011&quot;
-&lt;tr&gt;
-&lt;td&gt; \image html st-puzzletempl_0005.png &quot;PUZ_0100&quot;
-&lt;td&gt; \image html st-puzzletempl_0006.png &quot;PUZ_0101&quot;
-&lt;td&gt; \image html st-puzzletempl_0007.png &quot;PUZ_0110&quot;
-&lt;td&gt; \image html st-puzzletempl_0008.png &quot;PUZ_0111&quot;
-&lt;tr&gt;
-&lt;td&gt; \image html st-puzzletempl_0009.png &quot;PUZ_1000&quot;
-&lt;td&gt; \image html st-puzzletempl_0010.png &quot;PUZ_1001&quot;
-&lt;td&gt; \image html st-puzzletempl_0011.png &quot;PUZ_1010&quot;
-&lt;td&gt; \image html st-puzzletempl_0012.png &quot;PUZ_1011&quot;
-&lt;tr&gt;
-&lt;td&gt; \image html st-puzzletempl_0013.png &quot;PUZ_1100&quot;
-&lt;td&gt; \image html st-puzzletempl_0014.png &quot;PUZ_1101&quot;
-&lt;td&gt; \image html st-puzzletempl_0015.png &quot;PUZ_1110&quot;
-&lt;td&gt; \image html st-puzzletempl_0016.png &quot;PUZ_1111&quot;
-&lt;/tr&gt;
-&lt;/table&gt;
-*/
-namespace
-{
-    class PuzzleStone : public ConnectiveStone, public TimeHandler {
-        INSTANCELISTOBJ(PuzzleStone);
-        DECL_TRAITS;
-    public:
-        PuzzleStone(int connections, bool oxyd1_compatible_);  
-        
-        virtual void lightDirChanged(DirectionBits oldDirs, DirectionBits newDirs);
-        virtual bool is_transparent(Direction d) const;
-        virtual bool is_sticky(const Actor *a) const;
-        virtual bool allowsSpreading(Direction dir) const;
-        virtual void on_move();
-    protected:
-        virtual ~PuzzleStone() {
-            GameTimer.remove_alarm (this);
-        }     
-    private:
-        typedef vector&lt;GridPos&gt; Cluster;
-
-        /* ---------- Private methods ---------- */
-
-        bool oxyd1_compatible() const { return getAttr(&quot;oxyd&quot;) != 0; }
-
-        static bool visit_dir(vector&lt;GridPos&gt; &amp;stack, GridPos curpos,
-                              Direction dir, int wanted_oxyd_attrib);
-        static void visit_adjacent(vector&lt;GridPos&gt;&amp; stack, GridPos curpos,
-                                   Direction dir, int wanted_oxyd_attrib);
-
-        bool find_cluster(Cluster &amp;);
-        void find_adjacents(Cluster &amp;);
-        void find_row_or_column_cluster(Cluster &amp;c, GridPos startpos,
-                                        Direction  dir, int wanted_oxyd_attrib);
-
-        bool cluster_complete();
-        bool can_move_cluster (Cluster &amp;c, Direction dir);
-        void maybe_move_cluster(Cluster &amp;c, bool is_complete, bool actor_with_wand, 
-                                Direction dir);
-        void rotate_cluster(const Cluster &amp;c);
-        void maybe_rotate_cluster(Direction dir);
-
-        int get_modelno() const;
-
-        void        trigger_explosion(double delay);
-        static void trigger_explosion_at(GridPos p, double delay, int wanted_oxyd_attrib);
-        void        explode();
-        bool        explode_complete_cluster();
-
-        /* ---------- TimeHandler interface ---------- */
-
-        void alarm();
-
-        /* ---------- Stone interface ---------- */
-
-        virtual Value message(const Message &amp;m);
-
-        void on_creation (GridPos p);
-        void on_impulse (const Impulse&amp; impulse);
-
-        StoneResponse collision_response(const StoneContact &amp;sc);
-        void actor_hit (const StoneContact &amp;sc);
-        void actor_contact (Actor *a);
-
-        /* ---------- Variables ---------- */
-        bool visited;           // flag for DFS
-        enum { IDLE, EXPLODING } state;
-    };
-    DEF_TRAITSM(PuzzleStone, &quot;st-puzzle&quot;, st_puzzle, MOVABLE_IRREGULAR);
-}
-
-PuzzleStone::InstanceList PuzzleStone::instances;
-
-PuzzleStone::PuzzleStone(int connections, bool oxyd1_compatible_) : ConnectiveStone(connections), 
-  state (IDLE)
-//  illumination (NODIRBIT)
-{
-    setAttr(&quot;oxyd&quot;, int(oxyd1_compatible_));
-}
-
-
-bool PuzzleStone::visit_dir(vector&lt;GridPos&gt; &amp;stack, GridPos curpos, 
-        Direction dir, int wanted_oxyd_attrib)
-{
-    GridPos newpos = move(curpos, dir);
-    PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(newpos));
-
-    if ((!pz) || (wanted_oxyd_attrib != (int)pz-&gt;getAttr(&quot;oxyd&quot;)))
-        return false;
-
-    DirectionBits cfaces = pz-&gt;get_connections();
-
-    if (cfaces==NODIRBIT || has_dir(cfaces, reverse(dir))) {
-        // Puzzle stone at newpos is connected to stone at curpos
-        if (!pz-&gt;visited) {
-            pz-&gt;visited = true;
-            stack.push_back(newpos);
-        }
-        return true;
-    } else {
-        // The two stones are adjacent but not connected
-        return false;
-    }
-}
-
-/* Use a depth first search to determine the group of all stones that
-   are connected to the current stone.  Returns true if the cluster is
-   ``complete'' in the sense defined above. */
-bool PuzzleStone::find_cluster(Cluster &amp;cluster) {
-    for (unsigned i=0; i&lt;instances.size(); ++i)
-        instances[i]-&gt;visited=false;
-
-    vector&lt;GridPos&gt; pos_stack;
-    bool is_complete = true;
-    pos_stack.push_back(get_pos());
-    this-&gt;visited = true;
-    int wanted_oxyd_attrib = getAttr(&quot;oxyd&quot;);
-
-    while (!pos_stack.empty())
-    {
-        GridPos curpos = pos_stack.back();
-        pos_stack.pop_back();
-
-        PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(curpos));
-        ASSERT(pz, XLevelRuntime, &quot;PuzzleStone: missing stone in find_cluster&quot;);
-
-        cluster.push_back(curpos);
-        DirectionBits cfaces = pz-&gt;get_connections();
-
-        if (cfaces==NODIRBIT)
-            cfaces = DirectionBits(NORTHBIT | SOUTHBIT | EASTBIT | WESTBIT);
-
-        if (has_dir(cfaces, NORTH))
-            is_complete &amp;= visit_dir(pos_stack, curpos, NORTH, wanted_oxyd_attrib);
-        if (has_dir(cfaces, EAST))
-            is_complete &amp;= visit_dir(pos_stack, curpos, EAST, wanted_oxyd_attrib);
-        if (has_dir(cfaces, SOUTH))
-            is_complete &amp;= visit_dir(pos_stack, curpos, SOUTH, wanted_oxyd_attrib);
-        if (has_dir(cfaces, WEST))
-            is_complete &amp;= visit_dir(pos_stack, curpos, WEST, wanted_oxyd_attrib);
-    }
-    return is_complete;
-}
-
-void PuzzleStone::visit_adjacent (vector&lt;GridPos&gt;&amp; stack, GridPos curpos, 
-                                  Direction dir, int wanted_oxyd_attrib)
-{
-    GridPos newpos = move(curpos, dir);
-    if (PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(newpos))) {
-        if (!pz-&gt;visited) {
-            if (wanted_oxyd_attrib == (int)pz-&gt;getAttr(&quot;oxyd&quot;)) {
-                pz-&gt;visited = true;
-                stack.push_back(newpos);
-            }
-        }
-    }
-}
-
-/* Use a depth first search to determine the group of all puzzle stones
-   with the same &quot;oxyd&quot; attrib that are adjacent to the current stone
-   (or to any other member of the group).
-*/
-void PuzzleStone::find_adjacents(Cluster &amp;cluster) {
-    for (unsigned i=0; i&lt;instances.size(); ++i)
-        instances[i]-&gt;visited=false;
-
-    vector&lt;GridPos&gt; pos_stack;
-    pos_stack.push_back(get_pos());
-    this-&gt;visited = true;
-
-    int wanted_oxyd_attrib = getAttr(&quot;oxyd&quot;);
-
-    while (!pos_stack.empty()) {
-        GridPos curpos = pos_stack.back();
-        pos_stack.pop_back();
-
-        cluster.push_back(curpos);
-        visit_adjacent(pos_stack, curpos, NORTH, wanted_oxyd_attrib);
-        visit_adjacent(pos_stack, curpos, SOUTH, wanted_oxyd_attrib);
-        visit_adjacent(pos_stack, curpos, EAST, wanted_oxyd_attrib);
-        visit_adjacent(pos_stack, curpos, WEST, wanted_oxyd_attrib);
-    }
-}
-
-/* searches from 'startpos' into 'dir' for puzzle-stones.
-   wanted_oxyd_attrib == -1 -&gt; take any puzzle stone
-                      else  -&gt; take only puzzle stones of same type
-*/
-
-void PuzzleStone::find_row_or_column_cluster(Cluster &amp;c, GridPos startpos, 
-                                             Direction dir, int wanted_oxyd_attrib)
-{
-    ASSERT(dir != NODIR, XLevelRuntime,
-        &quot;PuzzleStone: no direction in find_row_or_column_cluster&quot;);
-
-    GridPos p = startpos;
-    while (Stone *puzz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(p))) {
-        if (wanted_oxyd_attrib != -1 &amp;&amp; wanted_oxyd_attrib != (int)puzz-&gt;getAttr(&quot;oxyd&quot;))
-            break; // stop when an unrequested puzzle stone type is readed
-        c.push_back(p);
-        p.move(dir);
-    }
-}
-
-bool PuzzleStone::can_move_cluster (Cluster &amp;c, Direction dir)
-{
-    sort(c.begin(), c.end());
-    Cluster mc(c);              // Moved cluster
-    Cluster diff;               // Difference between mc and c
-
-    for (unsigned i=0; i&lt;mc.size(); ++i)
-        mc[i].move(dir);
-
-    set_difference(mc.begin(), mc.end(), c.begin(), c.end(),
-                   back_inserter(diff));
-
-    // Now check whether all stones can be placed at their new
-    // position
-    bool move_ok = true;
-    for (unsigned i=0; i&lt;diff.size(); ++i)
-        if (GetStone(diff[i]) != 0)
-            move_ok = false;
-
-    return move_ok;    
-}
-
-void PuzzleStone::maybe_move_cluster(Cluster &amp;c, bool is_complete, 
-                                     bool actor_with_wand, Direction dir)
-{
-    sort(c.begin(), c.end());
-    Cluster mc(c);              // Moved cluster
-    Cluster diff;               // Difference between mc and c
-
-    for (unsigned i=0; i&lt;mc.size(); ++i)
-        mc[i].move(dir);
-
-    set_difference(mc.begin(), mc.end(), c.begin(), c.end(),
-                   back_inserter(diff));
-
-    // Now check whether all stones can be placed at their new
-    // position
-    bool move_ok = true;
-    for (unsigned i=0; i&lt;diff.size(); ++i)
-        if (GetStone(diff[i]) != 0)
-            move_ok = false;
-
-    if (!move_ok)
-        return;
-
-    // If the floor at a complete cluster's new position consists
-    // exclusively of abyss or water, create a bridge instead of
-    // moving the cluster.
-    //
-    // For partial clusters build bridges only on water and if the
-    // wielded item is NOT the magic wand.
-
-    bool create_bridge = true;
-
-    for (unsigned i=0; create_bridge &amp;&amp; i&lt;mc.size(); ++i) {
-        if (Floor *fl = GetFloor(mc[i])) {
-            if (fl-&gt;is_kind(&quot;fl-abyss&quot;)) {
-                if (!is_complete)
-                    create_bridge = false;
-            }
-            else if (fl-&gt;is_kind(&quot;fl-water&quot;)) {
-                if (!is_complete &amp;&amp; actor_with_wand) 
-                    create_bridge = false;
-            }
-            else
-                create_bridge = false;
-        }
-    }
-
-    // Finally, either move the whole cluster or create a bridge
-    sound_event(&quot;movebig&quot;);
-    if (create_bridge) {
-        for (unsigned i=0; i&lt;c.size(); ++i) {
-            KillStone(c[i]);
-            SetFloor(mc[i], MakeFloor(&quot;fl-gray&quot;));
-        }
-    } 
-    else {
-        vector&lt;Stone*&gt; clusterstones;
-        for (unsigned i=0; i&lt;c.size(); ++i)
-            clusterstones.push_back(YieldStone(c[i]));
-
-        for (unsigned i=0; i&lt;c.size(); ++i) {
-            SetStone(mc[i], clusterstones[i]);
-            clusterstones[i]-&gt;on_move();
-        }
-    }
-
-    server::IncMoveCounter (static_cast&lt;int&gt; (c.size()));
-}
-
-bool PuzzleStone::cluster_complete() {
-    Cluster c;
-    return find_cluster(c);
-}
-
-int PuzzleStone::get_modelno() const {
-    int modelno = getAttr(&quot;connections&quot;);
-    if (oxyd1_compatible()) modelno += 16;
-    return modelno;
-}
-
-void PuzzleStone::rotate_cluster(const Cluster &amp;c) {
-    size_t size = c.size();
-    if (size &gt; 1) {
-        int cn = GetStone(c[size-1])-&gt;getAttr(&quot;connections&quot;);
-        for (size_t i=size-1; i&gt;0; --i) {
-            PuzzleStone *st = dynamic_cast&lt;PuzzleStone*&gt; (GetStone (c[i]));
-            st-&gt;setAttr(&quot;connections&quot;, GetStone(c[i-1])-&gt;getAttr(&quot;connections&quot;));
-            st-&gt;init_model();
-        }
-        GetStone(c[0])-&gt;setAttr(&quot;connections&quot;, cn);
-        dynamic_cast&lt;PuzzleStone*&gt; (GetStone(c[0]))-&gt;init_model();
-    }
-}
-
-StoneResponse PuzzleStone::collision_response(const StoneContact &amp;/*sc*/) {
-    if (get_connections() == NODIRBIT)
-        return STONE_PASS;
-    return STONE_REBOUND;
-}
-
-void PuzzleStone::trigger_explosion(double delay) {
-    if (state == IDLE) {
-        state = EXPLODING;
-        GameTimer.set_alarm(this, delay, false);
-    }
-}
-
-void PuzzleStone::trigger_explosion_at (GridPos p, double delay,
-                                        int wanted_oxyd_attrib)
-{
-    PuzzleStone *puzz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(p));
-    if (puzz &amp;&amp; wanted_oxyd_attrib == (int)puzz-&gt;getAttr(&quot;oxyd&quot;)) {
-        // explode adjacent puzzle stones of same type
-        puzz-&gt;trigger_explosion(delay);
-    }
-}
-
-void PuzzleStone::explode() {
-    GridPos p       = get_pos();
-    int     ox_attr = getAttr(&quot;oxyd&quot;);
-
-    // exchange puzzle stone with explosion
-    sound_event(&quot;stonedestroy&quot;);
-    SetStone(p, MakeStone(&quot;st-explosion&quot;));
-
-    // trigger all adjacent puzzle stones :
-    const double DEFAULT_DELAY = 0.2;
-    trigger_explosion_at(move(p, NORTH), DEFAULT_DELAY, ox_attr);
-    trigger_explosion_at(move(p, SOUTH), DEFAULT_DELAY, ox_attr);
-    trigger_explosion_at(move(p, EAST),  DEFAULT_DELAY, ox_attr);
-    trigger_explosion_at(move(p, WEST),  DEFAULT_DELAY, ox_attr);
-
-    // @@@ FIXME: At the moment it's possible to push partial puzzle stones
-    // next to an already exploding cluster. Then the part will explode as well.
-    // Possible fix : mark whole cluster as &quot;EXPLODING_SOON&quot; when explosion is initiated
-
-    // ignite adjacent fields
-//     SendExplosionEffect(p, DYNAMITE);
-}
-
-void PuzzleStone::alarm() {
-    explode();
-}
-
-Value PuzzleStone::message(const Message &amp;m) {
-    if (m.message == &quot;scramble&quot;) {
-        // oxyd levels contain explicit information on how to
-        // scramble puzzle stones. According to that information
-        // a &quot;scramble&quot; message is send to specific puzzle stones
-        // together with information about the direction.
-        //
-        // enigma levels may create scramble messages using
-        // AddScramble() and SetScrambleIntensity()
-
-        Direction dir = to_direction(m.value);
-        Cluster   c;
-        find_row_or_column_cluster(c, get_pos(), dir, oxyd1_compatible());
-
-        size_t size = c.size();
-
-        // warning(&quot;received 'scramble'. dir=%s size=%i&quot;, to_suffix(dir).c_str(), size);
-
-        if (size &gt;= 2) {
-            int count = IntegerRand(0, static_cast&lt;int&gt; (size-1));
-            while (count--)
-                rotate_cluster(c);
-        }
-        else {
-            warning(&quot;useless scramble (cluster size=%i)&quot;, size);
-        }
-        return Value();
-    }
-    return ConnectiveStone::message(m);
-}
-
-void PuzzleStone::on_impulse(const Impulse&amp; impulse) 
-{
-//    if (!oxyd1_compatible() &amp;&amp; state == IDLE) {
-    if (state == IDLE) {
-        Cluster c;
-        bool    is_complete     = find_cluster(c);
-        bool    actor_with_wand = false;
-
-        if (Actor *ac = dynamic_cast&lt;Actor*&gt;(impulse.sender)) 
-            actor_with_wand = player::WieldedItemIs (ac, &quot;it_magicwand&quot;);
-
-        maybe_move_cluster(c, is_complete, actor_with_wand, impulse.dir);
-    }
-}
-
-bool PuzzleStone::explode_complete_cluster() 
-{
-    // @@@ FIXME: explode_complete_cluster should mark the whole cluster
-    // as &quot;EXPLODING_SOON&quot; (otherwise it may be changed before it explodes completely)
-
-    ASSERT(state == IDLE, XLevelRuntime,
-        &quot;PuzzleStone: explode_complete_cluster called with inconsistent state&quot;);
-    bool exploded = false;
-
-    Cluster complete;
-    if (find_cluster(complete)) {
-        Cluster all;
-        find_adjacents(all);
-
-        // If all adjacent stones build one complete cluster explode it
-        if (all.size() == complete.size()) {
-            explode();          // explode complete cluster
-            exploded = true;
-        }
-        else {
-            ASSERT(all.size() &gt; complete.size(), XLevelRuntime,
-                &quot;PuzzleStone: sizes don't match in explode_complete_cluster&quot;);
-            if (!oxyd1_compatible()) {
-                // check if 'all' is made up of complete clusters :
-
-                sort(all.begin(), all.end());
-
-                while (1) {
-                    sort(complete.begin(), complete.end());
-
-                    // remove one complete cluster from 'all'
-                    {
-                        Cluster rest;
-                        set_symmetric_difference(all.begin(), all.end(),
-                                                 complete.begin(), complete.end(),
-                                                 back_inserter(rest));
-                        // now rest contains 'all' minus 'complete'
-                        swap(all, rest);
-                    }
-
-                    if (all.empty()) { // none left -&gt; all were complete
-                        exploded = true;
-                        break;
-                    }
-
-                    // look for next complete cluster :
-                    complete.clear();
-                    {
-                        PuzzleStone *pz = dynamic_cast&lt;PuzzleStone*&gt;(GetStone(all[0]));
-                        ASSERT(pz, XLevelRuntime,
-                            &quot;PuzzleStone: missing stone in explode_complete_cluster&quot;);
-                        if (!pz-&gt;find_cluster(complete)) {
-                            break; // incomplete cluster found -&gt; don't explode
-                        }
-                    }
-                }
-
-                if (exploded) {
-//                     warning(&quot;exploding complete cluster&quot;);
-                    explode();
-                }
-            }
-        }
-    }
-
-    return exploded;
-}
-
-bool PuzzleStone::is_transparent(Direction d) const {
-    return get_connections() == 0;
-}
-
-bool PuzzleStone::is_sticky(const Actor *a) const {
-    return get_connections() != 0;
-}
-
-bool PuzzleStone::allowsSpreading(Direction dir) const {
-    return get_connections() == 0;
-}
-
-void PuzzleStone::on_move() {
-    if (get_connections() != 0) 
-        ShatterActorsInsideField (get_pos());
-}
-
-void PuzzleStone::maybe_rotate_cluster(Direction dir) 
-{
-    if (dir != NODIR) {
-        Cluster c;
-        find_row_or_column_cluster(c, get_pos(), dir, (int)getAttr(&quot;oxyd&quot;));
-        if (c.size() &gt;= 2) {
-//             warning(&quot;ok -&gt; rotate&quot;);
-            rotate_cluster(c);
-        }
-    }
-}
-
-void PuzzleStone::on_creation (GridPos p) {
-    activatePhoto();
-    ConnectiveStone::on_creation (p);
-}
-
-
-void PuzzleStone::lightDirChanged(DirectionBits oldDirs, DirectionBits newDirs) {
-    if (state == IDLE &amp;&amp; newDirs != NODIRBIT) {
-        if (!explode_complete_cluster() &amp;&amp; oxyd1_compatible()) {
-            if (newDirs &amp; SOUTHBIT) maybe_rotate_cluster(SOUTH);
-            if (newDirs &amp; NORTHBIT) maybe_rotate_cluster(NORTH);
-            if (newDirs &amp; WESTBIT)  maybe_rotate_cluster(WEST);
-            if (newDirs &amp; EASTBIT)  maybe_rotate_cluster(EAST);
-        }
-    }
-}
-
-void PuzzleStone::actor_hit(const StoneContact &amp;sc) 
-{
-    if (get_connections() == NODIRBIT)
-        return;                 // Puzzle stone is hollow
-
-    if (state == EXPLODING)
-        return;
-
-    Cluster c;
-    find_cluster (c);
-
-    Direction rotate_dir = reverse (contact_face (sc));
-    Direction move_dir = get_push_direction(sc);
-
-    if (oxyd1_compatible()) {
-        // Oxyd 1
-
-        if (explode_complete_cluster())
-            return;
-
-        // 1) If unconnected puzzle stones -&gt; try to move it
-        if (c.size() == 1 &amp;&amp; move_dir != NODIR) {
-            // if cluster contains single stone
-            // -&gt; move it if dest pos is free
-            GridPos dest = move(c[0], move_dir);
-            if (GetStone(dest) == 0) {
-                Stone *puzz = YieldStone(c[0]);
-                SetStone(dest, puzz);
-                puzz-&gt;on_move();
-                sound_event (&quot;movesmall&quot;);
-            } else
-                maybe_rotate_cluster (rotate_dir);
-        } 
-        // 2) If more than one stone, 
-        else 
-            maybe_rotate_cluster (rotate_dir);
-    }
-    else {
-        // Not Oxyd 1
-
-        bool has_magic_wand = player::WieldedItemIs (sc.actor, &quot;it_magicwand&quot;);
-
-        // 1) Try to start explosion of complete cluster
-        if (has_magic_wand &amp;&amp; explode_complete_cluster())
-            return;
-
-        // 2) Failed? Try to move the cluster
-        if (move_dir != NODIR &amp;&amp; can_move_cluster (c, move_dir)) {
-            sc.actor-&gt;send_impulse(get_pos(), move_dir);
-            return;
-        }
-
-        // 3) Last chance: try to rotate the row or column 
-        if (has_magic_wand)
-            maybe_rotate_cluster (rotate_dir);
-    }
-}
-
-void PuzzleStone::actor_contact (Actor *a)
-{
-    if (state == EXPLODING)
-        SendMessage(a, &quot;shatter&quot;);
-}
-
-
 /* -------------------- Stone impulse stones -------------------- */
 
 // Messages:
@@ -969,43 +305,6 @@
 
     Register(new MovableImpulseStone);
 
-    // PerOxyd/Enigma compatible puzzle stones:
-    Register(new PuzzleStone(0, false));
-    Register(&quot;st-puzzle-hollow&quot;, new PuzzleStone(1, false));
-    Register(&quot;st-puzzle-n&quot;, new PuzzleStone(9, false));
-    Register(&quot;st-puzzle-e&quot;, new PuzzleStone(5, false));
-    Register(&quot;st-puzzle-s&quot;, new PuzzleStone(3, false));
-    Register(&quot;st-puzzle-w&quot;, new PuzzleStone(2, false));
-    Register(&quot;st-puzzle-ne&quot;, new PuzzleStone(13, false));
-    Register(&quot;st-puzzle-nw&quot;, new PuzzleStone(10, false));
-    Register(&quot;st-puzzle-es&quot;, new PuzzleStone(7, false));
-    Register(&quot;st-puzzle-sw&quot;, new PuzzleStone(4, false));
-    Register(&quot;st-puzzle-ns&quot;, new PuzzleStone(11, false));
-    Register(&quot;st-puzzle-ew&quot;, new PuzzleStone(6, false));
-    Register(&quot;st-puzzle-nes&quot;, new PuzzleStone(15, false));
-    Register(&quot;st-puzzle-new&quot;, new PuzzleStone(14, false));
-    Register(&quot;st-puzzle-nsw&quot;, new PuzzleStone(12, false));
-    Register(&quot;st-puzzle-esw&quot;, new PuzzleStone(8, false));
-    Register(&quot;st-puzzle-nesw&quot;, new PuzzleStone(16, false));
-
-    // Oxyd1 compatible puzzle stones:
-    Register(&quot;st-puzzle2-hollow&quot;, new PuzzleStone(1, true));
-    Register(&quot;st-puzzle2-n&quot;, new PuzzleStone(9, true));
-    Register(&quot;st-puzzle2-e&quot;, new PuzzleStone(5, true));
-    Register(&quot;st-puzzle2-s&quot;, new PuzzleStone(3, true));
-    Register(&quot;st-puzzle2-w&quot;, new PuzzleStone(2, true));
-    Register(&quot;st-puzzle2-ne&quot;, new PuzzleStone(13, true));
-    Register(&quot;st-puzzle2-nw&quot;, new PuzzleStone(10, true));
-    Register(&quot;st-puzzle2-es&quot;, new PuzzleStone(7, true));
-    Register(&quot;st-puzzle2-sw&quot;, new PuzzleStone(4, true));
-    Register(&quot;st-puzzle2-ns&quot;, new PuzzleStone(11, true));
-    Register(&quot;st-puzzle2-ew&quot;, new PuzzleStone(6, true));
-    Register(&quot;st-puzzle2-nes&quot;, new PuzzleStone(15, true));
-    Register(&quot;st-puzzle2-new&quot;, new PuzzleStone(14, true));
-    Register(&quot;st-puzzle2-nsw&quot;, new PuzzleStone(12, true));
-    Register(&quot;st-puzzle2-esw&quot;, new PuzzleStone(8, true));
-    Register(&quot;st-puzzle2-nesw&quot;, new PuzzleStone(16, true));
-
     Register(new StoneImpulseStone);
 
 }

Modified: trunk/src/world.cc
===================================================================
--- trunk/src/world.cc	2008-09-13 14:48:18 UTC (rev 1316)
+++ trunk/src/world.cc	2008-09-13 14:51:32 UTC (rev 1317)
@@ -460,7 +460,7 @@
         for (; i != e; ++i) {
             Stone *puzz = GetStone(i-&gt;pos);
             if (puzz &amp;&amp; i-&gt;intensity) {
-                SendMessage(puzz, &quot;scramble&quot;, Value(double(i-&gt;dir)));
+                SendMessage(puzz, &quot;_scramble&quot;, Value(double(i-&gt;dir)));
                 --i-&gt;intensity;
             }
             else {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000746.html">[Enigma-game-svn] r1316 - in trunk: doc src src/floors src/items
</A></li>
	<LI>Next message: <A HREF="000748.html">[Enigma-game-svn] r1318 - team_levelpacks/team_test_new_api
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#747">[ date ]</a>
              <a href="thread.html#747">[ thread ]</a>
              <a href="subject.html#747">[ subject ]</a>
              <a href="author.html#747">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
