<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Enigma-game-svn] r1332 - in trunk/data/levels: enigma_experimental	lib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/enigma-game-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1332%20-%20in%20trunk/data/levels%3A%20enigma_experimental%0A%09lib&In-Reply-To=%3C200809152022.m8FKMBcb029783%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000761.html">
   <LINK REL="Next"  HREF="000763.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Enigma-game-svn] r1332 - in trunk/data/levels: enigma_experimental	lib</H1>
    <B>andreasl at mail.berlios.de</B> 
    <A HREF="mailto:enigma-game-svn%40lists.berlios.de?Subject=Re%3A%20%5BEnigma-game-svn%5D%20r1332%20-%20in%20trunk/data/levels%3A%20enigma_experimental%0A%09lib&In-Reply-To=%3C200809152022.m8FKMBcb029783%40sheep.berlios.de%3E"
       TITLE="[Enigma-game-svn] r1332 - in trunk/data/levels: enigma_experimental	lib">andreasl at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 22:22:11 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000761.html">[Enigma-game-svn] r1331 - in trunk: data src/stones
</A></li>
        <LI>Next message: <A HREF="000763.html">[Enigma-game-svn] r1333 - trunk/data/levels/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#762">[ date ]</a>
              <a href="thread.html#762">[ thread ]</a>
              <a href="subject.html#762">[ subject ]</a>
              <a href="author.html#762">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: andreasl
Date: 2008-09-15 22:22:06 +0200 (Mon, 15 Sep 2008)
New Revision: 1332

Modified:
   trunk/data/levels/enigma_experimental/test_libsoko.xml
   trunk/data/levels/lib/libsoko-designlist.xml
   trunk/data/levels/lib/libsoko-endphase.xml
   trunk/data/levels/lib/libsoko.xml
Log:
Trunk:
 - Adapt/repair libsoko (part II)
    - switch to namespace lib.soko in nearly all functions
    - remove function hooks
    - adapt test_libsoko.xml
Todo:
 - More beautifications
 - Finetuning of designs
 - Refman
Note:
 - libsoko uses enigma.LoadLib to define the field
   &quot;lib.soko&quot; prior to loading its two extension libraries.


Modified: trunk/data/levels/enigma_experimental/test_libsoko.xml
===================================================================
--- trunk/data/levels/enigma_experimental/test_libsoko.xml	2008-09-15 18:45:31 UTC (rev 1331)
+++ trunk/data/levels/enigma_experimental/test_libsoko.xml	2008-09-15 20:22:06 UTC (rev 1332)
@@ -313,12 +313,12 @@
 
 
 design_min = 1 --76
-design_max = table.getn(design_list)
+design_max = table.getn(lib.soko.design_list)
 
 design_number = 77 --design_max
 
 --create_sokoball(multilevel2, 1, 1)
-create_sokoball(multilevel2, 13, design_number)
+lib.soko.create_sokoball(multilevel2, 13, design_number)
 --create_sokoball(chessoban, 2)
 --draw_sokoball(0, 0, chessoban, 2, nil, true) --leftending)
 wo[{9,1}] = {&quot;st_switch&quot;, target=&quot;design_minus_one&quot;}
@@ -327,7 +327,7 @@
 
 function leftending(nr)
   if nr == 2 then
-    recreate_sokoball(150, 2)
+    lib.soko.recreate_sokoball(150, 2)
   else
     error(&quot;Should never happen!&quot;)
   end
@@ -339,7 +339,7 @@
   if design_number &lt; design_min then
     design_number = design_max
   end
-  recreate_sokoball(design_number)
+  lib.soko.recreate_sokoball(design_number)
   wo[{9,1}] = {&quot;st_switch&quot;, target=&quot;design_minus_one&quot;}
   wo[{10,1}] = {&quot;st_switch&quot;, target=&quot;design_plus_one&quot;}
 end
@@ -348,7 +348,7 @@
   if design_number &gt; design_max then
     design_number = design_min
   end
-  recreate_sokoball(design_number)
+  lib.soko.recreate_sokoball(design_number)
   wo[{9,1}] = {&quot;st_switch&quot;, target=&quot;design_minus_one&quot;}
   wo[{10,1}] = {&quot;st_switch&quot;, target=&quot;design_plus_one&quot;}
 end

Modified: trunk/data/levels/lib/libsoko-designlist.xml
===================================================================
--- trunk/data/levels/lib/libsoko-designlist.xml	2008-09-15 18:45:31 UTC (rev 1331)
+++ trunk/data/levels/lib/libsoko-designlist.xml	2008-09-15 20:22:06 UTC (rev 1332)
@@ -3,7 +3,7 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;library&quot;&gt;
       &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libsoko-designlist&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;2&quot; el:status=&quot;experimental&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;experimental&quot;/&gt;
       &lt;el:author el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
@@ -91,7 +91,7 @@
 --   block:X        : create oxyds with blocking object X
 --   outside:X      : create X oxyd-pairs in the outside and outer walls
   
-default_design = {
+lib.soko.default_design = {
   wall = { &quot;st-rock3&quot;, &quot;fl-leaves&quot; },
    inf = { &quot;fl-wood&quot; },
   outf = { &quot;fl-water&quot; },
@@ -109,7 +109,7 @@
 -- This is done to avoid a chess-stone from jumping into the void,
 -- as a present to the gamer.
 
-design_list = {
+lib.soko.design_list = {
 
 -- endp-algs: circle, ralf, hide, outside, allcrack, block, fourswitch
 --            vortex, gradients, magnets
@@ -646,7 +646,7 @@
 --   create_sokoban(..., ..., ralfcode_conversion_table[715])
 -- to activate it.
 --
-ralfcode_conversion_table = {
+lib.soko.ralfcode_conversion_table = {
      [0]   = 1,
    [714+1] = 4,
    [715+1] = 70,

Modified: trunk/data/levels/lib/libsoko-endphase.xml
===================================================================
--- trunk/data/levels/lib/libsoko-endphase.xml	2008-09-15 18:45:31 UTC (rev 1331)
+++ trunk/data/levels/lib/libsoko-endphase.xml	2008-09-15 20:22:06 UTC (rev 1332)
@@ -3,7 +3,7 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;library&quot;&gt;
       &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libsoko-endphase&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;experimental&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;4&quot; el:status=&quot;experimental&quot;/&gt;
       &lt;el:author el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
@@ -21,14 +21,16 @@
 -- endphases. Don't include this library with your levels (it won't
 -- have any effect), but libsoko.xml.
 
+lib.soko.GOAL_HOOK_RALF = 1
+
 ------------------------------------------------------------------------
 -- Goal Trigger and Endphase Main Functions
 ------------------------------------------------------------------------
 
-function goal_trigger(onoff, sender)
+function lib.soko.goal_trigger(onoff, sender)
   local nr = sender._sokoarea
   local more_boxes = false  -- memorizes whether a box was added or removed
-  if sokoarea[nr].endphase_started then
+  if lib.soko.sokoarea[nr].endphase_started then
     return
   end
 
@@ -36,7 +38,7 @@
   if(sender._box == 0) then
     if -wo:st(sender) then
       sender._box = 1
-      sokoarea[nr].goals_filled = sokoarea[nr].goals_filled + 1
+      lib.soko.sokoarea[nr].goals_filled = lib.soko.sokoarea[nr].goals_filled + 1
       more_boxes = true
     else
       -- blind alarm, probably a marble
@@ -44,49 +46,48 @@
     end
   else
     sender._box = 0
-    sokoarea[nr].goals_filled = sokoarea[nr].goals_filled - 1
+    lib.soko.sokoarea[nr].goals_filled = lib.soko.sokoarea[nr].goals_filled - 1
   end
 
   -- Call goal_hook, e.g. for algorithms &quot;ralf&quot; and &quot;allcrack&quot;.
-  if type(sokoarea[nr].goal_hook) == &quot;function&quot; then
-    sokoarea[nr].goal_hook(nr, sender, more_boxes, sokoarea[nr].goals_filled,
-              sokoarea[nr].number_goals)
+  if type(lib.soko.sokoarea[nr].goal_hook) == &quot;number&quot; then
+    if lib.soko.sokoarea[nr].goal_hook == lib.soko.GOAL_HOOK_RALF then
+      lib.soko.endphase_goal_hook_ralf(nr, sender, more_boxes,
+          lib.soko.sokoarea[nr].goals_filled, lib.soko.sokoarea[nr].number_goals)
   end
   
   -- Start endphase?
-  if sokoarea[nr].goals_filled == sokoarea[nr].number_goals then
-    sokoarea[nr].endphase_started = true
-    if type(sokoarea[nr].endphase_hook) == &quot;function&quot; then
-      sokoarea[nr].endphase_hook(nr)
-    else
-      mydebug(&quot;libsoko: No endphase hook found!&quot;)
+  if lib.soko.sokoarea[nr].goals_filled == lib.soko.sokoarea[nr].number_goals then
+    lib.soko.sokoarea[nr].endphase_started = true
+    if type(lib.soko.sokoarea[nr].endphase_hook) ~= &quot;nil&quot; then
+      lib.soko.debug(&quot;libsoko: Unknown endphase hook.&quot;)
     end
   end
 end
 
-function prepare_endphase(sokoarea_number)
+function lib.soko.prepare_endphase(sokoarea_number)
   local nr = sokoarea_number
   -- ensure existence of goals
-  if sokoarea[nr].number_goals &lt; 1 then
-    myerror(&quot;No goals defined!\n&quot;)
+  if lib.soko.sokoarea[nr].number_goals &lt; 1 then
+    lib.soko.error(&quot;No goals defined!\n&quot;)
   end
   -- ensure a correctly set endphase-attribute
-  local endp = sokoarea[nr].design.endp
+  local endp = lib.soko.sokoarea[nr].design.endp
   if not endp then
-    sokoarea[nr].design.endp = lib.lua.deep_copy(default_design.endp)
-    endp = sokoarea[nr].design.endp
+    lib.soko.sokoarea[nr].design.endp = lib.lua.deep_copy(lib.soko.default_design.endp)
+    endp = lib.soko.sokoarea[nr].design.endp
   end
   if type(endp) ~= &quot;table&quot; then
-    myerror(&quot;This design's endphase is given as &quot;..type(endp)
+    lib.soko.error(&quot;This design's endphase is given as &quot;..type(endp)
             ..&quot;, should be table.&quot;)
   end
   local alg = endp.alg
   if alg == nil then
-    sokoarea[nr].design.endp.alg = lib.lua.deep_copy(default_design.endp.alg)
+    lib.soko.sokoarea[nr].design.endp.alg = lib.lua.deep_copy(lib.soko.default_design.endp.alg)
     alg = endp.alg
   end
   if type(alg) ~= &quot;string&quot; then
-    myerror(&quot;This design's endphase algorithm is given as &quot;..type(alg)
+    lib.soko.error(&quot;This design's endphase algorithm is given as &quot;..type(alg)
             ..&quot;, should be string.&quot;)
   end
 
@@ -108,29 +109,29 @@
   elseif (alg == &quot;ralf&quot;)
       or (alg == &quot;allcrack&quot;)
       or (alg == &quot;vortex&quot;) then
-    endphase_set_block_oxyds(nr, (sokoarea[nr].design.door or
-        sokoarea[nr].design.wall or &quot;st_nil&quot;), param)
-    sokoarea[nr].goal_hook = endphase_goal_hook_ralf
+    lib.soko.endphase_set_block_oxyds(nr, (lib.soko.sokoarea[nr].design.door or
+        lib.soko.sokoarea[nr].design.wall or &quot;st_nil&quot;), param)
+    lib.soko.sokoarea[nr].goal_hook = lib.soko.GOAL_HOOK_RALF
   elseif (alg == &quot;block&quot;) then
-    endphase_set_block_oxyds(nr, param)
+    lib.soko.endphase_set_block_oxyds(nr, param)
   elseif (alg == &quot;outside&quot;) then
-    endphase_set_outside_oxyds(nr, param)
+    lib.soko.endphase_set_outside_oxyds(nr, param)
   elseif (alg == &quot;knock&quot;) then
-    endphase_set_block_oxyds(nr, sokoarea[nr].design.door, 3)
-    endphase_set_knocking(nr, param)
+    lib.soko.endphase_set_block_oxyds(nr, lib.soko.sokoarea[nr].design.door, 3)
+    lib.soko.endphase_set_knocking(nr, param)
   -- &quot;Jumpyoxyds&quot; deactivated for once
   --elseif (alg == &quot;jumpyoxyds&quot;) then
   --  endphase_set_block_oxyds(nr, &quot;jumpy&quot;)
-  --  goal_hook = endphase_goal_hook_ralf
+  --  goal_hook = lib.soko.GOAL_HOOK_RALF
   else
-    mywarning(&quot;Endphase algorithm &quot;..alg..&quot; unknown! Will use 'circle' instead.&quot;)
+    lib.soko.warning(&quot;Endphase algorithm &quot;..alg..&quot; unknown! Will use 'circle' instead.&quot;)
   end
 end
 
-function endphase(sokoarea_number)
+function lib.soko.endphase(sokoarea_number)
   -- Correct structure of endp-attribute has been checked
   -- by prepare_endphase, we trust it blindly.
-  local endp = lib.lua.deep_copy(sokoarea[sokoarea_number].design.endp)
+  local endp = lib.lua.deep_copy(lib.soko.sokoarea[sokoarea_number].design.endp)
   local alg = endp.alg
   local param = &quot;&quot;
   local marble = po(no[&quot;marble_&quot;..sokoarea_number..&quot;_1&quot;])
@@ -142,9 +143,9 @@
     param = string.sub(endp.alg, sep + 1)
   end
   if param == &quot;&quot; then
-    mydebug(&quot;Endphase starts of type &quot;..alg..&quot;, no parameter.&quot;)
+    lib.soko.debug(&quot;Endphase starts of type &quot;..alg..&quot;, no parameter.&quot;)
   else
-    mydebug(&quot;Endphase starts of type &quot;..alg..&quot;, parameter &quot;..param..&quot;.&quot;)
+    lib.soko.debug(&quot;Endphase starts of type &quot;..alg..&quot;, parameter &quot;..param..&quot;.&quot;)
   end
 
   -- redraw level and give items
@@ -156,13 +157,13 @@
   if type(give) == &quot;table&quot; then
     for k, v in pairs(give) do
       if is_item(v) or is_stone(v) or is_floor(v) then
-        set_element(marble, sokoarea_number, &quot;&quot;, v)
+        lib.soko.set_element(marble, sokoarea_number, &quot;&quot;, v)
       elseif is_actor(v) then
         wo[marble] = {v, 0.5, 0.5}
       elseif v == &quot;rubberball&quot; then
         local old_actor = no[&quot;marble_&quot;..sokoarea_number..&quot;_1&quot;]
         local actor_kind = &quot;ac-whiteball&quot;
-        if sokoarea[sokoarea_number].design.white then
+        if lib.soko.sokoarea[sokoarea_number].design.white then
           actor_kind = &quot;ac-blackball&quot;
         end
         wo[marble] = {actor_kind, &quot;rubberball_sokoarea_&quot;..sokoarea_number,
@@ -170,11 +171,11 @@
         wo:add({&quot;ot_rubberband&quot;, anchor1 = no[&quot;marble_&quot;..sokoarea_number],
             anchor2 = no[&quot;rubberball_sokoarea_&quot;..sokoarea_number], strength = 50})
       else
-        myerror(&quot;Can't give &quot;..v..&quot;.&quot;)
+        lib.soko.error(&quot;Can't give &quot;..v..&quot;.&quot;)
       end
     end
   elseif type(give) ~= &quot;nil&quot; then
-    myerror(&quot;Can't give something of type &quot;..type(v)..&quot;.&quot;)
+    lib.soko.error(&quot;Can't give something of type &quot;..type(v)..&quot;.&quot;)
   end
 
   if alg == &quot;circle&quot; then
@@ -209,38 +210,38 @@
   end
 end
 
-function endphase_redraw_level_array(sokoarea_number)
+function lib.soko.endphase_redraw_level_array(sokoarea_number)
   local nr = sokoarea_number or 1
-  local endp = lib.lua.deep_copy(sokoarea[nr].design.endp)
-  local offset = sokoarea[nr].offset
+  local endp = lib.lua.deep_copy(lib.soko.sokoarea[nr].design.endp)
+  local offset = lib.soko.sokoarea[nr].offset
   
   -- small routine to check the walls and outside
   local function is_oxyd_or_blocker(x,y)
-    if sokoarea[nr].list_oxyd[x..&quot;/&quot;..y] then
+    if lib.soko.sokoarea[nr].list_oxyd[x..&quot;/&quot;..y] then
       return true
-    elseif sokoarea[nr].list_blocker[x..&quot;/&quot;..y] then
+    elseif lib.soko.sokoarea[nr].list_blocker[x..&quot;/&quot;..y] then
       return true
     end
     return false
   end
   
   -- redraw outside
-  for p, v in pairs(sokoarea[nr].list_outside) do
+  for p, v in pairs(lib.soko.sokoarea[nr].list_outside) do
     if not is_oxyd_or_blocker(v.abs.x, v.abs.y) then
-      set_element(v.abs, nr, k, endp.outf)
+      lib.soko.set_element(v.abs, nr, k, endp.outf)
     end
   end
   
   -- redraw the rest inside level_array:
-  for y = 0, sokoarea[nr].array_height - 1 do
-    for x = 0, sokoarea[nr].array_width - 1 do
+  for y = 0, lib.soko.sokoarea[nr].array_height - 1 do
+    for x = 0, lib.soko.sokoarea[nr].array_width - 1 do
       if not is_oxyd_or_blocker(x + offset.x, y + offset.y) then
-        local ch = sokoarea[nr].level_array[y+1][x+1]
+        local ch = lib.soko.sokoarea[nr].level_array[y+1][x+1]
         for k, v in pairs(endp) do
           if    ((k == &quot;inf&quot;)  and char_is_inf(ch))
              or ((k == &quot;wall&quot;) and char_is_wall(ch))
              or ((k == &quot;goal&quot;) and char_is_goal(ch)) then
-            set_element(offset + {x,y}, nr, k, v)
+            lib.soko.set_element(offset + {x,y}, nr, k, v)
           end
         end
       end
@@ -248,9 +249,9 @@
   end
   
   -- if existent, redraw blocker floors
-  if (sokoarea[nr].list_blocker) and (endp.inf) then
-    for p, v in pairs(sokoarea[nr].list_blocker) do
-      set_element(v.abs, nr, &quot;inf&quot;, endp.inf)
+  if (lib.soko.sokoarea[nr].list_blocker) and (endp.inf) then
+    for p, v in pairs(lib.soko.sokoarea[nr].list_blocker) do
+      lib.soko.set_element(v.abs, nr, &quot;inf&quot;, endp.inf)
     end
   end 
 end
@@ -259,13 +260,13 @@
 -- Endphase Games and Algorithms
 ------------------------------------------------------------------------
 
-function endphase_circle(sokoarea_number)
-  local flavor = sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
+function lib.soko.endphase_circle(sokoarea_number)
+  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
   local actor = no[&quot;marble_&quot;..sokoarea_number..&quot;_1&quot;]
   if not -actor then
     actor = no[&quot;marble&quot;]
     if not -actor then
-      myerror(&quot;No marble found. Please name it 'marble'.&quot;)  
+      lib.soko.error(&quot;No marble found. Please name it 'marble'.&quot;)  
     end
   end
   local abs = po(actor)
@@ -276,14 +277,14 @@
     abs = abs + {0,-2}
   end
   for j = 0, 2 do
-    set_oxyd(sokoarea_number, {abs = abs + {j,-1}}, flavor, 2*j)
-    set_oxyd(sokoarea_number, {abs = abs + {-1,j}}, flavor, 2*j)
-    set_oxyd(sokoarea_number, {abs = abs + {j,3}},  flavor, 2*j+1)
-    set_oxyd(sokoarea_number, {abs = abs + {3,j}},  flavor, 2*j+1)
+    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {j,-1}}, flavor, 2*j)
+    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {-1,j}}, flavor, 2*j)
+    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {j,3}},  flavor, 2*j+1)
+    lib.soko.set_oxyd(sokoarea_number, {abs = abs + {3,j}},  flavor, 2*j+1)
     for k = 0, 2 do
       wo:st(abs + {j,k}):kill()
       wo:it(abs + {j,k}):kill()
-      set_element(abs + {j,k}, sokoarea_number, &quot;inf&quot;)
+      lib.soko.set_element(abs + {j,k}, sokoarea_number, &quot;inf&quot;)
     end
   end
   wo[abs + {1,1}] = {&quot;st_fart&quot;, _sokoarea = sokoarea_number}
@@ -294,18 +295,18 @@
 -- wall_two-area of the level. There will be 2 to 5 pairs of oxyds
 -- depending on the amount of space. PARAM may define a maximal
 -- number of oxyd pairs (good for outf = &quot;fl-space&quot;).
-function endphase_set_outside_oxyds(sokoarea_number, param)
+function lib.soko.endphase_set_outside_oxyds(sokoarea_number, param)
   local places = {}
   local nr = sokoarea_number or 1
-  local offset = sokoarea[nr].offset
-  local mx = sokoarea[nr].array_width
-  local my = sokoarea[nr].array_height
-  local flavor = sokoarea[nr].design.oxyd or &quot;b&quot;
+  local offset = lib.soko.sokoarea[nr].offset
+  local mx = lib.soko.sokoarea[nr].array_width
+  local my = lib.soko.sokoarea[nr].array_height
+  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
 
   -- Select all places outside or in the walls, unreachable
   -- for the marble.
-  for p, v in pairs(lib.lua.combine_tables(sokoarea[nr].list_outside,
-                sokoarea[nr].list_wall_two)) do
+  for p, v in pairs(lib.lua.combine_tables(lib.soko.sokoarea[nr].list_outside,
+                lib.soko.sokoarea[nr].list_wall_two)) do
     if (v.abs.x % 2 == 0) and (v.abs.y % 2 == 0) then
       table.insert(places, v)
     end
@@ -337,24 +338,24 @@
   places = lib.lua.shuffle(places)
 
   for j = 1, number_pairs do
-    set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
-    set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
+    lib.soko.set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
+    lib.soko.set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
   end
   wo:shuffleOxyd()
 end
 
-function endphase_set_block_oxyds(sokoarea_number, blocker, max_pairs)
+function lib.soko.endphase_set_block_oxyds(sokoarea_number, blocker, max_pairs)
   local oxyds = {}
   local nr = sokoarea_number or 1
-  local flavor = sokoarea[nr].design.oxyd or &quot;b&quot;
+  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
 
   -- Add all wall_one-elements with exactly one way near as blocker,
   -- and the opposite position as oxyd, if it is of type wall_two.
   -- Make sure that each possible oxyd position is assigned at most once,
   -- and that no other oxyds or blockers are near.
   local function opposite_as_oxyd(xy, dxy)
-    if     sokoarea[nr].list_way[(xy.x+dxy.x)..&quot;/&quot;..(xy.y+dxy.y)]
-       and sokoarea[nr].list_wall_two[(xy.x-dxy.x)..&quot;/&quot;..(xy.y-dxy.y)] then
+    if     lib.soko.sokoarea[nr].list_way[(xy.x+dxy.x)..&quot;/&quot;..(xy.y+dxy.y)]
+       and lib.soko.sokoarea[nr].list_wall_two[(xy.x-dxy.x)..&quot;/&quot;..(xy.y-dxy.y)] then
       -- Check that no oxyd has been set on this position before
       -- and no other oxyd or blocker is near the new oxyd or its
       -- blocker.
@@ -373,7 +374,7 @@
     return
   end
   local directions = {po({-1,0}), po({1,0}), po({0,-1}), po({0,1})}
-  for p, v in pairs(sokoarea[nr].list_wall_one) do
+  for p, v in pairs(lib.soko.sokoarea[nr].list_wall_one) do
     if v.count == 1 then
       for _, dir in ipairs(directions) do
         opposite_as_oxyd(v.abs, dir)
@@ -386,7 +387,7 @@
   local number_pairs = 2
   if max &lt; 4 then
     -- Not enough places? Choose &quot;circle&quot;-algorithm instead.
-    sokoarea[nr].design.endp.alg = &quot;circle&quot;
+    lib.soko.sokoarea[nr].design.endp.alg = &quot;circle&quot;
     return
   elseif max &lt;  8 then  number_pairs = 2
   elseif max &lt; 16 then  number_pairs = 3
@@ -418,13 +419,13 @@
       end
     end
     -- now set in-floor and blocker, and add to list_blocker.
-    set_element(w.abs, nr, &quot;inf&quot;)
-    set_element(w.abs, nr, &quot;&quot;, myblocker)
-    sokoarea[nr].list_blocker[(w.abs.x)..&quot;/&quot;..(w.abs.y)] = lib.lua.deep_copy(w)
+    lib.soko.set_element(w.abs, nr, &quot;inf&quot;)
+    lib.soko.set_element(w.abs, nr, &quot;&quot;, myblocker)
+    lib.soko.sokoarea[nr].list_blocker[(w.abs.x)..&quot;/&quot;..(w.abs.y)] = lib.lua.deep_copy(w)
   end
   for j = 1, number_pairs do   -- Testlevel: 14
-    set_oxyd(nr, oxyds[2*j-1], flavor, j - 1)
-    set_oxyd(nr, oxyds[2*j], flavor, j - 1)
+    lib.soko.set_oxyd(nr, oxyds[2*j-1], flavor, j - 1)
+    lib.soko.set_oxyd(nr, oxyds[2*j], flavor, j - 1)
     set_block(oxyds[2*j-1].blocker)
     set_block(oxyds[2*j].blocker)
   end
@@ -434,23 +435,23 @@
   -- Note: There might be more goals as blockers, and, vice versa,
   --       there might be more blockers as goals.
   local goal_table = {}
-  for p, v in pairs(sokoarea[nr].list_goal) do
+  for p, v in pairs(lib.soko.sokoarea[nr].list_goal) do
     table.insert(goal_table, v)
   end
   goal_table = lib.lua.shuffle(goal_table)
   for j = 2, math.min(table.getn(goal_table), table.getn(oxyds)) do
-    sokoarea[nr].goal_to_blocker[goal_table[j].goal_number] = oxyds[j].blocker
+    lib.soko.sokoarea[nr].goal_to_blocker[goal_table[j].goal_number] = oxyds[j].blocker
   end
 end
 
 -- endphase_set_hide_oxyds distributes oxyds over the wall_one-walls.
 -- PARAM is a maximal number of oxyd pairs.
-function endphase_set_hide_oxyds(sokoarea_number, param)
-  local flavor = sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
+function lib.soko.endphase_set_hide_oxyds(sokoarea_number, param)
+  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
   local places = {}
   
   -- add all wall_one-elements
-  for p, v in pairs(sokoarea[sokoarea_number].list_wall_one) do
+  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_wall_one) do
     table.insert(places, v)
   end
 
@@ -476,29 +477,29 @@
   
   -- set oxyds
   for j = 1, number_pairs do
-    set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
-    set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
+    lib.soko.set_oxyd(sokoarea_number, places[2*j-1], flavor, j - 1)
+    lib.soko.set_oxyd(sokoarea_number, places[2*j], flavor, j - 1)
   end
   wo:shuffleOxyd()
 end
 
-function endphase_gradients(sokoarea_number, param)
+function lib.soko.endphase_gradients(sokoarea_number, param)
   local force = tonumber(param) or 25.0
-  for p, v in pairs(sokoarea[sokoarea_number].list_way) do
+  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_way) do
     local grad_type = random(1,12)
     wo[v.abs] = {&quot;fl-gradient&quot;, type = grad_type, force = force}
   end
 end
 
-function endphase_magnets(sokoarea_number, param)
+function lib.soko.endphase_magnets(sokoarea_number, param)
   local force = tonumber(param) or 30.0
   local places = {}
   local nr = sokoarea_number or 1
-  local flavor = sokoarea[nr].design.oxyd or &quot;b&quot;
+  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
 
   -- add all way-elements which are not goals
-  for p, v in pairs(sokoarea[nr].list_way) do
-    if not char_is_goal(sokoarea[nr].level_array[v.rel.y][v.rel.x]) then
+  for p, v in pairs(lib.soko.sokoarea[nr].list_way) do
+    if not char_is_goal(lib.soko.sokoarea[nr].level_array[v.rel.y][v.rel.x]) then
       table.insert(places, v)
     end
   end
@@ -514,12 +515,12 @@
   end
 end
 
-function endphase_fourswitch(sokoarea_number)
-  local flavor = sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
+function lib.soko.endphase_fourswitch(sokoarea_number)
+  local flavor = lib.soko.sokoarea[sokoarea_number].design.oxyd or &quot;b&quot;
   local places = {}
 
   -- add all wall_one-elements
-  for p, v in pairs(sokoarea[sokoarea_number].list_wall_one) do
+  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_wall_one) do
     table.insert(places, v)
   end
 
@@ -546,13 +547,13 @@
     places[j].correct = false
   end
   places.number_pairs = number_pairs
-  sokoarea[sokoarea_number].places = lib.lua.deep_copy(places)
+  lib.soko.sokoarea[sokoarea_number].places = lib.lua.deep_copy(places)
 end
 
-function endphase_call_fourswitch(onoff, sender)
+function lib.soko.endphase_call_fourswitch(onoff, sender)
   local j = sender._number
   local nr = sender._sokoarea
-  local places = sokoarea[nr].places
+  local places = lib.soko.sokoarea[nr].places
 
   -- When fourswitch is knocked, count it.
   places[j].current = places[j].current + 1
@@ -570,7 +571,7 @@
   -- fourswitch that doesn't change any other), check all fourswitchs
   -- and replace them by oxyds if all are correct. Else, recreate the
   -- next fourswitch in hierarchy, set it to the old number, then
-  -- set the callback function and call it once by triggering another
+  -- set the callback function lib.soko.and call it once by triggering another
   -- time (making it show the new number). This means: Recursion!
   if j ~= 1 then
     -- Trigger all lower fourswitchs
@@ -595,8 +596,8 @@
     if correct then
       -- replace fourswitchs by oxyds
       for k = 1, places.number_pairs do
-        set_oxyd(sokoarea_number, places[2*k-1], flavor, k - 1)
-        set_oxyd(sokoarea_number, places[2*k], flavor, k - 1)
+        lib.soko.set_oxyd(sokoarea_number, places[2*k-1], flavor, k - 1)
+        lib.soko.set_oxyd(sokoarea_number, places[2*k], flavor, k - 1)
       end
       wo:shuffleOxyd()
     end
@@ -604,47 +605,47 @@
 end
 
 
-function endphase_allcrack(sokoarea_number)
-  for p, v in pairs(sokoarea[sokoarea_number].list_way) do
+function lib.soko.endphase_allcrack(sokoarea_number)
+  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_way) do
     if not -wo:it(v.abs) then
       wo[v.abs] = {&quot;it-crack3&quot;}
     end
   end  
 end
 
-function endphase_goal_hook_ralf(sokoarea_number, sender, more_boxes,
+function lib.soko.endphase_goal_hook_ralf(sokoarea_number, sender, more_boxes,
     goals_filled, number_goals)
   local nr = sokoarea_number or 1
   -- verify correct sokoarea-number and existence of &quot;goal_to_blocker&quot;
   if nr ~= sender._sokoarea then
-    myerror(&quot;libsoko: Inconsistent sokoarea numbers in goal hook!&quot;)
+    lib.soko.error(&quot;libsoko: Inconsistent sokoarea numbers in goal hook!&quot;)
   end
-  if type(sokoarea[nr].goal_to_blocker) ~= &quot;table&quot; then
-    myerror(&quot;libsoko: Blocker list is missing during goal hook!&quot;)
+  if type(lib.soko.sokoarea[nr].goal_to_blocker) ~= &quot;table&quot; then
+    lib.soko.error(&quot;libsoko: Blocker list is missing during goal hook!&quot;)
   end
   -- identify the corresponding door and open it
-  local blocker = sokoarea[nr].goal_to_blocker[sender._goal_number]
+  local blocker = lib.soko.sokoarea[nr].goal_to_blocker[sender._goal_number]
   if blocker then
     endphase_ralf_open_door(nr, more_boxes, blocker.abs)
   end
 end
 
-function endphase_ralf_open_doors(sokoarea_number)
-  for p, v in pairs(sokoarea[sokoarea_number].list_blocker) do
+function lib.soko.endphase_ralf_open_doors(sokoarea_number)
+  for p, v in pairs(lib.soko.sokoarea[sokoarea_number].list_blocker) do
     endphase_ralf_open_door(sokoarea_number, true, v.abs)
   end
 end
 
 -- endphase_ralf_open_door opens or closes a door at position
 -- (X,Y), dependend on the boolean OPEN.
-function endphase_ralf_open_door(sokoarea_number, open, xy)
-  local door_kind = sokoarea[sokoarea_number].design.endp.open_door
+function lib.soko.endphase_ralf_open_door(sokoarea_number, open, xy)
+  local door_kind = lib.soko.sokoarea[sokoarea_number].design.endp.open_door
   if door_kind then
     if not open then
-      door_kind =    sokoarea[sokoarea_number].design.door
-                  or sokoarea[sokoarea_number].design.wall or &quot;st_nil&quot;
+      door_kind =    lib.soko.sokoarea[sokoarea_number].design.door
+                  or lib.soko.sokoarea[sokoarea_number].design.wall or &quot;st_nil&quot;
     end
-    set_element(xy, sokoarea_number, &quot;&quot;, door_kind)
+    lib.soko.set_element(xy, sokoarea_number, &quot;&quot;, door_kind)
   else
     -- use default &quot;open&quot;/&quot;close&quot;-messages instead
     local st = wo:st(xy)
@@ -662,10 +663,10 @@
   end  
 end
 
-function endphase_vortex(sokoarea_number)
+function lib.soko.endphase_vortex(sokoarea_number)
   local nr = sokoarea_number or 1
   local list_way = 
-    lib.lua.combine_tables(sokoarea[nr].list_way, sokoarea[nr].list_blocker)
+    lib.lua.combine_tables(lib.soko.sokoarea[nr].list_way, lib.soko.sokoarea[nr].list_blocker)
   local components = 0
   local component = {}
 
@@ -678,7 +679,7 @@
   local function mark_component(xy)
     if     (list_way[xy.x..&quot;/&quot;..xy.y])
        and (not list_way[xy.x..&quot;/&quot;..xy.y].component)
-       and (not sokoarea[nr].list_goal[xy.x..&quot;/&quot;..xy.y]) then
+       and (not lib.soko.sokoarea[nr].list_goal[xy.x..&quot;/&quot;..xy.y]) then
       list_way[xy.x..&quot;/&quot;..xy.y].component = components
       --set_floor(({&quot;fl-leaves&quot;, &quot;fl-ice&quot;, &quot;fl-red&quot;, &quot;fl-black&quot;, &quot;fl-white&quot;,
       --    &quot;fl-sahara&quot;, &quot;fl-light&quot;, &quot;fl-gray&quot;, &quot;fl-lightgray&quot;, &quot;fl-rough&quot;,
@@ -691,7 +692,7 @@
     end
   end
   for p, v in pairs(list_way) do
-    if (not list_way[p].component) and (not sokoarea[nr].list_goal[p]) then
+    if (not list_way[p].component) and (not lib.soko.sokoarea[nr].list_goal[p]) then
       components = components + 1
       component[components] = {oxyds = 0}
       mark_component(v.abs)
@@ -704,10 +705,10 @@
   end
 
   -- Analyse oxyds and to which components they belong to.
-  for p, v in pairs(sokoarea[nr].list_oxyd) do
+  for p, v in pairs(lib.soko.sokoarea[nr].list_oxyd) do
     local component_number = list_way[v.blocker.abs.x..&quot;/&quot;..v.blocker.abs.y].component or -1
     if component_number == -1 then
-      myerror(&quot;Error in component calculation.&quot;)
+      lib.soko.error(&quot;Error in component calculation.&quot;)
     else
       component[component_number].oxyds = component[component_number].oxyds + 1
     end
@@ -756,13 +757,13 @@
   end  
 end
 
-function endphase_set_knocking(sokoarea_number, param)
+function lib.soko.endphase_set_knocking(sokoarea_number, param)
   local nr = sokoarea_number
-  local flavor = sokoarea[nr].design.oxyd or &quot;b&quot;
+  local flavor = lib.soko.sokoarea[nr].design.oxyd or &quot;b&quot;
   local places = {}
 
   -- add all blockers
-  for p, v in pairs(sokoarea[nr].list_blocker) do
+  for p, v in pairs(lib.soko.sokoarea[nr].list_blocker) do
     table.insert(places, v)
   end
 
@@ -781,16 +782,16 @@
   end
 end
 
-function endphase_call_knocking(onoff, sender)
+function lib.soko.endphase_call_knocking(onoff, sender)
   local j = sender._number
   local nr = sender._sokoarea
   if (not nr) or (not j) then
-    myerror(&quot;libsoko: Knocking's source has no number or no sokoarea.&quot;)
+    lib.soko.error(&quot;libsoko: Knocking's source has no number or no sokoarea.&quot;)
   end
-  mydebug(&quot;Knocked on &quot;..j..&quot;/&quot;..sokoarea[nr].number_oxyds)
+  lib.soko.debug(&quot;Knocked on &quot;..j..&quot;/&quot;..lib.soko.sokoarea[nr].number_oxyds)
   -- Deactivate the first door until endphase has started.
-  if (j == 1) and (not sokoarea[nr].endphase_started) then
-    mydebug(&quot;Door deactivated until endphase.&quot;)
+  if (j == 1) and (not lib.soko.sokoarea[nr].endphase_started) then
+    lib.soko.debug(&quot;Door deactivated until endphase.&quot;)
     return
   end
   -- Open or close the neccessary doors given as attributes.

Modified: trunk/data/levels/lib/libsoko.xml
===================================================================
--- trunk/data/levels/lib/libsoko.xml	2008-09-15 18:45:31 UTC (rev 1331)
+++ trunk/data/levels/lib/libsoko.xml	2008-09-15 20:22:06 UTC (rev 1332)
@@ -3,15 +3,15 @@
   &lt;el:protected&gt;
     &lt;el:info el:type=&quot;library&quot;&gt;
       &lt;el:identity el:title=&quot;&quot; el:id=&quot;lib/libsoko&quot;/&gt;
-      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;2&quot; el:status=&quot;experimental&quot;/&gt;
+      &lt;el:version el:score=&quot;1&quot; el:release=&quot;1&quot; el:revision=&quot;3&quot; el:status=&quot;experimental&quot;/&gt;
       &lt;el:author el:name=&quot;Enigma Team&quot; el:email=&quot;&quot; el:homepage=&quot;&quot;/&gt;
       &lt;el:copyright&gt;Copyright &#169; 2007, 2008 Enigma Team&lt;/el:copyright&gt;
       &lt;el:license el:type=&quot;GPL v2.0 or above&quot; el:open=&quot;true&quot;/&gt;
       &lt;el:compatibility el:enigma=&quot;1.10&quot;&gt;
         &lt;el:dependency el:path=&quot;lib/liblua&quot; el:id=&quot;lib/liblua&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
         &lt;el:dependency el:path=&quot;lib/libmath&quot; el:id=&quot;lib/libmath&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
-        &lt;el:dependency el:path=&quot;lib/libsoko-designlist&quot; el:id=&quot;lib/libsoko-designlist&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
-        &lt;el:dependency el:path=&quot;lib/libsoko-endphase&quot; el:id=&quot;lib/libsoko-endphase&quot; el:release=&quot;1&quot; el:preload=&quot;true&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libsoko-designlist&quot; el:id=&quot;lib/libsoko-designlist&quot; el:release=&quot;1&quot; el:preload=&quot;false&quot;/&gt;
+        &lt;el:dependency el:path=&quot;lib/libsoko-endphase&quot; el:id=&quot;lib/libsoko-endphase&quot; el:release=&quot;1&quot; el:preload=&quot;false&quot;/&gt;
       &lt;/el:compatibility&gt;
       &lt;el:modes el:easy=&quot;false&quot; el:single=&quot;false&quot; el:network=&quot;false&quot;/&gt;
       &lt;el:comments&gt;
@@ -30,16 +30,20 @@
 -- and endphases.
 
 lib.soko = {}
+setmetatable(lib.soko, getmetatable(lib))
 
+enigma.LoadLib(&quot;lib/libsoko-designlist&quot;)
+enigma.LoadLib(&quot;lib/libsoko-endphase&quot;)
+
 ------------------------------------------------------------------------
 -- Global variables
 ------------------------------------------------------------------------
 
 -- The global table &quot;sokoarea&quot; holds all sokoban parts a level
--- creates. I.e., sokoarea[1] holds information about the first
--- part, sokoarea[2] about the second etc. In most cases, only
--- sokoarea[1] will be used.
--- Each sokoarea[j] is again a table with the following entries:
+-- creates. I.e., lib.soko.sokoarea[1] holds information about the first
+-- part, lib.soko.sokoarea[2] about the second etc. In most cases, only
+-- lib.soko.sokoarea[1] will be used.
+-- Each lib.soko.sokoarea[j] is again a table with the following entries:
 --
 --        level_array - a 2D-array of characters defining the sokoban part
 --        array_width - width of level_array
@@ -53,15 +57,9 @@
 --         uses_chess - flag to note that st-chess was used (no shogun-triggers)
 --        level_width - width of whole level (create_sokoban only)
 --       level_height - height of whole level (create_sokoban only)
---          goal_hook - function to call when a goal activates/deactivates
---      endphase_hook - function to call when all triggers are filled
+--          goal_hook - describes the function to call when a goal is activated/deactivated
+--      endphase_hook - describes the function to call when all triggers are filled
 --
--- endphase_hook is a function with one argument, the sokoarea-number.
--- goal_hook takes five arguments: Sokoarea-number, goal-object that was
--- triggered, a bool whether the box was added (instead of removed), number
--- of now-filled goals in this area, number of all goals in this area.
--- Hooking goal_hook does not interfere the default operations of libsoko,
--- but hooking endphase_hook results in skipping the usual endphase.
 -- However, you can call endphase(sokoarea_number) yourself if neccessary.
 --
 --       list_outside - list of positions of outf-tiles
@@ -78,19 +76,19 @@
 -- (nil else). Some endphases also use list_oxyd, list_blocker,
 -- goal_to_blocker and/or number_oxyds as additional data structures.
 
-sokoarea = {}
+lib.soko.sokoarea = {}
 
 ------------------------------------------------------------------------
 -- Tools
 ------------------------------------------------------------------------
 
-function mydebug(st)
-  print(st)
+function lib.soko.debug(st)
+  --print(st)
 end
-function mywarning(st)
+function lib.soko.warning(st)
   print(st)
 end
-function myerror(st)
+function lib.soko.error(st)
   error(st, 2)
 end
 
@@ -108,7 +106,7 @@
 
 -- choose_among_multiples selects a number between 1 and COUNT
 -- based on the coordinates X and Y and the algorithm's name ALG.
-function choose_among_multiples(abs, count, alg)
+function lib.soko.choose_among_multiples(abs, count, alg)
   if alg == &quot;checkerboard&quot; then
     return (((abs.x%2) + (abs.y%2)) % count) + 1
   elseif alg == &quot;lines&quot; then
@@ -123,10 +121,10 @@
 
 -- check_chess returns a boolean whether a chess stone is used
 -- in the sokoarea SOKOAREA_NUMBER.
-function check_chess(sokoarea_number)
-  for y = 1, sokoarea[sokoarea_number].array_height do
-    for x = 1, sokoarea[sokoarea_number].array_width do
-      local ch = sokoarea[sokoarea_number].level_array[y][x]
+function lib.soko.check_chess(sokoarea_number)
+  for y = 1, lib.soko.sokoarea[sokoarea_number].array_height do
+    for x = 1, lib.soko.sokoarea[sokoarea_number].array_width do
+      local ch = lib.soko.sokoarea[sokoarea_number].level_array[y][x]
       if char_is_chess(ch) then
         return true
       end
@@ -137,49 +135,49 @@
 
 -- set_oxyd sets an oxyd with given flavor and color and adds
 -- the neccessary entry to list_oxyd.
-function set_oxyd(sokoarea_number, list_entry, flavor, color)
+function lib.soko.set_oxyd(sokoarea_number, list_entry, flavor, color)
   local entry = lib.lua.deep_copy(list_entry)
   entry.flavor = flavor
   entry.color = color
   wo[entry.abs] = {&quot;st_oxyd&quot;, flavor = flavor, oxydcolor = color}
-  sokoarea[sokoarea_number].list_oxyd[entry.abs.x..&quot;/&quot;..entry.abs.y] = entry
-  sokoarea[sokoarea_number].number_oxyds =
-      sokoarea[sokoarea_number].number_oxyds + 1
+  lib.soko.sokoarea[sokoarea_number].list_oxyd[entry.abs.x..&quot;/&quot;..entry.abs.y] = entry
+  lib.soko.sokoarea[sokoarea_number].number_oxyds =
+      lib.soko.sokoarea[sokoarea_number].number_oxyds + 1
 end
 
 -- create_lists creates the special lists list_outside, list_wall,
 -- list_way, list_wall_one and list_wall_two for SOKOAREA_NUMBER.
-function create_lists(sokoarea_number)
+function lib.soko.create_lists(sokoarea_number)
   local nr = sokoarea_number or 1
-  local offset = sokoarea[nr].offset
-  local mx = sokoarea[nr].array_width
-  local my = sokoarea[nr].array_height
-  sokoarea[nr].list_outside = {}
-  sokoarea[nr].list_way = {}
-  sokoarea[nr].list_wall_one = {}
-  sokoarea[nr].list_wall_two = {}
+  local offset = lib.soko.sokoarea[nr].offset
+  local mx = lib.soko.sokoarea[nr].array_width
+  local my = lib.soko.sokoarea[nr].array_height
+  lib.soko.sokoarea[nr].list_outside = {}
+  lib.soko.sokoarea[nr].list_way = {}
+  lib.soko.sokoarea[nr].list_wall_one = {}
+  lib.soko.sokoarea[nr].list_wall_two = {}
   -- list_way, list_wall and list_outside (inside level_array)
   for x = 0, mx - 1 do
     for y = 0, my - 1 do
-      local ch = sokoarea[nr].level_array[y+1][x+1]
+      local ch = lib.soko.sokoarea[nr].level_array[y+1][x+1]
       local entry = {abs = offset + {x,y}, rel = po({x+1, y+1})}
       local sig = entry.abs.x..&quot;/&quot;..entry.abs.y
       if char_is_outf(ch) then
-        sokoarea[nr].list_outside[sig] = entry
+        lib.soko.sokoarea[nr].list_outside[sig] = entry
       elseif char_is_wall(ch) then
-        sokoarea[nr].list_wall[sig] = entry
+        lib.soko.sokoarea[nr].list_wall[sig] = entry
       else
-        sokoarea[nr].list_way[sig] = entry
+        lib.soko.sokoarea[nr].list_way[sig] = entry
       end
     end
   end
   -- list_outside (outside level_array)
-  if sokoarea[nr].level_width and sokoarea[nr].level_height then
-    for x = 0, sokoarea[nr].level_width - 1 do
-      for y = 0, sokoarea[nr].level_height - 1 do
+  if lib.soko.sokoarea[nr].level_width and lib.soko.sokoarea[nr].level_height then
+    for x = 0, lib.soko.sokoarea[nr].level_width - 1 do
+      for y = 0, lib.soko.sokoarea[nr].level_height - 1 do
         if    (x &lt; offset.x) or (x &gt; mx + offset.x - 1)
            or (y &lt; offset.y) or (y &gt; my + offset.y - 1) then
-          sokoarea[nr].list_outside[x..&quot;/&quot;..y] = {abs = po({x,y})}
+          lib.soko.sokoarea[nr].list_outside[x..&quot;/&quot;..y] = {abs = po({x,y})}
         end
       end
     end
@@ -189,24 +187,24 @@
   -- (i) it's a wall, (ii) it's near or diagonal to outside,
   -- (iii) it's near a way.
   -- In addition, it counts the number of near ways.
-  for p, v in pairs(sokoarea[nr].list_wall) do
+  for p, v in pairs(lib.soko.sokoarea[nr].list_wall) do
     local x = v.abs.x
     local y = v.abs.y
-    if    sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y)]
-       or sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y)]
-       or sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y-1)]
-       or sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y+1)]
-       or sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y+1)]
-       or sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y-1)]
-       or sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y+1)]
-       or sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y-1)] then
+    if    lib.soko.sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y)]
+       or lib.soko.sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y)]
+       or lib.soko.sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y-1)]
+       or lib.soko.sokoarea[nr].list_outside[(x)..&quot;/&quot;..(y+1)]
+       or lib.soko.sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y+1)]
+       or lib.soko.sokoarea[nr].list_outside[(x+1)..&quot;/&quot;..(y-1)]
+       or lib.soko.sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y+1)]
+       or lib.soko.sokoarea[nr].list_outside[(x-1)..&quot;/&quot;..(y-1)] then
       local count = 0
-      if sokoarea[nr].list_way[(x-1)..&quot;/&quot;..(y)] then  count = count + 1  end
-      if sokoarea[nr].list_way[(x+1)..&quot;/&quot;..(y)] then  count = count + 1  end
-      if sokoarea[nr].list_way[(x)..&quot;/&quot;..(y-1)] then  count = count + 1  end
-      if sokoarea[nr].list_way[(x)..&quot;/&quot;..(y+1)] then  count = count + 1  end
+      if lib.soko.sokoarea[nr].list_way[(x-1)..&quot;/&quot;..(y)] then  count = count + 1  end
+      if lib.soko.sokoarea[nr].list_way[(x+1)..&quot;/&quot;..(y)] then  count = count + 1  end
+      if lib.soko.sokoarea[nr].list_way[(x)..&quot;/&quot;..(y-1)] then  count = count + 1  end
+      if lib.soko.sokoarea[nr].list_way[(x)..&quot;/&quot;..(y+1)] then  count = count + 1  end
       if count &gt; 0 then
-        sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] =
+        lib.soko.sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] =
             {abs = v.abs, rel = v.rel, count = count}
       end
     end
@@ -214,27 +212,27 @@
   -- list_wall_two
   -- There are three conditions for an element of list_wall_two:
   -- (i) it's near a wall_one, (ii) it's not a wall_one,
-  -- (iii) it's wall or outside. Next function checks (ii) and (iii)
+  -- (iii) it's wall or outside. Next function lib.soko.checks (ii) and (iii)
   -- and adds the checked element to the list. In addition, the
   -- neighboring wall_one are added into the list.
   local function check_ii_and_iii(x, y, one_x, one_y)
-    if sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] then
+    if lib.soko.sokoarea[nr].list_wall_one[x..&quot;/&quot;..y] then
       return
     end
-    if sokoarea[nr].list_way[x..&quot;/&quot;..y] then
+    if lib.soko.sokoarea[nr].list_way[x..&quot;/&quot;..y] then
       return
     end
-    if not sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] then
+    if not lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] then
       -- create new entry
-      sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] =
+      lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y] =
           {abs = po({x,y}), rel = nil, wall_one = {}}
     end
     -- add the corresponding wall_one
-    local w = table.getn(sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one) + 1
-    sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one[w] =
-        sokoarea[nr].list_wall_one[one_x..&quot;/&quot;..one_y]
+    local w = table.getn(lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one) + 1
+    lib.soko.sokoarea[nr].list_wall_two[x..&quot;/&quot;..y].wall_one[w] =
+        lib.soko.sokoarea[nr].list_wall_one[one_x..&quot;/&quot;..one_y]
   end
-  for p, v in pairs(sokoarea[nr].list_wall_one) do
+  for p, v in pairs(lib.soko.sokoarea[nr].list_wall_one) do
     check_ii_and_iii(v.abs.x+1, v.abs.y, v.abs.x, v.abs.y)
     check_ii_and_iii(v.abs.x-1, v.abs.y, v.abs.x, v.abs.y)
     check_ii_and_iii(v.abs.x, v.abs.y+1, v.abs.x, v.abs.y)
@@ -244,11 +242,11 @@
 
 -- new_sokoarea initialises a new entry in the global
 -- sokoarea table and returns its number.
-function new_sokoarea()
-  sokoarea_number = table.getn(sokoarea) + 1
-  sokoarea[sokoarea_number] = {
+function lib.soko.new_sokoarea()
+  sokoarea_number = table.getn(lib.soko.sokoarea) + 1
+  lib.soko.sokoarea[sokoarea_number] = {
     level_array = {},
-    design = default_design,
+    design = lib.soko.default_design,
     algorithms = {},
     number_goals = 0,
     goals_filled = 0,
@@ -278,17 +276,17 @@
 -- Drawing Functions and Level Interpretation
 ------------------------------------------------------------------------
 
--- set_element sets element name EL_STR of area SOKOAREA_NUMBER at x, y.
+-- lib.soko.set_element sets element name EL_STR of area SOKOAREA_NUMBER at x, y.
 -- EL_DESIGN is optional and overrides the design of the given sokoarea.
-function set_element(abs, sokoarea_number, el_str, el_design)
-  if type(sokoarea[sokoarea_number]) ~= &quot;table&quot; then
-    myerror(&quot;Sokoarea table number &quot;..sokoarea_number..&quot; broken or not existing.&quot;)
+function lib.soko.set_element(abs, sokoarea_number, el_str, el_design)
+  if type(lib.soko.sokoarea[sokoarea_number]) ~= &quot;table&quot; then
+    lib.soko.error(&quot;Sokoarea table number &quot;..sokoarea_number..&quot; broken or not existing.&quot;)
   end
-  local el = el_design or sokoarea[sokoarea_number].design[el_str]
-  local in_endphase = sokoarea[sokoarea_number].endphase_started
+  local el = el_design or lib.soko.sokoarea[sokoarea_number].design[el_str]
+  local in_endphase = lib.soko.sokoarea[sokoarea_number].endphase_started
 
   if (usertype(abs) ~= &quot;position&quot;) then
-    myerror(&quot;libsoko.set_element: Coordinate is not a position!&quot;)
+    lib.soko.error(&quot;libsoko.lib.soko.set_element: Coordinate is not a position!&quot;)
     return
   end
 
@@ -329,11 +327,11 @@
         elseif s == &quot;fire&quot;    then  fire = true
         elseif s == &quot;nofire&quot;  then  fire = false
         else
-          mywarning(&quot;Unknown entry &quot;..j..&quot;=&quot;..s..&quot; in design element.&quot;)
+          lib.soko.warning(&quot;Unknown entry &quot;..j..&quot;=&quot;..s..&quot; in design element.&quot;)
         end
       end
     else
-      mywarning(&quot;In design element, entry &quot;..j..&quot; is of type &quot;
+      lib.soko.warning(&quot;In design element, entry &quot;..j..&quot; is of type &quot;
                 ..type(v)..&quot;, not string.&quot;)      
     end
   end
@@ -342,7 +340,7 @@
 
   ----------- floor --------------
   if table.getn(fl) &gt; 0 then
-    local flkind = fl[choose_among_multiples(abs, table.getn(fl), multiple_alg)]
+    local flkind = fl[lib.soko.choose_among_multiples(abs, table.getn(fl), multiple_alg)]
     if flkind == &quot;fl-bridge_x&quot; then
       wo[abs] = {&quot;fl-bridge&quot;, type = &quot;x&quot;, burnable = false, eternal = true}
     elseif flkind == &quot;fl-bridge_y&quot; then
@@ -361,7 +359,7 @@
 
   ----------- stone ---------------
   if table.getn(st) &gt; 0 then
-    local stkind = st[choose_among_multiples(abs, table.getn(st), multiple_alg)]
+    local stkind = st[lib.soko.choose_among_multiples(abs, table.getn(st), multiple_alg)]
     if (not -wo:st(abs)) or (not wo:st(abs):is(&quot;st_oxyd&quot;)) then
       wo[abs] = {stkind, _sokoarea = sokoarea_number}
       created_objects.st = wo:st(abs)
@@ -370,16 +368,16 @@
 
   ----------- item ----------------
   if table.getn(it) &gt; 0 then
-    local itkind = it[choose_among_multiples(abs, table.getn(it), multiple_alg)]
-    if sokoarea[sokoarea_number].uses_chess and not in_endphase then
+    local itkind = it[lib.soko.choose_among_multiples(abs, table.getn(it), multiple_alg)]
+    if lib.soko.sokoarea[sokoarea_number].uses_chess and not in_endphase then
       itkind = &quot;it_trigger&quot;
     end
     wo[abs] = {itkind}
     created_objects.it = wo:it(abs)
     if (el_str == &quot;goal&quot;) and not in_endphase then
-      local gn = sokoarea[sokoarea_number].number_goals + 1
-      sokoarea[sokoarea_number].number_goals = gn
-      sokoarea[sokoarea_number].list_goal[abs.x..&quot;/&quot;..abs.y] =
+      local gn = lib.soko.sokoarea[sokoarea_number].number_goals + 1
+      lib.soko.sokoarea[sokoarea_number].number_goals = gn
+      lib.soko.sokoarea[sokoarea_number].list_goal[abs.x..&quot;/&quot;..abs.y] =
           {abs = abs, goal_number = gn}
       if created_objects.it and not in_endphase then
         created_objects.it.action = &quot;callback&quot;
@@ -418,18 +416,18 @@
 --  - set global variables
 --  - prepare oxyds
 --  - solve the level
--- This function is not intended to be used in level programming
+-- This function lib.soko.is not intended to be used in level programming
 -- directly, use &quot;draw_sokoball&quot; instead.
-function draw_level_array(sokoarea_number, outside, draw_actor)
+function lib.soko.draw_level_array(sokoarea_number, outside, draw_actor)
   local nr = sokoarea_number or 1
-  local design = sokoarea[nr].design
-  local offset = sokoarea[nr].offset
-  sokoarea[nr].list_goal = {}
+  local design = lib.soko.sokoarea[nr].design
+  local offset = lib.soko.sokoarea[nr].offset
+  lib.soko.sokoarea[nr].list_goal = {}
 
   -- create level
-  for y = 0, sokoarea[nr].array_height - 1 do
-    for x = 0, sokoarea[nr].array_width - 1 do
-      local ch = sokoarea[nr].level_array[y+1][x+1]
+  for y = 0, lib.soko.sokoarea[nr].array_height - 1 do
+    for x = 0, lib.soko.sokoarea[nr].array_width - 1 do
+      local ch = lib.soko.sokoarea[nr].level_array[y+1][x+1]
       local obj = {}
       local abs = offset + {x,y}
       
@@ -438,29 +436,29 @@
         if outside then
           wo:st(abs):kill()
           wo:it(abs):kill()
-          set_element(abs, nr, &quot;outf&quot;)
+          lib.soko.set_element(abs, nr, &quot;outf&quot;)
         end
       else
         wo:st(abs):kill()
         wo:it(abs):kill()
-        obj = set_element(abs, nr, &quot;inf&quot;)
+        obj = lib.soko.set_element(abs, nr, &quot;inf&quot;)
         obj.fl.freeze_check = true
       end
       
       -- Walls
       if char_is_wall(ch) then
-        obj = set_element(abs, nr, &quot;wall&quot;)
+        obj = lib.soko.set_element(abs, nr, &quot;wall&quot;)
       end
       
       -- Goals
       if char_is_goal(ch) then
-        obj = set_element(abs, nr, &quot;goal&quot;)
+        obj = lib.soko.set_element(abs, nr, &quot;goal&quot;)
         wo:fl(abs).freeze_check = false
       end
       
       -- Boxes
       if char_is_box(ch) then
-        obj = set_element(abs, nr, &quot;box&quot;)
+        obj = lib.soko.set_element(abs, nr, &quot;box&quot;)
         obj.st.freeze_check = true
       end
       
@@ -475,8 +473,8 @@
       
       -- Actors
       if char_is_player(ch) and draw_actor then
-        sokoarea[nr].actor_count = sokoarea[nr].actor_count + 1
-        local acname = &quot;marble_&quot;..nr..&quot;_&quot;..sokoarea[nr].actor_count
+        lib.soko.sokoarea[nr].actor_count = lib.soko.sokoarea[nr].actor_count + 1
+        local acname = &quot;marble_&quot;..nr..&quot;_&quot;..lib.soko.sokoarea[nr].actor_count
         if design[&quot;white&quot;] then
           wo[abs] = {&quot;#ac-whiteball&quot;, acname, controllers = 1, player = 0}
         else
@@ -507,9 +505,9 @@
 -- in which case SUBLEVEL determines the number of the level to unpack.
 -- Default of SUBLEVEL is 1.
 --
-function unpack_level(multilevel, sublevel_number)
+function lib.soko.unpack_level(multilevel, sublevel_number)
   if type(multilevel) ~= &quot;string&quot; then
-    myerror(&quot;Can't make sense of level type &quot;..type(level)..&quot;.&quot;)
+    lib.soko.error(&quot;Can't make sense of level type &quot;..type(level)..&quot;.&quot;)
   end
   local current_level = 0
   local level = &quot;&quot;
@@ -535,16 +533,16 @@
           level = line..&quot;\n&quot;
         end
       end
-      mydebug(&quot;Level &quot;..current_level..&quot; : |&quot;..line..&quot;|&quot;)
+      lib.soko.debug(&quot;Level &quot;..current_level..&quot; : |&quot;..line..&quot;|&quot;)
     else
       in_level = false
     end
   end
   
-  mydebug(level)
+  lib.soko.debug(level)
   
   if level == &quot;&quot; then
-    myerror(&quot;libsoko.unpack_level: Multilevel holds less than &quot;
+    lib.soko.error(&quot;libsoko.unpack_level: Multilevel holds less than &quot;
             ..sublevel_number..&quot; levels!&quot;)
   end
 
@@ -593,7 +591,7 @@
   end  
 
   -- mark outside floor fields from the border
-  function check_for_outside(x, y)
+  local function check_for_outside(x, y)
     if level_array[y][x] == &quot;-&quot; then
       level_array[y][x] = &quot; &quot;
       if y &gt; 1         then  check_for_outside(x, y - 1)  end
@@ -646,9 +644,9 @@
     end
   end
   if (border_n &gt;= border_s) or (border_w &gt;= border_e) then
-    myerror(&quot;libsoko: Level is empty or trimming code is corrupt.&quot;)
+    lib.soko.error(&quot;libsoko: Level is empty or trimming code is corrupt.&quot;)
   end
-  mydebug(&quot;N: &quot;..border_n..&quot;, S: &quot;..border_s
+  lib.soko.debug(&quot;N: &quot;..border_n..&quot;, S: &quot;..border_s
       ..&quot;, W: &quot;..border_w..&quot;, E: &quot;..border_e)
   local trimmed_array = {}
   for y = border_n, border_s do
@@ -658,9 +656,9 @@
       trimmed_array[y - border_n + 1][x - border_w + 1] = level_array[y][x]
       line = line .. level_array[y][x]
     end
-    mydebug(&quot;|&quot;..line..&quot;|&quot;)
+    lib.soko.debug(&quot;|&quot;..line..&quot;|&quot;)
   end
-  mydebug(table.getn(trimmed_array)..&quot; : &quot;..table.getn(trimmed_array[1]))
+  lib.soko.debug(table.getn(trimmed_array)..&quot; : &quot;..table.getn(trimmed_array[1]))
   return trimmed_array
 end
 
@@ -766,12 +764,12 @@
 --  only slightly above the normal distribution. However, their
 --  ratio varies with the list length.
 --
--- See also: Landau function g(n) for determining the maximal
+-- See also: Landau function lib.soko.g(n) for determining the maximal
 --           order of an element in the symmetric group S(n).
 --
-function number_from_level(level_array, list_length)
+function lib.soko.number_from_level(level_array, list_length)
   local j = list_length + 1
-  mydebug(&quot;Calculating number from level_array, modulus &quot;..list_length..&quot; ...&quot;)
+  lib.soko.debug(&quot;Calculating number from level_array, modulus &quot;..list_length..&quot; ...&quot;)
   local l = 2
   repeat
     j = j - 1
@@ -793,12 +791,12 @@
       end
     end
   until (b == 0) or (j == 1)
-  mydebug(&quot;Calculation ended. Result: &quot;..j)
+  lib.soko.debug(&quot;Calculation ended. Result: &quot;..j)
   return j
 end
 
-function design_from_level(level_array, list_length)
-  return design_list[number_from_level(level_array,
+function lib.soko.design_from_level(level_array, list_length)
+  return lib.soko.design_list[lib.soko.number_from_level(level_array,
             list_length or table.getn(design_list))]
 end
 
@@ -808,20 +806,20 @@
 --  - a number specifying the number of the design in the design list
 --  - &quot;nil&quot; plus a level_array from which a design from the design
 --    list will be chosen.
-function design_from_description(design_description, level_array, maxdesignnumber)
+function lib.soko.design_from_description(design_description, level_array, maxdesignnumber)
   -- choose design
   local design = {}
   if type(design_description) == &quot;number&quot; then
-    design = lib.lua.deep_copy(design_list[design_description])
+    design = lib.lua.deep_copy(lib.soko.design_list[design_description])
   elseif type(design_description) == &quot;table&quot; then
     design = lib.lua.deep_copy(design_description)
   elseif (type(design_description) == &quot;nil&quot;) and (type(level_array) == &quot;table&quot;) then
-    design = lib.lua.deep_copy(design_from_level(level_array, maxdesignnumber))
+    design = lib.lua.deep_copy(lib.soko.design_from_level(level_array, maxdesignnumber))
   else
-    myerror(&quot;Can't make sense of design type &quot;..type(design)..&quot;.&quot;)
+    lib.soko.error(&quot;Can't make sense of design type &quot;..type(design)..&quot;.&quot;)
   end
   -- fill chosen design with default values where neccessary
-  design = lib.lua.combine_tables({design, default_design})
+  design = lib.lua.combine_tables({design, lib.soko.default_design})
   -- No stone set for outf, not even &quot;st_nil&quot;?
   -- Use the default outf-stone instead, and remove it on endphase.
   if type(design.outf) ~= &quot;table&quot; then
@@ -832,7 +830,7 @@
       return design
     end
   end
-  table.insert(design.outf, default_design.outf_default_stone)
+  table.insert(design.outf, lib.soko.default_design.outf_default_stone)
   if type(design.endp.outf) ~= &quot;table&quot; then
     design.endp.outf = {design.endp.outf}
   end
@@ -863,60 +861,60 @@
 -- design list is enlarged.
 -- Returns width and height of new level.
 --
-function create_sokoball(level, sublevel, design, maxdesignnumber)
+function lib.soko.create_sokoball(level, sublevel, design, maxdesignnumber)
   -- check that this is the first sokoarea, and initialise it.
-  if type(sokoarea) ~= &quot;table&quot; then
-    myerror(&quot;No sense in sokoarea of type &quot;..type(sokoarea)..&quot;.&quot;)
+  if type(lib.soko.sokoarea) ~= &quot;table&quot; then
+    lib.soko.error(&quot;No sense in sokoarea of type &quot;..type(sokoarea)..&quot;.&quot;)
   end
-  if table.getn(sokoarea) ~= 0 then
-    myerror(&quot;Tried to use create_sokoball twice. Use draw_sokoball instead.&quot;)
+  if table.getn(lib.soko.sokoarea) ~= 0 then
+    lib.soko.error(&quot;Tried to use create_sokoball twice. Use draw_sokoball instead.&quot;)
   end
-  new_sokoarea()
+  lib.soko.new_sokoarea()
 
   -- unpack level
-  sokoarea[1].level_array = unpack_level(level, sublevel)
+  lib.soko.sokoarea[1].level_array = lib.soko.unpack_level(level, sublevel)
 
   -- calculate screen position
   -- Important Note: level_array is reversely indexed, i.e.
   --                 level_array[y-coordinate][x-coordinate]
-  sokoarea[1].array_width = table.getn(sokoarea[1].level_array[1])
-  sokoarea[1].array_height = table.getn(sokoarea[1].level_array)
-  sokoarea[1].uses_chess = check_chess(1)
-  local levelw = math.max(sokoarea[1].array_width, 20)
-  local levelh = math.max(sokoarea[1].array_height, 13)
-  sokoarea[1].level_width = levelw
-  sokoarea[1].level_height = levelh
+  lib.soko.sokoarea[1].array_width = table.getn(lib.soko.sokoarea[1].level_array[1])
+  lib.soko.sokoarea[1].array_height = table.getn(lib.soko.sokoarea[1].level_array)
+  lib.soko.sokoarea[1].uses_chess = lib.soko.check_chess(1)
+  local levelw = math.max(lib.soko.sokoarea[1].array_width, 20)
+  local levelh = math.max(lib.soko.sokoarea[1].array_height, 13)
+  lib.soko.sokoarea[1].level_width = levelw
+  lib.soko.sokoarea[1].level_height = levelh
   ti[&quot; &quot;] = {&quot;fl-abyss&quot;}
   wo(ti, &quot; &quot;, levelw, levelh)
   
   -- calculate padding
   local dx = 0
   local dy = 0
-  if levelw &gt; sokoarea[1].array_width then
-    dx = math.floor((levelw - sokoarea[1].array_width) / 2)
+  if levelw &gt; lib.soko.sokoarea[1].array_width then
+    dx = math.floor((levelw - lib.soko.sokoarea[1].array_width) / 2)
   end
-  if levelh &gt; sokoarea[1].array_height then
-    dy = math.floor((levelh - sokoarea[1].array_height) / 2)
+  if levelh &gt; lib.soko.sokoarea[1].array_height then
+    dy = math.floor((levelh - lib.soko.sokoarea[1].array_height) / 2)
   end
-  sokoarea[1].offset = po({dx, dy})
+  lib.soko.sokoarea[1].offset = po({dx, dy})
 
   -- calculate design
-  sokoarea[1].design =
-    design_from_description(design, sokoarea[1].level_array, maxdesignnumber)
+  lib.soko.sokoarea[1].design =
+    lib.soko.design_from_description(design, lib.soko.sokoarea[1].level_array, maxdesignnumber)
 
   -- create special position lists
-  create_lists(nr)
+  lib.soko.create_lists(nr)
   
   -- draw level
   for x = 0, levelw - 1 do
     for y = 0, levelh - 1 do
-      set_element(po({x,y}), 1, &quot;outf&quot;)
+      lib.soko.set_element(po({x,y}), 1, &quot;outf&quot;)
     end
   end
-  draw_level_array(1, true, true)
+  lib.soko.draw_level_array(1, true, true)
   
   -- prepare oxyds for end phase
-  prepare_endphase(1)
+  lib.soko.prepare_endphase(1)
 
   -- Enigma's global variables
   wo[&quot;ConserveLevel&quot;] = false
@@ -933,54 +931,54 @@
 -- from scratch, but not the world and doesn't add another
 -- actor.
 --
-function recreate_sokoball(design, maxdesignnumber, sokoarea_number)
+function lib.soko.recreate_sokoball(design, maxdesignnumber, sokoarea_number)
   local nr = sokoarea_number or 1
 
-  sokoarea[nr].design =
-      design_from_description(design, sokoarea[nr].level_array, maxdesignnumber)
+  lib.soko.sokoarea[nr].design =
+      lib.soko.design_from_description(design, lib.soko.sokoarea[nr].level_array, maxdesignnumber)
 
-  if sokoarea[nr].level_width and sokoarea[nr].level_height then
-    for x = 0, sokoarea[nr].level_width - 1 do
-      for y = 0, sokoarea[nr].level_height - 1 do
+  if lib.soko.sokoarea[nr].level_width and lib.soko.sokoarea[nr].level_height then
+    for x = 0, lib.soko.sokoarea[nr].level_width - 1 do
+      for y = 0, lib.soko.sokoarea[nr].level_height - 1 do
         wo:st(x, y):kill()
         wo:it(x, y):kill()
-        set_element(po({x,y}), nr, &quot;outf&quot;)
+        lib.soko.set_element(po({x,y}), nr, &quot;outf&quot;)
       end
     end
   else
-    for x = 0, sokoarea[nr].array_width - 1 do
-      for y = 0, sokoarea[nr].array_height - 1 do
-        local abs = sokoarea[nr].offset + {x,y}
+    for x = 0, lib.soko.sokoarea[nr].array_width - 1 do
+      for y = 0, lib.soko.sokoarea[nr].array_height - 1 do
+        local abs = lib.soko.sokoarea[nr].offset + {x,y}
         wo:st(abs):kill()
         wo:it(abs):kill()
-        set_element(abs, nr, &quot;outf&quot;)
+        lib.soko.set_element(abs, nr, &quot;outf&quot;)
       end
     end
   end
 
-  sokoarea[nr].number_goals = 0
-  sokoarea[nr].goals_filled = 0
-  sokoarea[nr].endphase_started = false
-  sokoarea[nr].goal_to_blocker = {}
-  sokoarea[nr].goal_hook = nil
-  sokoarea[nr].list_goal = {}
-  sokoarea[nr].list_oxyd = {}
-  sokoarea[nr].list_blocker = {}
-  sokoarea[nr].number_oxyds = 0
-  sokoarea[nr].goal_to_blocker = {}
-  sokoarea[nr].endphase_hook = endphase
+  lib.soko.sokoarea[nr].number_goals = 0
+  lib.soko.sokoarea[nr].goals_filled = 0
+  lib.soko.sokoarea[nr].endphase_started = false
+  lib.soko.sokoarea[nr].goal_to_blocker = {}
+  lib.soko.sokoarea[nr].list_goal = {}
+  lib.soko.sokoarea[nr].list_oxyd = {}
+  lib.soko.sokoarea[nr].list_blocker = {}
+  lib.soko.sokoarea[nr].number_oxyds = 0
+  lib.soko.sokoarea[nr].goal_to_blocker = {}
+  lib.soko.sokoarea[nr].goal_hook = nil
+  lib.soko.sokoarea[nr].endphase_hook = endphase
 
-  --sokoarea[nr].list_outside = {}
-  --sokoarea[nr].list_wall = {}
-  --sokoarea[nr].list_way = {}
-  --sokoarea[nr].list_wall_one = {}
-  --sokoarea[nr].list_wall_two = {}
+  --lib.soko.sokoarea[nr].list_outside = {}
+  --lib.soko.sokoarea[nr].list_wall = {}
+  --lib.soko.sokoarea[nr].list_way = {}
+  --lib.soko.sokoarea[nr].list_wall_one = {}
+  --lib.soko.sokoarea[nr].list_wall_two = {}
 
-  draw_level_array(nr, true, false)
+  lib.soko.draw_level_array(nr, true, false)
 
   -- prepare oxyds for end phase
-  prepare_endphase(nr)
-  mydebug(&quot;Prepared for endphase &quot;..sokoarea[nr].design.endp.alg..&quot;.&quot;)
+  lib.soko.prepare_endphase(nr)
+  lib.soko.debug(&quot;Prepared for endphase &quot;..lib.soko.sokoarea[nr].design.endp.alg..&quot;.&quot;)
 end
 
 -- draw_sokoball draws a sokoball level from argument LEVEL, sublevel
@@ -996,36 +994,36 @@
 --  - draw any oxyds
 --  - solve the level when all triggers are activated.
 -- DRAW_ACTOR determines if an actor should be placed.
--- ENDPHASE_HOOK is the function to be called when all goals are filled.
--- GOAL_HOOK is called when a single goal is triggered (see libsoko-endphase).
--- (As a function, not as a string!) If it's nil, the standard
+-- ENDPHASE_HOOK describes the function to be called when all goals are filled.
+-- GOAL_HOOK describes the function to be called when a single goal is
+-- triggered (see libsoko-endphase). If it's nil, the standard
 -- function from this library will be called. This might be
 -- broken as no oxyds have been prepared.
 -- Note: Overwriting one sokoarea with another creates problems
 --       with the triggers.
 --
-function draw_sokoball(offset, level, sublevel, design, draw_actor,
+function lib.soko.draw_sokoball(offset, level, sublevel, design, draw_actor,
                        endphase_hook, goal_hook)
-  local nr = new_sokoarea()
+  local nr = lib.soko.new_sokoarea()
   -- unpack level
-  sokoarea[nr].level_array = unpack_level(level, sublevel)
-  sokoarea[nr].array_width = table.getn(sokoarea[nr].level_array[1])
-  sokoarea[nr].array_height = table.getn(sokoarea[nr].level_array)
-  sokoarea[nr].uses_chess = check_chess(nr)
-  sokoarea[nr].offset = offset
-  sokoarea[nr].design = 
-      design_from_description(design, sokoarea[nr].level_array)
+  lib.soko.sokoarea[nr].level_array = lib.soko.unpack_level(level, sublevel)
+  lib.soko.sokoarea[nr].array_width = table.getn(lib.soko.sokoarea[nr].level_array[1])
+  lib.soko.sokoarea[nr].array_height = table.getn(lib.soko.sokoarea[nr].level_array)
+  lib.soko.sokoarea[nr].uses_chess = lib.soko.check_chess(nr)
+  lib.soko.sokoarea[nr].offset = offset
+  lib.soko.sokoarea[nr].design = 
+    lib.soko.design_from_description(design, lib.soko.sokoarea[nr].level_array)
   if hook ~= nil then
-    sokoarea[nr].endphase_hook = endphase_hook
+    lib.soko.sokoarea[nr].endphase_hook = endphase_hook
   end
-  sokoarea[nr].goal_hook = goal_hook
-  create_lists(nr)
-  draw_level_array(nr, false, draw_actor)
+  lib.soko.sokoarea[nr].goal_hook = goal_hook
+  lib.soko.create_lists(nr)
+  lib.soko.draw_level_array(nr, false, draw_actor)
 end
 
--- design_statistics uses mywarning to output statistics of
+-- design_statistics uses lib.soko.warning to output statistics of
 -- the used algorithms
-function design_statistics()
+function lib.soko.design_statistics()
   alglist = {}
   for k, v in pairs(design_list) do
     if v.endp then
@@ -1038,7 +1036,7 @@
     end
   end
   for k, v in pairs(alglist) do
-    mywarning(k..&quot;: &quot;..v)
+    lib.soko.warning(k..&quot;: &quot;..v)
   end
 end
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000761.html">[Enigma-game-svn] r1331 - in trunk: data src/stones
</A></li>
	<LI>Next message: <A HREF="000763.html">[Enigma-game-svn] r1333 - trunk/data/levels/lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#762">[ date ]</a>
              <a href="thread.html#762">[ thread ]</a>
              <a href="subject.html#762">[ subject ]</a>
              <a href="author.html#762">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/enigma-game-svn">More information about the Enigma-game-svn
mailing list</a><br>
</body></html>
